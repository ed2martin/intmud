IntMUD (Interpretador MUD)

Índice

0. Créditos
1. Sobre o IntMUD
2. Opções dos arquivos *.INT
2.1. Opção INCLUIR
2.2. Opção EXEC
2.3. Opção TELATXT
2.4. Opção LOG
2.5. Opção ERR
2.6. Opção COMPLETO
2.7. Opção ARQEXEC
3. Classes
4. Variáveis
5. Funções
6. Constantes
7. Funções do tipo variáveis
8. Herança
9. Conteúdo das funções
10. Variáveis básicas
11. Identificadores comum e sav
12. Vetores
13. Operadores
13.1. Verdadeiro e falso
13.2. Lista de operadores
13.3. Precedência de operadores
13.4. Operadores ? e :
13.5. Operador ??
13.6. Conversão de tipos em operadores binários
13.7. Operadores de bit
13.8. Operadores de bit com textos
14. Instruções de controle de fluxo
15. Lista de funções
15.1. Funções chamadas pelo interpretador
15.2. Funções numéricas
15.3. Funções de texto
15.4. Funções para procura e substituição de textos
15.5. Funções para apelido e senha
15.6. Funções para objetos
15.7. Outras funções
15.8. Funções de vetores de variáveis numéricas
15.9. Funções de vetores de variáveis txt1 a txt512
16. Outros tipos de variáveis
17. ListaObj - lista de objetos
18. ListaItem - um item de ListaObj
19. TextoTxt - lista de texto
20. TextoPos - acessar linha de textotxt
21. TextoVar - lista de variáveis de texto
22. TextoObj - lista de variáveis ref
23. NomeObj - para obter um ou mais objetos
24. ArqDir - acessar diretórios
25. ArqLog - gravar texto em arquivos de log
26. ArqSav - salvar objetos em arquivos
27. ArqTxt - acessar arquivos de texto
28. IntTempo - gerar eventos depois de um tempo
29. IntExec - gerar evento assim que possível
30. TelaTxt - acessar a janela do programa
31. Socket - comunicação via TCP/IP
32. Serv - receber conexões via TCP/IP
33. Prog - ler e alterar o programa
33.1. Funções para iniciar uma consulta
33.2. Funções para ler o resultado da consulta
33.3. Funções para obter informações
33.4. Funções para alterar o programa
34. ArqProg - busca nos diretórios os arquivos que compõem o programa
35. ArqExec - executar outros programas
36. Debug - auxiliar a detectar erros no programa
37. IndiceObj - objetos organizados de acordo com um texto
38. IndiceItem - obter objeto pelo texto
39. DataHora - calendário


0. CRÉDITOS

Este manual foi escrito por Edward Martin e revisado posteriormente
por Paulo Santos Ramos e Edward Martin.


1. SOBRE O INTMUD

O IntMUD é um interpretador de comandos que trabalha com um ou mais
arquivos textuais de extensão .int, cujo o conteúdo deverá ser puramente
oriundo da linguagem de maneira coerente às regras da mesma, para sua
eficaz interpretação.

Por padrão, o arquivo principal chama-se intmud.int. É possível mudar
esse padrão, das seguintes formas:

 - Renomeando o executável (intmud.exe) e o arquivo principal assumirá
   o nome alterado matendo a extensão .int, como dito anteriormente;

Exemplo: Se mudar o nome do arquivo 'intmud.exe' para 'teste.exe'
         o arquivo principal passará a ser teste.int.

 - Seguindo as sintaxes:
   <nome do executável> <nome do arquivo>.int
   <nome do executável> <nome do arquivo>

Exemplos:
 - INTMUD TESTE.INT            - Interpreta o arquivo teste.int
                                 com o executável denominado intmud.exe;
 - INTMUD TESTE                - O mesmo que 'intmud teste.int', já
                                 visto acima.

OBS.1: Observe que executando o programa em IntMUD da maneira anterior,
       não faz diferença omitir ou não a extensão .int do arquivo
       desejado;
OBS.2: Note também que o primeiro arquivo é o executável e o segundo é o
       que contém a linguagem.

 - Em ambiente gráfico, pode-se arrastar o arquivo .int para o executável
   com o botão esquerdo do mouse.

Em tópicos posteriores a este, conheceremos mais detalhadamente a
estrutura completa do IntMUD.


2. OPÇÕES DOS ARQUIVOS *.INT

O arquivo .int principal possui algumas definições padrão inseridas
no início, conforme a seguinte sintaxe:

<opção> = <valor>

Após as opções vem as definições de classes, que compõem o programa em si.


2.1. OPÇÃO INCLUIR

Esta opção permite incluir mais de um arquivo .int como parte do
código, objetivando principalmente facilitar possíveis manutenções de
programas muito grandes.

Sintaxe: INCLUIR = <nome do arquivo ou diretório>

Conforme a sintaxe, serão incluídos todos os arquivos que começam com
o nome especificado. Caso o nome termine com uma / (barra) será
interpretado como sendo um diretório, incluindo assim todos os seus
arquivos .int.

Nota: Os arquivos e diretórios especificados na inclusão devem pertencer
ao mesmo diretório do arquivo .int principal.

Exemplos:

incluir = mud-
incluir = area/
incluir = teste/mud
incluir = teste1/teste2/

O primeiro exemplo inclui todos os arquivos cujo nome começa com mud-.
Já o segundo inclui todos os arquivos do diretório areas.
O terceiro inclui todos os arquivos do diretório teste cujos nomes começam
com a palavra mud. O quarto incluir todos os arquivos do diretório teste2,
que é um sub-diretório de teste1.


2.2. OPÇÃO EXEC

Sintaxe: EXEC = <número de instruções>

Se essa opção estiver ausente, assume 5000.

Essa opção indica quantas linhas do programa podem ser executadas antes
do controle retornar automaticamente ao IntMUD. Notar que em algumas
situações, duas ou mais linhas podem ser consideradas como apenas uma.
Exemplo, quando é o usado o caracter '\' no final da linha para dividí-la.

É muito importante definir um número não muito grande. Quando há algum bug
no programa, de modo que algumas instruções são executadas indefinidamente,
essa é a única forma de evitar que o programa trave. Após um tempo o controle
volta ao IntMUD. Mas se o número for muito alto, não será possível corrigir
o bug sem desativar o programa.

Por outro lado, se esse valor for muito baixo, corre-se o risco de alguma
função não ser executada até o final. Pode ser cancelada por atingir a
quantidade de linhas definidas em EXEC.

A função CRIAR, em particular, não funcionará se EXEC for menor que 500.
Nesse caso, ao invés de criar um objeto, o controle retornará ao IntMUD.

Se uma função específica necessitar de um valor maior de EXEC, pode-se mudar
temporariamente esse número em tempo de execução, através da variável DEBUG
(vide em 'Outros tipos de variáveis').

Exemplo: Para executar 10 mil linhas antes do controle retornar
         automaticamente ao programa, basta adicionar uma linha assim:

EXEC = 10000


2.3. OPÇÃO TELATXT

Sintaxe: TELATXT = 0
         TELATXT = 1

Se essa opção estiver ausente, assume 0.

Se TELATXT for 0, o programa roda em segundo plano (nenhuma janela é aberta).

Se TELATXT for 1, é aberta uma janela do programa, semelhante ao Prompt de
Comado do Windows. Deficientes visuais podem usar programas como o Jaws e
o NVDA para ler a janela, pois o programa em si não possui síntese de voz.
As setas também funcionam: a posição do cursor muda e tanto o Jaws quanto
o NVDA conseguem ler.

Pode acontecer das letras acentuadas aparecerem sem acentuação na tela.
Nesse caso, pressione ALT esquerdo + espaço e vá em propriedades, e mude
a fonte de caracteres. Ocorre que algumas fontes, ou mesmo o tamanho da
letra, não têm acentuação.

Em ambientes Unix e Linux, quando TELATXT for 1, deve-se executar o programa
em um terminal.

A comunicação com o usuário se dá sempre através da variável telatxt (vide
'Outros tipos de variáveis').


2.4. OPÇÃO LOG

Sintaxe: LOG = 0
         LOG = 1

Se essa opção estiver ausente, assume 0.

Quando o IntMUD é executado, o programa é lido de um ou mais arquivos.
Se alguma linha não estiver de acordo com as regras da linguagem, torna-se
impossível a interpretação. Nesse caso, cada erro encontrado gera uma linha
que o identifica resumidamente.

Essa opção define para onde vão as linhas de erros. O valor 0 apresenta
as linhas na janela do programa; o valor 1 coloca em um arquivo de LOG.

O nome do arquivo é o mesmo do executável, mas terminado em '.log'.
Por exemplo, se o executável chamar-se 'teste.exe' o arquivo de LOG será
'teste.log'.


2.5. OPÇÃO ERR

Sintaxe: ERR = 0
         ERR = 1
         ERR = 2

Se essa opção estiver ausente, assume 0.

Via de regra, o IntMUD não checa se os blocos de controle de fluxo estão
coerentes. Por exemplo, é explicado neste manual que se há uma instrução
Enquanto ou EPara, mais para frente na mesma função deve existir um EFim.
Mas se não houver, ele não acusa erro. Apenas a função não funciona
como deveria.

O valor 0 não checa nenhuma inconsistência.
O valor 1 considera erro no código qualquer inconsistência nas instruões
de controle de fluxo, mas permite omitir a instrução FimSe quando
esta for a última instrução da função.
O valor 2 também checa inconsistências, mas não permite omitir FimSe.


2.6. OPÇÃO COMPLETO

Sintaxe: COMPLETO = 0
         COMPLETO = 1

Se essa opção estiver ausente, assume 0.

Quando essa opção for 0, o programa roda com as seguintes restrições:
Não pode acessar arquivos fora do diretório e subdiretórios do programa
Não pode acessar executáveis e .bat .com .exe .pif .scr
Arquivos .int só podem ser alterados via PROG
Arquivos .log só podem ser alterados via ARQLOG (não podem ser apagados)
ArqExec só podem executar programas das opções ArqExec

Em caso de dúvida, deixar 0.


2.7. OPÇÃO ARQEXEC

Sintaxe: ARQEXEC = <nome do comando>

Esta opção só tem efeito quando a opção COMPLETO for 0.
Ela define quais arquivos podem ser executados (via ArqExec).
Se o nome do comando terminar com um asterisco, significa qualquer
comando que começa com o texto especificado.

Exemplo 1 - permitir executar o programa cmd, sem argumentos:
arqexec = cmd

Exemplo 2 - permitir executar wget seguido de um texto qualquer:
arqexec = wget *


3. CLASSES

Após as opções vem as definições de classes, que constituem as instruções
da linguagem. Durante a execução do programa, todos os objetos criados
sempre serão derivados do conteúdo delas. Com isso, pode-se afirmar que
uma classe é o 'alicerce principal' de um objeto, pois ela contém todas
as instruções que caracterizam a funcionalidade do mesmo. Mais ainda,
quando uma classe é alterada, todos os objetos derivados dela também são.

Nota: Para mais detalhes de criação/remoção de objetos, vide funções
      CRIAR() e APAGAR().

Sintaxe para definir uma classe:

classe <nome da classe>
herda <classe 1>, <classe 2>, <classe 3> ... <classe n>
<variáveis e/ou constantes da classe>
<funções e/ou constantes da classe>

Os nomes de classes, funções e variáveis podem conter os seguintes caracteres:
 - Letras de A a Z;
 - Números de 0 a 9, exceto no início do nome;
 - Um 'ç' (c cedilha);
 - Um sinal de '@' (arroba);
 - Se conter espaço, o IntMUD o considera como um sinal de '_'
   (sublinhado);


4. VARIÁVEIS

São elementos que possuem um nome e uma informação, que pode ser um número,
um texto, um objeto, etc. As variáveis diferem entre si conforme o tipo de
informação que podem guardar. Por exemplo, um int8 contém um número inteiro
de -128 a 127, enquanto que um txt3 contém um texto qualquer de até
3 caracteres.

As variáveis são definidas conforme a sintaxe:
<tipo da variável> <nome da variável>

Exemplos:
INT8 TESTE0
TXT8 TESTE1

Nesse caso, temos duas variáveis, teste0 que é do tipo int8, e teste1, que
é do tipo txt8.

Quando a variável estiver definida em uma função, é possível atribuir um
valor inicial a ela, conforme a seguinte sintaxe:
<tipo da variável> <nome da variável> = <valor>

Exemplos:
INT8 TESTE0 = 4
TXT8 TESTE1 = "Fulano"

Os tipos de variaveis serão detalhados mais adiante.


5. FUNÇÕES

São partes do programa que via de regra fazem uma tarefa específica.
As funções são sempre definidas dentro de uma classe e possuem nomes, pelos
quais podem ser chamadas.

Sintaxe para definir uma função:
func <nome da função>
<variáveis e/ou instruções>

Sintaxe para chamar sem argumentos:
<nome da função>

Sintaxe para chamar com argumentos:
<nome da função>(argumento 1, argumento 2, ..., argumento N)

Tudo que estiver após a definição do nome da função pertence a ela até
iniciar a próxima classe, constante ou função.

Os argumentos são informações enviadas para a função, como variáveis, textos
e números. Quando uma função é chamada, tudo que estiver separado por vírgula
entre parênteses após o seu nome, são os argumentos enviados para ela.

Exemplos:

teste # Nesse caso a função teste é chamada sem nenhum argumento
ganhaexp(10) # Um argumento, o valor numérico 10
teste2(1, 2, "x") # Três argumentos: 1, 2 e "x"

Dentro da função, esses argumentos são as variáveis de 'arg0' a 'arg9', e
a quantidade de argumentos recebidos é sempre 'args'. Se um argumento não
existir, será NULO, que significa simplesmente um valor nulo, sem qualquer
efeito prático. Exemplo, se não passou nenhum argumento, 'arg0' a 'arg9'
terão o valor 'nulo'.

Há casos em que é interessante a função retornar uma informação a quem a
chamou. Isso é feito com a instrução 'ret', com a seguinte sintaxe:

ret <valor de retorno>

Essa instrução será vista mais detalhadamente em tópicos posteriores,
mas o que ela faz é retornar de uma função.

Exemplo:

func soma # Retorna a soma dos dois primeiros argumentos
ret arg0 + arg1

func y
int8 x
x = soma(1, 2) # Atribui o valor 3 à variável 'x'

Portanto, pode-se dizer que a instrução 'ret' faz o caminho inverso dos
argumentos. E, da mesma forma, se o valor de retorno for omitido ou se a
função retornar porque chegou no final, é retornado o valor 'nulo'.


6. CONSTANTES

Em princípio, são semelhantes a variáveis, porém possuem uma informação que
não pode ser alterada. E é justamente essa imutabilidade de alteração
que dá origem ao nome 'constante' para as tais.

Sintaxe para definir uma constante:
const <nome da constante> = <valor da constante>

Exemplos:

# Constante denominada 'teste0' equivale ao número 10
const teste0 = 10

# Constante denominada 'teste1' equivale ao texto "bom dia"
const teste1 = "bom dia"

Internamente, constantes são semelhantes a funções contendo apenas uma
instrução RET, nada além disso. Por exemplo, considere a seguinte função:

func x # Função denominada 'x'
# Retorna um valor numérico multiplicado por 10
ret arg0 * 10

Pode ser reescrita na forma de constante, da seguinte forma:

# Constante denominada 'x' que retorna o resultado da expressão arg0 * 10
const x = arg0 * 10


7. FUNÇÕES DO TIPO VARIÁVEIS

É um tipo de função que se comporta como se fosse uma variável:
 - Quando é feita uma leitura da variável, ao invés disso a função
   é chamada sem nenhum argumento e deve retornar o valor lido.
 - Quando a variável é alterada, a varfunc é chamada com o valor de
   alteração em arg0. O valor de retorno não tem qualquer efeito.

Sintaxe:
varfunc <nome da função>

Exemplo:

varfunc x # Varfunc denominada 'x'
  se args==0
# Leitura da variável: retorna "bom dia"
    ret "bom dia"
  fimse
# Mudar a variável: nesse caso está chamando outra função
  este.msg(arg0)
func teste
  txt10 n
# Vai fazer: n = "bom dia"
  n = x
# Tem o mesmo efeito de: este.msg("teste")
  x = "teste"

Varfunc também pode ser escrita na forma de constante. Nesse caso, deve-se
definir como varconst ao invés de const.

Exemplo:

int16 x1
varconst x = args ? (x1 = arg0 * 100) : x1 / 100

Tem o mesmo efeito da função:

int16 x1
varfunc x # Função 'x' que se comporta como se fosse uma variável
se args # Se for alteração
x1 = arg0 * 100 # Coloca em x1 o novo valor multiplicado por 100
senao # Se for leitura
ret x1 / 100 # Retorna o valor de x1 dividido por 100.

Esse é um exemplo prático de como representar um número de dois dígitos
após a vírgula em uma variável int16. Enquanto um int16 vai de -32768
a 32767, a varfunc x vai de -327,68 a 327,67.


8. HERANÇA

É um mecanismo que possibilita o compartilhamento de variáveis, funções,
constantes e etc. entre duas ou mais classes. Através da instrução herda,
uma classe passa a incorporar todo o conteúdo de outra.

 - A classe que tem o conteúdo herdado é chamada de classe base ou
   superclasse.
 - A classe que herda é chamada de classe derivada ou subclasse.

A herança é definida no início da classe, conforme a sintaxe:
herda <classe 1>, <classe 2>, <classe 3> ... <classe n>

Exemplo 1:

classe x
int8 teste0
classe y
herda x
txt8 teste1

Exemplo 2:

classe y
int8 teste0
txt8 teste1

Nestes dois exemplos a classe 'y' sempre possui a variável 'int8 teste0':
 - No primeiro exemplo, porque herdou da classe 'x';
 - No segundo, porque foi definida na própria classe 'y'.

Uma classe derivada pode adquirir o conteúdo de maneira indireta, ou seja,
através da herança de outras classes. Veja o exemplo abaixo.

Exemplo 3:

classe A
int8 ano
classe B
herda A
int8 mes
classe C
herda B
int8 dia

 - A classe A contém a variável ano;
 - A classe B contém as variáveis ANO e MES; pois herdou a variável ANO
   da classe A com a instrução herda;
 - A classe C contém as variáveis DIA, MES (pois C herdou B) e ANO
   (pois C também herdou A, por ser herança de B).

Quando houver um nome de variável ou função repetido na herança, prevalece
a primeira encontrada. As demais são ignoradas. Veja o exemplo abaixo.

Exemplo 4:
classe A
txt10 x
classe B
herda A
int8 x

Nesse caso a classe B possui a variável 'int8 x', mas não possui a variável
'txt10 x'.


9. CONTEÚDO DAS FUNÇÕES

As instruções executadas pelo interpretador são sempre escritas dentro de
funções. Esta sessão trata do que pode-se escrever em cada linha.

9.1. Comentários

Quando for necessário escrever uma explicação (um comentário) para quem
estiver lendo o código, acrescente o símbolo # (number) seguido de um
texto qualquer. É possível escrever comentários em praticamente qualquer
lugar da classe, exceto nas instruções classe e herda.

Exemplo:

x = 10 # Faz x ser 10
se x == 10 # Verifica se x é 10
# Se x for 10, executa algo aqui
fimse

Nota: Os comentários não interferem no período de tempo da interpretação
      quando estão na frente de uma instrução. No caso de linhas iniciadas
      por '#', há um consumo de tempo, porém desprezível.

9.2. Textos

Qualquer sequência de texto que esteja entre aspas duplas (") é
interpretada como um texto.

Exemplo 1:

# A linha abaixo atribui o texto 'bom dia' à variável 'x'
x = "bom dia"

É possível representar caracteres como aspas duplas e definição de cores
em textos através do caracter '\' (raíz).

São eles:

\n - Indica o fim de uma linha e começo de outra logo abaixo;
\\ - O mesmo que '\' visível no texto;
\" - Aspas duplas visível no texto;
\b - Altera cor dos caracteres para branco com fundo preto e sem
     sublinhado, piscante e reverso;
\c - Altera apenas a cor dos caracteres (veja abaixo);
\d - Altera apenas a cor de fundo (veja abaixo)

O primeiro caracter após '\c' ou '\d' corresponde à nova cor.

Caracteres válidos para '\c' e '\d':
0 - Preto
1 - Vermelho
2 - Verde
3 - Marrom
4 - Azul
5 - Magenta
6 - Ciano
7 - Branco

Caracteres válidos apenas para '\c':
8 - Cinza
9 - Vermelho intenso
A - Verde intenso
B - Amarelo
C - Azul intenso
D - Magenta intenso
E - Ciano intenso
F - Branco intenso
G - Liga o sublinhado (um traço horizontal em baixo)
H - Desliga o sublinhado
I - Liga inversão de frente com fundo (troca cores de frente com fundo)
J - Desliga inversão de frente com fundo
K - Liga texto piscante
L - Desliga texto piscante
M - Echo off (não deve ecoar na tela o que o usuário digita)
N - Echo on (deve ecoar na tela o que o usuário digita)
O - Go ahead (usado por alguns clientes de MUD para identificar o prompt)
P - Bipe

Importante:
A janela do IntMUD, no Windows, não permite sublinhado e texto piscante.

Exemplo 2:

const x = "Ao acordar diga:\n\"Bom dia!\""
const y = "\bFruta verde: \c2limão\b"

Nesse caso, a constante x corresponde ao seguinte texto de duas linhas:
Ao acordar diga:
"Bom dia!"

Já a constante y corresponde ao texto 'Fruta verde: limão', sendo que
'Fruta verde:' está em branco com fundo preto e 'limão' está em verde
(com fundo preto, pois a cor de fundo não foi mudada). O '\b' no final
faz a letra voltar a ficar branca com fundo preto.

9.3. Números

Qualquer digito de 0 a 9, que pode ter as seguintes características
matemáticas, específicas ou simultâneas:

 - Não precedente a um sinal de '-' (menos) será um número positivo;
 - Precedente a um sinal de '-' (menos) será um número negativo;
 - Precedendo a um '.' (ponto) que precede um dígito também de 0 a 9 será
   um número decimal.

Exemplo 1: Atribuição de números em variáveis

func valor
real w # Variável usada para valores positivos, negativos e decimais
uint8 x # Usada apenas para valore positivos
int8 y # Usada para valores positivos e negativos
real z # Usada para valores positivos, negativos e decimais
# Atribui o valor decimal '1.5' em 'w'
w = 1.5
# Atribui o valor positivo '10' em 'x'
x = 10
# Atribui o valor negativo '-10' em 'y'
y = -10
# Atribui o valor negativo e decimal '-1.5' em 'z'
z = -1.5

9.4. Números em hexadecimal

Qualquer número que começar com '0x' está em hexadecimal. Não é permitido
o ponto decimal, mas pode haver um sinal de '-' (menos) para indicar
quando o número for negativo.

Exemplos de números em hexadecimal:

0x10
-0x48a
0xfc3d5

O sistema de numeração hexadecimal utiliza 16 símbolos, de '0' a '9' e
de 'a' a 'f', para representar qualquer número, enquanto que o sistema
decimal usa somente os dígitos de '0' a '9'. Uma explicação mais detalhada
está mais adiante, no tópico 13.6, que trata de operadores de bit.

9.5. Definição de uma variável

Segue a mesma sintaxe vista anteriormente:
<tipo de variável> <nome da variável>

As variáveis são sempre definidas dentro de classes, mas dependendo
de onde, possuem um tempo de existência diferente.

Antecedente às funções, pertencem à classe.
Cada objeto criado possui a variável (vide instruções 'criar' e 'apagar').
Portanto, se existirem 10 objetos de uma mesma classe, existirão 10
variáveis com o mesmo nome e tipo, porém em objetos diferentes.

Dentro de uma função, existem apenas na própria função.
É criada quando a função é chamada e o interpretador encontra a
definição da variável, e apagada quando a função retorna.

Dentro de um bloco de controle, em uma função, o tempo de existência da
variável é ainda menor. É apagada quando o bloco termina. Em blocos de
repetição (vide instruções 'enquanto' e 'efim'), a cada repetição
a variável também é apagada.

Exemplo:

classe a
uint8 x # Essa variável existe em cada objeto da classe 'a'
func f1
# Aqui a variável 'w' ainda não existe
ref w # Essa variável existe em qualquer lugar de 'f1', até 'f1' retornar
se !args # Aqui começa um bloco 'se'
int8 y # Essa variável só existe dentro desse bloco 'se'
senao
txt10 y # Essa é outra variável 'y', independente da 'y' acima
fimse # Marca o fim do bloco 'se'
# Aqui a variável 'y' já não existe mais, porém 'w' ainda existe

Nota: O exemplo acima não produz nenhum resultado prático.
      O único objetivo é demonstrar o tempo de existência das variáveis.

9.6. Acessar variáveis e chamar funções

Sintaxe: <nome da variável>

As variáveis e funções só são reconhecidas quando:

 - São funções nativas da linguagem, como por exemplo 'intabs';
 - Estiverem definidas na própria função ou na mesma classe;
 - Caso não exista, resultará em NULO.

É possível também passar variáveis como argumentos para outra função,
ou mesmo retornar uma variável pela instrução ret.

Quando houver duas ou mais funções e/ou variáveis com o mesmo nome,
somente a que foi definida primeiro estará acessível. A exceção são
variáveis do objeto, que ficam inacessíveis quando houver outra na função
ou nativa da linguagem. Nesse caso, só será possível acessá-las através
do objeto 'este'. Isso será visto adiante.

Exemplo:

telatxt = 1
classe teste
const a = "classe1" # Primeira constante A na classe
const a = "classe2" # Segunda constante A na classe
const intabs = "classe3"
func iniclasse # Classe foi criada, cria um objeto
criar(arg0)
func ini # Objeto foi criado
telatxt tela # Para mostrar mensagens na tela
tela.msg("A=" + a + "\n") # Mostra 'A=classe1'
txt10 a # Aqui a variável A passa a existir na função
tela.msg("A=" + a + "\n") # Mostra o valor inicial de A, mostra 'A='
a = "func1"
tela.msg("A=" + a + "\n") # Mostra 'A=func1'
tela.msg("este.A=" + este.a + "\n") # Mostra 'A=classe1'
txt10 a # Essa segunda variável A da função não tem efeito
tela.msg("A=" + a + "\n") # Mostra 'A=func1'
tela.msg("intabs=" + intabs(-10) + "\n") # Mostra 'intabs=10'
tela.msg("este.intabs=" + este.intabs(-10) + "\n") # Mostra 'intabs=classe3'

9.7. Palavras predefinidas

 - 'ARG0' a 'ARG9'             - argumentos passados para a função, sendo
                                 'arg0' o primeiro argumento;
 - 'ARGS'                      - quantidade de argumentos passados
                                 para a função;
 - 'NULO'                      - significa um valor nulo (não textual,
                                 numérico ou objeto);
 - 'ESTE'                      - refere-se ao objeto atual.

9.8. Símbolo cifrão ($)

Sintaxe: $<nome da classe>

Corresponde sempre ao primeiro objeto da classe. Se a classe não existir
ou não possuir nenhum objeto, assume NULO. Para mais detalhes de
criação e remoção de objetos, vide funções CRIAR() e APAGAR().

Exemplo:
'$teste' corresponde ao primeiro objeto da classe 'teste'.

9.9. Colchetes

Qualquer coisa entre colchetes é transformado em um texto, que fará parte
do nome de uma variável ou função.

Exemplos:

txt10 y # Um texto de até 10 caracteres
x["1"] = 10 # É o mesmo que: x1 = 10
y = "_teste"
x[y] = 20 # É o mesmo que: x_teste = 20

9.10. Dois pontos

Sintaxe: <nome da classe>:<nome da variável ou função>

São usados para acessar uma variável ou função de uma classe específica,
como se estivesse definida na classe em que foi chamada.

Exemplo:

classe misc
func xy
y = x * 2

classe teste
const x = 2
int8 y
func f1
y = x * 3 # Aqui 'y' passa a ser 6
misc:xy # Aqui 'y' passa a ser 4 (faz o mesmo que 'y=x*2')

9.11. Um ponto

Frequentemente variáveis e objetos possuem outras variáveis e funções,
e para usá-las, deve-se escrever o caminho completo até elas.
São dois ou mais nomes separados por um ponto. Exemplo, se A possui B,
que por sua vez possui C, para acessar 'C' escreva 'A.B.C'.

Outros exemplos:

func teste
este # É o objeto atual
este.x # É a variável ou função 'x' do objeto atual
x # É o mesmo que 'este.x', porque não há uma variável 'x' na função
ref r # 'r' é um tipo de variável que corresponde a um objeto
r = este # 'r' é o objeto atual
r.y # É o mesmo que 'este.y'
telatxt t # 't' é uma variável do tipo 'telatxt'
t.msg("oi\n") # Chama a função 'msg' da variável 't'
r.x.y # Significa 'y', que pertence a 'x', que por sua vez pertence a 'r'
$teste.x # Variável 'x' do primeiro objeto da classe 'teste'

9.12. Uma expressão

Qualquer combinação de operandos e operadores. É muito comum atribuir um
valor a uma variável dessa forma.

Exemplos:

x = 10 # Faz 'x' ser 10
y = x * 0.5 # O mesmo que '10 / 0.5' pois x = 10
z = intabs(-3) # Faz 'z=3', pois intabs retorna o número sem sinal de menos
z1 = 10, z2 = 10 + z1 # 'z2 = 10 + z1' é o mesmo que 'z2 = 10 + 10' pois z1=10
a = b = c = 4 # Primeiro faz c=4, depois b=c e por último a=b

9.13. Controle de fluxo

São instruções que ocupam uma linha inteira e mudam a sequência como as
instruções são executadas. Geralmente é executada linha por linha, até a
última, quando a função retorna. Mas com uma instrução 'se', é possível
executar algumas linhas sob determinada condição. Já uma instrução enquanto
permite repetir várias vezes uma ou mais linhas.

As lista completa de instruções de controle de fluxo será vista adiante.

Exemplo:
se x==10 # Se x for igual a 10
teste(4) # Chama a função teste
fimse

Nota: o sinal de igual para comparação é sempre escrito com == (dois iguais).


10. VARIÁVEIS BÁSICAS

10.1. int1 <nome da variável>
Pode ser 0 ou 1.

10.2. int8 <nome da variável>
Número inteiro de -128 a 127.

10.3. int16 <nomedavariável>
Número inteiro de -32768 a 32767.

10.4. int32 <nome da variável>
Número inteiro de -2147483648 a 2147483647.

10.5. uint8 <nomedavariável>
Número inteiro de 0 a 255.

10.6. uint16 <nome da variável>
Número inteiro de 0 a 65535.

10.7. uint32 <nome da variável>
Número inteiro de 0 a 4294967295.

10.8. intdec <nome da variável>
Número inteiro de -1.048.575 a 1.048.575. Quando o valor numérico
dessa variável for maior que zero, é subtraído uma unidade a cada
décimo de segundo.

Possui as seguintes funções e variáveis:
 - NEG: Interrompe a contagem se estiver contando.
   Isso é feito multiplicando a variável por -1 caso seja maior que zero.
 - POS: Faz a contagem voltar se estiver parada.
   Isso é feito multiplicando a variável por -1 caso seja menor que zero.
 - ABS: Um número de 0 a 1.048.575, que corresponde à contagem atual.
   É o valor da variável sem o sinal.

Exemplo:

intdec x
x = 10 # Esse valor equivale a um segundo
x.neg # Faz 'x' ser negativo, interrompendo a contagem; faz 'x = - 10'
n = x.abs # Mesmo que 'n = 10'
x.abs = 5 # Muda a contagem para 5, mas mantém parada; faz 'x = -5'
x.pos # Faz 'x' ser positivo, voltando a contagem; faz 'x = 5'
x.abs = 3 # Faz 'x = 3'

Nota: se não houver interesse em interromper a contagem, não há
necessidade de usar essas funções e variáveis.

10.9. intinc <nome da variável>
Número inteiro de -1.048.575 a 1.048.575. Quando o valor numérico dessa
variável for maior ou igual a zero zero, é somado uma unidade a cada
décimo de segundo.

Possui as funções 'neg', 'pos' e 'abs', exatamente como intdec (vide
acima).

10.10. real <nome da variável>
Corresponde ao tipo 'float' em C++.
Pode representar números na faixa de 10 elevado a -38 (menor que isso
é considerado zero) até 10 elevado a 38 (maior que isso é considerado
infinito), tanto positivos quanto negativos. A precisão é de 6 dígitos.
Ocupa o mesmo espaço na memória que uma variável int32.

10.11. real2 <nome da variável>
Variável real de dupla precisão. Corresponde ao tipo 'double' em C++.
Pode representar números na faixa de 10 elevado a -308 (menor que isso
é considerado zero) até 10 elevado a 308 (maior que isso é considerado
infinito), tanto positivos quanto negativos. A precisão é de 15 dígitos.
Ocupa o mesmo espaço na memória que duas variáveis int32.
Internamente, os cálculos matemáticos são feitos com variáveis real2.

10.12. txt<quantidade de caracteres> <nome da variável>
Define uma variável que contém um texto, de até 1 a 512 caracteres.

Exemplo:
txt10 x # Define a variável 'x', de até 10 caracteres

Nota: Se for atribuído um texto que ultrapassa a quantidade de caracteres
      da variável, ele será truncado.

Exemplo:

txt3 y # Quantidade máxima de caracteres de 'y' é 3
y = "bom dia" # Tem o mesmo efeito que y="bom"

10.13. ref <nome da variável>
Referência a um objeto, ou seja, corresponde a um objeto qualquer.

Essa variável passa a ter o valor NULO quando:
 - É criada;
 - É atribuído o valor NULO;
 - O objeto correspondente a ela é apagado.

Exemplo:

ref r0
# Cria um objeto da classe 'teste' e faz 'r0' corresponder a esse objeto
r0 = criar("teste")
# Altera variável 'x' do objeto criado
r0.x = 2
# Anula a referência, sem apagar o objeto criado
r0 = nulo

10.14. refvar <nome da variável> = <valor>
Referência a uma variável, ou seja, corresponde a uma variável qualquer.
A principal utilidade é abreviar nomes extensos de variáveis. Vide
exemplos abaixo.

Exemplo 1:

arg0.dono.nivel
refvar niv = arg0.dono.nivel # 'niv' é o memso que 'arg0.dono.nivel'

Exemplo 2:

telatxt t
t.msg("teste\n") # Mostra a palavra 'teste' na janela do programa
refvar xyz = t # Faz com que 'xyz' seja a variável 't'
xyz.msg("teste\n") # Mostra a palavra 'teste' na janela do programa

Nota 1: Essas variáveis só podem ser definidas dentro de funções.

Nota 2: É possível atribuir expressões a uma variável refvar.

Exemplo:
refvar xyz = 1 + 2 # Efetua soma '1 + 2', portanto 'xyz' passa a ser '3'

Nota 3: Variaveis desse tipo não podem referenciar funções.

Exemplo:
telatxt t
refvar xyz = t.msg # 'xyz' passa a ser o valor de retorno da função 't.msg'

Nota 4: Não é possível alterar o valor original após definições anteriores.

Exemplo:
refvar xyz = 5 # Faz com que 'xyz' seja 5
refvar xyz = 10 # Não tem efeito, porque a variável 'xyz' já existe


11. IDENTIFICADORES COMUM E SAV

Antes dos nomes que especificam o tipo da variável, é permitido colocar
as palavras 'comum' e 'sav'.

11.1. comum
Indica que a variável é a mesma para todos os objetos da classe.
Existe uma só variável, independente da quantidade de objetos criados.

Exemplo:
comum int8 x

11.2. sav
Indica que a variável deve ser salva em arquivo quando o objeto
for salvo por arqsav. Vide também o tópico da variável arqsav.


12. VETORES

São conjuntos de variáveis de mesmo tipo.

Sintaxe para definir um vetor:
<tipo da variável> <nome do vetor>.<número de variáveis de 1 a 255>

Exemplo:

int8 v.3

Nesse caso existem 3 variáveis do tipo 'int8':

v.0
v.1
v.2

Quando uma variável de um vetor gera um evento, o índice da variável
é passado como um argumento.

Exemplo:

classe x
inttempo n.5
func n_exec # Evento para as 5 variáveis 'n'
# No caso desse evento, ARG0 é o índice do vetor
# n.[arg0] corresponde à variável que gerou o evento

Nota: Funções e constantes não podem ser tratados como vetores.


13. OPERADORES

São símbolos que realizam operações, como por exemplo '+' (soma), '-'
(subtração), '*' (multiplicação) e '/' (divisão).

São chamados binários quando trabalham com dois operandos.

Exemplo:
1 + 2

O sinal de '+' no exemplo acima é binário, porque requer dois operandos.
Nesse caso, está somando 1 com 2.

Os operadores são unitários quando trabalham com apenas um operando.

Exemplos:
-x
!y

Nesses dois casos são unitários, e podem ser explicados assim:
 - No primeiro caso multiplica o valor de 'x' por '-1';
 - No segundo, resulta em 0 (falso) se 'y' for verdadeiro ou em 1
   (verdadeiro) se 'y' for falso.


13.1. VERDADEIRO E FALSO

Alguns operadores e instruções de controle de fluxo checam se uma
condição é verdadeira. Na maioria dos casos, o resultado é bastante
óbvio. Por exemplo, 'a==1' resulta em verdadeiro se a for igual a 1.
Mas quando a condição é uma variável, é um pouco diferente.

- O valor NULO é sempre falso.
- Números são considerados verdadeiros quando forem diferente de zero.
- Textos são considerados verdadeiros quando não forem textos vazios.
- Quando a variável não existe, ou quando é uma função que não
  retorna nenhum valor, o resultado é NULO, portanto falso.


13.2. LISTA DE OPERADORES

Segue a lista de operadores existentes. Nas explicações abaixo,
A e B são dois operandos (podem ser variáveis, textos, números, etc.).

OPERADORES BÁSICOS
A*B        - Multiplicação de A por B;
A/B        - Divisão de A por B. Pode resultar em número não inteiro;
A+B        - Soma de A com B;
A-B        - Subtração de A por B;
A%B        - O resto da divisão de A por B;

OPERADORES PARA BITS
~A         - Complemento de A, será explicado em operadores de bit;
A<<B       - Deslocamento à esquerda, sendo que A é o valor numérico e B
             é a quantidade de bits;
A>>B       - Deslocamento à direita, sendo que A é o valor numérico e B é
             a quantidade de bits;
A|B        - Operação 'OU' para bits entre A e B;
A^B        - Operação 'OU exclusivo' para bits entre A e B;
A&B        - Operação 'E' para bits entre A e B;

COMPARAÇÃO E ATRIBUIÇÃO
!A         - Se A for falso, o resultado será 1 (verdadeiro); Se A for
             verdadeiro, o resultado será 0 (falso);
A<B        - Verdadeiro se A for menor que B;
A<=B       - Verdadeiro se A for menor ou igual a B;
A>B        - Verdadeiro se A for maior que B;
A>=B       - Verdadeiro se A for maior ou igual a B;
A==B       - Verdadeiro se A for igual a B;
A===B      - Verdadeiro se A for exatamente igual a B;
A!==B      - Verdadeiro se A não for exatamente igual a B;
A!=B       - Verdadeiro se A for diferente de B;
A&&B       - Verdadeiro se A for verdadeiro e B também for;
A||B       - Verdadeiro se A for verdadeiro e/ou B for verdadeiro;
A=B        - Operador de atribuição, faz A igual a B.

FORMAS COMPACTAS
A*=B       - O mesmo que: A = A * B;
A/=B       - O mesmo que: A = A / B;
A%=B       - O mesmo que: A = A % B;
A+=B       - O mesmo que: A = A + B;
A-=B       - O mesmo que: A = A - B;
A<<=B      - O mesmo que: A = A << B;
A>>=B      - O mesmo que: A = A >> B;
A|=B       - O mesmo que: A = A | B;
A^=B       - O mesmo que: A = A ^ B;
A&=B       - O mesmo que: A = A & B.

INCREMENTO E DECREMENTO
++A        - O mesmo que (A = A + 1), mas sempre resulta em um valor numérico
--A        - O mesmo que (A = A - 1), mas sempre resulta em um valor numérico
A++        - Mesmo que ++A, mas o resultado é o valor de A antes da soma
A--        - Mesmo que --A, mas o resultado é o valor de A antes da soma

Exemplo:
int8 x # Nesse momento, x=0
int8 y # Nesse momento, y=0
int8 a
x++, y++ # Faz x e y serem 1
a = ++x # Faz x=2 e a=2
a = y++ # Faz y=2 e a=1

Pode-se usar também os parênteses em expressões.

Exemplo:
2*(3+4)

Nota: Duas variáveis são consideradas exatamente iguais se forem do mesmo
      tipo (dois números, dois textos, etc.) e possuírem o mesmo valor. Em
      textos, letras maiúsculas e minúsculas não são exatamente iguais.


13.3. PRECEDÊNCIA DE OPERADORES

Há uma precedência de operadores nos cálculos que, se não for levada
em conta, poderá produzir resultados indesejáveis.

Por exemplo, multiplicações e divisões são calculadas antes de soma e
subtração. Porém, uma soma entre parênteses é calculada antes, pois os
parênteses têm precedência sobre a multiplicação e a divisão.

Os operadores são avaliados na seguinte ordem:
! ~ ++ --       - 'NÃO' lógico, complemento, incremento e decremento;
* / %           - Multiplicação, divisão e resto;
+ -             - Soma e subtração;
<< >>           - Rotação para esquerda e para direita;
&               - 'E' para bits;
^               - 'OU exclusivo' para bits;
|               - 'OU' para bits;
<= < > >=       - Comparação;
== === != !==   - Igual a, exatamente igual a, diferente de, não
                  exatamente igual a;
&&              - 'E' lógico;
||              - 'OU' lógico;
? : ??          - Comparação similar a 'se' e 'senao' e operador ??;
= *= /= += -=   - Atribuição e formas compactas de atribuição.

Todos os operadores são processados da esquerda para a direita, com
exceção dos operadores de atribuição, que são processados da direita para
esquerda.

Exemplo 1:
X = 1 + 2 + 7

Soma 1 com 2, que resulta em 3; depois soma 3 com 7 que resulta em 10.
O resultado total será atribuído a 'x' então x = 10;

Exemplo 2:
W = X = 10

Faz 'X=10', depois faz 'W=X'. Os dois sinais de igual têm a mesma
precedência, mas o segundo (o que está mais à direita) é processado primeiro,
porque operadores de atribuição são processados da direita para a esquerda.

Exemplo 3:
y = (10+3)/2 <= 7 || (3>=3)*4 >= 2

Nesse caso, primeiro é avaliado o que está entre parênteses, resultando em:
y = 13/2 <= 7 || 1*4 >= 2
Depois multiplicação e divisão:
y = 7.5 <= 7 || 4 >= 2
Depois os operadores <= e >=:
y = 0 || 1
Depois 'OU' lógico, resultando em:
y = 1


13.4. OPERADORES ? E :

Os operadores '?' e ':' funcionam como as instruções 'se' e 'senao', com
algumas limitações, por serem operadores. Nas explicações abaixo, A e B
são dois operandos (podem ser variáveis, textos, números, etc).

a ? b : c
Se 'a' for verdadeiro, resulta em 'b'; se falso, resulta em 'c'.

a ? b
Se 'a' for verdadeiro, resulta em 'b'; se falso, resulta em 'nulo'.

a : b
Pouco usado. Calcula 'a' e 'b', porém resulta sempre em 'b'.

É possível combinar diversos desses operadores, alternando entre
interrogação e dois pontos.

Exemplo:
a ? b : c ? d : e

Nesse caso, temos o seguinte:
 - Se 'a' for verdadeiro resulta em 'b';
 - Se 'a' for falso checa 'c';
 - Se na segunda checagem 'c' for verdadeiro resulta em 'd';
 - Se 'c' for falso resulta em 'e'.

O operador ':' sempre deve estar separado por espaços, caso contrário
terá outro significado. Por exemplo, 'a : b' funciona como explicado acima.
Já 'a:b' significa a função ou variável b da classe a.


13.5. OPERADOR ??

É usado da seguinte forma:
a ?? b
Se a for verdadeiro, resulta em a. Se for falso, resulta em b.
Vide também tópico 13.1 Verdadeiro e falso.

Exemplos:
1 ?? 2
Resulta em 1, porque 1 é considerado verdadeiro.
0 ?? 2
Resulta em 2, porque 0 é considerado falso.


13.6. CONVERSÃO DE TIPOS EM OPERADORES BINÁRIOS

Via de regra, os operadores binários convertem o segundo operando para
o mesmo tipo do primeiro.

Exemplos:

10 > 2 # Verdadeiro; está comparando números
10 > "2" # Verdadeiro; o texto "2" é transformado em número antes da comparação
"10" > "2" # Falso; está comparando dois textos; o "1" vem antes do "2"
"10" > 2 # Falso; o número 2 é transformado em texto antes da comparação
"1" + 2 # É o mesmo que "1" + "2", portanto resulta em "12"
1 + "2" # É o mesmo que 1 + 2, portanto resulta em 3


13.7. OPERADORES DE BIT

Bit é a menor unidade de informação e pode assumir apenas dois valores,
0 ou 1. Variáveis int1 correspondem a um bit.

Nesse manual, chamaremos "ativo" quando um bit estiver em 1 e "desativo"
quando um bit for 0.

Operações com bits funcionam assim:

'~' (til) é um operador unitário que inverte o bit:
~0 resulta em 1
~1 resulta em 0

'&' (e comercial) resulta em ativo somente se os dois bits estiverem ativos:
0&0, 0&1 e 1&0 resultam em 0
1&1 resulta em 1

'|' (traço vertical) resulta em ativo se qualquer um dos bits estiver ativo:
0&0 resulta em 0
0&1, 1&0 e 1&1 resultam em 1

'^' (acento circunflexo) resulta em ativo se apenas um dos bits estiver ativo:
0&0 e 1&1 resultam em 0
0&1 e 1&0 resultam em 1

Essas operações também são possíveis com variáveis int8, uint8, int16,
etc. Para entender como funcionam, é necessário desmembrar em variáveis
int1. Os bits são numerados de 0 até 7 (em int8 e uint8), 15 (em int16 e
uint16) ou 31 (em int32 e uint32).

Cada bit ativo representa um valor, que é sempre a 2 elevado ao número
do bit, conforme a seguinte tabela:

bit 0 ativo = 1
bit 1 ativo = 2
bit 2 ativo = 4
bit 3 ativo = 8
bit 4 ativo = 16
bit 5 ativo = 32
etc.

O valor numérico da variável é a soma desses valores, ou zero, se nenhum
bit estiver ativo. Exemplo, o número 5 corresponde aos bits 2 e 0 ativos,
pois 5 significa somar 4 (bit 2) com 1 (bit 0). Não é possível formar o
número 5 com outra combinação de bits.

Os operadores de bit trabalham com cada bit individualmente.

Exemplo, considere os seguintes números:
7 = 4+2+1, portanto somente os bits 2, 1 e 0 estão ativos
12 = 8+4, portanto somente os bits 3 e 2 estão ativos

Assim, conclui-se que:

7 & 12          - O resultado é 4 (apenas o bit 2 ativo), pois é o único
                  bit ativo simultaneamente nos dois números, 7 e 12.
7 | 12          - O resultado é 15 pois os bits 0, 1, 2 e 3 estão ativos
                  em pelo menos um dos dois números, 7 ou 12.
7 ^ 12          - Resulta em 11, pois apenas os bits 3, 1 e 0 estão
                  ativos em um dos dois números e desativos no outro.

A grande vantagem dos operadores de bit em relação a vetores é poder
testar e/ou alterar vários bits simultaneamente:

'|' (ou) permite ativar um ou mais bits;
'&' (e) junto com '~' (inverter) permite desativar;
'^' (ou exclusivo) permite inverter;
'&' sozinho permite testar se um ou mais bits estão ativos.

Exemplo:

uint8 x
x = 1
x = x | 4 # Ativa o bit 2 de x
x = x & ~5 # Desativa os bit 2 e 0 de x
x = x ^ 6 # Inverte os bits 2 e 1 de x
x = x & 4 # Desativa todos os bits de x, exceto o bit 2
se x & 8 # Checa se o bit 3 está ativo
  msg("bit 3 de x está ativo\n")
senao
  msg("bit 3 de x não está ativo\n")
fimse

Outra forma de trabalhar com bits é usando vetores de int1. A variável
'bits' do vetor é o valor numérico correspondente.

Exemplo:

int1 x.32
x.bits = 3 # Ativa os bits 0 e 1 e desativa os demais;
x.3 = 1 # Ativa o bit 3; agora x.bits = 11.

Para simplificar as operações com bits, é usado o sistema de numeração binário,
que utiliza apenas os algarismos 0 e 1 na representação de qualquer número,
ao contrário do sistema decimal, que usa os algarismos de 0 a 9 para isso.

Vale lembrar que em uma contagem no sistema decimal, quando se esgotam
todas as possibilidades com o último dígito, que é o 9, passamos a
acrescentar mais um. Por essa razão após o 9 vem o 10; após o 99 vem o 100
e assim por diante. No sistema binário acontece a mesma coisa. Após o 1 vem
o 10 (2 em decimal), depois o 11 (3 em decimal), 100 (4 em decimal), etc.
Por isso diz-se que em binário 1+1=10.

Se os oito bits de uma variável uint8 forem escritos lado a lado, do bit 7
ao 0, o resultado será um número no sistema de numeração binário.

Exemplos:

00000000 em binário = 0 em decimal
00000001 em binário = 1 em decimal
00000010 em binário = 2 em decimal
10000000 em binário = 128 em decimal
11111111 em binário = 255 em decimal

As variáveis int8, int16 e int32, que permitem números negativos, possuem
a mesma quantidade de bits de uint8, uint16 e uint32, respectivamente. A
diferença está apenas na faixa de valores. Exemplo, um uint8 vai de 0 a 255,
enquanto que um int8 vai de -128 a 127. Nas variáveis que permitem números
negativos, o resultado depende de um cálculo:

 - Em int8, se o valor numérico passar de 127 (o bit 7 está ativo),
   subtraia 256;
 - Em int16, se o valor numérico passar de 32767 (o bit 15 está ativo),
   subtraia 65536;
 - Em int32, se o valor numérico passar de 2147483647 (o bit 31 está ativo),
   subtraia 4294967296.

Por exemplo, em um uint8, se todos os bits estiverem ativos, o valor
numérico será 255, como visto anteriormente. Em um int8, como passou
de 127, subtraia 256. Portanto, todos os bits ativos formam o número -1.
Já o número 10 é o mesmo, tanto em um int8 quanto em um uint8, porque
não passou de 127.

Na prática, quando qualquer operação com bits é realizada, todos
os números são transformados em int32. Porém, usamos int8 nas explicações
porque a quantidade de bits é bem menor.

Existem dois operadores, '>>' e '<<', chamados de deslocamento de bits.
O primeiro desloca os bits para a direita, em binário, sem alterar o último
bit. Já o segundo, desloca para a esquerda e desativa o bit 0.

Por exemplo, considere o número 00001100 em binário.
Um deslocamento para a esquerda resulta em: 00011000.
Dois deslocamentos para a esquerda resultam em: 00110000.
Um deslocamento para a direita resulta em: 00000110.
Dois deslocamentos para a direita resulta em: 00000011.

Esses operadores são usados conforme a sintaxe:
<valor numérico> >> <quantidade de deslocamentos>
<valor numérico> << <quantidade de deslocamentos>

Exemplos:

2 << 1 # Resulta em 4, pois o que estava no bit 1 passa para o bit 2
2 << 2 # Resulta em 8 (dois deslocamento)
2 << 3 # Resulta em 16 (três deslocamentos)
5 << 1 # Resulta em 10 (um deslocamento para os bits 0 e 2)
4 >> 1 # Resulta em 2
4 >> 2 # Resulta em 1
4 >> 3 # Resulta em 0
3 >> 1 # Resulta em 1
-3 >> 1 # Resulta em -2

No penúltimo exemplo, 3 >> 1 resulta em 1.
O número 3, em binário é 00000011. Após uma rotação para a direita,
o resultado é 00000001, que corresponde a 1.

O último exemplo é o mais complicado. Em um int8, o número -3
é 11111101 em binário. Após uma rotação para a direita, o resultado
será 11111110 em binário, que corresponde ao número -2.

Como pode-se observar, o operador '>>' divide por potências de 2 arredondando
para baixo e o operador '<<' multiplica por potências de 2. Mas cuidado!
Se o resultado da multiplicação não couber em um int32, o valor de alguns
bits perde-se. Dois exemplos demonstram claramente esse problema:

1 << 31 # Resulta em -2147483648, pois o conteúdo do bit 0 vai para o bit 31
1 << 32 # Resulta em 0, pois o conteúdo do bit 0 iria para o bit 32

Na prática, só é interessante usar esses operadores quando estiver lidando
com bits. Para multiplicação e divisão, é melhor usar '*' e '/'.

O IntMUD não permite escrever diretamente em binário, e em decimal muitas
vezes envolve vários cálculos. Por isso, é possível usar o sistema de
numeração hexadecimal. Os números são compostos da sequência '0x' seguido
de um ou mais caracteres, entre os dígitos de '0' a '9' e letras de 'a' a 'f'.
As letras correspondem aos valores de 10 a 15 em decimal. Também é possível
o sinal de '-' (menos) na frente, mas não é permitido o ponto decimal.

Exemplos de números em hexadecimal e o valor correspondente em decimal:

0x09 = 9
0x0a = 10
0x10 = 16
-0x10 = -16
0xff = 255

Nota: É fácil saber o sistema de numeração usado. Todos os números em
hexadecimal começam com '0x'.

A conversão entre decimal e hexadecimal baseia-se em potências de 16.
Por exemplo, para converter o número 0x2f8 (hexadecimal) em 760 (decimal),
o cálculo é:

2 * 256 + 15 * 16 + 8

O número 256 é 16 elevado ao quadrado, e o número 15 corresponde ao dígito
'f' em hexadecimal.

Para converter em decimal, deve-se fazer sucessivas divisões por 16.
Nesse caso:

760 / 16 = 47 (resto 8)
47 / 16 = 2 (resto 15)

O resultado da última divisão e os restos (2, 15, 8) formam o número 0x2f8.

A conversão entre binário e hexadecimal é direta. Cada 4 dígitos em
binário formam um dígito em hexadecimal:

0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = 8
1001 = 9
1010 = a
1011 = b
1100 = c
1101 = d
1110 = e
1111 = f

Exemplo, para converter o número 0x2f8 em binário, basta substituir cada
dígito hexadecimal pelos quatro dígitos correspondente em binário:

001011111000


13.8. OPERADORES DE BIT COM TEXTOS

Para converter entre sistemas de numeração pelo IntMUD, usar a função
txtconv. Por exemplo, a conversão de 0x2f8 em binário pode ser feita assim:
txtconv("2F8", "hx") # Resulta em "0000001011111000"

Os operadores de bit '|' (ou), '&' (e) e '^' (ou exclusivo), funcionam
de outra forma quando o primeiro operando for um texto. Nesse caso,
o texto é tratado como se fosse um número em hexadecimal. Ou seja, são
considerados somente os dígitos de 0 a 9 e as letras de A a F.

Exemplo, "123" ^ "456" resulta em "575". Isso acontece porque comparando
dígito por dígito temos: 1^4=5, 2^5=7 e 3^6=5.

Como é de se esperar, quando um dos textos é menor, é considerado como
se houvessem zeros no começo.

Por exemplo, considere a expressão:
"1" | "abc"

Isso é o mesmo que:
"001" | "abc"

E resulta em "abd".

O operador '~' (inverter) com um texto inverte os bits de cada dígito.

Exemplo, ~"1111" (em cada dígito, apenas o bit 0 está ativo) resulta em
"eeee" (bit 0 desativado e todos os outros três bits: 1, 2 e 3 estão
ativados em cada dígito).

Antes de inverter os bits, geralmente é interessante definir quantos
caracteres um número tem, acrescentando zeros no começo se necessário.
Isso é feito com a função txthex, da seguinte forma:
txthex(<texto>, <quantidade de caracteres>).

Exemplo, para inverter os bits do número "11" considerando 5 dígitos:
~txthex("11", 5)

Como o número informado, "11", tem menos de 5 dígitos, a função txthex
acrescenta zeros à esquerda, retornando o valor "00011". Em seguida,
ao inveter os bits com o operador '~', resulta em "fffee". Isso seria
o mesmo que ~"00011".

Quando o número informado ultrapassa a quantidade de caracteres definida,
a função txthex funciona como txtfim, retornando os últimos caracteres
do texto.

Exemplo, txthex("11188", 2) resulta em "88".

Os operadores '>>' e '<<', deslocam os bits do número em hexadecimal, para
a direita e para a esquerda respectivamente. O operando da direita, por ser
o número de deslocamentos, é sempre um número. O valor em hexadecimal,
que possui a sequência dos bits, é o operando da esquerda.

Exemplo, "220" << 4 resulta em "2200", enquanto que "220" >> 4 resulta
em "22". Algo como "1" << 10 significa 10 deslocamentos para a esquerda.
e resulta em "400".

Para eliminar os zeros à esquerda do número, basta fazer uma operação "ou"
ou "ou exclusivo" com 0. Exemplo, "000045" | 0 resulta em "45".

Seguem abaixo outras aplicações práticas. Notar que na operação de zerar
bit, o resultado não passará de 10 dígitos.

a = "12f0" | ("1" << 3) # Coloca o bit 3 de "12f0 em 1 (faz a="12f8")
a = "12f0" | intbith(3) # Mesma coisa, porém usando intbith
b = "12f0" & ~txthex("1" << 4, 10) # Zera o bit 5 de "12f0" (faz b="12e0")
b = "12f0" & ~txthex(intbith(4), 10) # Mesma coisa, porém usando intbith
c = "12f0" ^ ("1" << 2) # Inverte o bit 2 de "12f0" (faz c="12f4)
c = "12f0" ^ intbith(2) # Mesma coisa, porém usando intbith


14. INSTRUÇÕES DE CONTROLE DE FLUXO

14.1. Bloco 'se'

Permite executar ou não instruções baseando-se em uma ou mais condições.

Sintaxe mais simples:

se <condição>
<comandos>
fimse

Se a condição for verdadeira, os comandos que vierem abaixo são
executados. Se for falsa, vai direto para o 'fimse'.

Sintaxe completa:

se <condição>
<comandos>
senao <condição>
<comandos>
senao
<comandos>
fimse

Permitem testar várias condições, na sequência, até que uma seja
verdadeira, e assim executar os comandos correspondentes a ela.

- A instrução 'se' contém a primeira condição, e marca o início do bloco;
- As instruções 'senao' são opcionais. Elas contém as próximas condições;
- Um 'senao' sem condição significa executar o que vier abaixo, tendo em
  vista todas as condições anteriores falsas;
- Um 'fimse' marca o fim do bloco. É opcional se for a última instrução
  da função (se for omitido, subentende-se que lá existe um fimse).

Exemplo:

func x
uint8 n
n = rand(1, 4) # Faz n ser um número aleatório de 1 a 4
se n == 1
msg("n é 1")
senao n == 2
msg("n é 2")
senao
msg("n não é 1 e nem 2")
fimse # Nota: esse 'fimse' aqui é opcional

14.2. Bloco 'casovar'

Sintaxe:

casovar <argumento>
casose "texto"
<comandos>
casose
<comandos>
casofim

Transforma <argumento> em texto e verifica qual instrução 'casose' contém o
mesmo texto. Nessa comparação, letras maiúsculas e minúsculas são
consideradas diferentes.

Se encontrar, vai para os comandos da instrução 'casose' correspondente.
Se não encontrar, vai para a instrução 'casose' sem argumentos ou, se essa
não existir, vai direto para a instrução 'casofim'.

A instrução 'sair', dentro do bloco 'casovar', avança direto para a instrução
'casofim'. Por isso, é comum terminar os comandos com uma instrução 'sair'.
Caso contrário, o IntMUD prossegue executando os comandos dos próximos
'casose', na sequência.

Nota: Um 'casovar' com vários 'casose' é mais eficiente que várias
      instruções 'se' e 'senao'.

Exemplo:

func x
casovar rand(1, 5)
casose "1"
msg("N é 1")
sair
casose "2"
msg("N é 2")
sair
casose "5"
msg("Adivinha só?")
casose
msg("N não é nem 1 nem 2")
casofim

Exemplo correspondente usando um bloco 'se':

func x
uint8 n
n = rand(1, 5)
se n == 1
msg("N é 1")
senao n == 2
msg("N é 2")
senao n == 5
msg("Adivinha só?")
msg("N não é nem 1 nem 2")
senao
msg("N não é nem 1 nem 2")
fimse

14.3. Laço 'enquanto'

Sintaxe:

enquanto <condição>
<comandos>
efim

Repete os comandos enquanto a condição for verdadeira.

Isso é feito da seguinte forma:
- Avalia a condição;
- Se for falsa, vai para a instrução após o 'efim';
- Se for verdadeira, executa os comandos e volta para o 'enquanto',
  para testar a condição novamente.

Exemplo:

func teste
telatxt t
int8 x
x = 2
enquanto x < 5
t.msg("x é " + x + "\n")
x += 1
efim

Exemplo correspondente sem usar o 'enquanto':

func teste
telatxt t
t.msg("x é 2\n")
t.msg("x é 3\n")
t.msg("x é 4\n")

14.4. Laço 'epara'

Sintaxe:

epara <inicialização>, <condição>, <incremento>
<comandos>
efim

É um laço de repetição mais completo que o 'enquanto'.

Funciona da seguinte forma:
- Executa a inicialização;
- Avalia a condição;
- Se for falsa, vai para a instrução pós o 'efim';
- Se for verdadeira, executa os comandos e o incremento, e volta para
  o 'epara', para testar a condição novamente.

Exemplo: Mesma funcionalidade do exemplo do laço 'enquanto'

telatxt t
int8 x
epara x = 2, x < 5, x += 1
t.msg("x é " + x + "\n")
efim

14.5. Instrução 'sair'

Sintaxe:
sair [condição]

Sai do bloco 'enquanto', 'epara' ou 'casovar', aonde essa instrução foi
colocada, indo para a primeira instrução após o fim do bloco.

Se a condição for definida, ela precisa ser verdadeira para a instrução
'sair' funcionar. Se for falsa, nada faz.

14.6. Instrução 'continuar'

Sintaxe:
continuar [condição]

Vai para a próxima instrução 'efim'. Portanto, essa instrução só tem
sentido dentro de um bloco 'enquanto' ou 'epara'.

Se a condição for definida, ela precisa ser verdadeira para a instrução
'continuar' funcionar. Se for falsa, nada faz.

14.7. Instrução 'ret'

Sintaxe:
ret
ret <argumento>
ret <condição>, <argumento>

Como visto anteriormente, a instrução 'ret' retorna de uma função.

Ela funciona da seguinte forma:
- Sem argumento retorna 'nulo'. Tem o mesmo efeito de 'ret nulo';
- Com um argumento retorna o próprio argumento;
- Com dois argumentos só retorna se a condição for verdadeira.
  Se for falsa, nada faz.

Exemplo:

ret rand(3) == 0, "Bom dia" # Retorna "bom dia" se rand(3) for igual a 0

Tem o mesmo efeito de:

se rand(3) == 0
ret "bom dia"
fimse

14.8. terminar

Encerra o programa (fecha o IntMUD).


15. LISTA DE FUNÇÕES

15.1. FUNÇÕES CHAMADAS PELO INTERPRETADOR

São funções que você pode criar no programa, e o interpretador chamará
em determinadas ocasiões.

15.1.1. ini

Sempre que um objeto é criado, logo em seguida é chamada a função 'ini'.
Portanto, é comum criar uma função 'ini' quando é necessário inicializar
algumas variáveis.

Veja também a função 'criar()'.

15.1.2. fim

É executada antes do objeto ser apagado.
Veja também a função 'apagar'.

15.1.3. iniclasse

É executada quando a classe é criada. Dentro dessa função, 'arg0' é sempre
o nome da classe. Quando o IntMUD é executado, ele chama as funções
'iniclasse' de todas as classes existentes.

É bastante comum, em diversas classes, uma função 'iniclasse' que cria
um único objeto. O seguinte código:

func iniclasse
criar(arg0)

Como esse é o primeiro objeto da classe, para usá-lo basta escrever
o símbolo '$' seguido do nome da classe. Por exemplo, '$teste.x' seria
a função ou variável 'x' do primeiro objeto da classe 'teste'.


15.2. FUNÇÕES NUMÉRICAS

15.2.1. intpos(<número>)
Se o número for menor ou igual a zero, retorna 0; se for maior que zero,
retorna o próprio número.

15.2.2 intabs(<número>)
O módulo do número (o número sem sinal).
Exemplo: intabs(-1) e intabs(1) são sempre 1.

15.2.3. int(<número>)
O valor inteiro do número (semelhante a variáveis 'int32').

15.2.4. intdiv(<número>)
O valor inteiro do número (semelhante a variáveis 'int32'), porém sem
arredondar (os dígitos após a vírgula são ignorados).
Exemplo, intdiv(1.7) resulta em 1; enquanto que int(1.7) resulta em 2.

15.2.5. intmax(<um ou mais argumentos>)
Compara numericamente os argumentos e retorna o maior deles.

15.2.6. intmin(<um ou mais argumentos>)
Compara numericamente os argumentos e retorna o menor deles.

15.2.7. rand(<número>)
Um número aleatório, inteiro, de 0 a número-1.
Exemplo: rand(10) retorna um número aleatório de 0 a 9.

15.2.8. rand(<mínimo>, <máximo>)
Um número inteiro aleatório de <mínimo> a <máximo>.
Exemplo: rand(2,4) retorna um número aleatório de 2 a 4.

15.2.9. rand(<texto>)
Retorna o texto original, mas com os caracteres embaralhados.
Exemplo: rand("abcde") retorna algo como "debac".

15.2.10. matcima(<número>)
Arredonda o número para cima. Exemplo, matcima(1.3) resulta em 2.

15.2.11. matbaixo(<número>)
Arredonda o número para cima. Exemplo, matcima(1.3) resulta em 1.

15.2.12. matraiz(<número>)
Calcula a raiz quadrada de um número.

15.2.13. matsin(<ângulo>)
Calcula o seno de um ângulo (o ângulo está em radianos).

15.2.14. matcos(<ângulo>)
Calcula o cosseno de um ângulo (o ângulo está em radianos).

15.2.15. mattan(<ângulo>)
Calcula a tangente de um ângulo (o ângulo está em radianos).

15.2.16. matasin(<número>)
Calcula o arco seno, um número de -pi/2 a pi/2.

15.2.17. matacos(<número>)
Calcula o arco cosseno, um número de 0 a pi.

15.2.18. matatan(<número>)
Calcula a arco tangente, um número de -pi/2 a pi/2.

15.2.19. matexp(<número>)
Calcula a função exponencial, usando o logaritmo natural como base.

15.2.20. matlog(<número>)
Calcula o logaritmo natural.

15.2.21. matpow(<primeiro número>, <segundo número>)
Retorna o resultado do primeiro número elevado ao segundo número.

15.2.22. matrad(<número>)
Retorna o ângulo em radianos a partir do ângulo em graus.

15.2.23. matdeg(<número>)
Retorna o ângulo em graus a partir do ângulo em radianos.

15.2.24. matpi
Retorna o valor de PI.

15.2.25. intbit(<um ou mais textos>)
Retorna um número inteiro que é o resultado de uma operação de bits.
Os bits que contém o valor 1 são os números contidos nos textos. Qualquer
caracter que não seja um dígito de '0' a '9' pode ser usado para separar
os números, inclusive o sinal de menos.

Vide também o tópico 13.6 - Operadores de bit.

Exemplo 1:
intbit("0 1 4") # Retorna 19, que corresponde aos bits 0, 1 e 4 em 1
# 19 = 1+2+16 = 2 elevado a 0 + 2 elevado a 1 + 2 elevado a 4

Exemplo 2:
telatxt t
int32 x
x = intbit("2,3") # Faz x=12, ou seja apenas os bits 2 e 3 em 1
x = intbit("2", "3") # A mesma coisa, faz x=12
x = intbit(2, 3) # A mesma coisa, faz x=12
x |= intbit("0") # Faz o bit 0 de x ser 1
x &= ~intbit("3") # Faz o bit 3 de x ser 0
x ^= intbit("1") # Inverte o bit 1 de x; como estava em 0 agora vai para 1
se x & intbit("1")
  t.msg("O bit 1 de x está em 1\n")
senao ~x & intbit("0")
  t.msg("O bit 0 de x está em 0\n")
senao x & intbit("2 3 4")
  t.msg("O bit 2, o 3 e/ou o 4 de x está em 1\n")
senao x & intbit("1 2") == intbit("1 2")
  t.msg("Os bits 1 e 2 de x estão em 1\n")
senao x & intbit("2 5") == intbit("5")
  t.msg("O bit 2 de x está em 0 e o bit 5 de x está em 1\n")
fimse

15.2.26. intbith(<um ou mais textos>)
Funciona exatamente como intbit, porém retorna um texto que é o número
em hexadecimal.

15.2.27. txtbit(<número>, [delimitador])
Retorna um texto formado por números de 0 a 31, que correspondem aos bits
do número que estiverem em 1. Os números são separados pelo texto usado
delimitador. Se for omitido, será usado um espaço.
Essa função faz o processo inverso de intbit.

Exemplos:
txtbit(10) # Retorna o texto "1 3"
txtbit(52, ", ") # Retorna o texto "2, 4, 5"

15.2.28. txtbith(<número>, [delimitador])
Funciona exatamente como txtbit, porém o número é um texto em hexadecimal.

15.2.29. hexbit(<texto>, <quantidade de caracteres>)
Assim como txtfim, retorna um texto que contém os últimos caracteres do texto.
Porém, se o texto não tiver a quantidade de caracteres especificada, são
acrescentados zeros no início.


15.3. FUNÇÕES DE TEXTO

15.3.1. txtnum(<número>, <formato>)
Retorna um texto correspondente a um número ou variável numérica.

Formato é um texto que pode conter:
Dígito de 0 a 9 - É o número de casas após a vírgula;
',' (vírgula)   - Separar o número com vírgula;
'.' (ponto)     - Separar o número com pontos, o ponto decimal vira
                  vírgula;
'E' (letra E)   - Mostrar em notação científica; as outras opções são
                  ignoradas.

Exemplo:
txtnum(1005.23, "3.") # Retorna "1.005,230"

Nota: Números muito grandes (mais de 18 dígitos antes da vírgula) são
      mostrados em notação científica. Por exemplo, 5.9E+18 significa
      59 seguido de 17 zeros.

15.3.2. txt(<texto>)
Texto constante (não pode ser alterado) igual a <texto>.
Se <texto> não for um texto, retorna um texto vazio.
Se for objeto, retorna o nome da classe.

15.3.3. txt(<texto>, [início], [tamanho])
Retorna os caracteres de um texto começando pela posição especificada em
[início] e limitando a quantidade de caracteres no parâmetro [tamanho].

O argumento [início] representa o caracter inicial do texto retornado,
sendo 0 o primeiro caracter.

O argumento [tamanho] é tamanho do texto retornado em número de caracteres.
Se for omitido ou se texto original for menor, retorna até o final do texto.

Exemplo:
txt("abcdef", 2, 2) é o mesmo que "cd".

15.3.4. txtfim(<texto>, <quantidade de caracteres>)
Retorna um texto que contém os últimos caracteres do texto.

Exemplo:
txtfim("abcdef", 3) é o mesmo que "def".

15.3.5. txt1(<texto>)
Retorna a primeira palavra do texto.

15.3.6. txt2(<texto>)
Retorna tudo exceto a primeira palavra do texto.

15.3.7. intsub(<texto>)
Retorna a quantidade de palavras contidas no texto.
As palavras são sempre separadas por um ou mais espaços.

15.3.8. txtsub(<texto>, <palavra inicial>, [quantidade de palavras])
Retorna um texto que é parte de <texto>.
As palavras sempre separadas por espaços e numeradas a partir do 0.
Se a quantidade de palavras for omitida, assume até o final do texto.

Exemplos:
txtsub("bom dia boa tarde", 2) é o mesmo que "boa tarde".
txtsub("bom dia boa tarde", 1, 1) é o mesmo que "dia".

15.3.9. intsublin(<texto>)
Retorna a quantidade de linhas contidas no texto.
As linhas são separadas por '\n'.
Nota: Se for um texto vazio, essa função retorna 0.

15.3.10. txtsublin(<texto>, <linha inicial>, [quantidade de linhas])
Retorna um texto que é parte de <texto>, da mesma forma que a função txtsub.
As linhas são sempre separadas por '\n'.
Se a quantidade de linhas for omitida, assume até o final do texto.

15.3.11. txtcor(<texto>)
Retorna o texto sem as definições de cores e opções do Telnet, ou seja
sem as definições compostas por '\b', '\c' e '\d'.

Exemplo:
txtcor("\cF\d4Teste\b") # É o mesmo que "Teste".

15.3.12. txtmai(<texto>)
Retorna o texto em letras maiúsculas.

15.3.13. txtmin(<texto>)
Retorna o texto em letras minúsculas.

15.3.14. txtmaiini(<texto>)
Retorna o texto passando a primeira letra para maiúscula.
Se encontrar algum ponto, a próxima letra também será maiúscula.

15.3.15. txtmaimin(<texto>)
Retorna o texto com a primeira letra maiúscula e as demais minúsculas.
Se encontrar um ponto, a próxima letra será maiúscula.

15.3.16. txtmudamai(<texto>, [porcentagem])
Retorna um texto que é o texto original com letras maiúsculas
trocadas com minúsculas.

Exemplo: txtmudamai("Bom Dia") é o mesmo que "bOM dIA"

A porcentagem é um número de 0 a 100 que indica a probabilidade de
ocorrer essa mudança em cada letra. O valor 0 significa não trocar,
e 100 troca sempre.

15.3.17. txtcopiamai(<texto1>, <texto2>)
Retorna <texto1> com a mesma sequência de maiúsculas e minúsculas
existente em <texto2> (a única alteração no texto é passar letras
para maiúsculas ou minúsculas).

Exemplo: txtcopiamai("teste", "XYZnn") é o mesmo que "TESte"

15.3.18. txtfiltro(<texto>)
Filtra e retorna o texto filtrado.

O que o filtro elimina:
- Espaços no começo e no fim do texto;
- A mesma sequência de caracteres repetida várias vezes seguidas;
- Muitos caracteres seguidos sem nenhuma vogal.

Exemplos de filtragens:
- 'aaaaaaaaaaaaa' vira 'aaaaa';
- 'abababababab' vira 'ababab';
- 'bom dia bom dia bom dia bom dia!' vira 'bom dia bom dia bom di!';
- 'http://xxx.yyy.zzz.nnn.br' vira 'http://xxx.yyy.zzz.nn', porque são
  muitos caracteres seguidos sem uma vogal.

15.3.19. txtesp(<quantidade de espaços>)
Retorna de 0 a 100 espaços conforme <quantidade de espaços>.

15.3.20. txtrepete(<texto>, <quantidade de repetições>)
Retorna o <texto> concatenando-o com ele mesmo repetidas vezes.

Exemplos:
txtrepete("a", 3) # é o mesmo que "aaa"
txtrepete("bom", 2) # é o mesmo que "bombom"

15.3.21. txtsepara(<texto>, <opções>, [texto usado como separador])
Separa números e palavras de um texto, acrescentando um texto separador.
Se o texto separador for omitido, será usado um espaço.

Opções é um texto, sendo que cada letra significa um tipo de caracter:
L - Uma letra;
D - Dígito de 0 a 9;
N - Números. Podem ser negativos (começar com um sinal de menos) e ter
    um ponto decimal;
E - Espaço;
O - Outros caracteres (vírgulas, sublinhados, pontos e etc);
V - Vazio (antes do início e depois do fim do texto).

Para indicar aonde o texto separador deve ser acrescentado, escreve-se
uma ou mais letras, que correspondem a um tipo de caracter, seguido do
sinal de mais e uma ou mais letras, correspondentes ao tipo de caracter
seguinte.

Pode-se usar mais de uma condição, separando-as com vírgulas.

Exemplo 1:
Para adicionar um espaço entre letras, o texto de opções deve ser "L+L".

txtsepara("bom dia!", "L+L") # Resulta em "b o m d i a!"

Exemplo 2:
txtsepara("bom dia boa tarde", "L+EV", "!")
# É o mesmo que: "bom! dia! boa! tarde!"

Exemplo 3:
Para separar os números, acrescentando um espaço na frente, o texto
de opções é "LNO+N", que significa qualquer letra, número ou outro carater
seguido de um número.

txtsepara("1,10abc-40", "LNO+N") # Resulta em: "1, 10abc -40"

Exemplo 4: Usando mais de uma condição

txtsepara("1,10abc-40", "LON+N,N+LON")
# É o mesmo que: "1 , 10 abc -40"

15.3.22. txtremove(<texto>, <opções>)
Retorna <texto> com algumas alterações como remover espaços extras,
cores, remover acentos de letras acentuadas, etc.

O argumento <opções> é um texto, sendo que cada letra é um tipo de alteração:
E - Remover espaços à esquerda;
M - Remover espaços extras, exceto à esquerda e à direita;
D - Remover espaços à direita;
C - Remover cores, exatamente como a função txtcor;
T - Remover eco, "go ahead" e bipe (de "\cg" até "\cj");
S - Remover aspas simples trocando espaços entre duas aspas por sublinhado;
A - Remover aspas duplas trocando espaços entre duas aspas por sublinhado;
7 - Usar letras sem acentuação (caracteres em 7 bits).

Exemplos:

txtremove("  bom  dia  ", "EMD") # É o mesmo que "bom dia"
txtremove("  bom  dia  ", "ED") # É o mesmo que "bom  dia"
txtremove("\cF\d4Teste\b", "C") # É o mesmo que "Teste"
txtremove("tenha um 'bom dia' !", "S") # É o mesmo que "tenha um bom_dia !"

15.3.23. intdist(<texto1>, <texto2>)
Calcula a distância 'Levenshtein' entre os dois textos.
Em outras palavras, calcula o quanto os dois textos são diferentes.
Retorna a quantidade de mudanças necessárias. O valor 0 significa
textos iguais.

As funções intdistmai e intdistdif fazem a mesma coisa, exceto que:
intdist    - Considera iguais letras minúsculas, maiúsculas e acentuadas;
intdistmai - Considera iguais letras maiúsculas e minúsculas;
intdistdif - Diferencia letras maiúsculas, minúsculas e acentuadas.

15.3.24. txtrev(<texto>)
Reverte um texto, de modo que o primeiro caracter é trocado com o último,
o segundo é trocado com o penúltimo, e assim por diante. Porém, não inverte
definições de cores.

Exemplos:

txtrev("abc") # É o mesmo que "cba"
txtrev("Bom dia") # É o mesmo que "aid moB"
txtrev("\c3\d4teste\b") # É o mesmo que "\betset\d4\c3"

15.3.25. txtconv(<texto>, <tipo de conversão>)
Converte texto em um formato para outro.
Tipo de conversão é um texto de dois caracteres. O primeiro é o formato
atual do argumento <texto>. O segundo é o formato retornado por txtconv.

Essa função trabalha com os seguintes formatos:
T é um texto no padrão iso8859-1 (é o formato usado no IntMUD).
    Todas as conversões envolvendo esse formato, exceto "TU" e "UT",
    removem as definições de cores.
U é um texto no padrão UTF-8.
    As únicas conversões possíveis com esse formato são "TU" e "UT".
B é uma sequência de bytes codificados em Base64.
    (cada 4 caracteres representam 3 bytes)
H é uma sequência de bytes codificados em Hexadecimal.
    (caracteres de 0 a 9 e de a a f; cada 2 caracteres representam um byte)
D é um número em decimal (são usados somente os dígitos de 0 a 9 e são
    eliminados zeros à esquerda do número). Para grandes textos, conversões
    com esse formato são um pouco lentas, se comparado com outras.
    A exceção é "DD", que é rápido.
X é um número em binário (caracteres 0 e 1; cada 8 caracteres representam
    um byte).

Pode-se usar ainda os seguintes textos no tipo de conversão:
"HH" faz o texto ser algo válido em Hexadecimal.
"BB" faz o texto ser algo válido em Base64.
"DD" mantém apenas os caracteres de 0 a 9, com exceção do 0 no começo
     do texto. No caso de não haver nenhum dígito de 0 a 9, retorna "0".

Exemplos:
txtconv("Não", "TU") # Texto convertido para UTF-8; aparece como "NÃ£o"
txtconv("A", "TD") # O mesmo que "65", que é o código ASCII da letra "A"
Nota: txt(intchr("A")) produz o mesmo resultado
txtconv("A", "TH") # O mesmo que "41", que por sua vez é 65 em hexadecimal
txtconv("ABC", "TH") # O mesmo que "414243"
txtconv("65", "DT") # O mesmo que "A", e o mesmo que txtchr(65)
txtconv("16", "DH") # O mesmo que "10", que é o número 16 em hexadecimal


15.4. FUNÇÕES PARA PROCURA E SUBSTITUIÇÃO DE TEXTOS

15.4.1. txtcod(<texto>)
Codifica um texto de modo que possa ser usado como nome de variável.
Os caracteres válidos em nomes de variáveis não são alterados, com exceção
do espaço, que muda para '@_'. Outros caracteres, como ponto, vírgula, etc,
são substituídos por uma '@' (arroba) seguido de um caracter válido em nomes
de variáveis, conforme a tabela abaixo.

@ (arroba)                  @@    \b (letras brancas sobre preto) @b
\c (cor das letras)         @c    \d (cor de fundo)               @d
\n (fim de linha)           @n    " (aspas)                       @a
! (exclamação)              @e    # (cerquilha)                   @f
$ (cifrão)                  @g    % (porcentagem)                 @h
& (E comercial)             @i    ' (apóstrofo)                   @j
( (abre parênteses)         @k    ) (fecha parêntese)             @l
* (asterisco)               @m    + (soma)                        @o
, (vírgula)                 @p    - (subtração ou hífen)          @q
. (ponto)                   @r    / (divisão)                     @s
: (dois pontos)             @t    ; (ponto-e-vírgula)             @u
< (menor que)               @v    = (igual)                       @w
> (maior que)               @x    ? (interrogação)                @y
[ (abre colchetes)          @z    \ (barra invertida)             @0
] (fecha colchetes)         @1    ^ (acento circunflexo)          @2
` (crase)                   @3    { (abre chaves)                 @4
| ('pipe', traço vertical)  @5    } (fecha chaves)                @6
~ (til)                     @7

Vide exemplo em txtdec (abaixo).

15.4.2. txtdec(<texto>)
Decodifica um texto. Processo inverso de txtcod.

Exemplo de como testar txtcod e txtdec:

telatxt = 1
classe tela
telatxt tela
func iniclasse
  criar(arg0)
func tela_msg
  tela.msg("txtcod = \"" + txtcod(arg0) + "\"\n")
  tela.msg("txtdec = \"" + txtdec(txtcod(arg0)) + "\"\n")

15.4.3. txtvis(<texto>)
Torna visíveis caracteres especiais, como \n e \b, fazendo as seguintes
substituições:
"\b" muda para "\\b"
"\c" muda para "\\c"
"\d" muda para "\\d"
"\n" muda para "\\n"
"\"" muda para "\\\""
"\\" muda para "\\\\"

Exemplo 1:

txtvis("\C1 \"Bom dia\" \B") # É o mesmo que "\\C1 \\\"Bom dia\\\" \\B".

Exemplo 2:

txt10 x
x = "\b\""
msg("A variável x contém \"" + txtvis(x) + "\"\n")

15.4.4. txtinvis(<texto>)
Processo inverso da função txtvis.

15.4.5. txtproc(<texto1>, <texto2>, [caracter inicial])
Procura <texto2> em <texto1>.
Retorna -1 se não encontrou ou o número do caracter se encontrou.
O [caracter inicial] indica o número do caracter em que deve-se começar
a busca. O valor 0 corresponde ao primeiro caracter, o valor 1 o segundo,
etc. Se omitido, começa no primeiro.

As funções txtprocmai e txtprocdif fazem a mesma coisa, exceto que:
txtproc    - Considera iguais letras minúsculas, maiúsculas e acentuadas;
txtprocmai - Considera iguais letras maiúsculas e minúsculas;
txtprocdif - Diferencia letras maiúsculas, minúsculas e acentuadas.

15.4.6. txtproclin(<texto1>, <texto2>, [linha inicial])
Procura uma linha de <texto1> com o texto de <texto2>.
Retorna -1 se não encontrou ou o número da linha se encontrou.
Quando um texto possui mais de uma linha, as linhas são separadas com um
caracter "\n". Tanto <texto1> quanto <texto2> podem ter várias linhas.
A [linha inicial] indica o número da linha em que deve-se começar
a busca. O valor 0 corresponde à primeira linha, o valor 1 à segunda,
etc. Se omitido, começa na primeira.

As funções txtproclinmai e txtproclindif fazem a mesma coisa, exceto que:
txtproclin    - Considera iguais letras minúsculas, maiúsculas e acentuadas;
txtproclinmai - Considera iguais letras maiúsculas e minúsculas;
txtproclindif - Diferencia letras maiúsculas, minúsculas e acentuadas.

15.4.7. txttroca(<texto>, <valor anterior>, <novo valor>)
Troca <valor anterior> por <novo valor> no <texto>.
Retorna o texto modificado ao invés de alterar o texto original.
Nota: Se <valor anterior> for um texto vazio, retorna <texto>.

Exemplo:
txttroca("possibilidade", "i", "e") é o mesmo que "possebeledade".

As funções txttrocamai e txttrocadif fazem a mesma coisa, exceto que:
txttroca    - Considera iguais letras minúsculas, maiúsculas e acentuadas;
txttrocamai - Considera iguais letras maiúsculas e minúsculas;
txttrocadif - Diferencia letras maiúsculas, minúsculas e acentuadas.

15.4.8. txte(<texto>)
Retorna o texto substituindo sublinhado '_' por espaço ' '.
Tem o mesmo efeito de txttroca(<texto>, "_", " ").

15.4.9. txts(<texto>)
Retorna o texto substituindo espaço ' ' por sublinhado '_'.
Tem o mesmo efeito de txttroca(<texto>, " ", "_").

15.4.10. vartroca(<texto>, <texto2>, <variável>, [porcentagem], [espaço])
Procura alguns textos em <texto> e substitui por variáveis ou funções
do objeto 'este'.
Os textos procurados são <texto2> seguido de uma palavra qualquer.
Os nomes das funções são <variável> seguido da mesma palavra.

Exemplo:

const t_1 = "joão"  # $1 = joão
const t_2 = "maria" # $2 = maria
vartroca("$1 falou com $2", "$", "t_")
# É o mesmo que: t_1 + " falou com " + t_2
# Que por sua vez, resulta no texto "joão falou com maria"

A [porcentagem] é um número de 0 a 100 que indica a probabilidade de
ocorrer cada troca. O valor 0 significa não trocar, e 100 troca sempre.
Se omitido, assume 100.

O [espaço] é um número que indica quantas trocas não deve fazer após
ter efetuado a última troca. Se omitido, assume 0.
Exemplo: 1 significa cada vez que trocar ignora a próxima troca

Quando vartroca chama uma função, coloca em arg0 o texto encontrado.

Exemplo de como diferenciar letras maiúsculas de minúsculas:

func teste_a
  se arg0 === "A" # Se for exatamente igual
    ret "A maiúsculo"
  senão
    ret "A minúsculo"
vartroca("$A $a", "$", "teste_") # Produz o texto "A maiúsculo A minúsculo"

Outra forma de escrever:

const teste_a = arg0 === "A" ? "A maiúsculo" : "A minúsculo"
vartroca("$A $a", "$", "teste_")


15.5. FUNÇÕES PARA APELIDO E SENHA

15.5.1. txtmd5(<texto>)
Calcula e retorna o MD5 de um texto.
O texto original é codificado de modo que não é possível decodificar.
O resultado é um texto de 32 caracteres de '0' a '9' e 'a' a 'f'.

15.5.2. txtsha1(<texto>)
Calcula e retorna o SHA1 de um texto.
O texto original é codificado de modo que não é possível decodificar.
O resultado é um texto de 40 caracteres de '0' a 9' e 'a' a 'f'.

15.5.3. txtsha1bin(<texto>)
Calcula e retorna o SHA1 de um texto.
O texto original é codificado de modo que não é possível decodificar.
O resultado do SHA é compactado em um texto de 27 caracteres contendo
letras maiúsculas e alguns símbolos.

15.5.4. txtnome(<texto>)
Codifica apelido para comparação.
São feitas diversas mudanças de acordo com algumas regras de pronúncia
do português. Por exemplo, 'ph' tem som de 'pi', 'l' seguido de qualquer
coisa exceto uma vogal tem som de 'u', 'c' exceto em 'ce' e 'ci' tem som
de 'k', entre outros. A lista de mudanças é um pouco complexa, por isso
foi omitida nesse manual.
Basicamente, se essa função retornar o mesmo texto para dois apelidos,
é quase certo que as pessoas que usam um sintetizador de voz em português
não conseguirão distinguir a diferença.
Nota: o texto retornado nunca é maior que o apelido.

15.5.5. intnome(<texto>)
Verifica se texto é válido para apelido.
Retorna um número:
0 - Apelido válido;
1 - Muito pequeno (menos de 2 caracteres);
2 - Contém caracteres inválidos.
Nota: Essa função também retorna 2 para algumas combinações de letras que
      podem causar resultados imprevisíveis nos sintetizadores de voz.
      Por exemplo, qualquer letra seguida de 'h', exceto 'ch', 'lh' e 'nh'.

15.5.6. intsenha(<texto>)
Verifica se texto é válido para senha.
Retorna um número:
0 - Senha válida;
1 - Muito pequena (menos de 5 caracteres);
2 - Contém caracteres inválidos;
3 - Contém só letras ou só números.


15.6. FUNÇÕES PARA OBJETOS

15.6.1. ref(<objeto 1>, <robjeto 2>, <objeto 3> ..., <objeto N>)
Checa os argumentos, do primeiro ao último, até encontrar um que seja
um objeto. Se encontrou, retorna o objeto. Caso contrário retorna NULO.
Portanto, quando houver apenas um argumento, que retorna o objeto
correspondente ou NULO se não for objeto.

15.6.2. criar(<nome da classe>, [um ou mais argumentos da função ini])
Cria um objeto e chama a função 'ini' do objeto.
O <nome da classe> é um texto que contém o nome da classe.
Retorna uma referência para o objeto, ou NULO se classe não existe.

Exemplos:
ref x
x = criar("teste1")
criar("teste2")

15.6.3. apagar(<objeto>)
Marca um objeto para ser apagado. O objeto só será realmente apagado após
o controle retornar ao programa. Mesmo assim, antes de apagar ainda será
chamada a função 'fim' do objeto.

Exemplo:
apagar(este)

15.6.4. objantes(<objeto>)
Retorna o objeto anterior da classe ou NULO se não houver.

15.6.5. objdepois(<objeto>)
Retorna o próximo objeto da classe ou NULO se não houver.

15.6.6. $<nome da classe>
Retorna o primeiro objeto da classe especificada.
Exemplos: $jog  ou  $["jog"]


15.7. OUTRAS FUNÇÕES

15.7.1. txturlcod(<texto>)
Codifica um texto formando uma URL válida.

Atua da seguinte forma:
- O primeiro '\n' é substituído por '?' (interrogação);
- Os próximos '\n' são substituídos pelo caracter '&'.
- O espaço é substituído por um sinal de '+' (mais);
- Letras de 'A' a 'Z' maiúsculas e minúsculas, dígitos decimal, '-'
  (hífen), '.' (ponto), '=' (igual) e '/' (barra) não são alterados;
- Qualquer outro caracter é substituído por um '%' seguido de dois
  dígitos, que são o código ASCII do caracter, em hexadecimal.

Exemplo:

txturlcod("/x.html\na=1\nb=bom dia!")
Resulta em "/x.html?a=1&b=bom+dia%21"
Em um servidor HTTP, isso geralmente significa acessar a página "/x.html"
passando as variáveis a="1" e b="bom dia!".

15.7.2. txturldec(<texto>)
Decodifica uma URL formando um texto. Processo inverso de txturlcod.

Exemplo:

txturldec("/x.html?a=1&b=bom+dia%21")
# Resulta em "/x.html\na=1\nb=bom dia!"

15.7.3. intchr(<texto>, [posição do caracter])
Retorna um número que é o código ASCII de um caracter, de 32 a 255,
ou um dos seguintes números:
0 - Não é um caracter (por exemplo, um texto vazio);
1 - '\b' (caracteres brancos com cor de fundo preta);
2 - '\c' (mudar cor dos caracteres);
3 - '\d' (mudar cor de fundo);
10 - '\n' (passar para a próxima linha).

Se a posição do caracter no texto for omitida, assume 0, ou seja o
primeiro caracter do texto.

15.7.4. txtchr(<valor numérico>)
Retorna o caracter correspondente a um código ASCII, ou um texto
vazio se não for um código ASCII válido.

15.7.5. inttotal(<variável>)
Se for objeto, retorna a quantidade de objetos da classe.
Se for texto, retorna o tamanho do texto em caracteres.
Se for vetor, retorna a quantidade de variáveis do vetor.
Se for fornecido mais de um argumento, é retornada a soma.

Exemplo:
inttotal("bom", "dia")

Nesse caso, é o mesmo que: inttotal("bom") + inttotal("dia")


15.8. FUNÇÕES DE VETORES DE VARIÁVEIS NUMÉRICAS

As variáveis do tipo 'real' e os tipos numéricos começados com a palavra
'int' (int1 a int32, uint1 a uint32, intinc, intdec e inttempo) possuem
as seguintes funções:

15.8.1. limpar([novo valor])
Faz todas as variáveis serem iguais ao novo valor. Se o novo valor for
omitido, faz todas variáveis serem 0.

15.8.2. bits
Existente somente em vetores de 'int1'. É uma variável do tipo 'int32',
que corresponde ao valor numérico das variáveis do vetor.


15.9. FUNÇÕES DE VETORES DE VARIÁVEIS TXT1 A TXT512

15.9.1. limpar([novo texto])
Faz todas as variáveis conterem o novo texto. Se o novo texto for omitido,
faz todas as variáveis conterem um texto vazio.

Exemplo:

txt10 x.3
x.limpar

É o mesmo que:

txt10 x.3
x.0 = ""
x.1 = ""
x.2 = ""

15.9.2. texto([número da primeira variável], [número da última variável])
Retorna um texto que corresponde a todas as variáveis concatenadas.

Exemplo:

txt10 x.3
x.0 = "a"
x.1 = "b"
x.2 = "c"
msg(x.texto) # É o mesmo que msg("abc")
msg(x.texto(0,1)) # É o mesmo que msg("ab")

15.9.3. palavras(<texto>, [número de palavras])
Divide o texto em palavras.
As palavras são separadas por espaço ou '\n'.
Retorna o número de palavras (pode ser zero).

Exemplo:

txt10 x.2
x.palavras("bom dia !")

É o mesmo que:

txt10 x.2
x.0 = "bom"
x.1 = "dia !"

15.9.4. linhas(<texto>, [número de colunas])
Preenche as variáveis do vetor com o texto, da seguinte forma:
- Cada variável recebe uma linha do texto (o caracter '\n' indica
  o fim de uma linha).
- Linhas que não cabem em uma variável são divididas automaticamente,
  de preferência no último espaço entre <número de colunas> e o tamanho
  da variável.
Retorna o número de linhas (pelo menos uma linha).

15.9.5. separar(<texto>, <delimitador>, [número de textos])
Divide o texto com o delimitador especificado.
Cada variável do vetor recebe um texto.
A última variável recebe o restante do texto.
Retorna o número de variáveis (pelo menos uma variável).

As funções separarmai e separardif fazem a mesma coisa, exceto que:
separar    - Considera iguais letras minúsculas, maiúsculas e acentuadas.
separarmai - Considera iguais letras maiúsculas e minúsculas.
separardif - Diferencia letras maiúsculas, minúsculas e acentuadas.

Exemplo:

txt10 x.4
x.separar("abc:10::def:20", ":")

É o mesmo que:

txt10 x.4
x.0 = "abc"
x.1 = "10"
x.2 = ""
x.3 = "def:20"

15.9.6. juntar(<delimitador>, [número de variáveis])
Concatena o número de variáveis do vetor especificadas, acrescentando
o delimitador entre duas variáveis. Retorna o texto obtido.

Exemplo:
x.juntar(",", 3) # É o mesmo que: x.0 + "," + x.1 + "," + x.2

15.9.7. txtremove(<opções>)
Altera todos os textos do vetor com a função txtremove.

Exemplo:

txt10 x.2
x.0 = txtremove(x.0, "C")
x.1 = txtremove(x.1, "C")

É o mesmo que:

txt10 x.2
x.txtremove("C")


16. OUTROS TIPOS DE VARIÁVEIS

Constituem uma extensão do programa interpretador. Algumas permitem
a comunicação com o mundo externo, outras possibilitam mais recursos.

Possuem funções/variáveis e podem gerar eventos (executar funções
da classe ou do objeto em que pertencem).

Sintaxe para definir uma variável:
<tipo de variável>  <nome da variável>

Exemplo:
listaobj x

Sintaxe para executar uma função:
<nome da variável>.<nome da função>

Exemplos:

x.limpar
x.addini(este)

Sintaxe dos eventos (funções chamadas pela variável):
func <nome da variável>_<nome do evento>

Exemplo:

telatxt tela # Aqui define-se a variável 'tela', do tipo 'telatxt'
func tela_msg # Esse é o evento 'msg', da variável 'tela'


17. LISTAOBJ - LISTA DE OBJETOS

Um objeto pode ser adicionado várias vezes em uma lista.
Como valor numérico, é 0 se a lista estiver vazia ou 1 se não estiver.
Quando um objeto é apagado, é executada a função 'apagar' de todas
as variáveis listaobj do objeto.

Funções:

17.1. addini(<objetos e/ou listaobj>)
Adiciona objetos no topo da lista.
Quando o argumento for uma listaobj, adiciona todos os objetos da listaobj.
Pode-se adicionar mais de um objeto ou listaobj de uma vez, separando-os
por vírgulas.
Retorna o primeiro item adicionado da lista (uma variável listaitem).

Exemplo:

listaobj l
l.addini(este, $teste) # Adiciona os objetos 'este' e '$teste' em 'l'

17.2. addfim(<objetos e/ou listaobj>)
Idêntico a 'addini', exceto que os objetos são adicionados no fim da listaobj.

17.3. addini1 e addfim1
Idênticos a 'addini' e 'addfim', exceto que não adiciona os objetos que já
estiverem na 'listaobj'.

17.4. remove
Remove objetos repetidos na lista.
Retorna a quantidade de objetos removidos.

17.5. remove(<objetos e/ou listaobj>)
Retira objetos da lista.
Retorna a quantidade de objetos removidos.

17.6. rand
Muda a ordem dos objetos aleatoriamente.

17.7. limpar
Retira todos os objetos da lista.

17.8. possui(<objetos e/ou listaobj>)
Retorna quantos objetos estão na lista. O valor 0 significa nenhum objeto.

17.9. apagar
Marca todos os objetos da lista para exclusão, usando a função 'apagar'.

17.10. total([nome da classe])
Quantidade de itens da lista.
Se o nome da classe for especificado, considera apenas objetos da classe.

Nota: Se o objetivo for saber apenas se existe algum objeto, as funções
      'objini' e 'objfim' são mais eficientes.

17.11. objlista
Objeto que contém a lista; pode ser NULO.

17.12. ini([nome da classe])
Primeiro item da lista (uma variável 'listaitem').
Se o nome da classe for especificado, considera apenas objetos da classe.

17.13. fim([nome da classe])
Último item da lista (uma variável 'listaitem').
Se o nome da classe for especificado, considera apenas objetos da classe.

17.14. objini([nome da classe])
Primeiro objeto da lista, o mesmo que 'ini.obj'.
Se o nome da classe for especificado, considera apenas objetos da classe.

17.15. objfim([nome da classe])
Último objeto da lista, o mesmo que 'fim.obj'.
Se o nome da classe for especificado, considera apenas objetos da classe.


18. LISTAITEM - UM ITEM DE LISTAOBJ

É usada para acessar os objetos de 'listaobj'. Representa um objeto.
Como valor numérico, é 1 se for um objeto ou 0 se não for.

Funções:

18.1. addantes(<objetos e/ou listaobj>)
Adiciona objetos antes desse.
Retorna o primeiro item adicionado da lista (uma variável 'listaitem').

18.2. adddepois(<objetos e/ou listaobj>)
Adiciona objetos depois desse.
Retorna o primeiro item adicionado da lista (uma variável 'listaitem').

18.3. addantes1 e adddepois1
Idênticos a addantes e adddepois, exceto que não adiciona os objetos que
já estiverem na listaobj.

18.4. antes([número de objetos])
Recua a quantidade de objetos especificada.
Nada faz se a quantidade for menor ou igual a zero.
Sem argumentos, posiciona-se no objeto anterior.

18.5. depois([número de objetos])
Avança a quantidade de objetos especificada.
Nada faz se a quantidade for menor ou igual a zero.
Sem argumentos, posiciona-se no próximo objeto.

18.6. objantes([número de objetos])
Semelhante à função 'antes', mas considera apenas objetos da mesma classe.

18.7. objdepois([número de objetos])
Semelhante à função 'depois', mas considera apenas objetos da mesma classe.

18.8. remove
Remove objeto da lista, a 'listaitem' passa a não ser um objeto válido.

18.9. removeantes
Remove objeto da lista e passa para o anterior.
Nota: Não confundir com 'remover o objeto anterior'.

18.10. removedepois
Remove objeto da lista e passa para o próximo.
Nota: Não confundir com 'remover o próximo objeto'.

18.11. obj
O objeto atual.

18.14. total
Quantidade de itens da lista.

18.15. objlista
Objeto que contém a lista; pode ser NULO.

18.16. Exemplo usando 'listaobj' e 'listaitem':

listaobj l
listaitem i
l.addantes(este) # Adiciona no topo da lista
l.adddepois(este) # Adiciona no final da lista
l.remove(l.ini.obj) # remove um objeto da lista
l.possui(este) # retorna diferente de zero se objeto está na lista
l.ini.obj # é o primeiro objeto da lista
l.fim.obj # é o último objeto da lista
i = l.ini  # i é o primeiro item da lista
enquanto i    # Enquanto 'i' for um objeto (não acabou a lista)
  i.obj.x = 1   # Faz a variável 'x' do objeto ser 1
  i.depois      # Passa para o próximo objeto
efim


19. TEXTOTXT - LISTA DE TEXTO

Lista de textos. É o equivalente ao texto de um editor de textos.
Todas as linhas de texto terminam com um caracter '\n'.

Funções:

19.1. ini
Primeira linha do texto (variável textopos).

19.2. fim
Fim do texto, após a última linha do texto (variável textopos).

19.3. linhas
Retorna o número de linhas de texto.

19.4. bytes
Retorna a quantidade de bytes de texto.

19.5. limpar
Limpa o texto.

19.6. addini(<texto>)
Adiciona linhas no início do textotxt.

19.7. addfim(<texto>)
Adiciona linhas no fim do textotxt.

19.8. remove(<quantidade de linhas>)
Retorna um texto que contém uma quantidade de linhas do início do
textotxt. Retira essas linhas do textotxt.
Se a quantidade de linhas for omitida, remove uma linha apenas.

19.9. ordena
Organiza as linhas em ordem alfabética.

19.10. ordenalin
Organiza as linhas em ordem alfabética, sendo que:
A primeira palavra de cada linha é a quantidade de textos.
Da segunda palavra em diante é o texto propriamente dito.
As linhas que não começam com um número são apagadas.
Linhas iguais são somadas.

Exemplo:

textotxt t
t.addfim("1 Carro pequeno")
t.addfim("3 Carro pequeno")
t.addfim("2 Caminhão")
t.ordenalin

Tem o mesmo efeito de:

textotxt t
t.addfim("2 Caminhão")
t.addfim("4 Carro pequeno")

19.11. ordenalin(<texto1>, <texto2>)
Mesmo que ordenalin sem argumentos, exceto que após ordenar altera
as linhas de acordo com a quantidade (a primeira palavra):
Se for 0 ou não for um número: apaga a linha
Se for 1: apaga o número no começo da linha
Se for 2 ou mais: adiciona <texto1> antes do número e <texto2> depois.

Exemplo:

textotxt t
t.addfim("0 Bolsa")
t.addfim("1 Garrafa")
t.addfim("5 Copo")
t.ordenalin("(", "x)")

Tem o mesmo efeito de:

textotxt t
t.addfim("(5x) Copo")
t.addfim("Garrafa")

19.12. juntalin
       juntalin(<texto1>, <texto2>)
Junta as linhas repetidas exatamente como ordenalin, porém mantém
a ordem original das linhas.

19.13. juntar
Acrescenta um espaço entre as linhas e junta todas as linhas do
textotxt, formando uma só. Pode ser bastante útil antes de dividelin
ou dividelincor.

19.14. dividelin(<colmin>, <colmax>)
Linhas que tiverem mais que <colmax> colunas são divididas entre
as colunas <colmin> e <colmax>, preferêncialmente no último espaço
encontrado. Se <colmin> ou <colmax> for menor que dois, essa
função não tem efeito.

19.15. dividelincor(<colmin>, <colmax>)
Mesmo que dividelin, porém não considera definições de cores na
contagem de caracteres por linha.

19.16. rand
Muda a ordem das linhas aleatoriamente.

19.17. txtremove(<texto>)
Altera todas as linhas do textotxt com a função txtremove.

Exemplo:

textotxt t
t.addfim(txtremove("  bom  dia  ", "MC"))
t.addfim(txtremove("\cF\d4Teste\b", "MC"))

Tem o mesmo efeito de:

textotxt t
t.addfim("  bom  dia  ")
t.addfim("\cF\d4Teste\b")
t.txtremove("MC")

19.18. ler(<nome do arquivo>)
Lê um arquivo de texto e coloca em textotxt.
Retorna 1 se conseguiu ou 0 se não conseguiu.
Nota 1: Não acessa arquivos executáveis ou terminados em:
        .exe, .com, .bat, .pif, .scr ou .log
Nota 2: O arquivo deve pertencer ao diretório atual ou a um subdiretório
        dele. Não é possível acessar arquivos de outros lugares.

19.19. salvar(<nome do arquivo>)
Salva o conteúdo de textotxt em um arquivo de texto.
Retorna 1 se conseguiu ou 0 se não conseguiu.
Notas: vide função ler (acima)

19.20. clipler
Lê texto da área de transferência (clipboard).
Retorna 1 se conseguiu ler ou 0 se não conseguiu. Por exemplo, se a área
de transferência não tiver um texto, retorna 0. Nesse caso, o texto de
textotxt não é alterado.
Nota: Só funciona no Windows.

19.21. clipsalvar
Copia o texto de textotxt para a área de transferência (clipboard).
Retorna 1 se conseguiu copiar ou 0 se não conseguiu.
Nota: Só funciona no Windows.


20. TEXTOPOS - ACESSAR LINHA DE TEXTOTXT

É usado para acessar o texto de textotxt. Representa uma linha.
Como valor numérico, é 1 se linha existe ou 0 se está no fim do texto.

Funções:

20.1. linha
Número da linha atual; começa em 0.
Pode ser lido e alterado, como uma variável.
Nota 1: prefira usar 'linha.depois' ao invés de 'linha+=1'.
Nota 2: Internamente muda de linha chamando as funções antes e depois.

20.2. byte
Retorna a quantidade de bytes desde o início do texto; começa no 0.

20.3. lin
É 1 se linha válida ou 0 se chegou no fim do texto.

20.4. antes
Passa para a linha anterior.

20.5. antes(<número de linhas>)
Recua o número de linhas especificado.
Nada faz se o número for menor ou igual a zero.

20.6. depois
Vai para a próxima linha.

20.7. depois(<número de linhas>)
Avança o número de linhas especificado.
Nada faz se o número for menor ou igual a zero.

20.8. texto([caracter inicial], [quantidade de caracteres])
Retorna o texto da linha atual ou de parte da linha atual.

20.9. textolin(<número de linhas>)
Retorna texto correspondente ao número de linhas especificado.

20.10. mudar(<novo texto>, [caracter inicial], [quantidade de caracteres])
Muda o texto da linha atual ou parte do texto da linha atual.
Caracter inicial e quantidade de caracteres referem-se à linha atual.

20.11. add(<novo texto>)
Adiciona linha antes da linha atual.
Retorna a quantidade de linhas adicionadas.
Após essa função, textopos corresponde ao texto adicionado.

20.12. add(<textopos início>, <número de linhas>)
Adiciona as linhas correspondente ao texto especificado.
Retorna a quantidade de linhas adicionadas.

20.13. addpos(<novo texto>)
       addpos(<textopos início>, <número de linhas>)
Mesmo que a função add, porém avança o textopos para depois do texto que
foi adicionado.

20.14. remove
Remove a linha atual.

20.15. remove(<número de linhas>)
Remove a quantidade de linhas especificadas, a partir da linha atual.

20.16. juntar
Junta a linha atual com a anterior. Não avança textopos para outra linha.
Exemplo, se textopos estiver na linha 3, a função juntar juntará as linhas
2 e 3, e o textopos estará na linha 2.
Retorna 1 se juntou linhas ou 0 se não juntou.
Nota: Para dividir uma linha, adicionar texto '\n' com a função mudar.

20.17. txtproc(<texto>, [núm. do caracter inicial], [núm. de linhas])
Procura <texto> no textotxt sem diferenciar letras maiúsculas de
minúsculas e acentuadas de não acentuadas.

A busca começa na linha atual, a partir do [núm. do caracter inicial].
O valor 0 corresponde ao primeiro caracter, o valor 1 o segundo, etc.
Se omitido começa no primeiro.

O [núm. de linhas] é o número máximo de linhas a buscar o texto. Se for
omitido, procura até ao final do textotxt.

Para procurar uma linha que começa e/ou termina com um determinado
texto, acrescente um '\n' no início e/ou no fim do <texto> respectivamente.

Se encontrou, posiciona na linha que contém o texto e retorna o número
do caracter (0=início da linha). Se não encontrou, retorna -1, sem mudar
de linha.

20.18. txtprocmai(<texto procurado>, <caracter inicial>, [núm. de linhas])
Mesmo que txtproc (acima), exceto que diferencia letras acentuadas e não
acentuadas (exemplo, 'a' e 'á'). Mas não diferencia letras maiúsculas
de minúsculas.

20.19. txtprocdif(<texto procurado>, <caracter inicial>, [núm. de linhas])
Mesmo que txtproc (acima), exceto que diferencia letras maiúsculas,
acentuadas e sem acento. Exemplo, 'a', 'A' e 'Á' são consideradas três
letras diferentes em txtprocdif.

20.20. txtmd5([número de linhas])
Calcula e retorna o MD5 do texto correspondente ao número de linhas
especificado. Se o número de linhas for omitido, será 1.

20.21. txtsha1([número de linhas])
Calcula e retorna o SHA1 do texto correspondente ao número de linhas
especificado. Se o número de linhas for omitido, será 1.


21. TEXTOVAR - LISTA DE VARIÁVEIS DE TEXTO

Lista de variáveis organizadas em ordem alfabética.
Semelhante a Textotxt, porém as linhas contêm variáveis de texto
no formato 'nome da variável=valor', organizadas em ordem alfabética.
Cada variável pode conter qualquer texto, inclusive caracteres como
'\b', '\n' e '='.

É possível trabalhar outros tipos de dados, além de texto, bastando
adicionar um dos seguintes caracteres após o nome:
- _ (sublinhado) para números, semelhante à variáveis real2.
- @ (arroba) contagem regressiva: um número inteiro de 1 a 1.048.575,
  subtraído 1 a cada décimo de segundo. Ao chegar em zero ou menos,
  a variável é apagada automaticamente.
- $ (cifrão) para referência a um objeto, semelhante à variáveis ref.
- Um caracter espaço para tratar como texto; isso só é possível nas funções
    Valor, ValorIni, ValorFim e Mudar de TextoVar.

Na ausência desses caracteres, a variável é tratada como texto.

Quando uma variável não existe no TextoVar, o valor dela é:
Um texto vazio "", se for texto.
O valor 0 se for numérica.
O valor nulo se for referência a um objeto.

É possível usar os operadores de atribuição e comparação (=, ==, !=, <, <=, >
e >=) entre duas variáveis Textovar.

Dois Textovar são considerados iguais se tiverem um conteúdo idêntico:
- Mesma quantidade de variáveis;
- Variáveis com o mesmo nome;
- Variáveis do mesmo tipo;
- Variáveis com o mesmo valor.

Funções:

21.1. ini([texto])
Retorna nome da primeira variável cujo nome começa com o texto.
Sem argumentos, retorna nome da primeira variável.

21.2. fim([texto])
Retorna nome da última variável cujo nome começa com o texto.
Sem argumentos, retorna nome da última variável.

21.3. tipo(<nome da variável>)
Retorna um texto de um caracter, que indica o tipo de variável:
Um espaço se for variável de texto;
_ (sublinhado) se for numérica;
@ (arroba) se for de contagem regressiva;
$ (cifrão) se for referência a um objeto;
Um texto vazio se variável inexistente.

21.4. antes(<nome da variável>, [prefixo])
Retorna nome da variável anterior ou um texto vazio se não existir.
Prefixo é um texto. Se estiver definido e o nome da variável anterior
não começar com o prefixo especificado, retorna um texto vazio.

21.5. depois(<nome da variável>, [prefixo])
Retorna nome da próxima variável ou um texto vazio se não existir.
Prefixo é um texto. Se estiver definido e o nome da próxima variável
não começar com o prefixo especificado, retorna um texto vazio.

21.6. valor(<nome da variável>)
Corresponde à variável com o nome especificado.
Nesta função, o nome da variável pode ser qualquer texto de até 79 caracteres,
porém deve-se observar que o último caracter pode indicar o tipo de variável.

21.7. valorini(<nome da variável>)
Corresponde à primeira variável cujo nome começa com o texto.

21.8. valorfim(<nome da variável>)
Corresponde à última variável cujo nome começa com o texto.

21.9. nomevar(<nome da variável>)
Retorna o nome da variável (um texto) ou um texto vazio se não existir.

21.10. mudar("variável=valor")
       mudar(<nome da variável>, <valor>)
Cria uma variável ou muda se já existir.
Para apagar uma variável, basta atribuir um texto vazio a ela.

21.11. limpar([texto])
Apaga todas as variáveis cujos nomes começam com o texto.
Nota: pode ser fornecido vários textos (vários argumentos).
Sem argumentos, apaga todas as variáveis do textovar.

21.12. total([texto])
Retorna a quantidade de variáveis que começam com o texto especificado.
A função 'total' sem argumentos tem o mesmo efeito de 'total("")',
ou seja, retorna a quantidade de variáveis do 'textovar'. Nesse caso,
essa função é bem mais eficiente.

21.13. Outros nomes:
Correspondem a uma variável de TextoVar.

21.14. Exemplos:

textovar v
v.mudar("x=teste") # Cria variável x faz ser "teste"
v.x = "teste" # Mesma coisa, faz x ser "teste"
v.mudar("x=") # Apaga a variável x
v.mudar("x") # Mesma coisa, apaga a variável x
v.mudar("y=10") # Cria variável y = 10
v.y_ = 10 # Mesma coisa, porém y é numérico, enquanto que x é texto
v.y_ += 2 # Faz a variável y ser 12 (10 + 2)
v.mudar("y=teste", "z=12") # Faz a variável y ser "teste" e z ser "12"

# As próximas instruções mostram todas as variáveis do textovar v
telatxt tela # Para mostrar o resultado na tela
txt80 nome
epara nome = v.ini, nome, nome = v.depois(nome)
tela.msg(nome + v.tipo(nome) + "=" + v.valor(nome + " ") + "\n")
efim


22. TEXTOOBJ - LISTA DE VARIÁVEIS REF

Permitem associar nomes de variáveis a objetos. Funcionam exatamente como
textovar, exceto que as variáveis são referências a objetos.

Quando um objeto é apagado, é executada a função apagar de todas
as variáveis textoobj do objeto.

Devido à grande semelhança entre textoobj e textovar, são listadas aqui
as funções que possuem alguma diferença.

22.1. valor(<nome da variável>)
Retorna o objeto ou NULO se a variável não existir.

22.2. valorini(<nome da variável>)
Retorna o objeto da primeira variável cujo nome começa com o texto,
ou "" se a variável não existir.

22.3. valorfim(<nome da variável>)
Retorna o objeto da última variável cujo nome começa com o texto,
ou "" se a variável não existir.

22.4. mudar("variável", [objeto])
Cria uma variável ou muda se já existir.
Se [objeto] for omitido ou não for um objeto, a variável será apagada.

22.5. apagar([texto])
Marca para exclusão (usando a função apagar) todos os objetos das variáveis
cujos nomes começam com o texto.
Nota: pode ser fornecido vários textos (vários argumentos).
Sem argumentos, marca para exclusão todos os objetos do textoobj.

22.4. Outros nomes:
Correspondem a uma variável de textoobj, do tipo ref.


23. NOMEOBJ - PARA OBTER UM OU MAIS OBJETOS

Usado para obter um ou mais objetos, correspondente ao que o usuário
digitou. Como valor numérico, é o resultado da última função 'nome'
da variável nomeobj.

Funções:

23.1. ini(<texto>, [quantidade], [tudo])
Inicia a busca por objetos.

O parâmetro <texto> é o nome que corresponde aos objetos procurados,
e geralmente é o que o usuário digitou.

Só é necessário digitar uma ou mais palavras que fazem parte do nome
do objeto, e ainda pode-se abreviar escrevendo só o começo da palavra.
Exemplo, "chave", "pequena" ou mesmo "ch peq" podem ser usados para pegar
um objeto chamado "chave pequena". Porém, "pequena" e "ch peq" não
servem para outro objeto chamado "chave grande".

Qualquer caracter que não for letra pode ser usado para separar
as palavras. Exemplo, "ch_peq" e "ch+*-peq" têm o mesmo efeito que
"ch peq".

Pode-se escolher o número do objeto acrescentando um número e um ponto
antes do nome. Isso é útil quando há vários objetos com o mesmo nome.
Exemplo, "2.poção" é a segunda poção.

Para escolher mais de um objeto, acrescenta-se um número e um espaço
antes. Exemplo, "10 poção" significa 10 objetos 'poção'.

O parâmetro [quantidade] é a quantidade máxima de objetos que podem ser
encontrados. Se for omitido, assume apenas um. Por exemplo, se for
desejável encontrar no máximo 10 objetos, mesmo que existam mais,
a quantidade deve ser o número 10.

O parâmetro [tudo] é a palavra que o usuário deve digitar quando quiser
todos os objetos. Exemplo, se esse parâmetro for o texto "tudo", o usuário
pode-se digitar:
"tudo" para todos os objetos
"10 tudo" para os 10 primeiros objetos
"10 4.tudo" para 10 objetos a partir do quarto
"tudo.perg" para todos os objetos cujo nome começa com perg

Vide também exemplo de código no tópico 23.3 (abaixo).

23.2. nome(<texto>, [quantidade])
Checa se um objeto corresponde ao objeto escolhido pelo usuário.

O parâmetro <texto> contém as palavras que se referem ao objeto.

O parâmetro [quantidade] é a quantidade de objetos com o nome
especificado. Se for omitido, será apenas um.

Essa função retorna a quantidade de objetos encontrados.

23.3. Exemplo

nomeobj x
x.ini("2.ch", 5, "tudo")# Achar no máximo 5 objetos que começam com "ch"
                # No entanto, como o texto é "2.ch", procurará só o segundo
x.nome("bolsa") # Retorna 0 porque não é o objeto procurado
x.nome("chave azul") # Retorna 0; o nome confere, mas esse é o primeiro objeto
x.nome("chave verde") # Retorna 1
x.nome("chave azul") # Retorna 0 porque já encontrou o objeto


24. ARQDIR - ACESSAR DIRETÓRIOS

Funções:

24.1. abrir(<nome do diretório>)
Inicia a busca de arquivos/diretórios em um diretório.
Retorna "" se sucesso ou um texto contendo o erro.

24.2. fechar
Encerra a busca em um diretório.

24.3. lin
É 1 se entrada válida ou 0 se chegou no fim do diretório.

24.4. texto
Nome da entrada.

24.5. depois
Passa para a próxima entrada.
Fecha o diretório se não houver próxima entrada.

24.6. tipo([nome da entrada])
Sem argumentos, retorna o tipo da entrada encontrada em abrir()
Retorna o tipo:
"A" = arquivo, "D" = diretório, "O" = outro tipo de entrada
"?" = não existe

24.7. tamanho(<nome da entrada>)
Retorna o tamanho do arquivo.

24.8. atempo(<nome da entrada>)
Retorna quando o arquivo foi acessado; um texto no formato:
ano mês dia hora minuto segundo milhonésimos de segundo.
Exemplo: "2010 1 20 14 30 02 1500"
Retorna um texto vazio se o arquivo não existir ou não permitido.

24.9. mtempo(<nome da entrada>)
Retorna quando o arquivo foi modificado, da mesma forma que atempo.

24.10. criardir(<nome do diretório>)
Cria um diretório.
Retorna "" se sucesso ou um texto contendo o erro.

24.11. apagardir(<nome do diretório>)
Apaga um diretório, exceto se não estiver vazio.
Retorna "" se sucesso ou um texto contendo o erro.

24.12. apagar(<nome do arquivo>)
Apaga um arquivo.
Retorna "" se sucesso ou um texto contendo o erro.

24.13. renomear(<antigo nome>, <novo nome>)
Renomeia uma entrada.
Retorna "" se sucesso ou um texto contendo o erro.

24.14. barra(<texto>)
Acerta a barra que separa nomes de diretórios e arquivos:
No Windows, troca a barra normal por barra invertida.
No Linux, troca a barra invertida por barra normal.


25. ARQLOG - GRAVAR TEXTO EM ARQUIVOS DE LOG

Para gravar mensagens em arquivos de texto chamados de log.
Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.

Funções:

25.1. valido(<nome do arquivo>)
Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.

25.2. existe(<nome do arquivo>)
Retorna 1 se arquivo existe ou 0 se não existe.

25.3. abrir(<nome do arquivo>)
Abre arquivo, cria se não existir.
Retorna 1 se conseguiu abrir ou 0 se não conseguiu.
Nota 1: O nome do arquivo sempre terminará com '.log'.
Nota 2: O arquivo deve pertencer ao diretório atual ou a um
subdiretório dele. Não é possível criar arquivos em outros lugares.

25.4. fechar
Fecha o arquivo.

25.5. msg(<texto>)
Grava texto em uma nova linha, no final do arquivo.
Nota 1: Definições de cores e linhas vazias não são gravadas.
Nota 2: Pode demorar até 2 segundos para o texto ser realmente
        gravado no arquivo.


26. ARQSAV - SALVAR OBJETOS EM ARQUIVOS

Para salvar objetos em arquivos e recuperar posteriormente.
Nota 1: Não acessa arquivos executáveis ou terminados em:
        .exe, .com, .bat, .pif, .scr ou .log
Nota 2: O arquivo deve pertencer ao diretório atual ou a um
subdiretório dele. Não é possível criar arquivos em outros lugares.

Os objetos que serão salvos devem ser colocados em uma listaobj.
As variáveis salvas devem ser definidas com a palavra 'sav' antes.
Exemplo:
classe x
sav int8 a # Essa variável é salva por arqsav
int8 b # Já essa não é salva

Variáveis que acessam recursos externos nunca são salvas:
arqlog, arqsav, arqtxt, telatxt, serv, socket
Essas outras também não, por motivos óbvios:
nomeobj, prog, indiceitem
Referência a outros objetos (ref, listaobj, listaitem, etc.) são salvas
quando se referem a outro objeto que também será salvo no mesmo arquivo.

Funções:

26.1. valido(<nome do arquivo>)
Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.

26.2. existe(<nome do arquivo>)
Retorna 1 se arquivo existe ou 0 se não existe.

26.3. senha(<nome do arquivo>, <senha>)
Retorna 1 se senha correta ou 0 se incorreta.

26.4. dias(<nome do arquivo>)
Retorna quantos dias faltam para o arquivo expirar.
Retorna 0 se expirou, -1 se nunca expira.

26.5. ler(<nome do arquivo>, <listaobj>, [núm. de objetos lidos])
Cria objetos na listaobj a partir do conteúdo do arquivo.
O primeiro objeto da lista é o primeiro do arquivo, o segundo da
lista é o segundo do arquivo, e assim por diante.
Se a listaobj já conter objetos, estes serão alterados de acordo com as
variáveis presentes no arquivo.
Número de objetos lidos é a quantidade máxima de objetos que serão lidos do
arquivo. Se for omitido, assume 4000.
Retorna a quantidade de objetos lidos.

26.6. salvar(<nome do arquivo>, <listaobj>, <dias>, <senha>)
Salva em arquivo todos os objetos de uma listaobj.
<dias> é a quantidade de dias para apagar o arquivo, 0=nunca apagar
Retorna 1 se conseguiu salvar ou 0 se não conseguiu.

26.7. apagar(<nome do arquivo>)
Apaga arquivo.
Retorna 1 se conseguiu apagar ou arquivo não existia.
Retorna 0 se não conseguiu apagar.

26.8. limpar(<nome do diretório>)
Inicia checagem dos arquivos .sav no diretório especificado; apaga
arquivos que expiraram. Os arquivos são verificados aos poucos para
ficar transparente aos usuários.
Retorna 1 se conseguiu ou 0 se diretório não permitido.
Exemplo:
arqsav sav
sav.limpar(".") # Inicia checagem do diretório atual, em segundo plano

26.9. limpar
Checa de uma vez todos os diretórios que estiverem sendo checados
aos poucos, em segundo plano.
Exemplo:
arqsav sav
sav.limpar(".") # Inicia checagem do diretório atual
sav.limpar # Checa todos os arquivos de uma vez

26.10. limpou
Retorna um texto de uma ou mais linhas.
A primeira linha é o texto "1" se a função 'limpar' estiver verificando
arquivos em segundo plano, ou "0" se não estiver.
Da segunda linha em diante são os nomes dos arquivos que foram apagados
pela função 'limpar' desde a última vez que a função 'limpou' foi chamada.
Nota: As linhas são separadas por caracteres '\n'.
Veja também a função 'txtsublin'.


27. ARQTXT - ACESSAR ARQUIVOS DE TEXTO

Para ler ou gravar arquivos de texto.
Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.
Nota: A escrita em arquivo não é tão eficiente quanto arqlog.

Funções:

27.1. valido(<nome do arquivo>)
Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.

27.2. existe(<nome do arquivo>)
Retorna 1 se arquivo existe ou 0 se não existe.

27.3. abrir(<nome do arquivo>, <modo>)
Abre arquivo. Retorna 1 se conseguiu ou 0 se não conseguiu.

Modo é um número que indica como o arquivo deve ser aberto:
0 - Somente leitura;
1 - Leitura e escrita;
2 - Somente escrita; o tamanho do arquivo é truncado para 0 bytes;
3 - Para escrever no final do arquivo.
4 - Modo binário somente leitura;
5 - Modo binário leitura e escrita;
6 - Modo binário somente escrita; tamanho do arquivo é truncado para 0 bytes;
7 - Modo binário para escrever no final do arquivo.

Os modos 0, 1, 4 e 5 não criam um novo arquivo, caso ele não exista.
No modo binário, cada 2 caracteres representam um byte do arquivo,
no formato hexadecimal. Assim, se for necessário obter o texto correspodente
a uma sequência de caracteres em hexadecimal, usar a função txtconv.

Nota 1: Não acessa arquivos executáveis ou terminados em:
        .exe, .com, .bat, .pif, .scr ou .log
Nota 2: O arquivo deve pertencer ao diretório atual ou a um subdiretório
        dele. Não é possível acessar arquivos de outros lugares.

27.4. fechar
Fecha o arquivo.

27.5. truncar(<arquivo>, <tamanho>)
Trunca o tamanho de um arquivo no tamanho especificado.
Retorna 1 se conseguiu ou 0 se não conseguiu.

Exemplo:

truncar("a.txt", 0) # Limpa o conteúdo do arquivo a.txt

27.6. msg(<texto>)
Escreve texto no arquivo.
Se for especificado mais de um texto, serão concatenados no arquivo.
Exemplo, escr("ab", "\n") é o mesmo que escr("ab\n")

27.7. flush
Grava em arquivo as alterações pendentes.

27.8. ler
Lê uma linha do arquivo; retorna a linha lida sem o \n no final.
Pode ler menos se chegou no fim do arquivo.
Em modo binário, lê um caracter do arquivo (2 caracteres em hexadecimal).

27.9. ler(<tamanho>)
Lê um determinado número de caracteres do arquivo.
Pode ler menos se chegou no fim do arquivo.
Exemplo: ler(1) lê um caracter.

27.10. pos
Retorna a posição atual no arquivo (0=está no início do arquivo).

27.11. pos(<posição>, <modo>)
Muda a posição atual no arquivo.

O modo é um número que indica como deve mudar a posição:
0 - A partir do início do arquivo
1 - A partir da posição atual
2 - A partir do fim do arquivo

27.12. eof
1 se chegou no fim do arquivo, 0 se não chegou.


28. INTTEMPO - GERAR EVENTOS DEPOIS DE UM TEMPO

Uma variável inteira de 0 a 1.048.575, subtraída 1 a cada décimo de segundo.
A diferença de inttempo para intdec é que quando chega a 0, uma função
do objeto é executada. O nome da função é <nomedavariável>_exec.
Na função: arg0 = índice da variável vetor, se não for vetor arg0=0
Nota: o valor 1.048.575 corresponde a 29 horas, 7 minutos e 37.5 segundos.
inttempo aceita valores negativos, mas nesse caso a contagem fica parada.

Possui as funções e variáveis:
neg - Faz a variável ser menor que zero, multiplicando por -1 se necessário
pos - Faz a variável ser maior que zero, multiplicando por -1 se necessário
abs - Valor de inttempo sem o sinal

Exemplo:

classe x
inttempo n
func n_exec
  # Essa função é executada quando a variável n chegar a zero
func s
n = 20 # 20 segundos
n.neg # Pára a contagem (n=-20)
n.abs = 4 # n passa a ser -4
n.pos # Volta a contar (n=4)
teste = n.abs # Mesmo que teste=4


29. INTEXEC - GERAR EVENTO ASSIM QUE POSSÍVEL

É uma variável que pode ser 0 ou 1, exatamente como int1.

Assim que o controle retorna ao IntMUD, se essa variável for 1, ela muda
para 0 e em seguida é executada uma função dessa variável, cujo nome é
<nomedavariável>_exec.

Se houver alguma alteração pendente no programa (vide variável prog) ou
algum objeto a ser apagado, esses procedimentos serão executados antes
da função de intexec.

Qualquer outro evento também tem preferência em relação a intexec.
Por exemplo, se houver dois eventos de inttempo, um de socket e um de
intexec, mesmo os quatro ocorrendo simultaneamente, o evento de intexec
será executado por último.

Exemplo:

telatxt = 1
classe x
intexec n # Para gerar evento
prog p # Para alterar o programa
func iniclasse # Classe x foi criada
criar(arg0) # Cria objeto
func ini # Objeto foi criado
p.criar("x", "int8 y") # Cria variável y na classe x
n = 1 # Gerar evento depois
func n_exec # Essa função é executada depois da variável y ser criada
telatxt t
t.msg("Variável y é do tipo: " + p.vartipo("x", "y") + "\n")


30. TELATXT - ACESSAR A JANELA DO PROGRAMA

Semelhante a socket, mas trabalha com uma tela de texto, chamada console.
Essa tela é semelhante ao 'prompt de comando', no Windows, ou o próprio
terminal, em Unix.

Funções e variáveis:

30.1. proto
Retorna 0 se a janela do IntMUD estiver fechada ou 6 se estiver aberta.
O valor de 'proto' depende da opção 'TELATXT' no início do programa
(vide tópico 2.3).

30.2. posx
Posição do cursor: quantos caracteres enviou após o último \n.
Caracteres especiais, como definição da cor, não contam.

30.3. msg(<mensagem>)
Envia mensagem para telatxt.

30.4. tecla(<nome da tecla>)
Processa uma tecla, como se tivesse sido digitada pelo usuário.
Nota: não gera eventos.

30.5. texto
Conteúdo da linha sendo digitada pelo usuário. Pode ser mudado.

30.6. total
Tamanho da linha sendo editada, de 1 a 1023. Pode ser mudado.

30.7. linha
Linha em que o cursor está. 0 é a linha de edição, 1=última linha
de texto, 2 = linha anterior, etc.

30.8. limpa
Limpa a tela.

Eventos:

30.9. <nomedavariável>_msg
Recebeu mensagem.
arg0 = Mensagem recebida
arg1 = Índice da variável vetor, se não for vetor arg1=0

29.10. <nomedavariável>_tecla
Chamado sempre que o usuário pressionar uma tecla.
arg0 = Nome da tecla
arg1 = Índice da variável vetor, se não for vetor arg1=0
Se retornar verdadeiro, significa que a função já processou a tecla.
Portanto, não será processada pelo IntMUD.

Nomes das teclas especiais:

Teclas de função: F1 a F12
Setas: UP DOWN LEFT RIGHT (nessa ordem: cima, baixo, esquerda, direita)
Outras: INS DEL HOME END PGUP PGDN TAB ENTER ESC BACK
Com SHIFT: S_F1 a S_F12 S_TAB S_ENTER
Com CONTROL: C_INS C_DEL C_HOME C_END C_PGUP C_PGDN
Setas com CONTROL: C_UP C_DOWN C_LEFT C_RIGHT
Letras A-Z com CONTROL: C_A a C_Z
Notas - em um terminal Unix ou Linux:
 - Control+C encerra o programa (não gera evento _tecla)
 - Control+Z coloca o programa em segundo plano (não gera evento _tecla)
 - Control+I é a tacla TAB
 - Control+M é a tecla ENTER


31. SOCKET - COMUNICAÇÃO VIA TCP/IP

Representa uma conexão TCP/IP com outro programa.
Como valor numérico, é 1 se proto!=0 (está conectado) ou 0 se proto=0.
Nota: uma conexão pode ser copiada de um objeto socket para outro.
Nesse caso, os eventos são gerados em mais de uma variável socket.

Funções e variáveis:

31.1. proto
É um número que define o protocolo usado:
0 - Não está conectado;
1 - Conectando;
2 - Telnet, só recebe mensagens completas;
3 - Telnet, pode receber mensagens incompletas (sem o \n no fim);
4 - IRC;
5 - Papovox (sem cores);
6 - WebSocket sem codificar as mensagens enviadas;
7 - WebSocket codificando as mensagens enviadas.

Nota: É possível mudar essa variável para qualquer valor de 2 a 7,
      quando o socket estiver conectado.

31.2. cores
É um número que define como deve usar as cores nas mensagens:
0 - Nenhuma cor;
1 - Cores somente ao receber;
2 - Cores somente ao enviar;
3 - Cores ao enviar e receber.

31.3. aflooder
O anti flooder impede o recebimento de muitas mensagens ao mesmo tempo.
0 desativa o anti flooder, outro valor ativa.

31.4. opctelnet
Define se pode receber caracteres especiais do protocolo Telnet:
Eco desligado "\ci", eco ligado "\cj", caracteres go ahead "\ck"
e bipe "\cl". Não tem efeito em IRC e Papovox.

31.5. posx
Posição do cursor: quantos caracteres enviou após o último \n.
Caracteres especiais, como definição da cor, não contam.

31.6. ip
Endereço IP correspondente a quem está conectado.

31.7. iplocal
Endereço IP local.

31.8. abrir(<endereço>, <porta>)
Tenta conectar-se a um endereço.
Após conectar, 'proto' passa a ser 3 e o evento _con é chamado (vide abaixo).
Retorna 1 se conexão em progresso ou 0 se ocorreu erro
(0 geralmente significa endereço inválido)

31.9 abrirssl(<endereço>, <porta>)
Mesmo que a função abrir, acima, porém usando conexão segura (SSL).

31.10. fechar
Encerra a conexão; não gera o evento fechou.

31.11. msg(<mensagem>, [tipo de mensagem])
Envia mensagem para o socket.
O tipo de mensagem é usado somente no Papovox e em WebSocket.
Se for omitido, assume 1, que no Papovox significa mensagem de texto.
Vide mais detalhes sobre o tipo da mensagem no evento <nomedavariável>_msg.
Retorna 1 se conseguiu enviar ou 0 se buffer cheio.
Nota 1: Se o protocolo for Papovox, devido às limitações do Papovox,
é acrescentado "\n" no final da mensagem se já não houver um "\n".
Nota 2: No protocolo WebSocket, para enviar um texto é necessário antes
converter para UTF-8 e Hexadecimal. A conversão pode ser feita assim:
txtconv(txtconv("sua mensagem", "tu", "th"))

31.12. inissl
Apenas carrega biblioteca OpenSSL, usada para conexões seguras.
Retorna a mensagem de erro ou "" se sucesso.
Nota: a função 'abrirssl' já carrega a biblioteca automaticamente.

31.13. txtmd5
Usado somente em conexões SSL. Retorna a assinatura MD5 do certificado
do servidor.

31.14. txtsha1
Usado somente em conexões SSL. Retorna a assinatura SHA1 do certificado
do servidor.

31.15. ipvalido(<texto>)
Retorna 1 se <texto> for um endereço IP, ou 0 se não for.

31.16. ipnome(<nome ou endereço IP>)
Retorna o nome da máquina a partir do endereço IP.
Se o nome não existir, retorna um texto vazio.
Essa função funciona independente do socket estar conectado.
Em servidores, não é recomendável usá-la pois enquanto o nome estiver
sendo resolvido, o IntMUD fica parado. Melhor usar eventoip.

31.17. nomeip(<nome ou endereço IP>)
Retorna o endereço IP a partir do nome da máquina ou endereço IP.
Funciona exatamente como a função ipnome acima.

31.18. eventoip(<nome ou endereço IP>)
Obtém nome e endereço IP a partir de um endereço.
Não trava o programa até o endereço ser resolvido. Ao invés disso, gera
um evento '_eventoip' (vide abaixo).
Retorna 1 se começou a resolver ou 0 se ocorreu algum erro interno
(não conseguiu usar os recursos necessários; raramente retorna 0).
Nota: Se essa função for chamada várias vezes, vários eventos serão
gerados, mas não necessariamente na mesma ordem. Alguns endereços
podem levar mais tempo para serem resolvidos.

Eventos:

31.19. <nomedavariável>_msg
Recebeu mensagem.
arg0 = Mensagem recebida.
arg1 = 1 se mensagem completa, 0 se incompleta (sem o \n).
arg2 = Um número de 0 a 255 que indica o tipo de mensagem.
       Usado somente no Papovox e no WebSocket (vide abaixo).
arg3 = Índice da variável vetor, se não for vetor arg3=0.

Tipo de mensagem:
No Papovox, geralmente só é usado o valor 1, que significa mensagem de texto.
No WebSocket, os valores usados são os seguintes:
129 - Mensagem de texto sem continuação
130 - Mensagem binária sem continuação
1   - Primeira parte da mensagem de texto
2   - Primeira parte da mensagem binária
0   - Continuação da mensagem (de texto ou binária)
128 - Última parte da mensagem (de texto ou binária)
136 - Fechar a conexão (motivo vai em arg1)
137 - Ping (deve responder com Pong com a mesma mensagem de arg1)
138 - Pong
Outros valores - Reservado, não usar
No WebSocket, mensagens de texto (em arg1) estão em UTF-8 e em Hexadecimal.
Para transformar para texto: txtconv(txtconv(arg1, "ht"), "ut")

31.20. <nomedavariável>_env
Todas as mensagens foram transmitidas (buffer de transmissão
ficou vazio).
arg0 = índice da variável vetor, se não for vetor arg0=0.

31.21. <nomedavariável>_fechou
O socket foi fechado remotamente.
arg0 = Motivo (um texto).
arg1 = Índice da variável vetor, se não for vetor arg1=0.
Se essa função não existir, o objeto que contém o socket é apagado.

31.22. <nomedavariável>_con
Conseguiu conectar.
arg0 = Índice da variável vetor, se não for vetor arg0=0.

31.23. <nomedavariável>_err
Não conseguiu conectar.
arg0 = Mensagem de erro.
arg1 = Índice da variável vetor, se não for vetor arg1=0.

31.24. <nomedavariável>_eventoip
Resolveu um endereço fornecido pela função eventoip.
arg0 = texto recebido pela função eventoip.
arg1 = Nome da máquina, ou um texto vazio se não encontrou.
arg2 = Endereço IP da máquina, ou um texto vazio se não encontrou.
arg3 = Índice da variável vetor, se não for vetor arg3=0.


32. SERV - RECEBER CONEXÕES VIA TCP/IP

Funções:

32.1 abrir(<endereço>, <porta>)
Abre uma porta para receber conexões.
Se não quiser especificar um endereço, colocar "" no endereço.
Retorna 1 se conseguiu abrir ou 0 se não conseguiu.

32.2 abrirssl(<endereço>, <porta>)
Mesmo que a função abrir, acima, porém usando conexão segura (SSL).
Para essa função funcionar, o suporte a conexões seguras já deve ter
sido inicializado (vide função inissl, abaixo).

32.3. fechar
Deixa de receber conexões.

32.4. inissl(<nome do arquivo CRT>, <nome do arquivo KEY>)
Carrega biblioteca OpenSSL (usada para conexões seguras) um certificado
digital (um arquivo CRT) e uma chave privativa (um arquivo KEY).
Retorna a mensagem de erro ou "" se sucesso.

Para criar esses arquivos, primeiro instalar o OpenSSL, se ainda não
estiver instalado. Depois, abrir um terminal (no Linux/Unix) ou abrir
o "Prompt do MS-DOS" e digitar:
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout x.key -out x.crt

O programa pedirá algumas informações, e em seguida criará os arquivos,
que nesse caso serão 'x.key' e 'x.crt'.

Eventos:

32.5. <nomedavariável>_socket
arg0 = Socket correspondente à conexão (com a variável 'proto' sendo 2)
arg1 = Índice da variável vetor, se não for vetor arg1=0

Exemplo de uso com socket:

classe x
comum serv servidor
socket conec
func iniclasse
  x:servidor.abrir("", 2000)
func servidor_socket
  ref novo
  novo = criar("x")
  novo.conec = arg0
  novo.conec.msg("Benvindo\n")
func conec_msg
  conec.msg("você escreveu " + arg1 + "\n")


33. PROG - LER E ALTERAR O PROGRAMA

Nota: pode ser usado um objeto no lugar do nome de uma classe.

33.1. Funções para iniciar uma consulta

Retornam 1 se há algum resultado resultado (pelo menos uma linha)
para a consulta ou 0 se não há.

33.1.1. iniarq
Obter os nomes dos arquivos que compõem o programa em o .int no final.
Não necessariamente em ordem alfabética.

33.1.2. iniarq(<nome do arquivo sem o .int>)
Obter as classes que pertencem ao arquivo, na ordem definida no arquivo.
Um texto vazio significa o arquivo .int principal.

33.1.3. iniclasse([texto])
Obter os nomes das classes que começam com o texto especificado.
Em ordem alfabética.

33.1.4. inifunc(<nome da classe>, [texto])
Obter os nomes das funções e variáveis definidas em uma classe.
Somente as variáveis e funções que começam com o texto especificado.
Em ordem alfabética.

33.1.5. inifunctudo(<nome da classe>, [texto])
Mesmo que inifunc, mas inclui também as variáveis e funções herdadas.

33.1.6. inifunccl(<nome da classe>, [texto])
Mesmo que inifunc, mas as funções e variáveis são listadas na ordem em que
aparecem na classe.

33.1.7. iniherda(<nome da classe>)
Obter os nomes das classes definidas na instrução 'herda'.
Na ordem definida na classe.

33.1.8. iniherdatudo(<nome da classe>)
Obter a lista de classes herdadas por uma classe.
Inclui também as classes herdadas indiretamente.
Na ordem em que as classes são herdadas.

33.1.9. iniherdainv(<nome da classe>)
Herança inversa: obter os nomes das classes que herdam uma classe.
A ordem em que as classes são listadas é imprevisível.

33.1.10. inilinha(<nome da classe>)
Obter as linhas correspondentes a uma classe.

33.1.11. inilinha(<nome da classe>, <nome da função>)
Obter as linhas correspondentes a uma variável ou função da classe
(definida na classe ou herdada).


33.2. Funções para ler o resultado da consulta

33.2.1. lin
É 1 se linha válida ou 0 se chegou no fim da consulta.

33.2.2. depois
Vai para a próxima linha.

33.2.3. depois(<número de linhas>)
Avança o número de linhas especificado.
Nada faz se o número for menor ou igual a zero.

33.2.4. texto
Retorna o texto da linha atual.

33.2.5. nivel
Retorna um número, que é o nível de indentação. Usado somente com
inilinha.


33.3. Funções para obter informações

Nota: Funcionam independente das demais.

33.3.1. existe(<nome da classe>)
Retorna 1 se a classe existe ou 0 se não existe.

33.3.2. existe(<nome da classe>, <nome da variável>)
Retorna 0 se a variável ou função não existe, 1 se estiver
definido na própria classe ou 2 se foi herdada.

33.3.3. arquivo(<nome da classe>)
Retorna o nome do arquivo que contém a classe sem o .int no final.
Exemplo, abc corresponde ao arquivo abc.int.
Um texto vazio significa o arquivo .int principal. No entanto, a forma
mais segura de obter o nome do arquivo é usando a função arqnome, abaixo.

33.3.4. arqnome(<nome do arquivo sem o .int>)
Retorna o nome do arquivo a partir do nome fornecido pela função arquivo.
Um texto vazio significa o arquivo .int principal.

Exemplo:
prog p
p.arqnome("abc") # Retorna algo como "abc.int".

33.3.5. vartipo(<nome da classe>, <nome da variável>)
Retorna o tipo de variável ou "" se a variável não existe.

33.3.6. varlugar(<nome da classe>, <nome da variável>)
Retorna um número de acordo com o tipo de variável ou função:
0 = Função ou variável não existe;
1 = É variável da classe, está antes das funções;
2 = É 'const' ou 'varconst', pode ser colocado em qualquer lugar;
3 = É 'func' ou 'varfunc', está depois das variáveis.

33.3.6. varnum(<nome da classe>, <nome da variável>)
Retorna 1 se for constante numérica do tipo:
const variável = valor numérico
ou 0 se não for.

33.3.7. vartexto(<nome da classe>, <nome da variável>)
Retorna 1 se for constante de texto do tipo:
const variável = "texto"
ou 0 se não for.

33.3.8. varcomum(<nome da classe>, <nome da variável>)
Retorna 1 se variável for comum ou 0 se não for.

33.3.9. varsav(<nome da classe>, <nome da variável>)
Retorna 1 se variável for sav ou 0 se não for.

33.3.10. varvetor(<nome da classe>, <nome da variável>)
Retorna a quantidade de variáveis do vetor ou 0 se não for vetor.

33.3.11. const(<nome da classe>, <nome da variável>)
Retorna o texto de uma variável constante do tipo:
const variável = valor    (nesse caso retorna valor)
const variável = "texto"  (nesse caso retorna texto)
Retorna um texto vazio para outros tipos de variáveis.

33.3.12. classe(<nome da classe>, <texto>)
Primeiro checa se <texto> pode ser o conteúdo de uma classe (se não tem
nenhum erro). Depois checa se está igual à classe especificada.
Retorna a lista de erros em <texto>. Se não houver nenhum erro,
retorna "1" se estiver igual ou "0" se estiver diferente.


33.4. Funções para alterar o programa

Nota: as alterações só serão efetuadas quando o controle retornar ao IntMUD.

33.4.1. apagar(<classe>)
        apagar(<classe>, <variável>)
Apaga classe ou variável.
Retorna: 1=sucesso, 0=falha (classe ou variável não existe)

33.4.2. criar(<texto>)
Cria uma classe. Se já existia, altera ao invés de criar.
A primeira linha é o nome da classe.
A segunda linha de <texto> é o nome do arquivo sem o .int no final.
    Exemplo, "abc" corresponde ao arquivo 'abc.int'.
    Um texto vazio corresponde ao arquivo .int principal.
Da terceira linha em diante são as instruções (o contéudo da classe).
Retorna um texto vazio se conseguiu criar ou a mensagem de erro
se não conseguiu.
Exemplo:
    prog p
    p.criar("abc\n\nint8 x\nconst n = 10")
Cria a seguinte classe no arquivo .int principal:
    classe abc
    int8 x
    const n = 10
Para criar a mesma classe, mas no arquivo x.int:
    p.criar("abc\nx\nint8 x\nconst n = 10")

33.4.3. criar(<nome da classe>, <texto>)
Cria uma função ou variável de uma classe.
Se já existia, antes apaga a função ou variável.
<texto> contém todas as instruções da função ou variável.
Se houver mais de uma linha, usar \n para separar as linhas.
A primeira linha deve conter o nome e o tipo.
Retorna um texto vazio se conseguiu criar ou a mensagem de erro
se não conseguiu.
Exemplos:
    prog p
    p.criar("abc", "int8 n") # Cria a variável n na classe abc
    p.criar("xyz", "func x\nret 10") # cria a função x na classe xyz

33.4.4. apagarlin(<nome da classe>, <número da linha>)
   apagarlin(<nome da classe>, <nome da variável>, <número da linha>)
Apaga uma linha de uma classe ou variável.
Nota: A primeira linha é a número 1.
Retorna um texto vazio se conseguiu criar ou a mensagem de erro
se não conseguiu.

33.4.5. criarlin(<nome da classe>, <linha inicial>, <texto>)
   criarlin(<nome da classe>, <nome da variável>, <linha inicial>, <texto>)
Adiciona linhas na classe ou função especificada.
Nota: A primeira linha é a número 1.
Retorna um texto vazio se conseguiu criar ou a mensagem de erro
se não conseguiu.

33.4.6. fantes(<nome da classe>, <nome da função 1>, [nome da função 2])
Muda uma função, constante ou variável de lugar em uma classe.
Coloca a função 1 antes da função 2, caso as duas existam.
Se a função 2 for omitida, coloca a função 1 no início da classe.
Retorna um texto vazio se conseguiu mover ou a mensagem de erro se não
conseguiu.

33.4.7. fdepois(<nome da classe>, <nome da função 1>, [nome da função 2])
Muda uma função, constante ou variável de lugar em uma classe.
Coloca a função 1 depois da função 2, caso as duas existam.
Se a função 2 for omitida, coloca a função 1 no final da classe.
Retorna um texto vazio se conseguiu mover ou a mensagem de erro se não
conseguiu.

33.4.8. renomear(<nome da classe>, <novo nome da classe>)
Renomeia a classe.
Nota: A classe só será realmente renomeada quando o controle voltar ao
IntMUD e após todas as outras alterações pendentes serem realizadas.

33.4.9. salvar([texto])
Salva as alterações nos arquivos correspondentes, depois que todas
as alterações pendentes nas classes forem efetuadas.
O texto é composto de letras seguidas de números, que indicam como
o arquivo deve ser salvo.

As opções são as seguintes:
'L70' a 'L4000'   - Quantidade máxima de caracteres por linha, de 70 a 4000;
'N0'              - Não divide linhas grandes (a opção 'L' é gnorada);
'N1'              - Divide linhas grandes somente em const contendo
                    apenas texto;
'N2'              - Divide linhas grandes em qualquer const;
'N3'              - Sempre divide linhas grandes;
'I0' a 'I8'       - Quantos espaços usados para indentação, de 0 a 8;
'C0' a 'C10'      - Linhas vazias entre classes, de 0 a 10;
'F0' a 'F10'      - Linhas vazias entre funções, de 0 a 10;
'V0' a 'V10'      - Linhas vazias entre variáveis e constantes, de 0 a 10.

A função salvar sem argumentos é o mesmo que:
salvar("L4000N0I2C1F1V0")

Significa não dividir linhas, 2 espaços para indentação, 1 linha vazia
entre classes e entre funções e nenhuma linha vazia entre variáveis.

33.4.10. salvartudo([texto])
Mesmo que a função salvar, porém salva todos os arquivos,
independete de terem sido alterados ou não.


33.5. Funções para organizar as classes nos arquivos

33.5.1. clini(<nome do arquivo sem o .int>)
Retorna o nome da primeira classe do arquivo ou "" se não existe.

33.5.2. clfim(<nome do arquivo sem o .int>)
Retorna o nome da última classe do arquivo ou "" se não existe.

33.5.3. clantes(<nome da classe>)
Retorna classe anterior do arquivo, ou "" se não houver.

33.5.4. cldepois(<nome da classe>)
Retorna próxima classe do arquivo, ou "" se não houver.

Para mudar a posição de uma classe no arquivo, acrescentar um argumento,
que é o nome da classe.

Exemplos:

clini("", "teste")
# Define a classe teste como sendo a primeira do arquivo .int principal.

cldepois("abc", "teste")
# A classe 'teste' vai para o mesmo arquivo da classe 'abc', após 'abc'.

Exemplo de função que coloca todas as classes em ordem alfabética:

func organiza
  prog arquivos
  epara arquivos.iniarq, arquivos.lin, arquivos.depois
    prog p
    textotxt t
    epara p.iniarq(arquivos.texto), p.lin, p.depois
      t.addfim(p.texto)
    efim
    t.ordena
    p.clini(arquivos.texto, t.ini.texto)
    enquanto t.linhas > 1
      p.cldepois(t.remove, t.ini.texto)
    efim
  efim
  arquivos.salvar # Salva os arquivos que foram alterados


34. ARQPROG - OBTER OS ARQUIVOS DO PROGRAMA

Busca nos diretórios os arquivos que compõem o programa.

Funções:

34.1. abrir
Inicia a busca dos arquivos.

34.2. fechar
Encerra a busca dos arquivos.

34.3. lin
É 1 se entrada válida ou 0 se chegou no fim da busca.

34.4. texto
Nome da entrada (nome do arquivo sem o .int no final).
Nota: a primeira entrada da busca é sempre o arquivo .int principal.

34.5. depois
Passa para a próxima entrada, ou encerra a busca se não houver.


35. ARQEXEC - Executar outros programas

Funções e variáveis:

35.1. abrir(<comando>)
Executa o programa com o nome especificado.
Se conseguiu executar, retorna um texto vazio.
Caso contrário, retorna a mensagem de erro.
Nota: As opções COMPLETO e ARQEXEC definem quais programas podem ser
executados.

35.2. fechar
Fecha o programa sendo executado.

35.3. aberto
Retorna 1 (verdadeiro) se estiver executando um programa ou 0 (falso) se
não estiver.

35.4. msg(<texto>)
Envia uma mensagem para o programa.

Eventos:

35.5. <nomedavariável>_msg
Recebeu mensagem do programa.
arg0 = Mensagem recebida
arg1 = 1 se mensagem completa, 0 se incompleta (sem o \n)
arg2 = Índice da variável vetor, se não for vetor arg2=0

35.6. <nomedavariável>_env
Todas as mensagens foram enviadas ao programa (buffer de saída ficou vazio).
arg0 = Índice da variável vetor, se não for vetor arg0=0

35.7. <nomedavariável>_fechou
O programa terminou.
arg0 = Código de retorno (um número)
arg1 = Índice da variável vetor, se não for vetor arg1=0


36. DEBUG - AUXILIAR A DETECTAR ERROS NO PROGRAMA

Funções:

36.1. exec
Contador de instruções - opção 'exec' no início do arquivo int.
A cada instrução executada essa variável é subtraída de 1.
Quando chega a 0, o controle retorna automaticamente ao IntMUD.
Pode ser lido e alterado, como uma variável.

36.2. ini
Inicializa exec com o valor definido na opção 'exec' no início
do arquivo int.

36.3. cmd(<texto>)
      cmd(<objeto>, <texto>)
Executa as instruções que estão no texto especificado.
Quando houver mais de uma instrução, deve-se separá-las com '\n'.
Se houver algum erro (como sintaxe incorreta ou instrução inexistente),
essa função retornará a mensagem de erro.
Variáveis criadas no 'cmd' deixam de existir quando o 'cmd' retornar.
Instruções 'ret' no texto fazem a função 'cmd' retornar o valor do 'ret',
na forma de texto.
Se o objeto for especificado, será o objeto 'este' das instruções.

Exemplos:
debug d
d.cmd("x = 10")
d.cmd("x=x+1\nteste(\"x=\"+x+\"\\n\")")
d.cmd("ret \"teste\"") # d.cmd retorna "teste"
d.cmd("int8 x\nx=1+2\nret x") # d.cmd retorna "3"

36.4. passo(<objeto>, <texto>)
      passo()
Antes de executar cada instrução chama a função de <objeto>
com o nome especificado em <texto>. Se a função não existir, passa
a executar instruções sem chamar nenhuma função.
Na função:
arg0 é oobjeto 'este'
arg1 é o texto contendo a instrução que será executada executada

36.5. func
Retorna o nível de funções: quantas funções foram chamadas até chegar
na instrução atual. Exemplo:
classe x
func iniclasse
    # Aqui debug.func será 0 quando a classe for criada
    x:teste
func teste
    # Aqui debug.func será 1 porque foi chamado por x:iniclasse

36.6. stempo
36.7. utempo
Quanto tempo o programa usou do processador, em milésimos de segundos.
stempo é o tempo usado pelo sistema e utempo é o tempo usado pelo programa.
Se não for possível obter essa informação, essas funções retornam -1.

36.8. mem
Quantidade de memória que o programa está usando, em bytes.

36.9. memmax
Quantidade máxima de memória que o programa chegou a usar, em bytes.

36.10. ver
Retorna um texto que é a versão do IntMUD.

36.11. data
Retorna um texto que é a data em que o programa (mais especificamente
o arquivo var-debug.cpp) foi compilado.

Eventos:

36.12. <nomedavariável>_erro
Ocorreu algum erro ao executar uma função.
arg0 = Mensagem de erro (uma linha) seguido dos detalhes sobre o erro
arg1 = Índice da variável vetor, se não for vetor arg1=0

Os erros podem ser:
- A variável exec chegou a 0
  (exemplo, uma instrução 'enquanto 1' seguido de um 'efim' gera esse erro)
- Atingido limite de funções
  (exemplo, quando uma função chama a si própria indefinidamente)
- Atingido limite de variáveis
  (exemplo, uma função com uma variável 'txt512 x.255')

Exemplo de classe que mostra os erros na tela:

classe mostra_erro
comum debug d
func d_erro
telatxt tt
tt.msg("Erro:   " + arg0 + "\n")


37. INDICEOBJ - OBJETOS ORGANIZADOS DE ACORDO COM UM TEXTO

É semelhante a uma variável txt64, porém o texto é associado ao objeto
que contém essa variável. O processo inverso, obter um objeto a partir
de um texto, é possível com a variável indiceitem.


38. INDICEITEM - OBTER OBJETO PELO TEXTO

Permite obter os objetos que contém uma variável indiceobj com um
determinado texto. Ignora variáveis indiceobj com texto vazio.

Funções:

38.1. ini(<texto>)
Vai para o primeiro objeto com o texto ou parte dele.

38.2. fim(<texto>)
Vai para o último objeto com o texto ou parte dele.

38.3. antes
Passa para o objeto anterior.

38.4. antes(<número de objetos>)
Recua o número de objetos especificado.
Nada faz se o número for menor ou igual a zero.

38.5. depois
Passa para o próximo objeto.

38.6. depois(<número de objetos>)
Avança o número de objetos especificado.
Nada faz se o número for menor ou igual a zero.

38.7. obj
Objeto.

38.8. txt
Texto associado ao objeto.

38.9. obj(<texto>)
Objeto que contém o texto exato.
Essa função funciona independente das demais.

Nota: Pode-se passar mais de um texto para as funções que possuem texto.
Nesse caso, a função procurará por todos os textos.


39. DATAHORA - CALENDÁRIO

Operações envolvendo data e/ou hora, como obter a data atual e calcular
quantidade de dias entre duas datas.

Funções e variáveis:

39.1. novadata(<ano>, <mês>, <dia>)
Muda ano, mês e dia.

39.2. novahora(<hora>, <minuto>, <segundo>)
Muda hora, minuto e segundo.

39.3. antes
Muda data para o dia anterior.

39.4. depois
Muda data para o próximo dia.

39.5. agora
Muda para data e hora atuais.

39.6. diasem
Retorna o dia da semana, de 0 a 6 (0=domingo).

39.7. bissexto
Retorna 1 se o ano for bissexto ou 0 se não for.

39.8. ano
Ano, de 1 a 9999.

39.9. mes
Mês, de 1 a 12.

39.10. dia
Dia, de 1 a 31. Conforme o mês pode não chegar a 31.

39.11. hora
Hora, de 0 a 23.

39.12. min
Minuto, de 0 a 59.

39.13. seg
Segundo, de 0 a 59.

39.14. numdias
Número de dias desde 1/1/1.

39.15. numseg
Número de segundos desde o início do dia.

39.16. numtotal
Número de segundos desde 1/1/1.
