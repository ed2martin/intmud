classe jog_admsala
# Comandos de sala e de área
#
const txt_terreno = "Dentro, lugar fechado - 1mv\n\
Rua de uma cidade - 1mv\n\
Campo, um campo aberto - 2mv\n\
Pântano, itens afundam - 3mv\n\
Floresta densa - 3mv\n\
Colina - 4mv\n\
Montanha, excessivamente montanhoso - 6mv\n\
Água, pode nadar - 4mv\n\
Água, requer barco para passar - 1mv\n\
Em baixo d'água - 5mv\n\
Ar, itens e personagens caem - 1mv"
#
const txt_luta = "Pacífico\nExceto entre jogadores\nQualquer luta"
#
const txt_luz = "Claro com eventos de tempo\n\
Claro sem eventos de tempo\n\
Luz do sol\nEscuro"
#
const txt_porta = "Sem porta\nPorta aberta\nPorta fechada\nPorta trancada"
#
const txt_tranc = "Normal\n\
Fecha ao passar\n\
Tranca ao fechar\n\
Tranca ao fechar ou passar"
#
const adm_area = "\b\c3Comandos de áreas\b\n\
\c2LAREA\b [nome]\n\
  Lista áreas que começam com o nome especificado. Nome pode ser omitido.\n\
\c2CAREA\b <nome>\n\
  Cria área. Nomes de área devem ter de 2 a 16 letras de A a Z.\n\
\c2EAREA\b [nome]\n\
  Edita área. Se o nome for omitido, edita a área em que você está.\n\
\c2AAREA\b <nome>\n\
  Apaga área, desde que não tenha nenhuma sala."
const adm_sala = "\b\c3Comandos de salas\b\n\
\c2ISALA\b <nome>\n\
  Vai para a sala especificada.\n\
\c2LSALA\b [nome]\n\
  Lista salas que começam com o nome especificado.\n\
\c2CSALA\b <nome>\n\
  Cria sala com o nome especificado. Nomes de sala devem ser o nome\n\
  da área seguido de um número de 001 a 999 (três dígitos).\n\
\c2CSALA\b <direção>\n\
  Cria sala na direção especificada. Cria automaticamente uma saída\n\
  com a sala em que você está. Exemplo: csala ne\n\
\c2ESALA\b [nome]\n\
  Edita sala. Se o nome for omitido, edita a sala em que você está.\n\
\c2ASALA\b <um ou mais nomes>\n\
  Apaga uma ou mais salas. Atenção: não apaga as saídas das outras salas\n\
  para as que forem apagadas."
const adm_sai = "\b\c3Comandos de saídas das sala\b\n\
\c2LSAI\b\n\
  Mostra saídas da sala em que você está.\n\
\c2CSAI\b <direção> <sala>\n\
  Cria saída na direção especificada.\n\
\c2CSAI2\b <direção> <sala>\n\
  Mesmo que CSAI, mas cria também uma saída no sentido contrário.\n\
\c2ESAI\b <direção>\n\
  Edita tipo de saída na direção especificada.\n\
\c2ASAI\b <direção>\n\
  Apaga saída na direção especificada."

func cmd_larea # Listar áreas
  prog p
  se !p.iniclasse("a_" + arg0)
    msg("\bNenhuma área encontrada.")
  senao
    textotxt t
    t.addfim("\bÁreas (prefixo, nome, autor):")
    enquanto p.lin
      t.addfim(txt(p.texto, 2) + ", " + [p.texto]:a_nome + ", " + [p.texto]:a_autor)
      p.depois
    efim
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_carea # Criar área
  txt100 prefixo
  prefixo = txtmin(arg0)
  se $a_[prefixo]
    msg("\bÁrea já existe: " + prefixo)
  senao inttotal(prefixo) < 2 || inttotal(prefixo) > 10
    msg("\bNome de área deve ter de 2 a 10 caracteres")
  senao
    uint8 pos
    enquanto pos < inttotal(prefixo)
      se txt(prefixo, pos, 1) < "a" || txt(prefixo, pos, 1) > "z"
        msg("\bNome de área deve ter apenas letras de a a z.")
        ret 1
      fimse
      pos += 1
    efim
    prog p
    p.criar("a_" + prefixo + "\na-" + prefixo + "\nherda area")
    p.criar("b_" + prefixo + "\na-" + prefixo + "\nherda sala")
    config:salvar, msg("\bÁrea criada: " + prefixo)
  fimse
  ret 1

func cmd_aarea # Apagar área
  txt100 prefixo
  prog p
  prefixo = txtmin(arg0)
  se !$a_[prefixo]
    msg("\bÁrea não existe: " + prefixo)
  senao p.iniherdainv("b_" + prefixo)
    msg("\bÁrea contém pelo menos uma sala: " + txt(p.texto, 2))
  senao
    p.apagar("a_" + prefixo)
    p.apagar("b_" + prefixo)
    config:salvar, msg("\bÁrea apagada: " + prefixo)
  fimse
  ret 1

func cmd_earea # Editar área
  txt100 prefixo
  prog p
  prefixo = txtmin(arg0)
  se prefixo == ""
    prefixo = txt(perso.dono, 2, inttotal(txt(perso.dono)) - 5)
  fimse
  se !$a_[prefixo]
    msg("\bÁrea não existe: " + prefixo)
  senao
    var.classe1 = "a_" + prefixo
    var.classe2 = "b_" + prefixo
    m_menu("adm_area")
  fimse
  ret 1

func cmd_lsala # Listar salas
  prog p
  se !p.iniclasse("s_" + arg0)
    msg("\bNenhuma sala encontrada.")
  senao
    textotxt t
    t.addfim("\bSalas:")
    enquanto p.lin && t.linhas < 500
      t.addfim(txt(p.texto, 2) + "  " + $[p.texto].s_titulo)
      p.depois
    efim
    msg2(t.remove(500))
  fimse
  ret 1

func cmd_isala # Ir para uma sala específica
  se !$s_[arg0]
    msg("\bSala não existe: " + arg0)
  senao !perso
    msg("Você deve estar controlando um personagem para isso")
  senao
    perso.mudadono($s_[arg0])
  fimse
  ret 1

func cmd_csala # Criar sala
  prog p
  txt40 nome
  uint16 num
  se arg0 == ""
    msg("Tecle o nome da sala ou a direção após CSALA")
    ret 1
# Criar sala em uma direção
  senao misc:d1[arg0]
    txt2 dir
    dir = misc:d1[arg0]
# Obtém prefixo da área
    nome = txt(perso.dono, 0, inttotal(txt(perso.dono)) - 3)
    se txt(nome, 0, 2) != "s_"
      msg("Você não está em uma sala")
      ret 1
    fimse
# Checa se já existe sala nessa direção
    se p.existe(perso.dono, "dir_" + dir) == 1
      msg("Já existe sala na direção " + dir)
      ret 1
    fimse
# Obtém número da sala
    num = 1001
    enquanto num < 2000 && p.existe(nome + txtfim(num, 3))
      num += 1
    efim
    se num >= 2000
      msg("Sem espaço para criar sala na área " + txt(nome, 2))
      ret 1
    fimse
# Cria sala
    txt300 nome2
    nome2 = nome + txtfim(num, 3) + "\n" # Nome da classe
    nome2 += "a-" + txt(nome, 2) + "\n" # Nome do arquivo
    nome2 += "herda b_" + txt(nome, 2) + "\n" # Herda propriedades da área
    nome2 += "const dir_" + misc:d2[dir] + "=$" + perso.dono # Saída da sala
    p.criar(nome2)
    p.criar(perso.dono, "const dir_" + dir + "=$" + nome + txtfim(num, 3))
    config:salvar
    msg("\bSala criada em " + dir + ": " + txt(nome, 2) + txtfim(num, 3))
    ret 1
  fimse
# Tenta criar sala com o nome especificado
  num = int(txtfim(arg0, 3)) + 1000
  nome = txt(arg0, 0, inttotal(txt(arg0)) - 3)
  se num <= 1000 || txtfim(num, 3) != txtfim(arg0, 3)
    msg("Nome de sala ou direção inválida: " + arg0)
  senao p.existe("s_" + nome + txtfim(num, 3))
    msg("Sala já existe: " + arg0)
  senao !p.existe("b_" + nome)
    msg("Área não existe: " + nome)
  senao
    p.iniclasse("b_" + nome)
    nome = txt(p.texto, 2)
    p.criar("s_" + nome + txtfim(num, 3) + "\na-" + nome + "\nherda b_" + nome)
    config:salvar
    msg("\bSala criada: " + nome + txtfim(num, 3))
  fimse
  ret 1

func cmd_asala # Apagar sala
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes da sala após ASALA")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("s_" + txtsub(arg0, x, 1))
      msg("Sala não existe: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_asala
  ret 1

func p_asala # Confirmar que quer apagar sala
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("s_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Sala apagada: " + tpasso)
    senao
      msg("Salas apagadas: " + tpasso)
    fimse
  senao
    txt10 m1
    passo = "asala"
    txt2(tpasso) && (m1 = "s")
    msg("Apagar sala" + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_esala # Editar sala
  txt100 nome
  prog p
  nome = txtmin(arg0)
  nome == "" && (nome = txt(perso.dono, 2))
  se !$s_[nome]
    msg("\bSala não existe: " + nome)
  senao
    var.classe1 = "s_" + nome
    m_menu("adm_sala")
  fimse
  ret 1

func cmd_lsai # Listar saídas
  se !perso.dono
    msg("\bVocê não está em uma sala")
    ret 1
  fimse
  prog p
  txt80 dir
  txt80 lin
  tpasso = perso.dono
  msg("\bSaídas de " + txt(tpasso, 2) + ":")
  epara dir = "n s l o ne no se so c b", dir, dir = txt2(dir)
    continuar !p.existe(tpasso, "dir_" + txt1(dir))
    lin = txtmai(txt1(dir)) + "  "
    lin += t_sala(tpasso, "dir_" + txt1(dir))
    msg(lin)
  efim
  !lin && msg("Nenhuma")
  ret 1

func cmd_asai # Apagar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após ASAI")
  senao !dir
    msg("\bSaída não existe: " + arg0)
  senao
    p.apagar(perso.dono, "dir_" + dir)
    p.apagar(perso.dono, "portaini_" + dir)
    p.apagar(perso.dono, "inv_" + dir)
    p.apagar(perso.dono, "tranc_" + dir)
    p.apagar(perso.dono, "chave_" + dir)
    config:salvar, msg("\bSaída apagada: " + dir)
  fimse
  ret 1

func cmd_csai # Criar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após CSAI" + arg1)
  senao !dir
    msg("\bSaída não existe: " + txt1(arg0))
  senao !txt2(arg0)
    msg("\bDigite a sala após CSAI" + arg1 + " " + arg0)
  senao !p.existe("s_" + txt2(arg0))
    msg("\bSala não existe: " + txt2(arg0))
  senao
    p.criar(perso.dono, "const dir_" + dir + "=$s_" + txtmin(txt2(arg0)))
    se arg1
      p.criar("s_" + txt2(arg0), "const dir_" + misc:d2[dir] + "=$" + perso.dono)
      msg("\bSaída completa criada: " + dir + " para " + txtmin(txt2(arg0)))
    senao
      msg("\bSaída criada: " + dir + " para " + txtmin(txt2(arg0)))
    fimse
    config:salvar
  fimse
  ret 1

const cmd_csai2 = cmd_csai(arg0, "2") # Criar saída completa

func cmd_esai # Editar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após ESAI")
  senao !dir
    msg("\bSaída não existe: " + arg0)
  senao !p.existe(perso.dono, "dir_" + dir)
    msg("Não existe saída na direção " + txtmai(dir))
  senao
    var.classe1 = perso.dono
    var.saida1 = txtmin(dir)
    m_menu("adm_saida")
  fimse
  ret 1

const t_saiinicio = t_opcao(arg0, arg1, arg2)

func p_saiinicio
  p_opcao(arg0)
  se passo == "opcao"
    passo = "saiinicio"
  senao arg0 != "z" && passo != "saiinicio"
    $[var.classe1].mudaporta(var.saida1, arg0)
  fimse
  ret 1

const t_saiagora = t_opcaomostra($[arg0].[arg1], txt_porta)

func p_saiagora # Mudar o estado atual
  casovar arg0
  casose "z"
    sair
  casose "0"
  casose "1"
  casose "2"
  casose "3"
    se $[var.classe1].mudaporta(var.saida1, arg0)
      textotxt t
      t.addfim(txt_porta), t.remove(arg0)
      msg("Saída mudou para: " + arg0 + " " + t.remove)
    senao
      msg("Não foi possível mudar a saída")
    fimse
    sair
  casose
    passo = "saiagora"
    msg("Escolha: 0 Sem porta, 1 Aberto, 2 Fechado, 3 Trancado, Z Cancela")
    ret 1
  casofim
  passo = var.opcpasso, p_[passo]("\b")
  ret 1


classe adm_area
# Vide arquivo mud.txt, tópico "Criando menus de edição (administração)"
const titulo = "Área " + txt(var.classe1, 2)
#
const nome1 = "Nome"
const tipo1 = "linha-"
const classe1 = var.classe1
const var1 = "a_nome"
#
const nome2 = "Autor"
const tipo2 = "linha-"
const classe2 = var.classe1
const var2 = "a_autor"
#
const nome3 = "Tempo de reset"
const tipo3 = "numero"
const classe3 = var.classe1
const var3 = "a_tempo"
#
const nome4 = "Modo de reset"
const tipo4 = "opcao"
const classe4 = var.classe1
const var4 = "a_reset"
const extra4 = "Nunca\nQuando não há jogadores\nNormal"
#
const nome5 = "Terreno"
const tipo5 = "opcao"
const classe5 = var.classe2
const var5 = "s_terreno"
const extra5 = txt_terreno
#
const nome6 = "Luz"
const tipo6 = "opcao"
const classe6 = var.classe2
const var6 = "s_luz"
const extra6 = txt_luz
#
const nome7 = "Apagar itens (min)"
const tipo7 = "numero"
const classe7 = var.classe2
const var7 = "s_item"
#
const nome8 = "Morre ao entrar"
const tipo8 = "simnao"
const classe8 = var.classe2
const var8 = "s_morre"
#
const nome9 = "Silencioso"
const tipo9 = "simnao"
const classe9 = var.classe2
const var9 = "s_silencio"
#
const nome10 = "Batalha"
const tipo10 = "opcao"
const classe10 = var.classe2
const var10 = "s_luta"
const extra10 = txt_luta
#
const nome11 = "Sem magia"
const tipo11 = "simnao"
const classe11 = var.classe2
const var11 = "s_semmagia"
#
const nome12 = "PNJs não entram"
const tipo12 = "simnao"
const classe12 = var.classe2
const var12 = "s_sempnj"


classe adm_sala
const titulo = "Sala " + txt(var.classe1, 2)
#
const nome1 = "Título"
const tipo1 = "linha"
const classe1 = var.classe1
const var1 = "s_titulo"
#
const nome2 = "Descrição"
const tipo2 = "texto"
const classe2 = var.classe1
const var2 = "s_desc"
#
const nome3 = "Terreno"
const tipo3 = "opcao"
const classe3 = var.classe1
const var3 = "s_terreno"
const extra3 = txt_terreno
#
const nome4 = "Luz"
const tipo4 = "opcao"
const classe4 = var.classe1
const var4 = "s_luz"
const extra4 = txt_luz
#
const nome5 = "Apagar itens"
const info5 = "Tempo em minutos"
const tipo5 = "numero"
const classe5 = var.classe1
const var5 = "s_item"
#
const nome6 = "Morre ao entrar"
const tipo6 = "simnao"
const classe6 = var.classe1
const var6 = "s_morre"
#
const nome7 = "Silencioso"
const tipo7 = "simnao"
const classe7 = var.classe1
const var7 = "s_silencio"
#
const nome8 = "Batalha"
const tipo8 = "opcao"
const classe8 = var.classe1
const var8 = "s_luta"
const extra8 = txt_luta
#
const nome9 = "Sem magia"
const tipo9 = "simnao"
const classe9 = var.classe1
const var9 = "s_semmagia"
#
const nome10 = "PNJs não entram"
const tipo10 = "simnao"
const classe10 = var.classe1
const var10 = "s_sempnj"


classe adm_saida
const titulo = "Saída " + txtmai(var.saida1) + " de " + txt(var.classe1, 2)
#
const nome1 = "Estado inicial"
const tipo1 = "saiinicio"
const classe1 = var.classe1
const var1 = "portaini_" + var.saida1
const extra1 = txt_porta
#
const nome2 = "Estado atual"
const tipo2 = "saiagora--"
const classe2 = var.classe1
const var2 = "porta_" + var.saida1
#
const nome3 = "Invisível"
const tipo3 = "simnao"
const classe3 = var.classe1
const var3 = "inv_" + var.saida1
#
const nome4 = "Trancar"
const tipo4 = "opcao"
const classe4 = var.classe1
const var4 = "tranc_" + var.saida1
const extra4 = txt_tranc
#
const nome5 = "Chave"
const tipo5 = "linha"
const classe5 = var.classe1
const var5 = "chave_" + var.saida1
