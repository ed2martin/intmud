Índice
1. Comandos
2. Funções para obter personagem e item
3. Criando menus de edição (administração)
4. Funcionamento interno das opções dos menus
5. Criação de menus de comandos


1. Comandos

São classes cujo nome começa com um dos seguintes textos:
cmd_  para comandos normais
magia_  para magias (só podem ser lançadas com o comando Lançar)
soc_  para comandos sociais
adm_ para comandos de administração (não existem para não administradores)
Em seguida vem o nome do comando.

Exemplos:
cmd_config   Trata do comando Config
soc_abraçar  Trata do comando social Abraçar

Quando o jogador digita algo, primeiro são verificas as classe 'adm_',
caso seja um administrador. Depois, as classes 'magia_', 'cmd_' e 'soc_'.

A classe 'comando_comum' é herdada por todos os comandos.
Quando é necessário uma única classe herdada por dois ou mais comandos,
geralmente o nome dessa classe começa com 'comando_'.

Classes de comandos podem ter as seguintes funções e constantes:

const objcmd = este # Objeto que processa o comando, ou nulo se não existe
# arg0 = objeto do personagem
# arg1 = objeto perm com as permissões do personagem: $perm_[arg0.jogperm]

const objnivel = 0 # Prioridade do comando (0=maior prioridade)
# arg0 = objeto do personagem
# arg1 = objeto perm com as permissões do personagem: $perm_[arg0.jogperm]
Quando há mais de um comando que corresponde ao que o usuário digitou,
é escolhido o que tem o menor valor de objnivel.
Foram adotados os valores:
0 = a maioria dos comandos
2 = habilidades e magias em que o personagem não está com a arma necessária
4 = baixa prioridade (exemplo, Chat)
6 = comandos sociais (exemplo, Abraçar)

func escr # Processa o comando
# arg0 = objeto do personagem
# arg1 = texto digitado após o nome do comando
# arg2 = objeto perm com as permissões do personagem: $perm_[arg0.jogperm]

func txtajuda
# arg0 = objeto do personagem
# Deve retornar o texto de ajuda, ou nulo se não houver nenhuma ajuda
# Não depende da constante objcmd

func passo
# Função executada quando a variável passo for o nome da classe
# arg0 = objeto jogsock do jogador (vide arquivo obj/jogsock.int)
# arg1 = texto digitado
# Deve retornar 1 se processou o que o jogador digitou


2. Funções para obter personagem e item

As funções abaixo permitem obter o objeto correspondente ao item ou
personagem, a partir do que o usuário digitou. Se o item ou personagem
não for encontrado, essas funções retornam nulo. Vide exemplo mais adiante.

misc:itemtudo(<personagem>, <nome do item>)
Obtém um item no personagem ou na sala

misc:itemdono(<personagem>, <nome do item>)
Obtém um item na sala

misc:itemdentro(<personagem>, <nome do item>)
Obtém um item no personagem

misc:persodono(<personagem>, <nome do personagem>)
Obtém um personagem na sala

misc:persooutro(<personagem>, <nome do personagem>)
Obtém um personagem na sala que não seja o próprio personagem

misc:persodentro(<personagem>, <número do personagem>)
Obtém um animal do personagem a partir do número no comando Animal

misc:personum(<personagem>, <número do personagem>)
Obtém um personagem a partir do número no comando Animal

misc:itemlista(<personagem>, <nome do personagem>, <variável listaobj>)
Obtém um personagem ou item a partir dos personagens e itens da
variável listaobj

misc:persoinfo(<personagem>, <nome do personagem>, [msg não vê], [msg não possui])
Obtém o personagem que o jogador quer consultar a partir de um texto
Se [msg não vê] estiver ausente, assume "Você não vê $m."
Se [msg não possui] estiver ausente, assume "Você não possui $animal $m."

misc:separa(<texto>)
Essa função separa o texto em o nome do objeto e nome do alvo
Faz: misc:sep1 = objeto, misc:sep2 = alvo
Exemplo, misc:separa("10 carne joaquim") fará misc:sep1="10 carne"
e misc:sep2="joaquim"

misc:nomeperso(<texto>)
Verifica se um texto é válido para nome de personagem.
Retorna 1 se for válido ou 0 se não for.

Exemplo: Comando Copiar, faz o jogador ficar da mesma raça, classe
e subclasse de outro personagem.

classe cmd_copiar
herda comando_comum
const txtajuda = "\b\c3Copiar\b\n\
Sintaxe: COPIAR <personagem>\n\
Copia raça e classe de outro personagem."

func escr
  ret !arg1, arg0.msg("Digite copiar seguido do nome do personagem.")
  refvar r = misc:persooutro(arg0, arg1)
  ret !r, arg0.msg("Você não vê ninguém chamado " + arg1 + ".")
  $mens.p(arg0, r)
  $mens.msg("Você copia $a.", arg0)
  arg0.tipo1 = r.tipo1
  arg0.tipo2 = r.tipo2
  arg0.tipo3 = r.tipo3
  arg0.recalc = 1


3. Criando menus de edição (administração)

Primeiro criar uma classe como a seguinte:

classe menu_config
herda comando_menu

# Título é o nome do menu (aparece antes da lista de opções)
const titulo = "Configuração do MUD"

# Quantos caracteres deve ter o nome de cada opção do menu
# Se tiver menos que isso, são acrescentados espaços
const colunas = 28

# Nome da classe que contém o menu anterior, ou "" se não houver menu anterior
# Quando o usuário escolhe sair do menu (teclando Z), vai para esse menu
const menufim = ""

# Nome da classe, para as opções do menu que estiverem sem o nome da classe
const classe = ""

# Primeira opção do menu:

const nome1 = "Quantidade de animais"
# Nome é o nome da opção

const info1 = "Quantos animais um jogador pode usar em batalha"
# Texto de informações, mostrado quando a opção é escolhida
# Se estiver ausente, não é mostrado nenhum texto

const clas1 = "config"
# Nome da classe; se ausente ou for texto vazio, pega da constante classe

const vari1 = "animal"
# Nome da variável

const tipo1 = "opc_numero--"
# Tipo de dado - nome da classe responsável pelo dado sendo editado:
# "opc_linha" = texto de uma linha (exemplo: título das salas)
# "opc_texto" = texto de uma ou mais linhas (exemplo: descrição das salas)
# "opc_numero" = valor numérico inteiro
# "opc_numreal" = valor numérico que pode ter dígitos após a vírgula
# "opc_opcao" = um valor numérico baseado numa lista de opções
# "opc_txtopcao" = uma lista de opções: texto de várias linhas, sendo que
#                  pode-se mudar uma linha sem mudar as outras
# "opc_vetor" = um valor numérico sendo que cada bit é uma opção de uma lista
# "opc_vetorhex" = mesmo que "opc_vetor", porém o número é um texto em hexadecimal
# "opc_vetoritemtipos" = mesmo que "opc_vetor", mas leva em consideração
#                 os tipos de itens predefinidos
# "opc_tipos" = texto contendo uma lista de tipos (raças e classes)
# "opc_tipodep" = texto contendo uma lista de habilidades, magias e/ou idiomas
# "opc_listaidiomas" = texto contendo uma lista de idiomas
# "opc_listaregioes" = texto contendo uma lista de regiões (definidas nas áreas)
# "opc_simnao" = uma opção que pode ser apenas 0 (não) ou 1 (sim)
# "opc_sala" = uma sala
# "opc_salaitem" = uma sala ou um item
# "opc_listasala" = um texto contendo o nome de uma sala em cada linha
#                 (nomes dos objetos sem o "s_" no começo)
# "opc_listaperso" = um texto contendo o nome de um personagem em cada linha
#                 (nomes dos objetos sem o "p_" no começo)
# "opc_listaitem" = um texto contendo o nome de um item em cada linha
#                 (nomes dos objetos sem o "i_" no começo)
# "opc_listaefeito" = um texto contendo o nome de um efeito em cada linha
#                 (nomes dos objetos sem o "e_" no começo)
# "opc_atribcfg" = alterar atributos base para todos os personagens
# "opc_atribnum" = alterar atributos numéricos de um personagem
# "opc_atribobj" = alterar atributos de arma de um item
# "opc_atribbit" = alterar atributos sim/não de um personagem
# "opc_atribatk" = alterar atributos de ataque de um personagem
# "opc_atribdef" = alterar atributos de defesa de um personagem
# "opc_ajuda" = um texto explicativo, que é mostrado ao usuário
#               nesse caso, só é usada a constante extr (vide abaixo)
# Pode ser também o nome de um submenu
# Se não for possível editar como função, acrescente um sinal de '-' no nome
# Se não for possível apagar, acrescente mais um sinal de '-' no nome

const extr1 = "1 8"
# Opções extras. Os tipos que possuem opções extras são:
# No tipo "opc_numero" são os valores mínimo e máximo (nesse caso, vai de 1 a 8)
# No tipo "opc_opcao" é a lista de opções
# No tipo "opc_txtopcao" são a quantidade mínima e a quantidade máxima de linhas
#         e o número da primeira opção que pode ser alterada
# No tipo "opc_ajuda" é o texto que será mostrado ao usuário
# No tipo "opc_listasala", se não estiver vazio, é a quantidade máxima de salas
# No tipo "opc_listaitem", se não estiver vazio, é a quantidade máxima de itens
# No tipo "opc_listaefeito", se não estiver vazio, é a quantidade máxima de efeitos

const exec1 = "atualiza"
# Se não for nulo, quando o usuário muda a opção, é executada a função
# com esse nome de todos os objetos que foram mudados
# É possível especificar também a classe, da seguinte forma:
# const exec1 = "nomedaclasse:nomedafunção"

const nulo1 = ""
# O que mostrar quando a variável não estiver definida (quando aparece <nulo>)
# Se estiver vazio, apresenta a mensagem padrão da opção

const titu1 = "um texto qualquer"
# Título: mensagem que deve ser apresentada antes da opção

# As outras opções seguem o mesmo padrão, apenas mudando o número
# no nome da variável. Exemplo:

const nome2 = "Senha de administração" # Nome da opção
const tipo2 = "opc_linha" # Tipo de variável
const clas2 = "config"
const vari2 = "senhaadm"

const nome3 = "Tipo de ataque"
const tipo3 = "opc_opcao"
const clas3 = "config"
const vari3 = "atktempo"
const extr3 = "manual\nautomático" # 0=manual, 1=automático

Para chamar o menu, basta executar a função m_menu do jogador (classe
jogsock), passando como argumento o nome da classe.
Exemplo: arg0.sock.m_menu("menu_config")

Alguns exemplos de uso dos diversos tipos de dados:

"opc_linha" - usado em títulos de salas, nome do personagem, descrição curta
"opc_texto" - descrição de uma sala, ao olhar para um personagem ou item,
  mensagem de apresentação do mud
"opc_numero" - nível dos personagens e dos itens, tempo de reset de uma área
"opc_numreal" - taxa de manutenção das casas do MUD, porque pode ser um número
  abaixo de 1% do valor da casa
"opc_opcao" - tipo de terreno de uma sala, se uma saída não pode ser trancada,
  pode ser trancada ou tranca ao fechar, etc. Qualquer coisa que tenha duas
  opções ou mais, sendo cada uma um número
"opc_simnao" - qualquer coisa que seja 0=não e 1=sim, como permite PNJ,
  sala não permite magia, PNJ é agressivo, PNJ é imortal
"opc_vetor" - em que posições pode vestir um item, quando alguém cria um
  personagem, quais as opções do comando config vêm habilitadas,
  quais tipos de ataque são normais e quais são especiais (exemplo,
  contusão, luta e terra são normais, fogo, água e elétrico são especiais)
"opc_txtopcao" - tipos de produtos existentes, tipos de ataques (água, fogo,
  etc.), nomes das posições em que pode vestir alguma coisa
"opc_sala" - em que sala os jogadores começam o jogo e para que sala vão
  quando morrem
"opc_atrib*" - um submenu para alterar alguns atributos de itens, personagens
  e classes, como vida por nível, furtividade, ver invisível, porcentagem
  de defesa e de ataque para um elemento (cortante, perfurante, água,
  fogo, terra, etc.)
"opc_tipos" - com que raças e classes um vendedor ou professor não negocia,
  que raças e classes não podem vestir um item
"opc_tipodep" - quais habilidades e magias são necessárias para aprender uma
  determinada habilidade ou magia


4. Funcionamento interno das opções dos menus

Para cada tipo de opção, deve existir uma classe com o mesmo nome,
com duas funções:

func menu
É chamada para mostrar a opção no menu
arg0 = nome da classe (constante clas)
arg1 = nome da variável (constante vari)
arg2 = nomes das opções (constante extr)

func passo
É chamada quando o jogador escolhe a opção do menu
Vide tópico "Comandos"
arg0 = objeto jogsock do jogador (vide arquivo obj/jogsock.int)
arg1 = texto digitado
Deve retornar 1 se processou o que o jogador digitou

Outras variáveis da função passo:
arg0.var.opcnome = nome da opção (constante nome)
arg0.var.opcclasse = classe da variável (constante clas)
arg0.var.opcvar = nome da variável (constante vari)
arg0.var.opcextra = informações extras (constante extr)
arg0.var.opcpasso = usado para a opção poder voltar ao menu
 Para sair do menu, chamar passosair( personagem ) da classe comando_adm
arg0.var.opcvalido = 1 se a opço pode apagar a variável ou 0 se não pode
arg0.var.opcexec = função executada após alterar as variáveis (constante exec)
 Isso costuma ser feito com a seguinte linha:
 criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)

Quando a função passo altera o programa, costuma-se salvar o programa e gerar
uma mensagem para os jogadores que estão com o canal admlog habilitado.
São linhas como essas:
config:salvar
admlog(arg0, "mudou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)


5. Criação de menus de comandos

clase menu_econfig_cmd
herda comando_objmenu

# Título é o nome do menu (aparece antes da lista de opções)
const titulo = "Comandos dos jogadores"

# As classes editáveis começam com esse nome especificado.
# Em cada classe editável, deve exitir uma const objmenu com o objeto do menu
# responsável por editar a classe. Exemplo, para uma classe chamada cmd_abrir,
# provavelmente há uma linha const objmenu = $m_cmd_abrir
const classe = "cmd_"

# Para colocar menu, definir uma const objmenu com o objeto do menu responsável
# por editar essa classe.
# Exemplo, se a classe cmd_abrir tiver uma linha const objmenu = $m_cmd_abrir
# Isso significa que quando o usuário escolher editar a classe cmd_abrir,
# vai para o menu cuja classe é m_cmd_abrir.

# Nome da classe que contém o menu anterior, ou "" se não houver menu anterior
# Quando o usuário escolhe sair do menu (teclando Z), vai para esse menu
const menufim = ""
