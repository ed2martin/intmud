classe atualiza_601
# Atualiza arquivos mud/config/* e mud/areas/* de acordo com novas mudanças
prog p
debug dbg
uint16 versao
telatxt tela
intexec ini2
intexec ini3
intexec ini4

func p_criar # Para testar as modificações
  se args == 1
    tela.msg("p.criar1(" + arg0 + ")\n")
  senao
    tela.msg("p.criar2(" + arg0 + " , " + arg1 + ")\n")
  fimse

func p_apagar # Para testar as modificações
  se args == 1
    tela.msg("p.apagar1(" + arg0 + ")\n")
  senao
    tela.msg("p.apagar2(" + arg0 + " , " + arg1 + ")\n")
  fimse

func criafunc # Cria função ou constante se não existir
# arg0 = nome da classe
# arg1 = definição da função ou constante
  refvar nome = txtsub(txttroca(txttroca(arg1, "=", " ="), "#", " #"), 1, 1)
  p.existe(arg0, nome) != 1 && p.criar(arg0, arg1)

func movefunc # Move uma uma função, constante ou variável
# arg0 = nome da classe origem
# arg1 = nome da função na classe origem
# arg2 = nome da classe destino
# arg3 = novo nome da função (na classe destino)
# arg4 = se verdadeiro, não apaga função na classe origem
  prog p
  textotxt t
  ret !p.existe(arg2) || !p.inilinha(arg0, arg1), nulo
  t.addfim(txt1(p.texto) + " " + arg3 + " " + txtsub(p.texto, 2))
  epara p.depois, p.lin, p.depois
    t.addfim(p.texto)
  efim
  !arg4 && p.apagar(arg0, arg1), p.criar(arg2, t.remove(10000))

const iniclasse = !$[arg0] && criar(arg0)

func ini
  ini2 = 1
# Checa e muda a versão
  ret (versao = config:versao) >= 297, nulo
  p.criar("config", "const versao = 297 # Para atualizar arquivos mud/config/* e mud/areas/*")
  config:salvar
# Coloca habilidades e magias no arquivo mud-b-config.int
  se versao < 292
    textotxt t
    epara p.iniarq("b-config"), p.lin, p.depois
      continuar txt(p.texto, 0, 4) != "cmd_" && txt(p.texto, 0, 6) != "magia_"
      t.addfim(p.texto)
    efim
    epara p.iniarq("b-hab"), p.lin, p.depois
      t.addfim(p.texto)
    efim
    dbg.ini
    t.ordena
    p.clini("b-hab", t.ini.texto)
    enquanto t.linhas > 1
      p.cldepois(t.remove, t.ini.texto)
    efim
    dbg.ini
    criafunc("e_congelado", "func cmd_mover\narg0.msg(\"Você congelou\")\nret 1")
    criafunc("e_congelado", "func cmd_recalc2\narg0.atribs.addfim(\"Congelado\")")
    criafunc("config", "const echomsg = \"\b\cb(ADM) $m\b\"")
    criafunc("config", "const chatmsg = \"(chat) $R '$m'\"")
    criafunc("config", "const novatosmsg = \"(novatos) $R '$m'\"")
    criafunc("config", "const falarmsg = \"$P falou '$m'\"")
    criafunc("config", "const perguntarmsg = \"$P perguntou '$m'\"")
    criafunc("config", "const exclamarmsg = \"$P exclamou '$m'\"")
    criafunc("config", "const ponderarmsg = \"$P ponderou '$m'\"")
    criafunc("config", "const continuarmsg = \"$P continuou '$m'\"")
    dbg.ini
  fimse
# Para cada habilidade ou magia:
# msgauto1 = msgacertou1
# msgacertou1 e msgmatou1 = msgacertou2
# msgerrou1 = msgerrou2
# msgnulo1 = msgnulo2
# Apaga msgacertou2, msgnulo2 e msgerrou2
  se versao < 293
    textotxt t
    epara p.iniclasse("cmd_"), p.lin, p.depois
      [p.texto]:cmdmenu && t.addfim(p.texto)
    efim
    epara p.iniclasse("magia_"), p.lin, p.depois
      [p.texto].cmdmenu && t.addfim(p.texto)
    efim
    txt100 lin
    enquanto t.linhas
      dbg.ini
      refvar obj = criar(t.remove)
      apagar(obj)
      se obj.msgacertou2
        refvar t1 = (obj.msgacertou1 ? obj.msgacertou1 : obj.msgacertou2) + ", $m\\n\\n"
        refvar t2 = (obj.msgerrou2 ? obj.msgerrou2 : obj.msgacertou2) + ", errou"
        refvar t3 = (obj.msgnulo2 ? obj.msgnulo2 : obj.msgacertou2) + ", nada acontece"
        lin = "const msgatk0 = \""
        p.criar(obj, lin + t1 + t1 + "\\n" + t1 + "\\n" + t2 + "\\n\\n\\n" + t3 + "\"")
      fimse
      p.apagar(obj, "msgacertou1")
      p.apagar(obj, "msgacertou2")
      p.apagar(obj, "msgerrou1")
      p.apagar(obj, "msgerrou2")
      p.apagar(obj, "msgnulo1")
      p.apagar(obj, "msgnulo2")
    efim
    dbg.ini
# Cria constante config:atk_txt
    criafunc("config", "const atk_txt = \"bater\"")
# Cria habilidade bater
    t.addfim("cmd_Bater\nb-hab\nherda comando_ataque")
    t.addfim("const nomevar = \"h_Bater\"")
    t.addfim("const tipoalvo = 6 # Alvo: Ataque automático")
    lin = "#, $m\\n\\n#, $m\\n\\n\\n#, $m\\n\\n\\n#, errou\\n\\n\\n#, nada acontece\""
    t.addfim("const msgatk0 = \"" + txttroca(lin, "#", "$P bate em $a"))
    p.criar(t.remove(100))
# Cria constante config:equip_ordem
    criafunc("config", "const equip_ordem = \"49 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \
19 20 21 22 23 24 25 26 27 28 29\"")
# Cria função atribcfg
    t.addfim("func atribcfg # Altera atributos do personagem")
    t.addfim("# Função criada automaticamente")
    t.addfim("pvidamax = 15 * pnivel + 45")
    t.addfim("pmanamax = 1 * pnivel + 30")
    t.addfim("pmovemax = 2 * pnivel + 30")
    t.addfim("pveloc1 = 5 * pnivel + 20")
    t.addfim("atknorm = 12 * pnivel + 36")
    t.addfim("defnorm = 10 * pnivel + 30")
    t.addfim("atkesp = 12 * pnivel + 36")
    t.addfim("defesp = 10 * pnivel + 30")
    t.addfim("evasao = 2 * pnivel + 30")
    t.addfim("precisao = 2 * pnivel + 30")
    t.addfim("pesomax = 20000")
    p.criar("config", t.remove(100))
    config:salvar
  fimse
# Cria habilidades para cada ataque automático, nas variáveis:
# config:arma_txt, config:arma_acertou, config:arma_errou, config:arma_nulo
# Depois apaga essas variáveis
  se versao < 293
    textotxt arma
    textotxt acertou
    textotxt errou
    textotxt vazio
    arma.addfim(config:arma_txt), arma.remove
    acertou.addfim(config:arma_acertou), acertou.remove
    errou.addfim(config:arma_errou), errou.remove
    vazio.addfim(config:arma_nulo), vazio.remove
    txt100 lin
    enquanto arma.linhas
      refvar cl = "cmd_" + txtmin(txts(arma.remove))
      se !p.existe(cl)
        textotxt t
        t.addfim(cl)
        t.addfim("b-hab")
        t.addfim("herda comando_ataque")
        t.addfim("const nomevar = \"h_" + txt(cl, 4) + "\"")
        p.criar(t.remove(100))
      fimse
      p.criar(cl, "const tipoalvo = 6 # Alvo: Ataque automático")
      refvar t1 = (acertou.ini.texto ? acertou.ini.texto : "$P ataca $a") + ", $m\\n\\n"
      refvar t2 = errou.ini.texto ? errou.ini.texto : "$P ataca $a, errou"
      refvar t3 = vazio.ini.texto ? vazio.ini.texto : "$P ataca $a, nada acontece"
      lin = "const msgatk0 = \""
      p.criar(cl, lin + t1 + t1 + "\\n" + t1 + "\\n" + t2 + "\\n\\n\\n" + t3 + "\"")
      acertou.remove, errou.remove, vazio.remove
    efim
    p.apagar("config", "arma_acertou")
    p.apagar("config", "arma_errou")
    p.apagar("config", "arma_nulo")
    p.apagar("config", "atktipo")
    criafunc("config", "const matartipo = 1")
    criar("admordena", "b-hab")
    dbg.ini
  fimse
# Comando gritar
  se versao < 297
    criafunc("config", "const gritarmsg = \"$P gritou '$m'\"")
    criafunc("config", "const gritarmove = 2")
  fimse

func ini2_exec
  ini3 = 1
# Checa e muda a versão
  ret (versao = config:versao) >= 430, nulo
  p.criar("config", "const versao = 430 # Para atualizar arquivos mud/config/* e mud/areas/*")
  config:salvar
# Acerta variáveis das habilidades e magias
  se versao < 298
    uint16 valor
    epara p.iniarq("b-hab"), p.lin, p.depois
      dbg.ini
      se (valor = ([p.texto]:a_vida1 + [p.texto]:a_vida2) / 2) != 0
        p.criar(p.texto, "const a_vida1 = " + valor)
      senao
        p.apagar(p.texto, "a_vida1")
      fimse
      p.apagar(p.texto, "a_vida2")
      se (valor = ([p.texto]:a_mana1 + [p.texto]:a_mana2) / 2) != 0
        p.criar(p.texto, "const a_mana1 = " + valor)
      senao
        p.apagar(p.texto, "a_mana1")
      fimse
      p.apagar(p.texto, "a_mana2")
      se (valor = ([p.texto]:a_move1 + [p.texto]:a_move2) / 2) != 0
        p.criar(p.texto, "const a_move1 = " + valor)
      senao
        p.apagar(p.texto, "a_move1")
      fimse
      p.apagar(p.texto, "a_move2")
      refvar msgini = txtsublin([p.texto]:msgini, 0, 1)
      se [p.texto]:msgatk0
        refvar lin = msgini + "\n\n\n" + [p.texto]:msgatk0
        p.criar(p.texto, "const msgatk0=\"" + txtvis(lin) + "\"")
      senao msgini
        p.criar(p.texto, "const msgatk0=\"" + txtvis(msgini) + "\"")
      fimse
      se [p.texto]:msgatk1
        p.criar(p.texto, "const msgatk1=\"\\n\\n\\n" + txtvis([p.texto]:msgatk1) + "\"")
      fimse
      se [p.texto]:msgatk2
        p.criar(p.texto, "const msgatk1=\"\\n\\n\\n" + txtvis([p.texto]:msgatk2) + "\"")
      fimse
      se [p.texto]:msgatk3
        p.criar(p.texto, "const msgatk1=\"\\n\\n\\n" + txtvis([p.texto]:msgatk3) + "\"")
      fimse
      se [p.texto]:msgatk4
        p.criar(p.texto, "const msgatk1=\"\\n\\n\\n" + txtvis([p.texto]:msgatk4) + "\"")
      fimse
      p.apagar(p.texto, "msgini")
    efim
  fimse
# Mensagens do comando Sussurrar
  se versao < 303
    criafunc("config", "const sussurrar1msg = \"$P sussurrou algumas palavras.\"")
    criafunc("config", "const sussurrar2msg = \"$P sussurou para $a '$m'\"")
    criafunc("config", "const sussurrar3msg = \"$P sussurou algumas palavras para $a.\"")
  fimse
# Mensagens dos comandos Telepatia e Rezar e funções de reset das salas
  se versao < 307
    criafunc("config", "const telepatia1 = \"(+telepatia) $R '$m'\"")
    criafunc("config", "const telepatia2 = \"(telepatia) $R '$m'\"")
    criafunc("config", "const rezar1msg = \"(rezar) $R '$m'\"")
    criafunc("config", "const rezar2msg = \"Você rezou '$m'\"")
    epara p.iniclasse("s_"), p.lin, p.depois
      $reset.atualiza(p.texto, "a_reset", [p.texto]:a_reset)
      $reset.atualiza(p.texto, "s_reset", [p.texto]:s_reset)
      dbg.ini
    efim
  fimse
# Tipos de ataque (em habilidades e magias)
  se versao < 309
    epara p.iniarq("b-hab"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "tipoalvo") != 1
      casovar [p.texto]:tipoalvo
      casose "0"
        p.criar(p.texto, "const tipoalvo = 0 # Alvo: 0 Qualquer um; ataque")
        sair
      casose "1"
        p.criar(p.texto, "const tipoalvo = 1 # Alvo: 1 Exceto o personagem; ataque")
        sair
      casose "2"
        p.criar(p.texto, "const tipoalvo = 2 # Alvo: 2 Todos dividindo o ataque")
        sair
      casose "3"
        p.criar(p.texto, "const tipoalvo = 4 # Alvo: 4 Todos sem dividir o ataque")
        sair
      casose "4"
        p.criar(p.texto, "const tipoalvo = 6 # Alvo: 6 Qualquer um; não é ataque")
        sair
      casose "5"
        p.criar(p.texto, "const tipoalvo = 7 # Alvo: 7 O personagem; não é ataque")
        sair
      casose "6"
        p.criar(p.texto, "const tipoalvo = 8 # Alvo: 8 Ataque automático")
        sair
      casose "7"
        p.criar(p.texto, "const tipoalvo = 9 # Alvo: 9 Nenhum (não ataca)")
        sair
      casofim
    efim
  fimse
# Controle de banda
  se versao < 310
    criafunc("config", "const banda1 = 4000")
    criafunc("config", "const banda2 = 500")
    criafunc("config", "const nivelveterano = 10")
    criafunc("config", "const salvainiciante = 30")
    criafunc("config", "const salvaveterano = 60")
  fimse
# Retira mostraimortal e salvartipo, coloca mensagens de hora e nível
  se versao < 314
    p.apagar("config", "mostraimortal")
    p.apagar("config", "salvartipo")
    criafunc("config", "const horamsg5 = \"Começa a amanhecer.\"")
    criafunc("config", "const horamsg6 = \"O sol surge no leste.\"")
    criafunc("config", "const horamsg17 = \"O sol começa a se por no oeste.\"")
    criafunc("config", "const horamsg18 = \"A noite chega.\"")
    criafunc("config", "const nivelmsg1 = \"$P avança para o nível $m.\"")
    criafunc("config", "const nivelmsg2 = \"$1 avança para o nível $m.\"")
  fimse
# Diversos
  se versao < 318
    criafunc("config", "const atalhos = 50")
    criafunc("config", "const apresban = \"Seu endereço IP está bloqueado para novos personagens\"\
")
    criafunc("config", "const rezou1msg = \"(rezou) $R para $c '$m'\"")
    criafunc("config", "const rezou2msg = \"Os deuses responderam '$m'\"")
    criafunc("config", "const casajog = 3")
    criafunc("config", "const casanivel = 30")
    criafunc("config", "const casachave = 100")
    criafunc("config", "const casafechadura = 500")
  fimse
# Diversos
  se versao < 319
    criafunc("config", "const casaabriu1 = \"Você segura uma chave e abre a porta da sua \
casa.\"")
    criafunc("config", "const casaabriu2 = \"$P segura uma chave e abre a porta da casa del$v.\""\
)
  fimse
# Casas
  se versao < 321
    criafunc("config", "const casataxa = 5")
    criafunc("config", "const casatempotaxa = 30")
    criafunc("config", "const casatempoaviso = 5")
    criafunc("config", "const casatempobloq = 20")
    criafunc("config", "const casatempoperder = 180")
    criafunc("config", "const casamsgaviso = \"Há uma nota avisando que a taxa de manutenção da \
casa está atrasada.\"")
    criafunc("config", "const casamsgbloq = \"A porta foi lacrada por falta de pagamento.\"")
  fimse
# Echo, fórmula de experiência em batalha e sala fora da casa
  se versao < 324
    criafunc("config", "const jecho1msg = \"\b\cb$m\b\"")
    criafunc("config", "const jecho2msg = \"\bJEcho para $a '$m'\"")
    criafunc("config", "const sechomsg = \"\b\cb$m\b\"")
    criafunc("config", "const atkbexp = 8")
    criafunc("config", "const atkcexp = 8")
    criafunc("config", "const atkmaxexp = 100")
    criafunc("config", "const ptitulonivel = 10")
    criafunc("config", "const pdescnivel = 5")
    epara p.iniclasse("c_"), p.lin, p.depois
      dbg.ini
      p.apagar(p.texto, "sfora")
    efim
  fimse
# SVN 326
  se versao < 326
    criafunc("config", "const atknivel = 1")
  fimse
# SVN 334
  se versao < 334
    p.clfim("config/config", "config")
    epara p.iniclasse("e_"), p.lin, p.depois
      dbg.ini, p.texto != "e_apagar" && p.clfim("config/efeito", p.texto)
    efim
    epara p.iniclasse("cmd_"), p.lin, p.depois
      dbg.ini, [p.texto]:cmdmenu && p.clfim("config/hab", p.texto)
    efim
    epara p.iniclasse("magia_"), p.lin, p.depois
      dbg.ini, p.clfim("config/hab", p.texto)
    efim
    epara p.iniclasse("soc_"), p.lin, p.depois
      dbg.ini, p.clfim("config/social", p.texto)
    efim
    epara p.iniclasse("tipo_"), p.lin, p.depois
      dbg.ini, p.clfim("config/tipo", p.texto)
    efim
    epara p.iniclasse("a_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2), p.texto)
    efim
    epara p.iniclasse("b_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2), p.texto)
    efim
    epara p.iniclasse("c_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2, inttotal(p.texto) - 5), p.texto)
    efim
    epara p.iniclasse("i_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2, inttotal(p.texto) - 5), p.texto)
    efim
    epara p.iniclasse("p_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2, inttotal(p.texto) - 5), p.texto)
    efim
    epara p.iniclasse("s_"), p.lin, p.depois
      dbg.ini, p.clfim("areas/" + txt(p.texto, 2, inttotal(p.texto) - 5), p.texto)
    efim
  fimse
# Opções do comando Econfig
  se versao < 338
    criafunc("config", "const atkmtempo = 40")
    criafunc("config", "const gchatmsg = \"(gchat) $R '$m'\"")
    criafunc("config", "const gruponivel = 10")
    criafunc("config", "const ptitulomax = 30")
    criafunc("config", "const pdescmax = 1000")
    arqdir dir
    epara dir.abrir("sav1"), dir.lin, dir.depois
      continuar dir.texto == txts(dir.texto)
      dir.renomear("sav1/" + dir.texto, "sav1/" + txts(dir.texto))
    efim
    textotxt t
    textopos pos
    epara dir.abrir("sav2"), dir.lin, dir.depois
      continuar !t.ler("sav2/" + dir.texto)
      pos = t.ini
      continuar pos.txtproc("\nnomejog=cj ") < 0
      refvar num = intsub(pos.texto)
      continuar num <= 3
      txt512 lin
      lin = "nomejog=cj " + txts(txtsub(pos.texto, 1, num - 2))
      lin += " " + txtsub(pos.texto, num - 1)
      pos.remove(1)
      pos.add(lin)
      t.salvar("sav2/" + dir.texto)
      dbg.ini
    efim
  fimse
# Tipos (raças e classes)
  se versao < 341
    epara p.iniclasse("tipo_"), p.lin, p.depois
      se [p.texto]:menu == "raça"
        p.criar(p.texto, "const menu=1")
      senao [p.texto]:menu == "classe"
        p.criar(p.texto, "const menu=2")
      senao
        p.apagar(p.texto, "menu")
      fimse
      p.renomear(p.texto, "t_" + txt(p.texto, 5))
    efim
  fimse
# Renascer e comando COM
  se versao < 349
    criafunc("config", "const renascer = 2")
    se config:modoserv
      txt100 t1
      t1 = config:modoserv == 1 ? "telnet " : "papo "
      t1 += config:servender ? config:servender + " " : "* "
      criafunc("config", "const inicom1 = \"" + t1 + config:servporta + "\"")
    senao
      criafunc("config", "const inicom1 = \"\"")
    fimse
    se config:modobot && config:senha
      txt100 t1
      t1 = config:serv + " " + config:porta + " " + config:sala + " " + config:senha
      criafunc("config", "const inicom2 = \"bot " + t1 + "\"")
    senao
      criafunc("config", "const inicom2 = \"\"")
    fimse
    criafunc("config", "const inicom3 = \"\"")
    criafunc("config", "const inicom4 = \"\"")
    criafunc("config", "const inicom5 = \"\"")
    criafunc("config", "const inicom6 = \"\"")
    criafunc("config", "const inicom7 = \"\"")
    criafunc("config", "const inicom8 = \"\"")
    criafunc("config", "const inicom9 = \"\"")
    criafunc("config", "const inicom10 = \"\"")
    p.apagar("config", "modoserv")
    p.apagar("config", "modobot")
    p.apagar("config", "servender")
    p.apagar("config", "servporta")
    p.apagar("config", "serv")
    p.apagar("config", "porta")
    p.apagar("config", "sala")
    p.apagar("config", "senha")
  fimse
# Renascer e banido
  se versao < 362
    criafunc("config", "const exp_renascer = 100")
    criafunc("config", "const nivel_renascer = 0")
    criafunc("config", "const apresban2 = \"Seu endereço IP está bloqueado\"")
  fimse
# Bug e Ideia
  se versao < 371
    criafunc("config", "const bug1msg = \"(bug) $R '$m'\"")
    criafunc("config", "const bug2msg = \"Bug enviado '$m'\"")
    criafunc("config", "const bugtipo = 0")
    criafunc("config", "const bugnivel = 0")
    criafunc("config", "const l_bug = 0")
    criafunc("config", "const ideia1msg = \"(ideia) $R '$m'\"")
    criafunc("config", "const ideia2msg = \"Ideia enviada '$m'\"")
    criafunc("config", "const ideiatipo = 0")
    criafunc("config", "const ideianivel = 0")
    criafunc("config", "const l_ideia = 0")
  fimse
# Correção de recalc_auto para recalc1_auto e recalc2_auto
  se versao < 374
    epara p.iniclasse("p_"), p.lin, p.depois
      dbg.ini, movefunc(p.texto, "recalc_auto", p.texto, "recalc1_auto")
    efim
    epara p.iniclasse("i_"), p.lin, p.depois
      dbg.ini, movefunc(p.texto, "recalc_auto", p.texto, "recalc2_auto")
    efim
    epara p.iniclasse("e_"), p.lin, p.depois
      dbg.ini, movefunc(p.texto, "recalc_auto", p.texto, "recalc2_auto")
    efim
  fimse
# Permissões
  se versao < 383
    se !p.existe("perm_admin")
      p.criar("perm_admin\nconfig/perm\nherda comum_perm_admin")
    fimse
    se !p.existe("perm_autorizar")
      p.criar(perm_autorizar)
    fimse
    se !p.existe("perm_jog")
      p.criar("perm_jog\nconfig/perm\nherda comum_perm")
    fimse
  fimse
# Canal Schat
  se versao < 401
    criafunc("config", "const schatmsg = \"(chat) $m\"")
  fimse
# Tipos de arma Arco e flecha e Revolver
  se versao < 413
    txt512 lin
    lin = txtsublin(config:arma_txt, 0, 6) + "\nArco e flecha\n"
    lin += txtsublin(config:arma_txt, 7, 1) + "\nRevolver\n"
    lin += txtsublin(config:arma_txt, 9)
    se txtfim(lin, 1) == "\n"
      lin = txt(lin, 0, inttotal(lin) - 1)
    fimse
    p.criar("config", "const arma_txt = \"" + txtvis(lin) + "\"")
  fimse
# Ataque, casas e menu Herda do comando Econfig
  se versao < 417
    epara p.iniherdainv("comando_ataque"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "ataque") != 1
      refvar atk = [p.texto]:ataque
      p.criar(p.texto, "const ataquemin = " + int(atk * 0.5))
      p.criar(p.texto, "const ataquemax = " + int(atk * 1.5))
      p.apagar(p.texto, "ataque")
    efim
    epara p.iniherdainv("casa"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "c_salas") == 1
      refvar c = $[p.texto]
      txt512 lin
      c.s1 && (lin += "\n" + txt(c.s1, 2)), c.s2 && (lin += "\n" + txt(c.s2, 2))
      c.s3 && (lin += "\n" + txt(c.s3, 2)), c.s4 && (lin += "\n" + txt(c.s4, 2))
      c.s5 && (lin += "\n" + txt(c.s5, 2)), c.s6 && (lin += "\n" + txt(c.s6, 2))
      c.s7 && (lin += "\n" + txt(c.s7, 2)), c.s8 && (lin += "\n" + txt(c.s8, 2))
      c.s9 && (lin += "\n" + txt(c.s9, 2))
      lin = txt(lin, 1)
      se lin
        p.criar(p.texto, "const c_salas = \"" + txtvis(lin) + "\"")
        p.apagar(p.texto, "s1"), p.apagar(p.texto, "s2"), p.apagar(p.texto, "s3")
        p.apagar(p.texto, "s4"), p.apagar(p.texto, "s5"), p.apagar(p.texto, "s6")
        p.apagar(p.texto, "s7"), p.apagar(p.texto, "s8"), p.apagar(p.texto, "s9")
      fimse
      p.apagar(p.texto, "mudou")
      c.acerta_funcoes(lin)
    efim
    epara p.iniherdainv("comum_item"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "armaprecisao") != 1
      se [p.texto]:armaprecisao != 100
        p.criar(p.texto, "const armafalha = " + (100 - [p.texto]:armaprecisao))
      fimse
      p.apagar(p.texto, "armaprecisao")
    efim
    epara p.iniherdainv("comando_hab"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "precisao") != 1
      se [p.texto]:precisao != 100
        p.criar(p.texto, "const falha = " + (100 - [p.texto]:precisao))
      fimse
      p.apagar(p.texto, "precisao")
    efim
    criafunc("config", "const s_objmax = 100")
    criafunc("config", "const i_objmax = 100")
    criafunc("config", "const p_objmax = 100")
    criafunc("config", "const s_volmax = 1000000")
    criafunc("config", "const i_volmax = 1000000")
    criafunc("config", "const p_volmax = 1000000")
    criafunc("config", "const s_recup = 100")
    criafunc("config", "const s_pnj = 10")
    criafunc("config", "const s_jog = 100")
    criafunc("config", "const s_som = \"sala\"")
    criafunc("config", "const s_atk_move = 1")
    criafunc("config", "const p_corpo = 0")
    criafunc("config", "const p_exp = 100")
    criafunc("config", "const p_morreu1 = \"$P morreu.\"")
    criafunc("config", "const p_morreu2 = \"$P desmaiou.\"")
    criafunc("config", "const p_movervel = 140")
    criafunc("config", "const p_perseguevel = 20")
    criafunc("config", "const a_ataquemin = 25")
    criafunc("config", "const a_ataquemax = 75")
    criafunc("config", "const a_fatormin = 270")
    criafunc("config", "const a_fatormax = 330")
    criafunc("config", "const a_vel = 50")
  fimse
# Tempo para salvar jogo de admin
  se versao < 421
    p.apagar("config", "salvaadmin")
    uint16 tempo = config:salvaadmin ?? 120
    criafunc("perm_admin", "const salvardias = " + tempo)
  fimse
# Tipos de produtos
  se versao < 422
    criafunc("config", "const item_container = 2048")
    criafunc("config", "const item_arma = 2")
    criafunc("config", "const item_luz = 256")
    criafunc("config", "const item_vestimenta = 8")
    criafunc("config", "const item_bebida = 1024")
    criafunc("config", "const item_comida = 8192")
    criafunc("config", "const item_pergaminho = 64")
    criafunc("config", "const item_chave = 0")
  fimse
# Mensagens do canal AC
  se versao < 425
    criafunc("config", "const acmsg = \"(ac) $R: $m\"")
  fimse
# Experiência máxima e opção "Tempo lembra" dos personagens
  se versao < 430
    criafunc("config", "const expmax0 = 20")
    criafunc("config", "const expmax1 = 0")
    criafunc("config", "const expmax2 = 1")
    criafunc("config", "const p_lembra = 0")
    criafunc("config", "const atkexp0 = " + config:atkexp * 6)
    criafunc("config", "const atkexp1 = " + config:atkexp)
    p.apagar("config", "atkexp")
  fimse

func ini3_exec
  ini4 = 1
# Checa e muda a versão
  ret (versao = config:versao) >= 453, nulo
  p.criar("config", "const versao = 453 # Para atualizar arquivos mud/config/* e mud/areas/*")
  config:salvar
# Espera em ataques manuais, mensagens dos ataques
  se versao < 434
    criafunc("config", "const atkespera = 8")
    movefunc("config", "itens", "config", "p_objlimite")
    int8 y
    epara p.iniherdainv("comando_ataque"), p.lin, p.depois
      dbg.ini
      int8 x
      enquanto x < 5
        refvar linhas = [p.texto]:msgatk[x]
        p.apagar(p.texto, "msgatk" + x)
        x++
        continuar !linhas
        txt512 cod = linhas_atk
        epara y = 0, cod, y++
          refvar lin = txtsublin(linhas, y, 1)
          lin && criafunc(p.texto, "const atk" + x + txt1(cod) + "=\"" + txtvis(lin) + "\"")
          cod = txt2(cod)
        efim
      efim
    efim
  fimse
# Linhas de PDesc, mensagens de Capturar, mensagens entrando no MUD
  se versao < 438
    criafunc("config", "const pdesclinhas = 8")
    criafunc("config", "const capturar_nao = \"$P joga $o para $a, mas $a recusa.\"")
    criafunc("config", "const capturar_sim = \"$P joga $o para $a.\"")
    criafunc("config", "const capturar_equipe = \"$A entrou para a sua equipe.\"")
    criafunc("config", "const capturar_reserva = \"$A entrou para a sua equipe como reserva.\"")
    criafunc("config", "const capturar_outros = \"$A entrou para a equipe de $P.\"")
    criafunc("config", "const entrou_msgadm = \"*. Entrou: $P, $C, N$N, $$$M\"")
    criafunc("config", "const entrou_msgjog = \"*. $P entrou\"")
    criafunc("config", "const saiu_msgadm = \"*. Saiu: $P, $C\"")
    criafunc("config", "const saiu_msgjog = \"*. $P saiu\"")
    criafunc("config", "const criar_msgadm = \"*. Criando personagem: $P, $C\"")
    criafunc("config", "const naocriar_msgadm = \"*. Desistiu de criar: $P, $C\"")
    criafunc("config", "const criou_msgadm = \"*. Criou personagem: $P, $C\"")
    criafunc("config", "const criou_msgjog = \"*. $P entrou\"")
    criafunc("config", "const promptmsg = \"<%c3%hhp %c2%mmn %c6%vmv%b>\"")
    criafunc("config", "const bpromptmsg = \"<%c3%hhp %c2%mmn %c6%vmv%b>\"")
  fimse
# Constantes usadas ao vestir
  se versao < 451
    dbg.ini
    int8 cont
    epara cont = 0, cont < 30, cont++
      c_hex("config", "vestir" + cont)
    efim
    epara p.iniherdainv("comum_item"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "vestir1")
    efim
    epara p.iniherdainv("comum_perso"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "equip1")
      c_hex(p.texto, "equip2")
      c_hex(p.texto, "equip3")
    efim
    epara p.iniherdainv("comum_tipo"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "equip1")
      c_hex(p.texto, "equip2")
      c_hex(p.texto, "equip3")
    efim
  fimse
# sons
  se versao < 453
    arqtxt arq
    arq.abrir("sav2/som.txt", 0)
    enquanto !arq.eof
      dbg.ini
      refvar info = arq.ler
      txt512 lin = "som_" + txtsub(info, 1, 1) + "\nconfig/som\nherda comum_som\n"
      se txt1(info) == "e"
        lin += "const tipo = 0\n"
      senao txt1(info) == "i"
        lin += "const tipo = 1\n"
      senao txt1(info) == "m"
        lin += "const tipo = 2\n"
      senao
        continuar
      fimse
      lin += "const arquivo = \"" + txtvis(txtsub(info, 2, 1)) + "\"\n"
      txtsub(info, 3, 1) != "100" && (lin += "const volume = " + txtsub(info, 3, 1) + "\n")
      txtsub(info, 4, 1) != "1" && (lin += "const repete = " + txtsub(info, 4, 1) + "\n")
      p.criar(lin)
    efim
  fimse

func ini4_exec
  apagar(este)
# Checa e muda a versão
  ret (versao = config:versao) >= 601, nulo
  p.criar("config", "const versao = 601 # Para atualizar diretórios areas e config")
  config:salvar
# Comando Fim e Dicas aleatórias
  se versao < 457
    criafunc("config", "const fimmsg = \"Até mais. Aguardamos o seu retorno.\"")
    se !existe("config_dicas")
      p.criar("config_dicas\nconfig/config\nconst tempo=30\nconst texto=\"\"")
    fimse
  fimse
# Atualiza sons
  se versao < 460
    epara p.iniclasse("som_"), p.lin, p.depois
      dbg.ini
      [p.texto]:iniclasse(p.texto)
      p.apagar(p.texto, "som")
    efim
  fimse
# Opções dos menus
  se versao < 482
    dbg.ini
    movefunc("config", "falarmsg", "cmd_falar", "m_falar2")
    movefunc("config", "perguntarmsg", "cmd_falar", "m_perguntar2")
    movefunc("config", "exclamarmsg", "cmd_falar", "m_exclamar2")
    movefunc("config", "ponderarmsg", "cmd_falar", "m_ponderar2")
    movefunc("config", "continuarmsg", "cmd_falar", "m_continuar2")
    movefunc("config", "fimmsg", "cmd_fim", "m_fim")
    movefunc("config", "atalhos", "cmd_atalho", "v_maximo")
    movefunc("config", "gritarnivel", "cmd_gritar", "v_nivel")
    movefunc("config", "gritarmove", "cmd_gritar", "v_move")
    movefunc("config", "gritarmsg", "cmd_gritar", "m_gritar2")
    movefunc("config", "gritartipo", "cmd_gritar", "v_tipo")
    dbg.ini
    movefunc("config", "sussurrar1msg", "cmd_sussurrar", "m_msg1")
    movefunc("config", "sussurrar2msg", "cmd_sussurrar", "m_msg2")
    movefunc("config", "sussurrar3msg", "cmd_sussurrar", "m_msg3")
    movefunc("config", "telepatia1", "cmd_telepatia", "m_enviou")
    movefunc("config", "telepatia2", "cmd_telepatia", "m_recebeu")
    movefunc("config", "bugtipo", "cmd_bug", "v_tipo")
    movefunc("config", "bugnivel", "cmd_bug", "v_nivel")
    movefunc("config", "bug1msg", "cmd_bug", "m_canal")
    movefunc("config", "bug2msg", "cmd_bug", "m_enviou")
    movefunc("config", "ideiatipo", "cmd_ideia", "v_tipo")
    movefunc("config", "ideianivel", "cmd_ideia", "v_nivel")
    movefunc("config", "ideia1msg", "cmd_ideia", "m_canal")
    movefunc("config", "ideia2msg", "cmd_ideia", "m_enviou")
    dbg.ini
    movefunc("config", "emocaotipo", "cmd_emocao", "v_tipo")
    movefunc("config", "emocaonivel", "cmd_emocao", "v_nivel")
    movefunc("config", "ptitulonivel", "cmd_ptitulo", "v_nivel")
    movefunc("config", "ptitulomax", "cmd_ptitulo", "v_tamanho")
    p.apagar("config", "pdescnivel")
    p.apagar("config", "pdesclinhas")
    p.apagar("config", "pdescmax")
    movefunc("config", "olharnivel", "cmd_olhar", "v_olharnivel", 1)
    movefunc("config", "olhartipo", "cmd_olhar", "v_olhartipo", 1)
    movefunc("config", "olharvolume", "cmd_olhar", "v_olharvolume", 1)
    movefunc("config", "olharnivel", "cmd_ver", "v_olharnivel")
    movefunc("config", "olhartipo", "cmd_ver", "v_olhartipo")
    movefunc("config", "olharvolume", "cmd_ver", "v_olharvolume")
    dbg.ini
    movefunc("config", "chattipo", "cmd_schat", "v_tipo", 1)
    movefunc("config", "chatnivel", "cmd_schat", "v_nivel", 1)
    movefunc("config", "novatostipo", "cmd_novatos", "v_tipo")
    movefunc("config", "novatosnivel", "cmd_novatos", "v_nivel")
    movefunc("config", "novatosmsg", "cmd_novatos", "m_msg1", 1)
    movefunc("config", "novatosmsg", "cmd_novatos", "m_msg2")
    movefunc("config", "chattipo", "cmd_chat", "v_tipo")
    movefunc("config", "chatnivel", "cmd_chat", "v_nivel")
    movefunc("config", "chatmsg", "cmd_chat", "m_msg1", 1)
    movefunc("config", "chatmsg", "cmd_chat", "m_msg2")
    p.apagar("config", "schattipo")
    movefunc("config", "schatmsg", "cmd_schat", m_msg1, 1)
    movefunc("config", "schatmsg", "cmd_schat", m_msg2, 1)
    movefunc("config", "schatmsg", "cmd_schat", m_msg3)
    dbg.ini
    movefunc("config", "capturar", "cmd_capturar", "v_reserva")
    movefunc("config", "capturar_nao", "cmd_capturar", "capturar_nao1", 1)
    movefunc("config", "capturar_nao", "cmd_capturar", "capturar_nao2")
    movefunc("config", "capturar_sim", "cmd_capturar", "capturar_sim1", 1)
    movefunc("config", "capturar_sim", "cmd_capturar", "capturar_sim2")
    movefunc("config", "capturar_equipe", "cmd_capturar", "capturar_equipe1")
    movefunc("config", "capturar_reserva", "cmd_capturar", "capturar_reserva1")
    movefunc("config", "capturar_outros", "cmd_capturar", "capturar_equipe2", 1)
    movefunc("config", "capturar_outros", "cmd_capturar", "capturar_reserva2")
  fimse
  se versao < 484
    dbg.ini
    movefunc("config", "gruponivel", "cmd_grupo", "v_nivel")
    movefunc("config", "matartipo", "cmd_matar", "v_tipo")
    movefunc("config", "gchatmsg", "cmd_gchat", "m_enviou1", 1)
    movefunc("config", "gchatmsg", "cmd_gchat", "m_enviou2")
    epara p.iniherdainv("comum_item"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "luzliga") != 1
      movefunc(p.texto, "lugzliga", p.texto, "luzliga1", 1)
      movefunc(p.texto, "lugzliga", p.texto, "luzliga2")
    efim
    epara p.iniherdainv("comando_ataque"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "falha") != 1
      int16 valor = [p.texto]:falha
      p.apagar(p.texto, "falha")
      se valor < 0
        p.criar(p.texto, "const atkfalha = 0")
      senao valor > 0
        p.criar(p.texto, "const falha1 = " + valor)
        p.criar(p.texto, "const falha2 = " + valor)
      fimse
    efim
  fimse
# Condição batalha das habilidades e magias
  se versao < 502
    epara p.iniherdainv("comando_hab"), p.lin, p.depois
      dbg.ini
      continuar p.existe(p.texto, "a_batalha") != 1
      se [p.texto]:a_batalha == 1 # Durante a batalha
        p.criar(p.texto, "const a_montado = 0")
        p.criar(p.texto, "const a_em_pe = 0")
      senao [p.texto]:a_batalha == 2 # Fora da batalha
        p.criar(p.texto, "const a_bat_sentado = 0")
        p.criar(p.texto, "const a_bat_montado = 0")
        p.criar(p.texto, "const a_bat_em_pe = 0")
      fimse
      p.apagar(p.texto, "a_batalha")
    efim
  fimse
# Tipo de ataque: todos do grupo
  se versao < 509
    epara p.iniherdainv("comando_ataque"), p.lin, p.depois
      dbg.ini
      uint8 tipo = 1 + [p.texto]:tipoalvo
      continuar tipo < 9 || p.existe(p.texto, "tipoalvo") != 1
      p.criar(p.texto, "const tipoalvo = " + tipo)
    efim
  fimse
  se versao < 510
    p.apagar("config", "fomemsg")
  fimse
# Magias no arquivo config/magia.int
  se versao < 516
    txt100 lin
    epara p.iniclasse("magia_"), p.lin, p.depois
      dbg.ini
      lin ? p.cldepois(lin, p.texto) : p.clini("config/magia", p.texto)
      lin = p.texto
    efim
  fimse
# Mensagens de nível
  se versao < 522
    movefunc("config", "nivelmsg1", "perso_cfg", "exp_nivelmsg1")
    movefunc("config", "nivelmsg2", "perso_cfg", "exp_nivelmsg2")
    movefunc("config", "nmaxmsg", "perso_cfg", "exp_nmax")
  fimse
# Mensagem da posição padrão
  se versao < 534
    epara p.iniherdainv("comum_perso"), p.lin, p.depois
      dbg.ini
      continuar ![p.texto]:descpadr
      casovar [p.texto]:pospadr
      casose "4"
        movefunc(p.texto, "descpadr", p.texto, "descsala4c")
        sair
      casose "5"
        movefunc(p.texto, "descpadr", p.texto, "descsala5c")
        sair
      casose "6"
        movefunc(p.texto, "descpadr", p.texto, "descsala6c")
        sair
      casose "8"
        movefunc(p.texto, "descpadr", p.texto, "descsala8")
        sair
      casose
        movefunc(p.texto, "descpadr", p.texto, "descsalaN")
        sair
      casofim
    efim
  fimse
# Tipos de produtos
  se versao < 544
    dbg.ini
    movefunc("config", "produtos", "config", "item_tipos")
    c_hex("config", "item_container")
    c_hex("config", "item_arma")
    c_hex("config", "item_luz")
    c_hex("config", "item_vestimenta")
    c_hex("config", "item_bebida")
    c_hex("config", "item_comida")
    c_hex("config", "item_pergaminho")
    c_hex("config", "item_chave")
    c_hex("config", "s_doarsim")
    c_hex("config", "s_doarnao")
    epara p.iniherdainv("comum_persoitem"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "tipoitem")
    efim
    epara p.iniherdainv("area"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "s_doarsim")
      c_hex(p.texto, "s_doarnao")
    efim
    epara p.iniherdainv("sala"), p.lin, p.depois
      dbg.ini
      c_hex(p.texto, "s_doarsim")
      c_hex(p.texto, "s_doarnao")
    efim
  fimse
# Atalhos de comandos
  se versao < 562
    dbg.ini
    criaatalho("cmd_tomar", "cmd_beber")
    criaatalho("cmd_usar", "cmd_vestir")
    criaatalho("cmd_e", "cmd_l")
    criaatalho("cmd_w", "cmd_o")
    criaatalho("cmd_nw", "cmd_no")
    criaatalho("cmd_sw", "cmd_so")
    criaatalho("cmd_cima", "cmd_c")
    criaatalho("cmd_baixo", "cmd_b")
    criaatalho("cmd_u", "cmd_c")
    criaatalho("cmd_d", "cmd_b")
    movefunc("config", "rezartipo", "cmd_rezar", "v_tipo")
    movefunc("config", "rezarnivel", "cmd_rezar", "v_nivel")
    movefunc("config", "rezar1msg", "cmd_rezar", "m_rezar1")
    movefunc("config", "rezar2msg", "cmd_rezar", "m_rezar2")
  fimse
# Mensagens do comando lançar
  se versao < 564
    dbg.ini
    movefunc("comando_hab_cfg", "m_magia_sem", "cmd_lançar", "m_magia_sem")
    movefunc("comando_hab_cfg", "m_magia_nao", "cmd_lançar", "m_magia_nao")
  fimse
# Atalho Quit
  se versao < 565
    p.criar("cmd_quit\nconfig/cmd\nherda comando_atalho\nconst comando=\"cmd_fim\"")
  fimse
# Opção "Soltar itens" das salas
  se versao < 566
    epara p.iniherdainv("sala"), p.lin, p.depois
      dbg.ini
      continuar !p.existe(p.texto, "s_soltar")
      p.apagar(p.texto, "s_soltar")
      casovar [p.texto]:s_soltar
      casose "1"
        p.criar(p.texto, "const s_soltartipo = 1")
        sair
      casose "2"
        p.criar(p.texto, "const s_soltartipo = 2")
        p.criar(p.texto, "const s_soltarmsg1 = \"Você solta $o, que afunda em seguida.\"")
        p.criar(p.texto, "const s_soltarmsg2 = \"$P solta $o, que afunda em seguida.\"")
        sair
      casose "3"
        p.criar(p.texto, "const s_soltartipo = 2")
        p.criar(p.texto, "const s_soltarmsg1 = \"Você solta $o, que cai e some da sua vista.\"")
        p.criar(p.texto, "const s_soltarmsg2 = \"$P solta $o, que cai e some da sua vista.\"")
        sair
      casose "4"
        p.criar(p.texto, "const s_soltartipo = 2")
        p.criar(p.texto, "const s_soltarmsg1 = \"Você solta $o, que se desintegra em seguida.\"")
        p.criar(p.texto, "const s_soltarmsg2 = \"$P solta $o, que se desintegra em seguida.\"")
      casofim
    efim
  fimse
# Constantes novas de ataques
  se versao < 577
    dbg.ini
    epara p.iniherdainv("comando_ataque"), p.lin, p.depois
      dbg.ini
      [p.texto]:ataque2 && p.criar(p.texto, "const ataque2perso = 0")
    efim
  fimse
# Sexo e descrição dos personagens
  se versao < 581
    epara p.iniherdainv("comum_perso"), p.lin, p.depois
      dbg.ini
      continuar txt(p.texto, 0, 2) != "p_"
      se p.existe(p.texto, "sexoini") == 1
      senao p.existe(p.texto, "msexo") != 1
        p.criar(p.texto, "const sexoini = 0")
      senao p.varnum(p.texto, "msexo")
        p.apagar(p.texto, "msexo")
        p.criar(p.texto, "const sexoini = " + [p.texto]:msexo)
      senao
        movefunc(p.texto, "msexo", p.texto, "sexoini")
      fimse
      casovar [p.texto]:descdono
      casose "0"
        p.criar(p.texto, "const descdono1 = \"$q\"")
        p.criar(p.texto, "const descdono2 = \"$q\"")
        sair
      casose "1"
        p.criar(p.texto, "const descdono1 = \"$p\"")
        p.criar(p.texto, "const descdono2 = \"$p\"")
        sair
      casofim
      p.apagar(p.texto, "descdono")
    efim
  fimse
# Mensagens quando personagem morreu e se deixa corpo
  se versao < 601
    movefunc("config", "p_exp", "perso_cfg", "p_exp")
    movefunc("config", "p_morreu0", "perso_cfg", "p_morreu0")
    movefunc("config", "p_morreu1", "perso_cfg", "p_morreu1")
    movefunc("config", "p_morreu2", "perso_cfg", "p_morreu2")
    movefunc("config", "p_corpo", "perso_cfg", "p_corpo_tipo")
    criafunc("config", "const item_descsala = \"$P está aqui.\"")
    epara p.iniherdainv("comum_perso"), p.lin, p.depois
      dbg.ini
      continuar txt(p.texto, 0, 2) != "p_"
      movefunc(p.texto, "p_corpo", p.texto, "p_corpo_tipo")
    efim
    epara p.iniherdainv("comum_tipo"), p.lin, p.depois
      dbg.ini
      movefunc(p.texto, "morreu0", p.texto, "p_morreu0")
      movefunc(p.texto, "morreu1", p.texto, "p_morreu1")
      movefunc(p.texto, "morreu2", p.texto, "p_morreu2")
    efim
    epara p.iniherdainv("comum_item"), p.lin, p.depois
      dbg.ini
      continuar txt(p.texto, 0, 2) != "i_" || p.existe(p.texto, "descpos") != 1
      movefunc(p.texto, "descpos", p.texto, "descsala")
    efim
  fimse
# Avisa que atualizou arquivos
  tela.msg("Diretórios areas e config atualizados\n")

func criaatalho # arg0 = classe do atalho, arg1 = classe do comando
  ret p.existe(arg0), nulo
  p.criar(arg0 + "\nconfig/cmd\nherda comando_atalho\nconst comando=\"" + arg1 + "\"")

const perm_autorizar = "perm_autorizar\n\
config/perm\n\
herda comum_perm\n\
const nomequem = \"[Não autorizado]\"\n\
const saiumsg = \"Seu personagem foi aprovado\"\n\
const c_salvar = \"Seu personagem ainda não foi autorizado\"\n\
const salvar = 0"
#
const linhas_atk = "_usar1 _usar2 _usar3 _auto1 _auto2 _perso1 _perso2 _perso3 _matou1 _matou2 \
_matou3 _errou1 _errou2 _errou3 _nulo1 _nulo2 _nulo3 _esquivou1 _esquivou2 _esquivou3"
#
# Converte constante do tipo const a=10 para texto em hexadecimal como const a="a"
const c_hex = p.varnum(arg0, arg1) ? p.criar(arg0, "const " + arg1 + " = \"" + ("0" | txtconv([ar\
g0]:[arg1], "dh")) + "\"")
