classe opc_atribcomum
herda comando_adm
# Funções para mudar atributos de personagens e itens
#
real2 atribnum.24 # Atributos numéricos
real2 atribobj.8 # Atributos de itens
int8 atribbit.20 # Atributos de bit
real2 atribatk.32 # Ataques
real2 atribdef.32 # Defesas
#
const p_atrib_num = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Acerto de dano crítico (porcent)\n\
Bônus de dano crítico (porcent)\n\
Carrega (gramas)\n\
Carrega (gramas) por nível"
#
const p_atrib_obj = "Falha arma\n\
Falha arma por nível\n\
Precisão perso\n\
Precisão perso por nível\n\
Ataque mín\n\
Ataque mín por nível\n\
Ataque máx\n\
Ataque máx por nível"
#
const p_atrib_bit = "Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Pode ver voando\n\
Não pode ver voando\n\
Pode ver voando alto\n\
Não pode ver voando alto\n\
Está cego\n\
Torna invisível\n\
Torna oculto\n\
Invisível a não admin\n\
Visível no escuro\n\
Anda em silêncio\n\
Percebe andar em silêncio\n\
Está flutuando\n\
Está voando\n\
Está voando alto\n\
Está dormindo\n\
Imune a dormir"
#
const p_atrib_atk = "Tipos Físicos\nTipos Especiais\n" + config:atknomes

func atrib_dec # Decodifica: extrai números de um texto
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  txt100 lin = txttroca(arg0, "(", " ")
  se txtsub(lin, 3, 3) == "* pnivel -"
    arg2 = txtsub(lin, 2, 1)
    arg1 = -1 * txtsub(lin, 6)
  senao txtsub(lin, 3, 2) == "* pnivel"
    arg2 = txtsub(lin, 2, 1)
    arg1 = txtsub(lin, 6)
  senao
    arg1 = txtsub(lin, 2)
  fimse

func atrib_cod1 # Codifica: monta texto do tipo "a+=5*arg0" a partir de números
# arg0 = nome da variável
# arg1 = valor da variável pura
# arg2 = valor da variável multiplicada por pnivel
# arg3 = falso (0) se sem a eficiência, como "a+=5"
# arg3 = verdadeiro (1) se com a eficiência, como "a+=5*arg0"
  refvar ini = arg0 + " += "
  se !arg3
    ret !arg2, ini + txt(arg1) # Exemplo: a+=5
    ret !arg1, ini + txt(arg2) + "*pnivel" # Exemplo: a+=10*pnivel
    ret arg1 < 0, ini + txt(arg2) + "*pnivel" + txt(arg1) # Exemplo: a=10+pnivel-5
    ret ini + txt(arg2) + "*pnivel+" + txt(arg1)
  fimse
  ret !arg2, ini + txt(arg1) + "*arg0" # Exemplo: a+=5*arg0
  ret !arg1, ini + txt(arg2) + "*pnivel*arg0" # Exemplo: a+=10*pnivel*arg0
  ret arg1 < 0, ini + "(" + txt(arg2) + "*pnivel" + txt(arg1) + ")*arg0"
# Exemplo: a+=(10*pnivel-5)*arg0
  ret ini + "(" + txt(arg2) + "*pnivel+" + txt(arg1) + ")*arg0"
# Exemplo: a=(10*pnivel+5)*arg0

func atrib_cod2 # Codifica: monta texto do tipo "a=5" a partir de números
# arg0 = nome da variável
# arg1 = valor da variável pura
# arg2 = valor da variável multiplicada por pnivel
  ret !arg2, arg0 + "=" + txt(arg1) # Exemplo: a=5
  ret !arg1, arg0 + "=" + txt(arg2) + "*pnivel" # Exemplo: a=10*pnivel
  ret arg1 < 0, arg0 + "=" + txt(arg2) + "*pnivel" + txt(arg1) # Exemplo: a=10*pnivel-5
  ret arg0 + "=" + txt(arg2) + "*pnivel+" + arg1 # Exemplo: a=10*pnivel+5

func atrib_muldec # Decodifica: extrai um número de atributo de multiplicação
# arg0 = texto do tipo "atktipo.1 *= 0.3" ou "atktipo.1 *= -0.7 * arg0 + 1
  ret txtsub(arg0, 2, 1) == "0", 0
  ret txtsub(arg0, 2, 1) == "intmax(0.01,", 100 * txtsub(arg0, 3) + 100
  ret 100 * txtsub(arg0, 2)

func atrib_mulcod # Codifica: monta texto do tipo "a*=intmax(0.01,10*arg0+1)"
# arg0 = nome da variável
# arg1 = valor da variável, sendo que 100 é não alterar
# arg2 = falso (0) se sem a eficiência, como "a*=1.5"
# arg2 = verdadeiro (1) se com a eficiência, como "a*=intmax(0.01, 0.5*arg0+1)"
  ret arg1 <= 0, arg0 + " = 0"
  ret !arg2, arg0 + " *= " + arg1 / 100
  ret arg0 + " *= intmax(0.01, " + (arg1 / 100 - 1) + " * arg0 + 1)"

func atrib_ler # Extrai os atributos de uma função para variáveis atrib
# arg0 = nome da classe
# arg1 = nome da função
  int32 x
  atribnum.limpar
  atribobj.limpar
  atribbit.limpar
  atribatk.limpar(100)
  atribdef.limpar(100)
  prog p
  epara p.inilinha(arg0, arg1), p.lin, p.depois
    casovar txt1(p.texto)
    casose "pvidamax"
      atrib_dec(p.texto, atribnum.0, atribnum.1)
      sair
    casose "pmanamax"
      atrib_dec(p.texto, atribnum.2, atribnum.3)
      sair
    casose "pmovemax"
      atrib_dec(p.texto, atribnum.4, atribnum.5)
      sair
    casose "pveloc1"
      atrib_dec(p.texto, atribnum.6, atribnum.7)
      sair
    casose "atknorm"
      atrib_dec(p.texto, atribnum.8, atribnum.9)
      sair
    casose "defnorm"
      atrib_dec(p.texto, atribnum.10, atribnum.11)
      sair
    casose "atkesp"
      atrib_dec(p.texto, atribnum.12, atribnum.13)
      sair
    casose "defesp"
      atrib_dec(p.texto, atribnum.14, atribnum.15)
      sair
    casose "evasao"
      atrib_dec(p.texto, atribnum.16, atribnum.17)
      sair
    casose "precisao"
      atrib_dec(p.texto, atribnum.18, atribnum.19)
      sair
    casose "pcriticoacerto"
      atrib_dec(p.texto, atribnum.20, nulo)
      sair
    casose "pcriticoatk"
      atrib_dec(p.texto, atribnum.21, nulo)
      sair
    casose "pesomax"
      atrib_dec(p.texto, atribnum.22, atribnum.23)
      sair
    casose "var.z_armafalha_"
      atrib_dec(p.texto, atribobj.0, atribobj.1)
      sair
    casose "var.z_armaaddprecisao_"
      atrib_dec(p.texto, atribobj.2, atribobj.3)
      sair
    casose "var.z_armamin_"
      atrib_dec(p.texto, atribobj.4, atribobj.5)
      sair
    casose "var.z_armamax_"
      atrib_dec(p.texto, atribobj.6, atribobj.7)
      sair
    casose "bitver"
      refvar abit = atribbit
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        x = txt(txtsub(p.texto, 2), 1)
        (x & 1) && (abit.7 = 1) # Está cego
        (x & 16) && (abit.4 = 1) # Não pode ver voando
        (x & 32) && (abit.6 = 1) # Não pode ver voando alto
      senao
        x = txtsub(p.texto, 2)
        (x & 2) && (abit.0 = 1) # Visão noturna
        (x & 4) && (abit.1 = 1) # Pode ver invisível
        (x & 8) && (abit.2 = 1) # Pode ver oculto
        (x & 16) && (abit.3 = 1) # Pode ver voando
        (x & 32) && (abit.5 = 1) # Pode ver voando alto
        (x & 0x100) && (abit.12 = 1) # Anda em silêncio
        (x & 0x1000) && (abit.13 = 1) # Percebe quem anda em silêncio
        (x & 0x200) && (abit.14 = 1) # Voando ou flutuando
        (x & 0x400) && (abit.17 = 1) # Dormindo
        (x & 0x800) && (abit.18 = 1) # Imune a dormir
      fimse
      sair
    casose "bitinv"
      refvar abit = atribbit
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        abit.11 = 1 # Visível no escuro
      senao
        x = txtsub(p.texto, 2)
        (x & 4) && (abit.8 = 1) # Torna invisível
        (x & 8) && (abit.9 = 1) # Torna oculto
        (x & 16) && (abit.15 = 1) # Voando
        (x & 32) && (abit.16 = 1) # Voando alto
        (x & 128) && (abit.10 = 1) # Invisível a não admin
      fimse
      sair
    casose
      sair txtsub(p.texto, 1, 1) != "*=" && txtsub(p.texto, 1, 1) != "="
      se txt(p.texto, 0, 8) == "atktipo."
        atribatk.[int(txt(p.texto, 8))] = atrib_muldec(p.texto)
      senao txt(p.texto, 0, 8) == "deftipo."
        atribdef.[int(txt(p.texto, 8))] = atrib_muldec(p.texto)
      fimse
    casofim
  efim

func atrib_cod_ini # Gera código da função para inicializar atributos do personagem
# O código é gerado a partir das variáveis atrib
# arg0 = nome da função
  textotxt t
  t.addfim("func " + arg0 + " # Altera atributos do personagem")
  t.addfim("# Função criada automaticamente")
  t.addfim(atrib_cod2("pvidamax", atribnum.0, atribnum.1))
  t.addfim(atrib_cod2("pmanamax", atribnum.2, atribnum.3))
  t.addfim(atrib_cod2("pmovemax", atribnum.4, atribnum.5))
  t.addfim(atrib_cod2("pveloc1", atribnum.6, atribnum.7))
  t.addfim(atrib_cod2("atknorm", atribnum.8, atribnum.9))
  t.addfim(atrib_cod2("defnorm", atribnum.10, atribnum.11))
  t.addfim(atrib_cod2("atkesp", atribnum.12, atribnum.13))
  t.addfim(atrib_cod2("defesp", atribnum.14, atribnum.15))
  t.addfim(atrib_cod2("evasao", atribnum.16, atribnum.17))
  t.addfim(atrib_cod2("precisao", atribnum.18, atribnum.19))
  t.addfim(atrib_cod2("pcriticoacerto", atribnum.20, 0))
  t.addfim(atrib_cod2("pcriticoatk", atribnum.21, 0))
  t.addfim(atrib_cod2("pesomax", atribnum.22, atribnum.23))
  ret t.remove(1000)

func atrib_cod_mudar # Gera código da função para mudar atributos do personagem
# O código é gerado a partir das variáveis atrib
# arg0 = nome da função
# arg1 = 0 se codificar sem a eficiência (sem multiplicar por arg0)
# arg1 != 0 se codificar com a eficiência (multiplicando por arg0)
# Se não vai mudar nenhum atributo, retorna um texto vazio
  textotxt t
  t.addfim("func " + arg0 + " # Altera atributos do personagem")
  t.addfim("# Não alterar; função criada automaticamente")
  refvar anum = atribnum
  refvar aobj = atribobj
  refvar abit = atribbit
  (anum.0 || anum.1) && t.addfim(atrib_cod1("pvidamax", anum.0, anum.1, arg1))
  (anum.2 || anum.3) && t.addfim(atrib_cod1("pmanamax", anum.2, anum.3, arg1))
  (anum.4 || anum.5) && t.addfim(atrib_cod1("pmovemax", anum.4, anum.5, arg1))
  (anum.6 || anum.7) && t.addfim(atrib_cod1("pveloc1",  anum.6, anum.7, arg1))
  (anum.8 || anum.9) && t.addfim(atrib_cod1("atknorm", anum.8, anum.9, arg1))
  (anum.10 || anum.11) && t.addfim(atrib_cod1("defnorm", anum.10, anum.11, arg1))
  (anum.12 || anum.13) && t.addfim(atrib_cod1("atkesp", anum.12, anum.13, arg1))
  (anum.14 || anum.15) && t.addfim(atrib_cod1("defesp", anum.14, anum.15, arg1))
  (anum.16 || anum.17) && t.addfim(atrib_cod1("evasao", anum.16, anum.17, arg1))
  (anum.18 || anum.19) && t.addfim(atrib_cod1("precisao", anum.18, anum.19, arg1))
  anum.20 && t.addfim(atrib_cod1("pcriticoacerto", anum.20, 0, arg1))
  anum.21 && t.addfim(atrib_cod1("pcriticoatk", anum.21, 0, arg1))
  (anum.22 || anum.23) && t.addfim(atrib_cod1("pesomax", anum.20, anum.21, arg1))
  (aobj.0 || aobj.1) && t.addfim(atrib_cod1("var.z_armafalha_", aobj.0, aobj.1, arg1))
  (aobj.2 || aobj.3) && t.addfim(atrib_cod1("var.z_armaaddprecisao_", aobj.2, aobj.3, arg1))
  (aobj.4 || aobj.5) && t.addfim(atrib_cod1("var.z_armamin_", aobj.4, aobj.5, arg1))
  (aobj.6 || aobj.7) && t.addfim(atrib_cod1("var.z_armamax_", aobj.6, aobj.7, arg1))
  abit.11 && t.addfim("bitinv &= ~2") # Visível no escuro
  int32 x
  abit.4 && (x += 16) # Não pode ver voando
  abit.6 && (x += 32) # Não pode ver voando alto
  abit.7 && (x += 1) # Está cego
  x && t.addfim("bitver&=~" + x)
  x = 0
  abit.0 && (x += 2) # Visão noturna
  abit.1 && (x += 4) # Pode ver invisível
  abit.2 && (x += 8) # Pode ver oculto
  abit.3 && (x += 16) # Pode ver voando
  abit.5 && (x += 32) # Pode ver voando alto
  abit.12 && (x += 0x100) # Anda em silêncio
  abit.13 && (x += 0x1000) # Percebe quem anda em silêncio
  abit.14 && (x += 0x200) # Voando ou flutuando
  abit.17 && (x += 0x400) # Dormindo
  abit.18 && (x += 0x800) # Imune a dormir
  x && t.addfim("bitver|=" + x)
  x = 0
  abit.8 && (x += 4) # Torna invisível
  abit.9 && (x += 8) # Torna oculto
  abit.15 && (x += 16) # Voando
  abit.16 && (x += 32) # Voando alto
  abit.10 && (x += 128) # Invisível a não admin
  x && t.addfim("bitinv|=" + x)
  refvar total = intsublin(p_atrib_atk)
  epara x = 0, x < total, x++
    continuar atribatk.[x] == 100
    refvar lin = " # " + txtsublin(p_atrib_atk, x, 1)
    t.addfim(atrib_mulcod("atktipo." + x, atribatk.[x], arg1) + lin)
  efim
  epara x = 0, x < total, x++
    continuar atribdef.[x] == 100
    refvar lin = " # " + txtsublin(p_atrib_atk, x, 1)
    t.addfim(atrib_mulcod("deftipo." + x, atribdef.[x], arg1) + lin)
  efim
  ret t.linhas > 2 ? t.remove(1000) : ""

func atrib_salvar # Salva os atributos em função conforme variáveis atrib
# arg0 = objeto jogsock do jogador
# arg0.var.opcclasse e arg0.var.opcvar = nomes da classe e da função
# Usa também arg0.var.opcnome e arg0.var.opcexec
# arg1 = 0 se codificar simples (sem multiplicar por arg0)
# arg1 != 0 se codificar completo (multiplicando por arg0)
  refvar codigo = atrib_cod_mudar(arg0.var.opcvar, arg1)
# msg("----------\n" + codigo + "\n----------")
  prog p
  refvar var = arg0.var
  se codigo
    p.criar(var.opcclasse, codigo)
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse

func atrib_txt # Obtém texto com informações dos atributos, para os usuários
# arg0 = textotxt aonde colocar as informações
# Nota: antes chamar atrib_ler para preencher as variáveis atrib
  refvar p_atrib_atk1 = "físicos\nespeciais\n" + config:atknomes
  refvar p_atrib_def1 = "física\nespecial\n" + config:atknomes
  refvar p_atrib_def2 = "ataques físicos\nataques especiais\n" + config:atknomes
  txt512 lin
# Efeitos numéricos
  int8 x
  int8 total = intsublin(p_atrib_num)
  epara x = 0, x < total, x++
    continuar !atribnum.[x]
    lin = txtmin(txtsublin(p_atrib_num, x, 1))
    arg0.addfim("Afeta " + lin + " em " + atribnum.[x] + ".")
  efim
# Efeitos sim/não
  lin = ""
  total = intsublin(p_atrib_bit)
  epara x = 0, x < total, x++
    continuar !atribbit.[x]
    lin += ", " + txtmin(txtsublin(p_atrib_bit, x, 1))
  efim
  lin && arg0.addfim("Propriedades:" + txt(lin, 1) + ".")
# Efeitos de ataque
  total = intsublin(p_atrib_atk1)
  epara x = 0, x < total, x++
    continuar atribatk.[x] == 100
    lin = txtsublin(p_atrib_atk1, x, 1)
    se atribatk.[x] == 0
      arg0.addfim("Anula ataques " + lin + ".")
    senao atribatk.[x] < 100
      arg0.addfim("Reduz ataques " + lin + " em " + int(100 - atribatk.[x]) + "%.")
    senao
      arg0.addfim("Aumenta ataques " + lin + " em " + int(atribatk.[x] - 100) + "%.")
    fimse
  efim
# Efeitos de defesa
  epara x = 0, x < total, x++
    continuar atribdef.[x] == 100
    se atribdef.[x] == 0
      lin = "Torna imune a " + txtsublin(p_atrib_def2, x, 1)
      arg0.addfim(lin + ".")
    senao atribdef.[x] < 100
      lin = "Melhora defesa " + txtsublin(p_atrib_def1, x, 1)
      arg0.addfim(lin + " em " + int(10000 / atribdef.[x] - 100) + "%.")
    senao
      lin = "Piora defesa " + txtsublin(p_atrib_def1, x, 1)
      arg0.addfim(lin + " em " + int(100 - 10000 / atribdef.[x]) + "%.")
    fimse
  efim


classe opc_atribnum_perso
herda opc_atribcomum
# Atributos numéricos para personagem, não leva em conta eficiência
const com_eficiencia = 0
const vetor = atribnum
const lista = p_atrib_num

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  atrib_ler(arg0, arg1)
  refvar total = intsublin(lista)
  int8 x
  int8 linhas
  epara x = 0, x < total, x++
    linhas += vetor.[x] != 0
  efim
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo # Editando atributos
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vetor.limpar(0)
    atrib_salvar(arg0, com_eficiencia)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    arg0.perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    epara t1.addfim(lista), t1.linhas, linha++
      refvar lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      refvar n = vetor.[linha]
      se n
        arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + n + "\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    t2.linhas && arg0.txtmais.addfim(t2.remove(100))
    arg0.txtmostra
  senao txt(linha) != arg1 || !linha || linha > intsublin(lista)
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha--
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha
    arg0.msg(txtsublin(lista, linha, 1) + ": " + vetor.[linha])
    ret $opc_atrib2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atribnum_item
herda opc_atribnum_perso
# Atributos numéricos para item, leva em conta eficiência
const com_eficiencia = 1
const vetor = atribnum
const lista = p_atrib_num


classe opc_atribobj_perso
herda opc_atribnum_perso
# Atributos numéricos de itens, não leva em conta eficiência
const com_eficiencia = 0
const vetor = atribobj
const lista = p_atrib_obj


classe opc_atribobj_item
herda opc_atribnum_perso
# Atributos numéricos de itens, leva em conta eficiência
const com_eficiencia = 1
const vetor = atribobj
const lista = p_atrib_obj


classe opc_atribbit_perso
herda opc_atribcomum
# Atributos sim/não para personagem, não leva em conta eficiência
const com_eficiencia = 0

func menu # Retorna a quantidade de atributos sim/não
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 3) == "bit" && linhas++
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo # Editando atributos
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    atribbit.limpar(0)
    atrib_salvar(arg0, com_eficiencia)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    arg0.perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    epara t1.addfim(p_atrib_bit), t1.linhas, linha++
      refvar lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      se atribbit.[linha]
        arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    t2.linhas && arg0.txtmais.addfim(t2.remove(100))
    arg0.txtmostra
  senao txt(linha) != arg1 || !linha || linha > intsublin(p_atrib_bit)
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha--
    atribbit.[linha] = !atribbit.[linha]
    atrib_salvar(arg0)
    refvar lin = atribbit.[linha] ? "Sim" : "Não"
    arg0.msg(txtsublin(p_atrib_bit, linha, 1) + " mudou para: " + lin)
  fimse
  ret 1


classe opc_atribbit_item
herda opc_atribbit_perso
# Atributos sim/não para item, leva em conta eficiência
const com_eficiencia = 1


classe opc_atribatk_perso
herda opc_atribcomum
# Ataques, não leva em conta eficiência
const com_eficienciao = 0
const vetor = atribatk # Variável que contém os atributos
const nome = "atktipo" # Nome da variável

func menu # Retorna a quantidade de ataques
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == nome && linhas++
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo # Editando atributos
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vetor.limpar(100)
    atrib_salvar(arg0, com_eficiencia)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    arg0.perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    epara t1.addfim(p_atrib_atk), t1.linhas, linha++
      lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. Danos " : "\b.Danos ") + t1.remove
      refvar n = vetor.[linha]
      se n != 100
        arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + n + "%\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    t2.linhas && arg0.txtmais.addfim(t2.remove(100))
    arg0.txtmostra
  senao txt(linha) != arg1 || !linha || linha > intsublin(p_atrib_atk)
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha--
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha
    refvar nomedano = txtsublin(p_atrib_atk, linha, 1)
    arg0.msg("Danos " + nomedano + ": " + vetor.[linha] + "%")
    ret $opc_atrib2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atribatk_item
herda opc_atribatk_perso
# Ataques, leva em conta eficiência
const com_eficiencia = 1
const vetor = atribatk # Variável que contém os atributos
const nome = "atktipo" # Nome da variável


classe opc_atribdef_perso
herda opc_atribatk_perso
# Defesas, não leva em conta eficiência
const com_eficiencia = 0
const vetor = atribdef # Variável que contém os atributos
const nome = "deftipo" # Nome da variável


classe opc_atribdef_item
herda opc_atribatk_perso
# Defesas, leva em conta eficiência
const com_eficiencia = 1
const vetor = atribdef # Variável que contém os atributos
const nome = "deftipo" # Nome da variável


classe opc_atrib2
herda opc_atribcomum
# Usado por opc_atrib; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    casovar arg0.var.opcpasso2
    casose "opc_atribnum_perso"
    casose "opc_atribnum_item"
    casose "opc_atribbit_perso"
    casose "opc_atribbit_item"
      arg0.msg("Entre com a quantidade, 0=não alterar, Z cancela")
      sair
    casose "opc_atribatk_perso"
    casose "opc_atribatk_item"
    casose "opc_atribdef_perso"
    casose "opc_atribdef_item"
      arg0.msg("Entre com a porcentagem, 100=danos normais, Z cancela")
    casofim
  senao arg1 == "z"
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao
    casovar arg0.var.opcpasso2
    casose "opc_atribatk_perso"
    casose "opc_atribatk_item"
    casose "opc_atribdef_perso"
    casose "opc_atribdef_item"
      sair num >= 0
      arg0.msg("A porcentagem não pode ser menor que zero, entre com outra")
      ret 1
    casofim
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    atrib[txt(arg0.var.opcpasso2, 9, 3)].[arg0.var.opclin] = num
    atrib_salvar(arg0, [arg0.var.opcpasso2]:com_eficiencia)
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  fimse
  ret 1


classe opc_atribcfg
herda opc_atribcomum
# Atributos numéricos dos personagens no comando Econfig

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    linhas++
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    prog p
    p.apagar(arg0.var.opcclasse, arg0.var.opcvar)
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    admlog(arg0, "apagou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    txt100 lin
    epara t1.addfim(p_atrib_num), t1.linhas, linha++
      lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + atribnum.[linha] + "\b")
    efim
    arg0.txtmostra
  senao txt(linha) != arg1 || !linha || linha > intsublin(p_atrib_num)
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha--
    arg0.var.opclin = linha
    arg0.msg(txtsublin(p_atrib_num, linha, 1) + ": " + atribnum.[linha])
    ret $opc_atribcfg2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atribcfg2
herda opc_atribcomum
# Usado por opc_atribcfg; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    arg0.msg("Entre com a quantidade, Z cancela")
  senao arg1 == "z"
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    atribnum.[arg0.var.opclin] = num
    refvar codigo = atrib_cod_ini(arg0.var.opcvar)
    prog p
    p.criar(arg0.var.opcclasse, codigo)
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    admlog(arg0, "mudou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
    $admrecalc.exec # Para atualizar os personagens
  fimse
  ret 1


classe admrecalc
# Para recalcular os atributos de todos os personagens que lutam:
# $admrecalc.exec
# Para atualizar os atributos de todos os personagens:
# $admrecalc.atuperso
# Para atualizar os atributos de todos os itens:
# $admrecalc.atuitem
#
const iniclasse = !$[arg0] && criar(arg0)

func exec
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_persobat"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuperso
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_perso"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuitem
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_item"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim


classe teste_atrib
herda opc_atribcomum
# Classe criada para testar e validar atrib_ler e atrib_codif em opc_atribcomum
const testar = 0 # Pode ser 1 para validar ou 0 para não validar
intexec exec1
textotxt info # Informações

func iniclasse
  ret ![arg0]:testar, nulo
  ref r1 = criar(arg0)
  ref r2 = criar(arg0)
  uint8 x
  epara x = 0, x < 32, x++
    r1.atribnum.[x] = (x % 5 < 3 ? rand(100) - 50 : 0)
    r1.atribobj.[x] = rand(100) - 50
    r1.atribbit.[x] = rand(2)
    r1.atribatk.[x] = (x % 7 ? rand(200) : 0)
    r1.atribdef.[x] = (x % 7 ? rand(200) : 0)
  efim
  r1.atrib_txt(info)
  r2.exec1 = 1
  refvar codigo1 = r1.atrib_cod_mudar("teste1", 0)
  refvar codigo2 = r1.atrib_cod_mudar("teste2", 1)
  prog p
  p.criar(arg0, codigo1)
  p.criar(arg0, codigo2)
  telatxt tela
  tela.msg("\nCódigo sem arg0:\n" + codigo1 + "\n")
  tela.msg("\nCódigo com arg0:\n" + codigo2 + "\n")

func exec1_exec
  telatxt tela
  refvar r1 = $[este]
  atrib_ler(este, "teste1")
  atrib_txt(info)
  tela.msg("\nDescrição:\n" + info.ini.textolin(1000) + "\n\n")
  r1 == este && tela.msg("Mesmo objeto\n")
  enquanto r1.linhas || r2.linhas
    refvar l1 = r1.remove
    refvar l2 = r2.remove
    l1 != l2 && tela.msg("Descrição difere:\n " + lin1 + "\n " + lin2 + "\n")
  efim
  tela.msg("Comparando sem arg0\n")
  compara1
  atribnum.limpar(0)
  atribobj.limpar(0)
  atribbit.limpar(0)
  atribatk.limpar(0)
  atribdef.limpar(0)
  atrib_ler(este, "teste2")
  tela.msg("Comparando com arg0\n")
  compara1

func compara1
  refvar r1 = $[este]
  epara x = 0, x < 32, x++
    se r1.atribnum.[x] != atribnum.[x]
      tela.msg("atribnum." + x + ": " + r1.atribnum.[x] + " " + atribnum.[x] + "\n")
    fimse
    se r1.atribobj.[x] != atribobj.[x]
      tela.msg("atribobj." + x + ": " + r1.atribobj.[x] + " " + atribobj.[x] + "\n")
    fimse
    se r1.atribbit.[x] != atribbit.[x]
      tela.msg("atribbit." + x + ": " + r1.atribbit.[x] + " " + atribbit.[x] + "\n")
    fimse
    se r1.atribatk.[x] != atribatk.[x]
      tela.msg("atribatk." + x + ": " + r1.atribatk.[x] + " " + atribatk.[x] + "\n")
    fimse
    se r1.atribdef.[x] != atribdef.[x]
      tela.msg("atribdef." + x + ": " + r1.atribdef.[x] + " " + atribdef.[x] + "\n")
    fimse
  efim
