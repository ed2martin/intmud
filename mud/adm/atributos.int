classe opc_atribcomum
herda comando_adm
# Funções para mudar atributos de personagens e itens
#
real2 vatrib.120 # Atributos extraídos da função
const p_atrib_bit = 22 # A partir de que opção começam atributos de bit
const p_atrib_atk = 41 # A partir de que opção começam atributos de ataque/defesa
# Depois disso vem as opções de p_atrib_atk1, e são em porcentagem
#
const p_atrib_txtnum = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Carrega (gramas)\n\
Carrega (gramas) por nível"
#
const p_atrib_txtbit = "Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Pode ver voando\n\
Não pode ver voando\n\
Pode ver voando alto\n\
Não pode ver voando alto\n\
Está cego\n\
Torna invisível\n\
Torna oculto\n\
Invisível a não admin\n\
Visível no escuro\n\
Anda em silêncio\n\
Percebe andar em silêncio\n\
Está flutuando\n\
Está voando\n\
Está voando alto\n\
Está dormindo\n\
Imune a dormir"
#
const p_atrib_atk1 = "Tipos Normais\nTipos Especiais\n" + config:atknomes

func atrib2txt # Usado internamente em atrib_salvar
# arg0 e arg1 = variáveis
  ret !arg1, txt(0 + arg0) # Exemplo: 5
  ret !arg0, txt(arg1) + "*pnivel" # Exemplo: 10*pnivel
  ret arg0 < 0, txt(arg1) + "*pnivel" + txt(arg0) # Exemplo: 10*pnivel-5
  ret txt(arg1) + "*pnivel+" + txt(arg0) # Exemplo: 10*pnivel+5

func atrib_ler # Extrai os atributos de uma função para a variável vatrib
# arg0 = nome da classe
# arg1 = nome da função
  int32 x
  vatrib.limpar(100)
  epara x = p_atrib_atk - 1, x >= 0, x -= 1
    vatrib.[x] = 0
  efim
  prog p
  epara p.inilinha(arg0, arg1), p.lin, p.depois
    casovar txt1(p.texto)
    casose "pvidamax"
      atrib_ler2(p.texto, vatrib.0, vatrib.1)
      sair
    casose "pmanamax"
      atrib_ler2(p.texto, vatrib.2, vatrib.3)
      sair
    casose "pmovemax"
      atrib_ler2(p.texto, vatrib.4, vatrib.5)
      sair
    casose "pveloc1"
      atrib_ler2(p.texto, vatrib.6, vatrib.7)
      sair
    casose "atknorm"
      atrib_ler2(p.texto, vatrib.8, vatrib.9)
      sair
    casose "defnorm"
      atrib_ler2(p.texto, vatrib.10, vatrib.11)
      sair
    casose "atkesp"
      atrib_ler2(p.texto, vatrib.12, vatrib.13)
      sair
    casose "defesp"
      atrib_ler2(p.texto, vatrib.14, vatrib.15)
      sair
    casose "evasao"
      atrib_ler2(p.texto, vatrib.16, vatrib.17)
      sair
    casose "precisao"
      atrib_ler2(p.texto, vatrib.18, vatrib.19)
      sair
    casose "pesomax"
      atrib_ler2(p.texto, vatrib.20, vatrib.21)
      sair
    casose "bitver"
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        x = txt(txtsub(p.texto, 2), 1)
        x & 1 && (vatrib.29 = 1) # Está cego
        x & 16 && (vatrib.26 = 1) # Não pode ver voando
        x & 32 && (vatrib.28 = 1) # Não pode ver voando alto
      senao
        x = txtsub(p.texto, 2)
        x & 2 && (vatrib.22 = 1) # Visão noturna
        x & 4 && (vatrib.23 = 1) # Pode ver invisível
        x & 8 && (vatrib.24 = 1) # Pode ver oculto
        x & 16 && (vatrib.25 = 1) # Pode ver voando
        x & 32 && (vatrib.27 = 1) # Pode ver voando alto
        x & 0x100 && (vatrib.34 = 1) # Anda em silêncio
        x & 0x1000 && (vatrib.35 = 1) # Percebe quem anda em silêncio
        x & 0x200 && (vatrib.36 = 1) # Voando ou flutuando
        x & 0x400 && (vatrib.39 = 1) # Dormindo
        x & 0x800 && (vatrib.40 = 1) # Imune a dormir
      fimse
      sair
    casose "bitinv"
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        vatrib.33 = 1 # Visível no escuro
      senao
        x = txtsub(p.texto, 2)
        x & 4 && (vatrib.30 = 1) # Torna invisível
        x & 8 && (vatrib.31 = 1) # Torna oculto
        x & 16 && (vatrib.37 = 1) # Voando
        x & 32 && (vatrib.38 = 1) # Voando alto
        x & 128 && (vatrib.32 = 1) # Invisível a não admin
      fimse
      sair
    casose
      se txt(p.texto, 0, 8) == "atktipo." && txtsub(p.texto, 1, 1) == "*="
        vatrib.[int(txt(p.texto, 8)) * 2 + p_atrib_atk] = 100 * txtsub(p.texto, 2)
      senao txt(p.texto, 0, 8) == "deftipo." && txtsub(p.texto, 1, 1) == "*="
        vatrib.[int(txt(p.texto, 8)) * 2 + p_atrib_atk + 1] = 100 * txtsub(p.texto, 2)
      fimse
    casofim
  efim

func atrib_ler2 # Usado internamente em atrib_ler
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  se txtsub(arg0, 3, 3) == "* pnivel -"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = -1 * txtsub(arg0, 6)
  senao txtsub(arg0, 3, 2) == "* pnivel"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = txtsub(arg0, 6)
  senao
    arg1 = txtsub(arg0, 2)
  fimse

func atrib_salvar # Salva os atributos em função conforme a variável vatrib
# arg0 = objeto jogsock do jogador
# arg0.var.opcclasse e arg0.var.opcvar = nomes da classe e da função
# Usa também arg0.var.opcnome e arg0.var.opcexec
  textotxt t
  t.addfim("func " + arg0.var.opcvar + " # Altera atributos do personagem")
  t.addfim("# Não alterar; função criada automaticamente")
  (vatrib.0 || vatrib.1) && t.addfim("pvidamax+=" + atrib2txt(vatrib.0, vatrib.1))
  (vatrib.2 || vatrib.3) && t.addfim("pmanamax+=" + atrib2txt(vatrib.2, vatrib.3))
  (vatrib.4 || vatrib.5) && t.addfim("pmovemax+=" + atrib2txt(vatrib.4, vatrib.5))
  (vatrib.6 || vatrib.7) && t.addfim("pveloc1+=" + atrib2txt(vatrib.6, vatrib.7))
  (vatrib.8 || vatrib.9) && t.addfim("atknorm+=" + atrib2txt(vatrib.8, vatrib.9))
  (vatrib.10 || vatrib.11) && t.addfim("defnorm+=" + atrib2txt(vatrib.10, vatrib.11))
  (vatrib.12 || vatrib.13) && t.addfim("atkesp+=" + atrib2txt(vatrib.12, vatrib.13))
  (vatrib.14 || vatrib.15) && t.addfim("defesp+=" + atrib2txt(vatrib.14, vatrib.15))
  (vatrib.16 || vatrib.17) && t.addfim("evasao+=" + atrib2txt(vatrib.16, vatrib.17))
  (vatrib.18 || vatrib.19) && t.addfim("precisao+=" + atrib2txt(vatrib.18, vatrib.19))
  (vatrib.20 || vatrib.21) && t.addfim("pesomax+=" + atrib2txt(vatrib.20, vatrib.21))
  vatrib.33 && t.addfim("bitinv &= ~2") # Visível no escuro
  se 1
    int32 x
    vatrib.26 && (x += 16) # Não pode ver voando
    vatrib.28 && (x += 32) # Não pode ver voando alto
    vatrib.29 && (x += 1) # Está cego
    x && t.addfim("bitver&=~" + x)
    x = 0
    vatrib.22 && (x += 2) # Visão noturna
    vatrib.23 && (x += 4) # Pode ver invisível
    vatrib.24 && (x += 8) # Pode ver oculto
    vatrib.25 && (x += 16) # Pode ver voando
    vatrib.27 && (x += 32) # Pode ver voando alto
    vatrib.34 && (x += 0x100) # Anda em silêncio
    vatrib.35 && (x += 0x1000) # Percebe quem anda em silêncio
    vatrib.36 && (x += 0x200) # Voando ou flutuando
    vatrib.39 && (x += 0x400) # Dormindo
    vatrib.40 && (x += 0x800) # Imune a dormir
    x && t.addfim("bitver|=" + x)
    x = 0
    vatrib.30 && (x += 4) # Torna invisível
    vatrib.31 && (x += 8) # Torna oculto
    vatrib.37 && (x += 16) # Voando
    vatrib.38 && (x += 32) # Voando alto
    vatrib.32 && (x += 128) # Invisível a não admin
    x && t.addfim("bitinv|=" + x)
  fimse
  uint16 linha
  txt100 lin
  refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_atk
  epara linha = p_atrib_atk, linha < total, linha += 2
    continuar vatrib.[linha] == 100
    refvar indice = (linha - p_atrib_atk) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("atktipo." + indice + "*=" + vatrib.[linha] / 100 + lin)
  efim
  epara linha = p_atrib_atk + 1, linha < total, linha += 2
    continuar vatrib.[linha] == 100
    refvar indice = (linha - p_atrib_atk - 1) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("deftipo." + indice + "*=" + vatrib.[linha] / 100 + lin)
  efim
# msg("----------\n" + t.ini.textolin(10000) + "\n----------")
  prog p
  refvar var = arg0.var
  se t.linhas > 2
    p.criar(var.opcclasse, t.remove(10000))
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse

func passo # Editando atributos
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    casovar tipo
    casose "atribnum" # Atributos numéricos
      epara linha = 0, linha < p_atrib_bit, linha += 1
        vatrib.[linha] = 0
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara linha = p_atrib_bit, linha < p_atrib_atk, linha += 1
        vatrib.[linha] = 0
      efim
      sair
    casose "atribatk" # Ataques
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 2
      enquanto linha >= p_atrib_atk
        vatrib.[linha] = 100, linha -= 2
      efim
      sair
    casose "atribdef" # Defesas
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 1
      enquanto linha >= p_atrib_atk
        vatrib.[linha] = 100, linha -= 2
      efim
      sair
    casofim
    atrib_salvar(arg0)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    arg0.perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    casovar tipo
    casose "atribnum" # Atributos numéricos
      epara t1.addfim(p_atrib_txtnum), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se vatrib.[linha]
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[linha] + "\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara t1.addfim(p_atrib_txtbit), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se vatrib.[linha + p_atrib_bit]
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribatk" # Ataques
      int16 indice
      indice = p_atrib_atk
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se vatrib.[indice] != 100
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[indice] + \
"%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribdef" # Defesas
      int16 indice
      indice = p_atrib_atk + 1
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se vatrib.[indice] != 100
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[indice] + \
"%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casofim
    t2.linhas && arg0.txtmais.addfim(t2.remove(100))
    arg0.txtmostra
  senao txt(linha) != arg1
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao !linha || linha > p_atrib_atk + intsublin(p_atrib_atk1) * 2
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao tipo == "atribnum" # Atributos numéricos
    se !linha || linha > p_atrib_bit
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha
    arg0.msg(txtsublin(p_atrib_txtnum, linha, 1) + ": " + vatrib.[linha])
    ret $opc_atrib2.passo(arg0, "\b")
  senao tipo == "atribbit" # Atributos sim/não
    se !linha || linha > p_atrib_atk - p_atrib_bit
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha += p_atrib_bit - 1
    vatrib.[linha] = !vatrib.[linha]
    atrib_salvar(arg0)
    refvar lin = vatrib.[linha] ? "Sim" : "Não"
    arg0.msg(txtsublin(p_atrib_txtbit, linha - p_atrib_bit, 1) + " mudou para: " + lin)
    ret 1
  senao tipo == "atribatk" # Atributos de ataque
    se !linha || linha > intsublin(p_atrib_atk1)
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha * 2 + p_atrib_atk
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    arg0.msg("Danos " + nomedano + ": " + vatrib.[arg0.var.opclin] + "%")
    ret $opc_atrib2.passo(arg0, "\b")
  senao # Atributos de defesa
    se !linha || linha > intsublin(p_atrib_atk1)
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha * 2 + p_atrib_atk + 1
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    arg0.msg("Danos " + nomedano + ": " + vatrib.[arg0.var.opclin] + "%")
    ret $opc_atrib2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atrib2
herda opc_atribcomum
# Usado por opc_atrib; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opclin_ >= p_atrib_atk
      arg0.msg("Entre com a porcentagem, 100=danos normais, Z cancela")
    senao
      arg0.msg("Entre com a quantidade, 0=não alterar, Z cancela")
    fimse
  senao arg1 == "z"
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao num < 0 && arg0.var.opclin_ >= p_atrib_atk
    arg0.msg("A porcentagem não pode ser menor que zero, entre com outra")
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vatrib.[arg0.var.opclin] = num
    atrib_salvar(arg0)
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  fimse
  ret 1


classe opc_atribcfg
herda opc_atribcomum
# Atributos numéricos dos personagens no comando Econfig

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    linhas += 1
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    p.apagar(arg0.var.opcclasse, arg0.var.opcvar)
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    admlog(arg0, "apagou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    txt100 lin
    epara t1.addfim(p_atrib_txtnum), t1.linhas, linha += 1
      lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[linha] + "\b")
    efim
    arg0.txtmostra
  senao txt(linha) != arg1
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao !linha || linha > p_atrib_bit
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opclin = linha
    arg0.msg(txtsublin(p_atrib_txtnum, linha, 1) + ": " + vatrib.[linha])
    ret $opc_atribcfg2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atribcfg2
herda opc_atribcomum
# Usado por opc_atribcfg; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    arg0.msg("Entre com a quantidade, Z cancela")
  senao arg1 == "z"
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao num < 0 && arg0.var.opclin_ >= p_atrib_atk
    arg0.msg("O número não pode ser menor que zero, entre com outro")
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vatrib.[arg0.var.opclin] = num
    textotxt t
    t.addfim("func " + arg0.var.opcvar + " # Altera atributos do personagem")
    t.addfim("# Função criada automaticamente")
    t.addfim("pvidamax=" + atrib2txt(vatrib.0, vatrib.1))
    t.addfim("pmanamax=" + atrib2txt(vatrib.2, vatrib.3))
    t.addfim("pmovemax=" + atrib2txt(vatrib.4, vatrib.5))
    t.addfim("pveloc1=" + atrib2txt(vatrib.6, vatrib.7))
    t.addfim("atknorm=" + atrib2txt(vatrib.8, vatrib.9))
    t.addfim("defnorm=" + atrib2txt(vatrib.10, vatrib.11))
    t.addfim("atkesp=" + atrib2txt(vatrib.12, vatrib.13))
    t.addfim("defesp=" + atrib2txt(vatrib.14, vatrib.15))
    t.addfim("evasao=" + atrib2txt(vatrib.16, vatrib.17))
    t.addfim("precisao=" + atrib2txt(vatrib.18, vatrib.19))
    t.addfim("pesomax=" + atrib2txt(vatrib.20, vatrib.21))
    prog p
    p.criar(arg0.var.opcclasse, t.remove(10000))
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    admlog(arg0, "mudou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
    $admrecalc.exec # Para atualizar os personagens
  fimse
  ret 1


classe opc_atribnum
herda opc_atribcomum
# Atributos numéricos
const tipo = "atribnum"

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txtsub(p.texto, 1, 1) == "+=" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribbit
herda opc_atribcomum
# Atributos sim/não
const tipo = "atribbit"

func menu # Retorna a quantidade de atributos sim/não
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 3) == "bit" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribatk
herda opc_atribcomum
# Ataques
const tipo = "atribatk"

func menu # Retorna a quantidade de ataques
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "atktipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribdef
herda opc_atribcomum
# Defesas
const tipo = "atribdef"

func menu # Retorna a quantidade de defesas
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "deftipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe comando_identificar
herda comando_hab, opc_atribcomum
const posic = 8
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\n" + msgextra
const cmdmenu = "identif" # Editável via "menu_hab_identif" e "menu_magia_identif"
const tipoalvo = 6 # Não agressivo
const c_espera = 15 # Tempo de esperar após usar esse comando
textovar var
const p_atrib_atk1 = "normais\nespeciais\n" + config:atknomes
const p_atrib_def1 = "normal\nespecial\n" + config:atknomes
const p_atrib_def2 = "ataques normais\nataques especiais\n" + config:atknomes
#
# Ordem que deve organizar as constantes:
const admordem = "nomevar\n\
c_espera\n\
c_vida1 c_vida2\n\
c_mana1 c_mana2\n\
c_move1 c_move2\n\
aulaini aulafim\n\
depende\n\
precisao\n\
tipoarma\n\
tipoperso\n\
valor\n\
msgextra msgini1 msgini2\n\
msgperso1 msgperso2 msgperso3 msgobj1 msgobj2\n\
msgerrou1 msgerrou2 msgnulo1 msgnulo2"

func escr
# arg0 = personagem
# arg1 = o que o personagem digitou; usado para obter o item ou personagem alvo
# arg2 = item usado, ou nulo se não usou nenhum item
  ret !arg1, arg0.msg("Identificar o quê?")
  ret !checahab1(arg0.persobat, arg2), nulo
  nomeobj n
  listaobj l
  n.ini(arg1, 1)
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2, arg0.dentro1)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Eventos
    l.limpar
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_ident(arg0, r, arg0), nulo
    efim
    epara l.addfim(r.evento), l, l.ini.remove
      ret l.objini.cmd_ident(arg0, r, r), nulo
    efim
# Checa se pode identificar
    se !arg2.item
      custohab1(arg0.persobat)
      $mens.p(arg0) + $mens.mvis2(msgini1, msgini2)
    fimse
    arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
    se arg0.dono.s_semmagia && txt(nomevar, 0, 1) == "m"
      ret $mens.p(arg0) + $mens.mvis2(msgnulo1, msgnulo2)
    senao rand(100) >= precisao || arg0.atkenv # Checa a precisão e se está batalhando
      ret $mens.p(arg0) + $mens.mvis2(msgerrou1, msgerrou2)
    fimse
    se r.perso
      $mens.p(arg0, r)
      $mens.mvis3(msgperso1, msgperso2, msgperso3)
    senao
      $mens.p(arg0, nulo, r)
      $mens.mvis2(msgobj1, msgobj2)
    fimse
# Identifica
    textotxt t
    txtident(arg0, r, t)
# Envia mensagem
    arg0.msg2(t.remove(1000))
    arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
    ret
  efim
  arg0.msg("Você não vê isso.")

func txtident # Adiciona informações de item ou personagem em um textotxt
# arg0 = personagem que está solicitando as informações
# arg1 = item ou personagem sendo identificado
# arg2 = textotxt aonde colocar as informações
  txt100 lin
# Identificar personagem
  se arg1.perso
    lin = txtcopiamai(arg1.persobat.descnome, "A")
    se arg1 != arg1.persobat
      lin += " de " + arg1.descnome, arg1 = arg1.persobat
    fimse
    lin += ", nível " + arg1.pnivel
    arg1.prenascer && (lin += ", R" + arg1.prenascer)
    arg1.tipo1 && (lin += ", " + txtcopiamai(arg1.tipo1, "A"))
    arg1.tipo2 && (lin += ", " + txtcopiamai(arg1.tipo2, "A"))
    arg1.tipo3 && (lin += ", " + txtcopiamai(arg1.tipo3, "A"))
    arg2.addfim(lin)
    refvar m = txt(arg1.descident(arg0))
    m && arg2.addfim(m)
    ret
  fimse
# Nível do item
  se arg1.pnivel || arg1.prenascer
    lin = "É um objeto do nível " + arg1.pnivel
    arg1.prenascer && (lin += ", R" + arg1.prenascer)
    arg2.addfim(lin + ".")
  fimse
# Peso e valor
  refvar peso = arg1.pesoobj + arg1.pesoden
  lin = peso < 10000 ? txt(peso) + "g" : txt(peso / 1000) + "Kg"
  se !arg1.valor
  senao arg1.valor == 1
    lin += " e vale uma moeda"
  senao arg1.valor == 2
    lin += " e vale duas moedas"
  senao
    lin += " e vale " + arg1.valor + " moedas"
  fimse
  arg2.addfim("Isso pesa " + lin + ".")
# Se é arma
  se arg1.armatipo
    lin = "É uma arma do tipo \"" + txtsublin(config:arma_txt, arg1.armatipo, 1)
    lin += "\" de ataque " + arg1.armamin
    arg1.armamin != arg1.armamax && (lin += " a " + arg1.armamax)
    lin += " e precisão " + arg1.armaprecisao + "."
    arg2.addfim(lin)
  fimse
# Aonde pode ser vestido
  se 1
    uint8 x
    int32 valor
    lin = "", valor = arg1.vestir1
    arg1.armatipo && (lin += ", empunhando")
    enquanto x < 30 && valor
      valor & 1 && (lin += ", " + txtsublin(config:equip_txt, x, 1))
      x += 1, valor = valor >> 1
    efim
    lin && arg2.addfim("Pode ser usado em: " + txt(lin, 2) + ".")
  fimse
# Quem não pode vestir
  se arg1.vestirnao
    arg2.addfim("Não pode ser usado por: " + txttroca(arg1.vestirnao, "\n", ",") + ".")
  fimse
# Diversos
  arg1.i_chave && arg2.addfim("É um tipo de chave.")
  arg1.i_captura && arg2.addfim("Pode ser usado para capturar animais.")
# Obtém os efeitos (Extrai os atributos de uma função)
  atrib_ler(arg1, arg1.perso ? "recalc1_auto" : "recalc2_auto")
# Efeitos numéricos
  int8 x
  epara nulo, x < p_atrib_bit, x += 1
    continuar !vatrib.[x]
    lin = txtmin(txtsublin(p_atrib_txtnum, x, 1))
    arg2.addfim("Afeta " + lin + " em " + vatrib.[x] + ".")
  efim
# Efeitos sim/não
  lin = ""
  epara nulo, x < p_atrib_atk, x += 1
    continuar !vatrib.[x]
    lin += ", " + txtmin(txtsublin(p_atrib_txtbit, x - p_atrib_bit, 1))
  efim
  lin && arg2.addfim("Propriedades:" + txt(lin, 1) + ".")
# Efeitos de ataque
  refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_atk
  epara x = p_atrib_atk, x < total, x += 2
    continuar vatrib.[x] == 100
    lin = txtsublin(p_atrib_atk1, x - p_atrib_atk >> 1, 1)
    se vatrib.[x] == 0
      arg2.addfim("Anula ataques " + lin + ".")
    senao vatrib.[x] < 100
      arg2.addfim("Reduz ataques " + lin + " em " + int(100 - vatrib.[x]) + "%.")
    senao
      arg2.addfim("Aumenta ataques " + lin + " em " + int(vatrib.[x] - 100) + "%.")
    fimse
  efim
# Efeitos de defesa
  epara x = p_atrib_atk + 1, x < total, x += 2
    continuar vatrib.[x] == 100
    se vatrib.[x] == 0
      lin = txtsublin(p_atrib_def2, x - p_atrib_atk >> 1, 1)
      arg2.addfim("Torna imune a " + lin + ".")
    senao vatrib.[x] < 100
      lin = txtsublin(p_atrib_def1, x - p_atrib_atk >> 1, 1)
      arg2.addfim("Melhora defesa " + lin + " em " + int(10000 / vatrib.[x] - 100) + "%.")
    senao
      lin = txtsublin(p_atrib_def1, x - p_atrib_atk >> 1, 1)
      arg2.addfim("Piora defesa " + lin + " em " + int(100 - 10000 / vatrib.[x]) + "%.")
    fimse
  efim
# Identificação
  refvar m = txt(arg1.descident(arg0))
  m && arg2.addfim(m)


classe menu_magia_identif
herda menu_hab_identif
const titulo = "Magia_Ident " + txt(var.classe1, 6)


classe menu_hab_identif
herda menu_hab_comum
const titulo = "Hab_Ident " + txt(var.classe1, 4)
const colunas = 25
#
const nome11 = "Informações"
const info11 = "Informações extras"
const tipo11 = "opc_texto"
const clas11 = var.classe1
const vari11 = "msgextra"
#
const nome12 = "Mensagens"
const tipo12 = "menu_hab_identif0--"
#
const nome13 = "Menu de mensagens"
const tipo13 = "opc_ajuda--"
const extr13 = menu_hab_ataque:msg2


classe menu_hab_identif0
herda comando_menu
const titulo = "Mensagens"
const menufim = var.menufim
const colunas = 25
#
const titu1 = " * Ao usar, exceto poções comidas etc"
#
const nome1 = "Perso"
const tipo1 = "opc_linha"
const clas1 = var.classe1
const vari1 = "msgini1"
#
const nome2 = "Outros"
const tipo2 = "opc_linha"
const clas2 = var.classe1
const vari2 = "msgini2"
#
const titu3 = " * Identificou personagem"
#
const nome3 = "Perso"
const tipo3 = "opc_linha"
const clas3 = var.classe1
const vari3 = "msgperso1"
#
const nome4 = "Alvo"
const tipo4 = "opc_linha"
const clas4 = var.classe1
const vari4 = "msgperso2"
#
const nome5 = "Outros"
const tipo5 = "opc_linha"
const clas5 = var.classe1
const vari5 = "msgperso3"
#
const titu6 = " * Identificou objeto"
#
const nome6 = "Perso"
const tipo6 = "opc_linha"
const clas6 = var.classe1
const vari6 = "msgobj1"
#
const nome7 = "Outros"
const tipo7 = "opc_linha"
const clas7 = var.classe1
const vari7 = "msgobj2"
#
const titu8 = " * Falhou"
#
const nome8 = "Perso"
const tipo8 = "opc_linha"
const clas8 = var.classe1
const vari8 = "msgerrou1"
#
const nome9 = "Outros"
const tipo9 = "opc_linha"
const clas9 = var.classe1
const vari9 = "msgerrou2"
#
const titu10 = " * Não teve efeito"
#
const nome10 = "Perso"
const tipo10 = "opc_linha"
const clas10 = var.classe1
const vari10 = "msgnulo1"
#
const nome11 = "Outros"
const tipo11 = "opc_linha"
const clas11 = var.classe1
const vari11 = "msgnulo2"


classe admrecalc
# Para recalcular os atributos de todos os personagens que lutam:
# $admrecalc.exec
# Para atualizar os atributos de todos os personagens:
# $admrecalc.atuperso
# Para atualizar os atributos de todos os itens:
# $admrecalc.atuitem
#
const iniclasse = !$[arg0] && criar(arg0)
prog p
debug d
ref r

func exec
  d.exec = 50000
  epara p.iniherdainv("comum_persobat"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuperso
  d.exec = 50000
  epara p.iniherdainv("comum_perso"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuitem
  d.exec = 50000
  epara p.iniherdainv("comum_item"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim
