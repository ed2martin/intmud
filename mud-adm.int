classe jog_adm
# Funções necessárias para os comandos de administração
#
const txt_legenda = "Legenda:\n\
<nulo> Significa que a opção não foi definida.\n\
<herda> É herdado de outra classe.\n\
Exemplo, as salas herdam as propriedades das nas áreas.\n\
Outro texto entre os sinais de menor e maior indicam o modo\n\
como a opção foi definida. Exemplo, <func> significa função."

func m_menu
  tpasso = arg0, p_menu("")
  ret

func p_menu
  casovar txtmin(arg0)
  casose ""
  casose "\b"
    var.opcnome = "", var.opcclasse = "", var.opcvar = ""
    var.opcpasso = "", var.opcextra = "", var.opcmudou = ""
    passo = "menu"
    msg([tpasso]:titulo + ", tecle O para saber as opções")
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim("\b" + [tpasso]:titulo)
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("V mostra as variáveis alteradas em cada opção (classe:variável)")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "v"
    txtmais.limpar
    txt100 lin
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    txtmostra
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casofim
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao [tpasso]:nome[arg0] # Editar opção do menu
    var.opcnome = txtremove([tpasso]:nome[arg0], "ED")
    var.opcclasse = [tpasso]:classe[arg0]
    var.opcvar = [tpasso]:var[arg0]
    var.opcextra = [tpasso]:extra[arg0]
    var.opcpasso = passo
    var.opcvalido_ = txtproc([tpasso]:tipo[arg0], "--") >= 0
    var.opcmudou = [tpasso]:mudou[arg0]
    se !var.opcvar
      msg2(var.opcextra)
      ret 1
    fimse
    msg(m_menu2(tpasso, arg0))
    [tpasso]:info[arg0] && msg([tpasso]:info[arg0])
    p_[txttroca([tpasso]:tipo[arg0], "-", "")]("\b")
  senao txt(arg0, 0, 1) == "f" && [tpasso]:nome[txt(arg0, 1)] # Editar função
    se txtproc([tpasso]:tipo[txt(arg0, 1)], "-") >= 0
      msg("Essa opção não pode ser editada como função; escolha outra")
      ret 1
    fimse
    txt20 opc
    opc = txt(arg0, 1)
    var.opcnome = txtremove([tpasso]:nome[opc], "ED")
    var.opcclasse = [tpasso]:classe[opc]
    var.opcvar = [tpasso]:var[opc]
    var.opcextra = [tpasso]:extra[opc]
    var.opcpasso = passo
    var.opcmudou = [tpasso]:mudou[arg0]
    se !var.opcvar
      msg2(var.opcextra)
      ret 1
    fimse
    p_func("\b")
  senao # Nenhuma das anteriores
    msg("Opção inválida: " + arg0)
  fimse
  ret 1

func m_menu2 # Usado em m_menu para obter o texto de uma opção do menu
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  txt80 func1 # Função que mostra o conteúdo da variável
  lin = "\b\c2" + arg1 + (txt(arg1, 1) ? "\b." : "\b. ") + [arg0]:nome[arg1]
  inttotal(lin) < 23 && (lin = txt(lin + txtesp(20), 0, 23))
  func1 = "t_" + txttroca([arg0]:tipo[arg1], "-", "") # Nome da função
  ret lin + ": " + [func1]([arg0]:classe[arg1], [arg0]:var[arg1], [arg0]:extra[arg1])

func m_menu3 # Usado em m_menu para obter o nome da variável
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  lin = arg1 + (txt(arg1, 1) ? "." : ". ") + [arg0]:nome[arg1]
  inttotal(lin) < 20 && (lin = txt(lin + txtesp(18), 0, 20))
  ret lin + ": " + [arg0]:classe[arg1] + ":" + [arg0]:var[arg1]

func t_linha # Retorna texto de uma linha, do tipo "const x = \"abc\""
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + txtvis([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + txtvis([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_linha # Alterando um texto de uma linha
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "linha"
    msg("Entre com um texto, N nenhum, Z cancela")
    ret 1
  senao arg0 == "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    senao
      p.criar(var.opcclasse, "const " + var.opcvar + "=\"\"")
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg(var.opcnome + " mudou para um texto vazio")
      admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    fimse
  senao arg0 != "z"
    p.criar(var.opcclasse, "const " + var.opcvar + "=\"" + txtvis(arg0) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + arg0)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_texto # Retorna quantidade de linhas de texto de várias linhas
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> " + t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_texto2([arg0]:[arg1])
  casofim

func t_texto2 # Usado por t_texto
  txt10 x
  x = intsublin(arg0)
  ret x != "1" ? "\c6" + x + " linhas\b" : "\c6Uma linha\b"

func p_texto # Alterando um texto de várias linhas
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    textopos p1
    teditor.limpar
    teditor.addfim([var.opcclasse]:[var.opcvar])
    epara p1 = teditor.ini, p1.lin, p1.depois
      p1.mudar(txtvis(p1.texto))
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "texto"
    msg("Editando " + var.opcnome + ", O opções, X salvar, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    epara p1 = teditor.ini, p1.lin, p1.depois
      t1.addfim(txtinvis(p1.texto))
    efim
    txt200 t
    t = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, t + txtvis(t1.remove(1000)) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Salvou " + var.opcnome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret 1
  casofim
  ret p_editor(arg0, 2000, var.opcvar)

func t_numero # Retorna número, do tipo "const x = 10"
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), "\c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> \c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> \c60\b"
  casofim

func p_numero # Alterando um número
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "numero"
    se var.opcvalido
      msg("Entre com um número, Z cancela")
    senao
      msg("Entre com um número, N nenhum, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 valor
    valor = arg0
    se arg0 != valor # Checa se é número
      ret p_numero("\b")
    senao var.opcextra # Checa limites mínimo e máximo
      se valor < int(txt1(var.opcextra)) || valor > int(txt2(var.opcextra))
        msg("Entre com um número de " + txt1(var.opcextra) + " a " + txt2(var.opcextra) + ".")
        ret 1
      fimse
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + valor)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + valor)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_opcao # Retorna uma opção baseado numa lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_opcaomostra(0, arg2)
  casofim

func t_opcaomostra # Retorna o texto correspondente a uma opção
# arg0 = número da opção atual
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo a opção atual
  uint16 valor
  textotxt t
  valor = arg0
  t.addfim(arg1)
  t.remove(valor)
  ret "\c6" + valor + (t.linhas ? " " + t.remove(1) + "\b" : " <inválido>\b")

func p_opcao # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "opcao"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    textotxt t
    int16 x
    x = arg0, t.addfim(var.opcextra)
    se arg0 != x || x < 0 || x >= t.linhas
      msg("Opção inválida")
      ret p_opcao("\b")
    fimse
    t.remove(x)
    txt100 lin
    lin = " # " + var.opcnome + ": " + x + " " + t.ini.texto
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + x + " " + t.remove)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_txtopcao = t_texto(arg0, arg1)

func p_txtopcao
  uint16 linha
  linha = arg0, passo = "txtopcao"
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
  senao arg0 == "o"
    textotxt t
    t.addfim([var.opcclasse]:[var.opcvar])
    txtmais.limpar
    textopos pos
    epara pos = t.ini, pos, pos.depois
      txtmais.addfim("\c2" + txtmais.linhas + ".\b" + (pos.linha <= 9 ? " ") + pos.texto)
    efim
    txtmais.addini("\bOpções:")
    pos.antes
    se pos.texto != "" && t.linhas < int(txt2(var.opcextra))
      txtmais.addfim("\c2" + txt(txtmais.linhas - 1) + ".\b")
    fimse
    linha = txtsub(var.opcextra, 2)
    pos = txtmais.ini, pos.depois, pos.remove(linha)
    txt100 lin
    lin = "Para alterar, tecle um número de " + linha
    lin += " a " + (txt2(var.opcextra) - 1)
    txtmais.addfim(lin + ", seguido ou não de um texto")
    txtmais.addfim("Z Sair, M seguido de um texto executa comando do MUD")
    txtmostra
  senao arg0 == "z"
    passo = var.opcpasso, p_[passo]("\b")
  senao arg0 == "n" && !var.opcvalido
    prog p
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao txt(linha) != txt1(arg0)
    msg("Opção inexistente: " + txt1(arg0))
  senao linha < int(txtsub(var.opcextra, 2)) || linha >= int(txt2(var.opcextra))
    txt100 lin
    lin = "O número da linha vai de " + int(txtsub(var.opcextra, 2))
    msg(lin + " até " + (txt2(var.opcextra) - 1))
  senao
    textotxt t1
    textopos pos
    t1.addfim([var.opcclasse]:[var.opcvar])
    t1.linhas < linha && t1.addfim(txtrepete("\n", linha - t.linhas))
    pos = t1.ini, pos.linha = linha, pos.mudar(txt2(arg0))
    pos = t1.fim, pos.antes
    uint16 linhasmin
    linhasmin = txt1(var.opcextra)
    enquanto pos.linha > linhasmin && pos.texto == ""
      pos.remove, pos.antes
    efim
    pos.linha == linhasmin && pos.texto == "" && pos.remove
    prog p
    txt200 t
    t = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, t + txtvis(t1.remove(1000)) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Linha " + linha + " foi alterada")
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  ret 1

func t_vetor # Retorna as opções selecionadas de lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_vetormostra(0, arg2)
  casofim

func t_vetormostra # Retorna o texto correspondente a uma opção
# arg0 = valor numérico
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo as opções escolhidas
  int32 valor
  textotxt t
  txt512 lin
  valor = arg0
  epara t.addfim(arg1), t.linhas, valor = valor >> 1
    valor & 1 ? (lin += ", " + t.remove) : t.remove
  efim
  ret lin ? "\c6" + txt(lin, 2) + "\b" : ""

func p_vetor # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "vetor"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 x
    x = arg0
    se arg0 != x || x < 0 || x >= intsublin(var.opcextra)
      msg("Opção inválida")
      ret p_vetor("\b")
    fimse
    x = 1 << x ^ [var.opcclasse]:[var.opcvar]
    txt100 lin
    lin = txtcor(t_vetormostra(x, var.opcextra))
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + " # " + var.opcnome + ": " + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Escolheu: " + lin)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetor("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_tipos = t_vetorfunc(arg0, arg1)

func p_tipos
  prog p
  passo = "tipos"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("tipo_"), p.lin, p.depois
      txtmais.addfim(txt(p.texto, 5))
    efim
  fimse
  ret p_vetorfunc(arg0, p.existe("tipo_" + txts(arg0)))

const t_tipodep = t_vetorfunc(arg0, arg1)

func p_tipodep
  prog p
  passo = "tipodep"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("cmd_"), p.lin, p.depois
      $[p.texto].atkcom && txtmais.addfim("h_" + txt(p.texto, 4))
    efim
    epara p.iniclasse("magia_"), p.lin, p.depois
      txtmais.addfim("m_" + txt(p.texto, 6))
    efim
    epara p.iniclasse("idioma_"), p.lin, p.depois
      txtmais.addfim("i_" + txt(p.texto, 7))
    efim
  fimse
  casovar txtmin(txt(arg0, 0, 2))
  casose "h_"
    ret p_vetorfunc(arg0, $cmd_[txt(arg0, 2)].atkcom != nulo)
  casose "m_"
    ret p_vetorfunc(arg0, $magia_[txt(arg0, 2)] != nulo)
  casose "i_"
    ret p_vetorfunc(arg0, $idioma_[txt(arg0, 2)] != nulo)
  casofim
  ret p_vetorfunc(arg0, 0)

func t_vetorfunc # Usado intermanente: retorna uma lista de textos
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_vetorfunc # Usado intermanente: alterando um vetor de textos
# arg0 = texto digitado pelo usuário
# arg1 = verdadeiro se o texto for a texto válido para o vetor
# Se arg0=="o", a variável txtmais deve ter a lista de opções válidas, uma por linha
  prog p
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    se txtmais.bytes <= 1
      txtmais.limpar, txtmais.add("\bNão há nenhuma opção definida")
    senao
      txtmais.addfim(txttroca(txtmais.remove(5000), "\n", ", "))
      txtmais.juntar, txtmais.dividelin(40, 75)
      txtmais.addini("\bOpções:")
    fimse
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 lin
    lin = txts(arg0)
    textotxt t
    t.addfim([var.opcclasse]:[var.opcvar])
    t.bytes <= 1 && t.limpar
    textopos pos
    pos = t.ini
    se pos.txtproc("\n" + lin + "\n") >= 0
      pos.remove
    senao !arg1
      msg("Opção inválida: " + lin)
      ret p_vetorfunc("\b")
    senao
      t.addfim(lin), t.ordena
    fimse
    lin = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, lin + txtvis(t.ini.textolin(1000)) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Escolheu: " + txttroca(t.ini.textolin(1000), "\n", " "))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetorfunc("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_simnao # Retorna opção que pode ser 0 (não) ou 1 (sim)
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<" + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "\c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "\c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose "2" # Em uma classe herdada
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<herda " + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "<herda> \c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "<herda> \c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose # Não foi definido
    ret "<nulo> \c60 Não\b"
  casofim

func p_simnao # Alterando uma opção que pode ser "SIM" ou "NÃO"
  prog p
  casovar arg0
  casose "0"
  casose "1"
    txt100 lin
    lin = " # " + var.opcnome + ": " + (arg0 == 1 ? "Sim" : "Não")
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + arg0 + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + (arg0 == 1 ? "1 sim" : "0 não"))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  casose "z"
    sair
  casose "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
      sair
    fimse
  casose
    passo = "simnao"
    se var.opcvalido
      msg("Escolha: 0 não, 1 sim, Z cancela")
    senao
      msg("Escolha: 0 não, 1 sim, N nenhum, Z cancela")
    fimse
    ret 1
  casofim
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_sala # Retorna sala (constante do tipo "const x = $s_abc")
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<" + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<const>"
    senao
      ret txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose "2" # Em uma classe herdada
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<herda " + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<herda const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<herda const>"
    senao
      ret "<herda> " + txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_sala # Alterando a sala
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "sala"
    se var.opcvalido
      msg("Entre com o nome da sala, Z cancela")
    senao
      msg("Entre com o nome da sala, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 nome
    nome = txtmin(txts(arg0))
    se !p.existe("s_" + nome)
      msg("\bSala \"" + nome + "\" não existe, escolha outra.")
      ret 1
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=$s_" + nome)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para " + nome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_atrib # Retorna a quantidade de definições
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 1) != "#" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func p_atrib # Editando atributos
  uint16 linha
  linha = arg0, passo = "atrib"
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg0 == "n" && !var.opcvalido
    prog p
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    passo = var.opcpasso, p_[passo]("\b")
  senao arg0 == "z"
    passo = var.opcpasso, p_[passo]("\b")
  senao txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao arg0 == "o"
    real valor.50
    p_atrib_ler(var.opcclasse, var.opcvar, valor)
    txtmais.limpar
    txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    linhs = 0
    epara t1.addfim(p_atrib_txt), linha < p_atrib_valor, linha += 1
      lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      se valor.[linha]
        txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[linha] + "\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    epara nulo, linha < p_atrib_valor + p_atrib_sim, linha += 1
      lin = "\b\c2" + txt(linha + 1) + "\b." + t1.remove
      se valor.[linha]
        txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    t1.limpar
    epara t1.addfim(misc:atknomes), t1.linhas, linha += 1
      lin = "\b\c2" + txt(linha + 1) + "\b.Danos de " + t1.remove
      se valor.[linha] != 100
        txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[linha] + "%\b")
      senao
        t2.addfim(lin)
      fimse
    efim
    t2.linhas && txtmais.addfim(t2.remove(100))
    txtmostra
  senao txt(linha) != arg0
    msg("Opção inexistente: " + txt1(arg0))
  senao !linha || linha > p_atrib_valor + p_atrib_sim + intsublin(misc:atknomes)
    msg("Opção inexistente: " + txt1(arg0))
  senao
    real valor.50
    p_atrib_ler(var.opcclasse, var.opcvar, valor)
    linha -= 1
    var.opclin = linha
    se linha < p_atrib_valor
      msg(txtsublin(p_atrib_txt, linha, 1) + ": " + valor.[linha])
    senao linha < p_atrib_valor + p_atrib_sim
      valor.[linha] = !valor.[linha]
      txt100 lin
      lin = valor.[linha] ? "Sim" : "Não"
      msg(txtsublin(p_atrib_txt, linha, 1) + " mudou para: " + lin)
      var.opclin = linha
      p_atrib2(valor.[linha])
      ret 1
    senao
      txt100 lin
      lin = txtsublin(misc:atknomes, linha - p_atrib_valor - p_atrib_sim, 1)
      msg("Danos de " + lin + ": " + valor.[linha] + "%")
    fimse
    p_atrib2("\b")
  fimse
  ret 1

func p_atrib2 # Usado por p_atrib; editando um atributo
  real num
  num = arg0, passo = "atrib2"
  se arg0 == "" || arg0 == "\b"
    se var.opclin_ >= p_atrib_valor + p_atrib_sim
      msg("Entre com a porcentagem, 100=não alterar, Z cancela")
    senao
      msg("Entre com a quantidade, 0=não alterar, Z cancela")
    fimse
  senao arg0 == "z"
    var.opclin = "", p_atrib("")
  senao txt(num) != arg0
    msg("Opção inválida, entre com outra")
  senao num < 0 && var.opclin_ >= intsublin(p_atrib_txt)
    msg("A porcentagem não pode ser menor que zero, entre com outra")
  senao
    real valor.50
    p_atrib_ler(var.opcclasse, var.opcvar, valor)
    valor.[var.opclin] = num
    textotxt t
    t.addfim("func " + var.opcvar + " # Altera atributos do personagem")
    t.addfim("# Não alterar; função criada automaticamente")
    (valor.0 || valor.1) && t.addfim("pvidamax+=" + p_atrib2txt(valor.0, valor.1))
    (valor.2 || valor.3) && t.addfim("pmanamax+=" + p_atrib2txt(valor.2, valor.3))
    (valor.4 || valor.5) && t.addfim("pmovemax+=" + p_atrib2txt(valor.4, valor.5))
    (valor.6 || valor.7) && t.addfim("pveloc1+=" + p_atrib2txt(valor.6, valor.7))
    (valor.8 || valor.9) && t.addfim("atknorm+=" + p_atrib2txt(valor.8, valor.9))
    (valor.10 || valor.11) && t.addfim("defnorm+=" + p_atrib2txt(valor.10, valor.11))
    (valor.12 || valor.13) && t.addfim("atkesp+=" + p_atrib2txt(valor.12, valor.13))
    (valor.14 || valor.15) && t.addfim("defesp+=" + p_atrib2txt(valor.14, valor.15))
    (valor.16 || valor.17) && t.addfim("evasao+=" + p_atrib2txt(valor.16, valor.17))
    (valor.18 || valor.19) && t.addfim("precisao+=" + p_atrib2txt(valor.18, valor.19))
    (valor.20 || valor.21) && t.addfim("pesomax+=" + p_atrib2txt(valor.20, valor.21))
    se valor.22 || valor.23 || valor.24
      uint8 x
      valor.22 && (x += 2) # Visão noturna
      valor.23 && (x += 4) # Pode ver invisível
      valor.24 && (x += 8) # Pode ver oculto
      t.addfim("bitver=" + x + "|bitver")
    fimse
    se valor.25 || valor.26 || valor.27
      uint8 x
      valor.25 && (x += 4) # Torna invisível
      valor.26 && (x += 8) # Torna oculto
      valor.27 && (x += 16) # Voando ou flutuando
      t.addfim("bitinv=" + x + "|bitinv")
    fimse
    uint16 total
    uint16 linha
    txt100 lin
    total = intsublin(misc:atknomes) + 28
    epara linha = 28, linha < total, linha += 1
      continuar valor.[linha] == 100
      lin = " # " + txtsublin(misc:atknomes, linha - 28, 1)
      t.addfim("deftipo." + txt(linha - 28) + "*=" + valor.[linha] / 100 + lin)
    efim
# msg("----------\n" + t.ini.textolin(10000) + "\n----------")
    prog p
    p.criar(var.opcclasse, t.remove(10000))
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    var.opclin = "", p_atrib("")
  fimse
  ret 1

func p_atrib2txt # Usado internamente em p_atrib2
# arg0 e arg1 = variáveis
  ret !arg1, txt(arg0) # Exemplo: 5
  ret !arg0, txt(arg1) + "*pnivel" # Exemplo: 10*pnivel
  ret arg0 < 0, txt(arg1) + "*pnivel" + txt(arg0) # Exemplo: 10*pnivel-5
  ret txt(arg1) + "*pnivel+" + txt(arg0) # Exemplo: 10*pnivel+5

const p_atrib_valor = 22 # Quantidade de opções que recebem valor numérico
const p_atrib_sim = 6 # Quantidade de opções que podem ser sim ou não
# Depois disso vem as opções de misc:atknomes, e são em porcentagem
const p_atrib_txt = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Carrega (gramas)\n\
Carrega (gramas) por nível\n\
Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Torna invisível\n\
Torna oculto\n\
Está flutuando"

func p_atrib_ler # Extrai os atributos de uma função
# arg0 = nome da classe
# arg1 = nome da função
# arg2 = variável "real valor.50"
  int8 x
  arg2.limpar
  epara x = p_atrib_valor + p_atrib_sim, x < 50, x += 1
    arg2.[x] = 100
  efim
  prog p
  epara p.inilinha(arg0, arg1), p.lin, p.depois
    casovar txtsub(p.texto, 0, 2)
    casose "pvidamax +="
      p_atrib_ler2(p.texto, arg2.0, arg2.1)
      sair
    casose "pmanamax +="
      p_atrib_ler2(p.texto, arg2.2, arg2.3)
      sair
    casose "pmovemax +="
      p_atrib_ler2(p.texto, arg2.4, arg2.5)
      sair
    casose "pveloc1 +="
      p_atrib_ler2(p.texto, arg2.6, arg2.7)
      sair
    casose "atknorm +="
      p_atrib_ler2(p.texto, arg2.8, arg2.9)
      sair
    casose "defnorm +="
      p_atrib_ler2(p.texto, arg2.10, arg2.11)
      sair
    casose "atkesp +="
      p_atrib_ler2(p.texto, arg2.12, arg2.13)
      sair
    casose "defesp +="
      p_atrib_ler2(p.texto, arg2.14, arg2.15)
      sair
    casose "evasao +="
      p_atrib_ler2(p.texto, arg2.16, arg2.17)
      sair
    casose "precisao +="
      p_atrib_ler2(p.texto, arg2.18, arg2.19)
      sair
    casose "pesomax +="
      p_atrib_ler2(p.texto, arg2.20, arg2.21)
      sair
    casose "bitver ="
      uint8 x
      x = txtsub(p.texto, 2)
      x & 2 && (arg2.22 = 1) # Visão noturna
      x & 4 && (arg2.23 = 1) # Pode ver invisível
      x & 8 && (arg2.24 = 1) # Pode ver oculto
      sair
    casose "bitinv ="
      uint8 x
      x = txtsub(p.texto, 2)
      x & 4 && (arg2.25 = 1) # Torna invisível
      x & 8 && (arg2.26 = 1) # Torna oculto
      x & 16 && (arg2.27 = 1) # Voando ou flutuando
      sair
    casose
      se txt(p.texto, 0, 8) == "deftipo." && txtsub(p.texto, 1, 1) == "*="
        arg2.[int(txt(p.texto, 8)) + 28] = 100 * txtsub(p.texto, 2)
      fimse
    casofim
  efim

func p_atrib_ler2 # Usado internamente em p_atrib_ler
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  se txtsub(arg0, 3, 3) == "* pnivel -"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = -1 * txtsub(arg0, 6)
  senao txtsub(arg0, 3, 2) == "* pnivel"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = txtsub(arg0, 6)
  senao
    arg1 = txtsub(arg0, 2)

func p_func # Editar função
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
  senao
    p_codcomum(arg0, 0)
    passo == "codcomum" && (passo = "func")
  fimse
  ret 1

func p_classe # Editar classe
  var.opcnome = "classe " + var.opcclasse
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
  senao
    p_codcomum(arg0, 1)
    passo == "codcomum" && (passo = "classe")
  fimse
  ret 1

func p_codcomum
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    teditor.limpar
    prog p
    txt100 lin
    passo = "codcomum"
    lin = var.opcclasse + ":" + var.opcvar + ", O opções, Z sair"
# Classe
    se arg1
      msg("Editando classe " + var.opcclasse + ", O opções, Z sair")
      p.inilinha(var.opcclasse)
      teditor.addfim("ARQ:" + p.arquivo(var.opcclasse))
# Variável que não existe
    senao !p.inilinha(var.opcclasse, var.opcvar)
      msg(var.opcnome + ", criando " + lin)
      teditor.addfim("const " + var.opcvar + " = nulo")
# Constante
    senao txt1(p.texto) == "const" && inttotal(p.texto) > 75
      msg(var.opcnome + ", editando " + lin)
      teditor.addfim(txttroca(p.texto, "\\n", "\\n\\\n"))
      p.depois
# Qualquer outra coisa
    senao
      msg(var.opcnome + ", editando " + lin)
    fimse
# Copia o texto para o editor
    enquanto p.lin
      teditor.addfim(txtesp(p.nivel) + p.texto), p.depois
    efim
# Divide linhas grandes acrescentando barra invertida no final
    textopos pos
    int16 n
    int16 x
    epara pos = teditor.ini, pos, pos.depois
      enquanto pos.texto(100, 1)
        n = pos.txtproc("\\n", 60, 1) + 2
        se n < 60 || n > 98
          x = 60
          enquanto x && x < 100
            n = x, x = pos.txtproc(" ", x, 1) + 1
          efim
          n == 60 && (n = 100)
        fimse
        pos.mudar("\\\n", n, 0)
        pos.depois
      efim
    efim
# Acerta variáveis
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    ret 1
  casose "x" # Salvar o texto
    p_funcsalvar(arg1)
    ret 1
  casofim
  ret p_editor(arg0, 16384, var.opcnome)

func p_funcsalvar # Opçao salvar de p_func
  textotxt t1
  textopos p1
  txt512 lin
# Junta linhas e coloca em t1
  t1.ini.add(teditor.ini, teditor.linhas)
  p1 = t1.ini
  enquanto p1.txtproc("\\\n") >= 0
    p1.mudar("", inttotal(p1.texto) - 1, 1) # Tira a "\" no final
    p1.depois, p1.juntar # Junta as duas linhas
  efim
# SOMENTE FUNÇÕES
  se !arg0
# Obtém o nome da constante / função
    lin = t1.ini.texto
    enquanto txt1(lin) == "sav" || txt1(lin) == "comum"
      lin = txt2(lin)
    efim
    se t1.linhas > 1 && txt1(lin) != "func" && txt1(lin) != "varfunc"
      msg("Erro: somente FUNC e VARFUNC podem ter várias linhas")
      ret 1
    fimse
    lin = txt1(txttroca(txt2(lin), "#", " "))
# Checa se o nome mudou
    se lin != var.opcvar
      msg("Erro: mude o nome da variável de " + lin + " para " + var.opcvar)
      ret
    fimse
# Checa existência de outra função ou constante dentro
    p1 = t1.ini.texto
    epara p1.depois, p1.lin, p1.depois
      casovar txtmin(txt1(p1.texto))
      casose "func"
      casose "varfunc"
        msg("Erro: definido uma função dentro de outra")
        ret
      casose "const"
      casose "varconst"
        msg("Erro: definido uma constante dentro de uma função")
        ret
      casofim
    efim
# Tenta salvar
    prog p
    t1.addfim(p.criar(var.opcclasse, t1.remove(10000)))
  senao
# SOMENTE CLASSES
# Tenta salvar
    prog p
    se t1.ini.texto(0, 4) != "ARQ:"
      msg("Primeira linha deve conter o texto \"ARQ:\" seguido do nome do arquivo")
      ret 1
    fimse
    t1.addfim(p.criar(var.opcclasse + "\n" + txt(t1.remove(10000), 4)))
  fimse
# Informa se conseguiu salvar
  se t1.ini.texto == ""
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Salvo com sucesso")
    admlog("editou classe " + var.opcclasse)
    ret
  fimse
# Informa erros, corrigindo os números das linhas
  msg("Erro ao salvar:")
  p1 = t1.ini
  p1.depois(8), p1.remove(1000) # Mantém somente as primeiras mensagens
  uint16 x
  enquanto t1.linhas
    x = lin = t1.remove
    se txt(x) == txt(lin, 0, inttotal(txt(x)))
      p1 = teditor.ini
      enquanto p1.txtproc("\\\n") >= 0 && p1.linha < x
        p1.depois, x += 1
      efim
      lin = txt(x) + txt(lin, inttotal(txt(x)))
    fimse
    msg(lin)
  efim

func p_editor
# Processamento de qualquer editor de texto
# arg0 = texto digitado
# arg1 = quantidade máxima de bytes
# arg2 = nome da opção
# teditor contém o texto, leditor é a linha atual
# Retorna sempre 1
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
  casose "" # Entrou na opção ou apenas pressionou ENTER
    msg("Editando " + arg2 + ", O opções, Z sair")
    ret 1
  casose "." # Insere linha removendo espaços
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txtremove(txt(arg0, 1), "ED"))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "," # Insere linha
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txt(arg0, 1))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "a" # Apaga a linha atual
    se !leditor.lin
      msg("Está no fim do texto")
      ret 1
    fimse
    leditor.remove
    msg(leditor.lin ? "Linha apagada" : "Linha apagada; fim do texto")
    ret 1
  casose "i" # Informações sobre a linha atual
    txt100 t
    t = "Linha " + (leditor.linha + 1) + "/" + teditor.linhas
    t += ", " + inttotal(leditor.texto)
    t += " caracteres, " + teditor.bytes + "/" + arg1 + " bytes"
    msg(t)
    ret 1
  casose "l" # Mostra a linha atual
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  casose "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  casose "o" # Mostra opções do editor
    txtmais.limpar
    txtmais.addfim(m_editor)
    txtmostra
    ret 1
  casose "s" # Sobe uma ou mais linhas
    leditor.linha == 0 && msg("Início do texto")
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.antes, x -= 1
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
      ret !leditor.linha, 1
    efim
    ret 1
  casose "d"
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.depois, x -= 1
      se !leditor.lin
        msg("Fim do texto")
        ret 1
      fimse
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
    efim
    ret 1
  casose "t" # Informações sobre a área de transferência
    se transf.linhas == 0
      msg("Área de transferência vazia")
    senao transf.linhas == 1
      msg("Área de transferência: 1 linha " + transf.bytes + " bytes")
    senao
      msg("Área de transferência: " + transf.linhas + " linhas " + transf.bytes + " bytes")
    fimse
    msg("Bloco linhas " + (leditor1.linha + 1) + " a " + (leditor2.linha + 1))
    ret 1
  casose "p" # Procurar
    txt512 t # Texto após o comando P
    int16 col # Coluna aonde encontrou
    textopos pos # Posição aonde encontrou
    t = txtremove(txt(arg0, 1), "ED")
    se t # Procura texto
      peditor = t, pos = leditor
      col = pos.txtproc(t, 0)
    senao peditor # Procura novamente
      pos = leditor, pos.depois
      col = pos.txtproc(peditor, 0)
    senao # Nada para procurar
      col = -1
    fimse
    se col >= 0
      leditor = pos
      msg("Encontrado linha " + (leditor.linha + 1) + " coluna " + (col + 1))
      msg(leditor.texto)
    senao
      msg("Nada encontrado")
    fimse
    ret 1
  casose "e" # Embelezar o texto
    teditor.addini(txttroca(teditor.remove(10000), "\n", " "))
    teditor.dividelin(57, 77)
    msg("Texto embelezado; voltando à linha 1")
    ret 1
  casose "c" # Mostrar texto com as definições de cores
    textopos pos
    txtmais.limpar
    txtmais.addfim("\bTexto com cores:")
    epara pos = teditor.ini, pos.lin, pos.depois
      txtmais.addfim(txtinvis(pos.texto))
    efim
    txtmostra
    ret 1
  casofim
# Comandos de dois caracteres
  casovar txtmin(arg0)
  casose "bi"
    leditor1 = leditor
    msg("Início de bloco linha " + (leditor1.linha + 1))
    ret 1
  casose "bf"
    leditor2 = leditor
    msg("Fim de bloco linha " + (leditor2.linha + 1))
    ret 1
  casose "ba"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser apagado")
    senao
      leditor1.remove(total)
      se total == 1
        msg("Uma linha apagada")
      senao
        msg(txt(total) + " linhas apagadas")
      fimse
    fimse
    ret 1
  casose "bc"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    se transf.linhas == 1
      msg("1 linha guardada")
    senao
      msg(txt(transf.linhas) + " linhas guardadas")
    fimse
    ret 1
  casose "bx"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    leditor1.remove(total)
    se transf.linhas == 1
      msg("1 linha movida")
    senao
      msg(txt(transf.linhas) + " linhas movidas")
    fimse
    ret 1
  casose "bv"
    se teditor.bytes + transf.bytes > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor1.add(transf.ini, transf.linhas)
    se transf.linhas == 1
      msg("1 linha colada")
    senao
      msg(txt(transf.linhas) + " linhas coladas")
    fimse
    ret 1
  casose "be" # Embelezar o bloco
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser embelezado")
    senao
      textotxt t
      t.addfim(txttroca(leditor1.textolin(total), "\n", " "))
      t.dividelin(57, 77)
      leditor1.remove(total)
      leditor1.add(t.ini, t.linhas)
      leditor2.linha = leditor1.linha + t.linhas - 1
      se total == 1
        msg("Uma linha embelezada")
      senao
        msg(txt(total) + " linhas embelezadas")
      fimse
    fimse
    ret 1
  casose "bl" # Limpar o texto
    teditor.limpar
    msg("Texto apagado")
    ret 1
  casofim
# Checa número de linha
  uint16 lin
  lin = arg0
  se arg0 == lin
    leditor.linha = lin - 1
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  fimse
# Opção desconhecida
  msg("Opção desconhecida: " + txt(arg0, 0, 1))
  msg("Editando " + arg2 + ", O opções, Z sair")
  ret 1

const m_editor = "\b\c3Comandos do editor\b\n\
\c2I\b  Informações sobre a linha atual, quantidade de linhas, etc.\n\
\c2T\b  Informações sobre a área de transferência e o bloco marcado\n\
\c2L\b  Mostra a linha atual\n\
\c2S\b  seguido ou não de um número: Sobe uma ou mais linhas no texto\n\
\c2D\b  seguido ou não de um número: Desce uma ou mais linhas no texto\n\
\c2Um número qualquer:\b  Vai para a linha correspondente\n\
As linhas começam em 1; um número bem grande, vai para o fim do texto\n\
\c2Um ponto seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior\n\
A linha atual avança automaticamente\n\
\c2Uma vírgula seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior, sem remover espaços\n\
Exemplo: vírgula seguido de dois espaços e a letra A insere uma linha\n\
que contém dois espaços e a letra A\n\
\c2A\b  Apaga a linha atual\n\
\c2P\b  seguido de um texto: Procura um texto a partir da linha atual\n\
\c2P\b  Procura a próxima linha que contém o texto\n\
\c2E\b  Embeleza o texto, formatando em até 77 caracteres por linha\n\
\c2C\b  Mostra o texto com as definições de cores\n\
\c2M\b  seguido de um texto: Executa um comando do MUD sem sair da edição\n\
\c2X\b  Salva o texto\n\
\c2Z\b  Encerra a edição\n\
\c2BI\b  Marca início do bloco na linha atual\n\
\c2BF\b  Marca fim de bloco na linha atual\n\
\c2BA\b  Apaga bloco marcado\n\
\c2BC\b  Copia bloco para a área de transferência\n\
\c2BX\b  Move bloco para a área de transferência\n\
\c2BV\b  Insere texto da área de transferência entre a linha atual e a anterior\n\
\c2BE\b  Embeleza o bloco marcado\n\
\c2BL\b  Apaga todo o texto sendo editado"

func infosala # Retorna 1 se pode ser editado como variável tipo "const x = $s_abc"
# arg0=nome da classe, arg1=nome da variável
  prog p
  se p.existe(arg0, arg1) != 1 || !p.inilinha(arg0, arg1)
    ret 1
  senao txt1(p.texto) != "const"
    ret 0
  senao txt(p.texto, 6, inttotal(arg1) + 6) != arg0 + " = $s_"
    ret 0
  senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
    ret 0
  senao
    ret 1


classe admmudou
# Chama uma função de todos os objetos de uma determinada classe
# Modo de usar:
# criar("admmudou", <nome da classe>, <nome da função>)
intexec repete
txt100 nomefunc
listaobj l
ref r

func ini
  repete = 1, nomefunc = arg1
  epara r = $[arg0], r, r = objdepois(r)
    l.addfim(r)
  efim

func repete_exec
  ret !l, apagar(este)
  repete = 1, r = l.objini, l.ini.remove, r.[nomefunc]
