classe comum_persobat
herda comum_perso
# Personagem que pode batalhar
const objmax = 1 # Quantos itens pode carregar
const tipo1 = "normal" # Tipo de personagem
const p_agressivo = 1 # Ataca se atacarem
const p_atktipo = config:atk_txt # Que habilidade usar em ataques automáticos
const p_exp = 100 # Quantidade de experiência que dá, em porcentagem
const p_movervel = 140
const perso = 2 # Para identificar o tipo de personagem
const pesoadd = contr == este && !(bitinv & 48) && !(bitver & 512) # Se falso, está voando
#
const expmax = pnivel * pnivel + 20 # Experiência para subir de nível
sav textotxt p_hist # Histórico do personagem (quem ele matou)
sav uint32 expatual # Experiência atual
sav uint16 pnivel # Nível atual
sav uint32 pvida # Pontos de vida
sav uint32 pmana # Pontos de mana
sav uint32 pmove # Pontos de movimento
uint32 pvidamax # Quantidade máxima de vida
uint32 pmanamax # Quantidade máxima de mana
uint32 pmovemax # Quantidade máxima de movimento
uint16 pveloc1 # Velocidade calculada do personagem
const pveloc = intpos(pveloc1 - int((pesoden - pesoveste) / 1500))
uint32 atknorm # Quantidade de ataque normal, sem modificadores em atktipo
uint32 defnorm # Quantidade de defesa normal, sem modificadores em deftipo
uint32 atkesp # Quantidade de ataque especial, sem modificadores em atktipo
uint32 defesp # Quantidade de defesa especial, sem modificadores em deftipo
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
uint32 pesoveste # Metade do peso de tudo que está vestindo
uint32 pesomax # Quanto peso consegue carregar
#
# const tipo2 = "" # Segundo tipo do personagem
# const tipo3 = "" # Terceiro tipo do personagem
real atktipo.32 # Ataque de ataque para diversos tipos de danos
real deftipo.32 # Defesa contra os diversos tipos de danos
# As duas primeiras variáveis do vetor são golpes normais e especiais
# 1=danos normais e 0=nenhum dano (0.5=metade dos danos, etc.)
# Vide constante config:atknomes
#
listaobj atkrec # Quem atacou esse personagem; dá experiência se perder
listaitem atkenv # Item de atkrec; atkenv.objlista = alvo do personagem
listaobj atkdiv # Para dividir experiência entre personagens que atacaram
listaobj atkbat # Para apagar objetos ao iniciar ou terminar uma batalha
inttempo atktempo # Tempo para completar um turno da batalha
uint8 atkturno # Turno da batalha, usado para decidir se encerra
real atkdanos # Quantos pontos de danos causou no alvo durante a batalha
inttempo p_tempoatu # Tempo para atualizar personagem
inttempo p_proc # Para processar comportamento do personagem
intdec p_tmove # Quanto para se mover novamente

func ini # Objeto foi criado
  comum_perso:ini(arg0, arg1, arg2, arg3, arg4)
  p_restaura = 100
  pvida = pvidamax, pmana = pmanamax, pmove = pmovemax
  persobat = este, persoesc = este

func acertapos # Acerta posição
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  p_imortal && pvida < pvidamax && (pvida = pvidamax) # Imortal
  !p_tempoatu && (p_tempoatu = 100) # Para atualizar o personagem
  casovar pvida * 100 / pvidamax
  casose "0" # Mortalmente ferito ou morto
  casose "1"
    poslugar.remove
    ret !(posicao = pvida > 0) && arg0, morreu
    ret
  casose "2"
    poslugar.remove, posicao = 2 # incapacitado
    ret
  casose "3"
    poslugar.remove, posicao = 3 # fraco
    ret
  casose
    se bitver & 1024
      posicao = 4
    senao atkenv
      poslugar.remove, posicao = 7 # lutando
    senao posicao < 4 || posicao == 7
      poslugar.remove, posicao = pospadr # posição padrão
    fimse
  casofim

func recalc_exec # Ajusta variáveis, principalmente batalha
# Checa subida de nível
  se expatual >= expmax
    int8 num
    enquanto expatual >= expmax
      expatual -= expmax
      pnivel += 1
      var.z_aulas_ += config:aulas
      num += 1
      num >= 5 && (expatual = 0)
    efim
    $mens.o_1 = txtcopiamai(descnome, "A") + (este != contr ? " de " + contr.descnome)
    $mens.mens = pnivel
    $mens.p(este)
    $mens.mtodos2(config:nivelmsg1, config:nivelmsg2)
  fimse
# Acerta atributos básicos
  bitver = 17, bitinv = 3, atribs.limpar
  pesoveste = 0
  atktipo.limpar(1)
  deftipo.limpar(1)
# Acerta atributos conforme o tipo de personagem
  config:atribcfg, recalc_auto
  tipo_[tipo1]:recalc_auto, tipo_[tipo2]:recalc_auto, tipo_[tipo3]:recalc_auto
  tipo_[tipo1]:recalc, tipo_[tipo2]:recalc, tipo_[tipo3]:recalc
  cmd_recalc1(este)
# Bônus conforme o que está vestindo e os efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    [i.obj]:recalc_auto, i.obj.cmd_recalc2(este), pesoveste += iobj.pesotot
  efim
  pesoveste /= 2
  epara i = evento.ini, i, i.depois
    i.obj.cmd_recalc3(este)
  efim
# Acerta atributo dormindo de bitver
  bitver & 2048 && (bitver = bitver & ~1024)
  bitver & 1024 && posicao > 4 && (posicao = 4)
  atribs_exec
# Se for jogador, checa PNJs agressivos
  ret !jog, nulo
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.p_agressivo(este) == 2 && (i.obj.p_proc = 1)
  efim

const batalhaini = contr.bat_ini_int(arg0.contr, este, arg0)
# batalhaini - Indica que atacou outro personagem (está batalhando)
# arg0 = alvo do personagem

func bat_ini_int # Chamado internamente por batalhaini
# Personagem 'arg1' de 'este' quer atacar personagem 'arg2' de 'arg0'
  ret este == arg0, nulo # Não inicia batalha contra o próprio personagem
  se atkenv.objlista != arg0 # Se o alvo do ataque mudou...
    atkenv.remove
    atkenv = arg0.atkrec.addfim(este)
    atkdiv.limpar
    atktempo = config:atktempo, atkturno = 0
    posicao >= 4 && (posicao = 7)
    atkdanos = 1
  fimse
  atkdiv.addfim1(arg1) # Adiciona personagem para ganhar experiência
  se !arg0.atkenv # Se o alvo não está batalhando...
    arg0.atkenv = atkrec.addfim(arg0)
    arg0.atkdiv.limpar
    arg0.atkdiv.addfim(arg2)
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
    arg0.posicao >= 4 && (arg0.posicao = 7)
    arg0.atkdanos = 1
  fimse
  atkturno = arg0.atkturno = 0
  !p_proc && (p_proc = 1)
  arg0.p_proc = 1 # Para gerar evento de PNJs
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 3 && apagar(i.obj)
  efim

const batalhafim = contr.bat_fim_int(arg0)
# batalhafim - Encerra a batalha
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)

func bat_fim_int # Chamado internamente por batalhafim
  atkenv.remove, atktempo = 0, acertapos(arg0)
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 2 && apagar(i.obj)
  efim
  ref r
  enquanto atkrec.ini
    r = atkrec.objini, atkrec.ini.remove, r.atktempo = 0, r.acertapos(arg0)
    epara i = r.atkbat.ini, i, i.depois
      i.obj.e_condicao == 2 && apagar(i.obj)
    efim
  efim

func batalhaexp # Dá experiência a quem estiver atacando o personagem
# arg0 = fator do ganho de experiência
# Nota: não chamar batalhaexp duas vezes seguidas, porque ela altera variáveis
  listaitem i # Para consultar listas
  listaobj l # Personagens que participaram da batalha
  real2 v1
# Preenche a lista, obtém v1=2*danos_totais e acerta variáveis atkdanos
  epara i = contr.atkrec.ini, i, i.depois
    listaitem j
    epara j = i.obj.atkdiv, j, j.obj.pvida ? j.depois : j.removedepois
    efim
    refvar l1 = i.obj.atkdiv
    continuar !l1 # Checa se a lista está vazia
    v1 += i.obj.atkdanos, i.obj.atkdanos /= 1 + l1.total, l.addfim(l1)
  efim
# Ganha experiência
  ret !v1, nulo
  refvar exp1 = arg0 * config:atkexp * (pnivel + 6) / (2000 * v1)
  epara i = l.ini, i, i.depois
    refvar r = i.obj
    v1 = pnivel - r.pnivel
    se v1 < 0 # Atacou nível mais baixo
      v1 = config:atkbexp ? intpos(1 + v1 / config:atkbexp) : 1
    senao v1 # Atacou nível mais alto
      v1 = 1 + (config:atkcexp ? intmin(1, v1 / config:atkcexp) * config:atkmaxexp / 100)
    senao # Mesmo nível
      v1 = 1
    fimse
    r.dono.perso && r.var.z_dono != r.dono.descnome && (v1 *= 1.5)
    r.ganhaexp(v1 * exp1 * p_exp(r) * r.contr.atkdanos)
  efim

func ganhaexp # Personagem ganha experiência
# arg0 = experiência (se negativo perde experiência)
# arg1 = verdadeiro se não deve mostrar mensagem de ganhar XP para o jogador
  refvar exp1 = intpos(int(expatual + arg0)) - expatual
  ret !exp1, nulo
  expatual += exp1
# Mensagem de experiência ganha
  se !arg1
    refvar n1 = este == contr ? "Você" : txtcopiamai(descnome, "A")
    se exp1 > 1
      contr.msg(n1 + " recebe " + exp1 + " pontos de experiência.")
    senao exp1 < -1
      contr.msg(n1 + " perde " + -exp1 + " pontos de experiência.")
    senao exp1 == 1
      contr.msg(n1 + " recebe 1 ponto de experiência.")
    senao exp1 == -1
      contr.msg(n1 + " perde 1 ponto de experiência.")
    fimse
  fimse
# Subir de nível
  expatual >= expmax && (recalc = 1)

func atkauto # Realiza um ataque automático
# arg0 = alvo do ataque
# arg1 = quanto conhece da habilidade (primeiro, segundo ou terceiro ataque)
# Retorna verdadeiro se tentou atacar
  ref obj # Objeto correspondente à habilidade
  real2 aulas # Quanto sabe da habilidade, de 0 a 1
  se iempu.obj && !iempu.obj.armamanual # Ataque com arma
    obj = $cmd_[txtsublin(config:arma_txt, iempu.obj.armatipo, 1)]
    aulas = intpos((arg1 - 1) * (var.[obj.nomevar] - 1) / 49) # Nota: 49=7*7
    refvar obj2 = $cmd_[iempu.obj.armaatk]
    obj2 && (obj = obj2)
  senao # Ataque sem arma
    obj = $cmd_[p_atktipo]
    aulas = intpos(arg1 - 1) / 14 # Primeiro ataque sai com aulas=0.5 (intermediário)
  fimse
  ret int(obj.tipoalvo) != 8, nulo # Retorna se não for ataque automático
  ret !obj.autohab2(este, aulas), nulo # Checa condições para atacar
# ret txt(obj.cmdmenu) != "ataque", nulo # Retorna se comando não é habilidade
  obj.exechab(este, arg0, aulas, pnivel) # Realiza um ataque
  ret 1

func atktempo_exec # Encerra a batalha depois de um tempo
  ret !atkenv, batalhafim(1) # Termina a batalha se não tem um alvo
  atktempo = config:atktempo
  se pvida < p_fugir
# $cmd_fugir.fugir(este)
  senao persobat.atkauto(atkenv.objlista.persobat, 8)
    ret !atkenv || !persobat.var.h_segundo_ataque_, nulo
    debug d
    d.ini, persobat.atkauto(atkenv.objlista.persobat, persobat.var.h_segundo_ataque_)
    ret !atkenv || !persobat.var.h_terceiro_ataque_, nulo
    d.ini, persobat.atkauto(atkenv.objlista.persobat, persobat.var.h_terceiro_ataque_)
    ret
  fimse
  $mens.p(este, atkenv.objlista)
  casovar atkturno += 1
  casose "1"
    ret
  casose "2"
    posicao >= 4 && $mens.mvis1("$P se prepara.")
    ret
  casose "3"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P procura uma brecha.")
    ret
  casose "4"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P encara $a.")
    ret
  casofim
  atkenv.objlista.msg("Batalha encerrada.")
  msg("Batalha encerrada.")
  batalhafim(1)

func restaurar # Restaura personagem (HP, mana, etc.)
  pmana = pmanamax, pmove = pmovemax
  se !pvida && dono.perso
    pvida = pvidamax
    dono.escolhebat # Atualiza persobat
  senao
    pvida = pvidamax

func morreu # Procedimentos quando morre
# arg0 = quem atacou o personagem; pode ser nulo
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  ref corpo # Corpo do personagem morto
# Checa se pode morrer
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este), nulo
  efim
# Histórico
  mortes += 1
  se arg0.perso
    arg0.p_hist.remove(arg0.p_hist.linhas - 9)
    refvar lin = "N" + arg0.pnivel + " x " + este + "(" + nome + ") N" + pnivel
    se este == contr
      arg0.p_hist.addfim(lin)
    senao
      arg0.p_hist.addfim(lin + " de " + contr + "(" + contr.nome + ") N" + contr.pnivel)
    fimse
  fimse
# Jogador: anota no log, perde experiência e transfere jogador para outro lugar
  se jog
    se !arg0.perso
      $misclog.mortes(nome + " N" + pnivel)
    senao arg0.contr.jog
      refvar lin = nome + " N" + pnivel + " por jogador " + arg0.descnome + " N" + arg0.pnivel
      $misclog.mortes(arg0 == arg0.contr ? lin : lin + " de " + arg0.contr.descnome)
    senao
      refvar lin = nome + " N" + pnivel + " por " + arg0.descnome + " N" + arg0.pnivel
      $misclog.mortes(arg0 == arg0.contr ? lin : lin + " de " + arg0.contr.descnome)
    fimse
    pvida = intpos(pvidamax / 2 - 10) + 2
    pmana = pmanamax / 2
    pmove = pmovemax / 2
    p_restaura = rand(100, 130)
    p_sede = intmax($miscfome.cheio / 2, p_sede)
    p_fome = intmax($miscfome.cheio / 2, p_fome)
    p_bebida = p_diges = 0
    casovar config:atkmatoutipo
    casose # Quem atacou ganha experiência como ao matar um PNJ
      batalhaexp(config:atkmatouexp / 100)
      sair
    casose "1" # Transfere experiência para quem atacou
      listaitem i
      epara i = contr.atkrec.ini, i, i.depois
        i.obj.pvida && l.addfim(i.obj.atkdiv)
      efim
      refvar valor = expatual * config:atkmorreuexp * config:atkmatouexp / 10000
      epara i = l.ini, i, i.depois
        i.obj.ganhaexp(valor / l.total)
      efim
      l.limpar
      sair
    casose "2" # Quem atacou perde experiência
      epara l.addfim(contr.atkrec.ini), l, l.ini.remove
        continuar !l.objini.pvida
        l.objini.ganhaexp(l.objini.expatual * config:atkmatouexp / -100)
      efim
      sair
    casofim
    batalhafim # Encerra a batalha
    expatual *= (100 - config:atkmorreuexp) / 100
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    mudadono(config:salafim)
    salvar # Salva o jogo
    !sock && apagar(este) # Sai do jogo se ninguém está controlando o personagem
# Animal do jogador: não dá experiência
  senao dono.jog
    pvida = 0
    p_morreu2 && $mens.p(este) + $mens.mtodos1(p_morreu2)
    dono.escolhebat # Atualiza persobat
# Outro personagem: dá experiência
  senao dono.perso
    pvida = 0, batalhaexp(1.5)
    p_morreu2 && $mens.p(este) + $mens.mtodos1(p_morreu2)
    dono.escolhebat # Atualiza persobat
  senao
    pvida = 0, batalhaexp(1), batalhafim
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    apagar(este)
    ref r
    r = sock, r.mudaperso(nulo), r.reinicia
    p_corpo && (corpo = criar("comum_corpo", este, p_corpo == 2))
    se corpo.var.z_moedas && arg0.jogconfig.10 # Se deve pegar moedas
      refvar moeda = corpo.var.z_moedas == 1 ? "uma moeda" : corpo.var.z_moedas + " moedas"
      $mens.p(arg0)
      $mens.mvis1("$P pega " + moeda + ".")
      arg0.var.z_moedas_ += corpo.var.z_moedas_
      corpo.var.z_moedas = ""
    fimse
  fimse
# Apaga efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    i.obj.e_condicao && apagar(i.obj)
  efim
# Gera eventos
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este)
  efim
  !jog && !dono.perso && mudadono(nulo)
  ret corpo

func escolheatk # Escolhe e retorna o nome da variável de uma habilidade ou magia
  textotxt t # Lista de habilidades e magias
  txt100 t1 # Nome da habilidade ou magia
  t1 = persoesc.var.ini("h_")
  enquanto txt(t1, 0, 2) == "h_"
    refvar r = $cmd_[txt(t1, 2)]
    r.cmdmenu && 8 != r.tipoalvo && t.addfim(t1), t1 = persoesc.var.depois(t1)
  efim
  se !dono.s_semmagia
    t1 = persoesc.var.ini("m_")
    enquanto txt(t1, 0, 2) == "m_"
      refvar r = $magia_[txt(t1, 2)]
      r.cmdmenu && 8 != r.tipoalvo && t.addfim(t1), t1 = persoesc.var.depois(t1)
    efim
  fimse
  t.remove(rand(t.linhas))
  ret t.ini.texto

func escolhejog # Escolhe e retorna um jogador
  listaitem i
  listaobj l
# Obtém a quantidade de jogadores
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.jog && i.obj.visivel(este) && l.addfim(i.obj)
  efim
  ret !l.objini, nulo # Retorna se não tem jogador
# Escolhe um jogador
  i = l.ini, i.depois(rand(l.total))
  ret i.obj

func p_proc_exec # Processar comportamento do personagem
  ret este != contr, nulo # Retorna se pertence a outro personagem
  ret atkenv && pvida < p_fugir, $cmd_fugir.fugir(este) # Tenta fugir da luta
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
  !p_tempoatu && (p_tempoatu = 100)
# Evento do personagem
  ret cmd_pnj_proc, nulo
# Obtém o alvo para realizar um ataque
  ref alvo
  se atkenv # Alvo durante a batalha
    alvo = atkenv.objlista
  senao dono.socktot # Escolhe um jogador como alvo
    listaitem i
    listaobj l
    epara i = dono.dentro2.ini, i, i.depois
      i.obj.jog && p_agressivo(i.obj) == 2 && i.obj.visivel(este) && l.addfim(i.obj)
    efim
    se l.total
      i = l.ini, i.depois(rand(l.total)), alvo = i.obj
    fimse
  fimse
# Realiza um ataque
  se alvo && persobat.pvida && dono.s_luta
    txt100 t1
    t1 = escolheatk # Obtém o nome de um ataque
    se t1 # Ataque manual
      refvar obj = txt(t1, 0, 1) == "m" ? $magia_[txt(t1, 2)] : $cmd_[txt(t1, 2)]
      refvar aulas = intpos(persobat.var.[obj.nomevar] - 1) / 7
      se obj.autohab2(persobat, aulas)
        ret obj.exechab(persobat, alvo.persobat, aulas, persobat.pnivel)
      fimse
    senao !atkenv # Ataque automático
      persobat.atkauto(alvo.persobat, 8)
    fimse
  fimse
# Acerta condição do personagem
# pmove = pmovemax, pmana = pmanamax, pvida < pvidamax && (pvida += 1)
# Checa se é tempo de agir
  ret p_tmove, p_proc = p_tmove + 1
  ret posicao == 7, p_proc = 30
# Come corpos
  se p_comecorpo && posicao >= 5 && (alvo = dono.dentro1.objini("comum_corpo"))
    $mens.p(este, nulo, alvo)
    $mens.mtodos1("$P come $o.")
    alvo.apagar(1)
    p_tmove = rand(70, 130) * p_movervel / 100, p_proc = p_tmove + 1
# Movimenta-se
  senao p_mover && posicao == 8
    textotxt t
    prog p
    misc:obj = este
    refvar r = ref(dono)
    epara p.inifunctudo(r, "dir_"), p.lin, p.depois
      refvar x = ref(r.[p.texto])
      x && x.dentro2.total - x.socktot < x.s_pnj && t.addfim(txt(p.texto, 4))
    efim
    t.remove(rand(t.linhas)) # Para escolher uma direção aleatoriamente
    txt10 dir
    dir = t.ini.texto # Direção escolhida
    ret !dir || p_mover == 1 && r.dir_[dir].s_area != r.s_area, p_proc = 50
    $cmd_[dir].escr(este)
    p_tmove = rand(70, 130) * p_movervel / 100, p_proc = p_tmove + 1
    !p_tempoatu && (p_tempoatu = 100)
  fimse

func p_tempoatu_exec # Atualiza variáveis e salva o jogo de tempos em tempos
  refvar recup = contr.dono.s_recup(este) / 1200
  se recup && pvida
    uint8 x
    pvida < pvidamax && (x = pvida = intmin(pvidamax, intmax(2, pvida + pvidamax * recup)))
    pmana < pmanamax && (x = pmana = intmin(pmanamax, intmax(2, pmana + pmanamax * recup)))
    pmove < pmovemax && (x = pmove = intmin(pmovemax, intmax(2, pmove + pmovemax * recup)))
    x && (p_tempoatu = 100)
    posicao < 4 && acertapos # Se estiver incapacitado, pode voltar a ficar normal


classe comum_persoanimal
herda comum_persobat
# Personagem que pode batalhar e carregar animais
const perso = 3 # Para identificar o tipo de personagem
const objmax = 15 # Quantos itens pode carregar
sav ref persobat # Personagem usado na batalha
sav ref persoesc # Personagem escolhido pelo jogador

func ini
  comum_persobat:ini(arg0, arg1, arg2, arg3, arg4)

func escolhebat # Escolhe um personagem em condições de lutar
  se persoesc.pvida # Checa se personagem escolhido está em condições
    persobat = persoesc
  senao
    listaitem i
    epara i = dentro2.ini, i && !i.obj.pvida, i.depois
    efim
    persobat = i ? i.obj : este

func animalmais # Retorna quantos animais ainda pode adquirir
  uint8 x
  x = config:animal1
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && (x -= 1)) + i.depois
  efim
  ret x

func animaltot # Retorna quantos animais possui
  uint8 x
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && (x += 1)) + i.depois
  efim
  ret x

func animalnum # Retorna o animal a partir do número
# arg0 = número do animal (0 = o próprio personagem)
  int8 x
  x = arg0
  ret !x, este
  listaitem i
  epara i = dentro2.ini, i, i.depois
    sair i.obj.perso && !(x -= 1)
  efim
  ret ref(i.obj)

func p_proc_exec # Processar comportamento do personagem
  ret sock, comum_persobat:p_proc_exec # Checa se está sendo controlado por jogador
  ret p_espera, comum_persobat:p_proc_exec # Checa tempo para agir
# Escolhe animal
  se persoesc == este || !persoesc.pvida
    listaitem i
    epara i = dentro2.ini, i && !i.obj.pvida, i.depois
    efim
    persobat = i ? i.obj : este
    se persoesc != persobat
      persoesc = persobat
      $mens.p(este, persoesc)
      ret persobat != este, $mens.mvis1("$P escolhe $b.")
      ret $mens.mvis1("$P não escolhe ninguém.")
    fimse
  fimse
# Comportamento de PNJ que pode batalhar
  comum_persobat:p_proc_exec
