classe misc
# Miscelânea: tabelas (variáveis) e funções
# Deve ser usado como misc:variável ao invés de $misc.variável
#
# Objeto usado para acessar as saídas das salas
comum ref obj
#
# Objetos usados em misc:separa, misc:sepitem e misc:sepperso
comum txt100 sep1 # Objeto procurado
comum txt100 sep2 # Objeto ou personagem destino
#
# Mensagem conforme o sexo
const sletra0 = "a" # sletra[sexo] = "o" ou "a"
const sletra1 = "o"
const sum0 = "uma" # sum[sexo] = "um" ou "uma"
const sum1 = "um"
#
# Para calcular bônus conforme o tipo
comum real defbonus.255
#
# Hora MUD
comum int1 luz # Se tem luz do dia
comum uint8 hora # Hora MUD (1 dia MUD = 2 horas)
const min = intdiv((3000 - misc:imin) / 50) # Minuto MUD
comum inttempo imin # Usado internamente: quanto tempo para completar 1 hora MUD
#
# Direções
const d1n = "n"
const d1s = "s"
const d1l = "l"
const d1o = "o"
const d1c = "c"
const d1b = "b"
const d1e = "l"
const d1w = "o"
const d1u = "c"
const d1d = "b"
const d1ne = "ne"
const d1no = "no"
const d1se = "se"
const d1so = "so"
const d1nw = "no"
const d1sw = "so"
#
# Direções opostas
const d2n = "s"
const d2s = "n"
const d2l = "o"
const d2o = "l"
const d2c = "b"
const d2b = "c"
const d2e = "o"
const d2w = "l"
const d2u = "b"
const d2d = "c"
const d2ne = "so"
const d2no = "se"
const d2se = "no"
const d2so = "ne"
const d2nw = "se"
const d2sw = "ne"

func equip # Traduz número para lugar aonde está vestindo um item
# Retorna um texto ou "desconhecido" se não for um lugar válido
  casovar arg0
  casose "1"
    ret "como luz"
  casose "2"
    ret "na cabeça"
  casose "3"
    ret "sobre o rosto"
  casose "4"
    ret "nos olhos"
  casose "5"
    ret "nas orelhas"
  casose "6"
    ret "no pescoço"
  casose "7"
    ret "no corpo"
  casose "8"
    ret "sobre o corpo"
  casose "9"
    ret "nas costas"
  casose "10"
    ret "nos braços"
  casose "11"
    ret "nas mãos"
  casose "12"
    ret "no pulso direito"
  casose "13"
    ret "no pulso esquerdo"
  casose "14"
    ret "no dedo direito"
  casose "15"
    ret "no dedo esquerdo"
  casose "16"
    ret "empunhando"
  casose "17"
    ret "escudo"
  casose "18"
    ret "na cintura"
  casose "19"
    ret "nas pernas"
  casose "20"
    ret "calçando"
  casose
    ret "desconhecido"
  casofim

func atktipo # Tipos de golpes
# arg0 = número do golpe
# Retorna: 0=normal, 1=especial
# Nota: a quantidade de tipos está um pouco exagerada
  casovar arg0
  casose "0" # contusão/normal (um golpe de pancada)
  casose "1" # luta (um golpe de alguma arte marcial)
  casose "2" # cortante (ex. faca)
  casose "3" # perfurante (ex. flecha)
    ret 0
  casose "4" # fogo
  casose "5" # água
  casose "6" # gelo
    ret 1
  casose "7" # terra (ex. terremoto)
  casose "8" # pedra (ex. atirar pedras)
  casose "9" # ar/vento/aéreo (ex. furacão)
    ret 0
  casose "10" # luz
  casose "11" # trevas
  casose "12" # elétrico (ex. raio)
  casose "13" # vegetal (ex. planta carnívora)
  casose "14" # psíquico (ex. confusão)
    ret 1
  casose "15" # inseto
  casose "16" # fantasma
  casose "17" # dragão
    ret 0
  casofim
  ret 0 # Tipo desconhecido: golpe normal

func atknome # Retorna o nome do ataque a partir do tipo
  casovar arg0
  casose "0"
    ret "contusão"
  casose "1"
    ret "luta"
  casose "2"
    ret "cortante"
  casose "3"
    ret "perfurante"
  casose "4"
    ret "fogo"
  casose "5"
    ret "água"
  casose "6"
    ret "gelo"
  casose "7"
    ret "terra"
  casose "8"
    ret "pedra"
  casose "9"
    ret "aéreo/vento"
  casose "10"
    ret "luz"
  casose "11"
    ret "trevas"
  casose "12"
    ret "elétrico"
  casose "13"
    ret "vegetal"
  casose "14"
    ret "psíquico"
  casose "15"
    ret "inseto"
  casose "16"
    ret "fantasma"
  casose "17"
    ret "dragão"
  casofim
  ret "desconhecido"

func tipo_normal # Contusão/Normal
  deftipo.1 -= 2 # luta
  deftipo.2 -= 2 # cortante
  deftipo.3 -= 2 # perfurante
  deftipo.16 += 100 # fantasma

func tipo_luta
  deftipo.9 -= 2 # ar
  deftipo.8 += 2 # pedra
  deftipo.11 += 2 # trevas
  deftipo.15 += 2 # inseto

func tipo_cortante
  deftipo.4 -= 2 # fogo
  deftipo.5 -= 2 # água
  deftipo.12 -= 2 # eletricidade
  deftipo.6 += 2 # gelo
  deftipo.8 += 2 # pedra
  deftipo.11 += 2 # trevas

func tipo_perfurante
  deftipo.4 -= 2 # fogo
  deftipo.5 -= 2 # água
  deftipo.12 -= 2 # eletricidade
  deftipo.6 += 2 # gelo
  deftipo.8 += 2 # pedra
  deftipo.11 += 2 # trevas

func tipo_fogo
  deftipo.5 -= 2 # água
  deftipo.7 -= 2 # terra
  deftipo.8 -= 2 # pedra
  deftipo.4 += 2 # fogo
  deftipo.6 += 2 # gelo
  deftipo.13 += 2 # vegetal
  deftipo.15 += 2 # inseto

func tipo_agua
  deftipo.12 -= 2 # elétrico
  deftipo.13 -= 2 # vegetal
  deftipo.4 += 2 # fogo
  deftipo.5 += 2 # água
  deftipo.6 += 2 # gelo

func tipo_gelo
  deftipo.1 -= 2 # luta
  deftipo.4 -= 2 # fogo
  deftipo.8 -= 2 # pedra
  deftipo.2 += 2 # cortante
  deftipo.3 += 2 # perfurante
  deftipo.6 += 2 # gelo

func tipo_terra
  deftipo.4 -= 2 # fogo
  deftipo.5 -= 2 # água
  deftipo.6 -= 2 # gelo
  deftipo.13 -= 2 # vegetal
  deftipo.8 += 2 # pedra
  deftipo.12 += 100 # elétrico

func tipo_pedra
  deftipo.1 -= 2 # luta
  deftipo.5 -= 2 # água
  deftipo.7 -= 2 # terra
  deftipo.13 -= 2 # vegetal
  deftipo.0 += 2 # contusão/normal
  deftipo.2 += 2 # cortante
  deftipo.3 += 2 # perfurante
  deftipo.4 += 2 # fogo
  deftipo.9 += 2 # ar

func tipo_ar
  deftipo.6 -= 2 # gelo
  deftipo.8 -= 2 # pedra
  deftipo.12 -= 2 # elétrico
  deftipo.1 += 2 # luta
  deftipo.13 += 2 # vegetal
  deftipo.15 += 2 # inseto
  deftipo.7 += 100 # terra

func tipo_luz
  deftipo.13 -= 2 # vegetal
  deftipo.16 -= 2 # fantasma
  deftipo.10 += 2 # luz
  deftipo.11 += 2 # trevas
  deftipo.14 += 100 # psíquico

func tipo_trevas
  deftipo.10 -= 2 # luz
  deftipo.11 -= 2 # trevas
  deftipo.16 -= 2 # fantasma
  deftipo.1 += 2 # luta
  deftipo.15 += 2 # inseto
  deftipo.14 += 100 # psíquico

func tipo_eletrico
  deftipo.7 -= 2 # terra
  deftipo.9 += 2 # ar
  deftipo.12 += 2 # elétrico

func tipo_vegetal
  deftipo.2 -= 2 # cortante
  deftipo.4 -= 2 # fogo
  deftipo.6 -= 2 # gelo
  deftipo.9 -= 2 # ar
  deftipo.15 -= 2 # inseto
  deftipo.5 += 2 # água
  deftipo.7 += 2 # terra
  deftipo.10 += 2 # luz
  deftipo.12 += 2 # elétrico
  deftipo.13 += 2 # vegetal

func tipo_psiquico
  deftipo.1 -= 2 # luta
  deftipo.11 -= 2 # trevas
  deftipo.14 -= 2 # psíquico
  deftipo.11 += 2 # trevas
  deftipo.15 += 2 # inseto
  deftipo.16 += 2 # fantasma

func tipo_inseto
  deftipo.4 -= 2 # fogo
  deftipo.9 -= 2 # ar
  deftipo.8 -= 2 # pedra
  deftipo.1 += 2 # luta
  deftipo.7 += 2 # terra
  deftipo.13 += 2 # vegetal

func tipo_fantasma
  deftipo.16 -= 2 # fantasma
  deftipo.10 -= 2 # luz
  deftipo.11 -= 2 # trevas
  deftipo.15 += 2 # inseto
  deftipo.0 += 100 # contusão/normal
  deftipo.1 += 100 # luta
  deftipo.2 += 100 # cortante
  deftipo.3 += 100 # perfurante

func tipo_dragao
  deftipo.6 -= 2 # gelo
  deftipo.17 -= 2 # dragão
  deftipo.3 += 2 # perfurante
  deftipo.4 += 2 # fogo
  deftipo.5 += 2 # água
  deftipo.12 += 2 # elétrico
  deftipo.13 += 2 # vegetal

func separa # Separa o nome do objeto do nome do destino
# arg0 = texto completo
# Faz: misc:sep1 = objeto procurado, misc:sep2 = alvo
  txt200 x
  x = txtremove(arg0, "EMDSA")
  casovar intsub(x)
  casose "0"
  casose "1"
    misc:sep1 = x
    misc:sep2 = ""
    ret
  casose "2"
    se txt1(x) != int(txt1(x))
      misc:sep1 = txt1(x)
      misc:sep2 = txt2(x)
    senao
      misc:sep1 = x
      misc:sep2 = ""
    fimse
    ret
  casose "3"
    misc:sep1 = txtsub(x, 0, 2)
    misc:sep2 = txtsub(x, 2)
    ret
  casose
    uint8 tam
    tam = intsub(arg0) - 1
    misc:sep1 = txtsub(x, 0, tam)
    misc:sep2 = txtsub(x, tam)
  casofim

func sepitem # Procura o item destino
# arg0 = personagem, misc:sep2 = nome do alvo
# Retorna: o alvo ou nulo se não encontrar
  listaitem i
  nomeobj n
  n.ini(misc:sep2, 1)
  epara i = arg0.dentro1.ini, i, i.depois
    ret i.obj.visivel(arg0) && n.nome(i.obj.ident), i.obj
  efim
  epara i = arg0.dono.dentro1.ini, i, i.depois
    ret i.obj.visivel(arg0) && n.nome(i.obj.ident), i.obj
  efim

func sepperso # Procura o personagem destino
# arg0 = personagem, misc:sep2 = nome do alvo
# Retorna: o alvo ou nulo se não encontrar
  listaitem i
  nomeobj n
  n.ini(misc:sep2, 1)
# epara i = arg0.dentro2.ini, i, i.depois
# ret i.obj.visivel(arg0) && n.nome(i.obj.ident), i.obj
# efim
  epara i = arg0.dono.dentro2.ini, i, i.depois
    ret i.obj.visivel(arg0) && n.nome(i.obj.ident), i.obj
  efim

func iniclasse # Inicialização
# Inicia contagem de tempo hora MUD
  misc:imin = 3000
# Obtém os valores de defbonus
  real r # Valor inicial é 2 elevado a -64
  uint16 x
  r = 1 / 65536, r = r * r * r * r
  enquanto x < 256
    misc:defbonus.[x] = r
    misc:defbonus.[x + 1] = r * 1.414213562
    x += 2, r *= 2
  efim

func imin_exec # Atualiza hora MUD
  misc:imin = 3000 # 60 minutos * 60 segundos * 10 décimos / 12
  misc:hora = (misc:hora + 1) % 24
  misc:luz = misc:hora >= 6 && misc:hora < 18
  arqsav sav
  misc:hora == 0 && sav.limpar(".") # Limpa jogos antigos

func salacriar # Cria um objeto na sala se não houver outro igual
# arg0 a arg3 = argumentos do personagem, sem incluir o dono do personagem
# Retorna: objeto criado, ou nulo se não foi criado
  se txt(arg0)
    ref r
    epara r = este, r.dono, r = r.dono
    efim
    ret r.dentro1.objini(arg0) || r.dentro2.objini(arg0), nulo
    ret criar(arg0, r, arg1, arg2, arg3)

func evento # Objeto passa a receber eventos até um objeto mudar de sala
# arg0 a arg2 = objetos cujos eventos serão recebidos
  se ref(arg0)
    ref r
    r = criar("evrecebe")
    r.perso1 = arg0.evento.addfim(este, r)
    r.perso2 = arg1.evento.addfim(este, r)
    r.perso3 = arg2.evento.addfim(este, r)

func tempo # Eventos de tempo (cria objeto), vide classe evtempo
  se txt(arg0) && ref(arg1)
    ref r
    r = criar("evtempo")
    r.tempo1 = r.tempo2 = 1
    r.obj = este
    r.func = arg0
    r.tfunc = inttotal(arg0)
    r.perso1 = arg1, r.perso1.evento.addfim(r)
    r.perso2 = arg2, r.perso2.evento.addfim(r)
    r.perso3 = arg3, r.perso3.evento.addfim(r)


classe evrecebe
listaitem perso1 # Primeiro personagem
listaitem perso2 # Segundo personagem
listaitem perso3 # Terceiro personagem

func fim # Este objeto foi apagado
# Só para garantir, também chama aqui perso.remove
  perso0.remove, perso1.remove, perso2.remove, perso3.remove

func cmd_saiu # Personagem saiu da sala
  perso0.remove, perso1.remove, perso2.remove, perso3.remove
  apagar(este)

func cmd_fim # Personagem saiu do jogo
  perso0.remove, perso1.remove, perso2.remove, perso3.remove
  apagar(este)


classe evtempo
# Processa eventos de tempo
#
# Deve ser criado com:
# misc:tempo("nome da função", personagens)
# É permitido até 3 personagens.
# Se um dos personagens mudar de sala, o evento é encerrado.
#
# Resultado: são executadas as funções cujo nome é o nome
# especificado seguido do tempo decorrido, em décimos de segundo
# A função com o nome especificado seguido de "0" é executada
# quando o objeto for apagado.
#
# Na função:
# arg0 a arg2 = personagens
# arg3 = objeto evtempo
#
inttempo tempo1 # Para gerar eventos de tempo
uint32 tempo2 # tempo2-tempo1 = Tempo decorrido
txt100 func # Nome da função que deve chamar
uint8 tfunc # Tamanho de func em caracteres
ref obj # Objeto que contém a função
ref perso1 # Primeiro personagem
ref perso2 # Segundo personagem
ref perso3 # Terceito personagem
const cmd_saiu = apagar(este) # Personagem saiu da sala
const cmd_fim = apagar(este) # Personagem saiu do jogo

func fim # Este objeto foi apagado
  obj.[func]0(perso1, perso2, perso3, este)

func tempo1_exec # Executa eventos
  ret !obj, apagar(este)
  prog p
  uint32 x
  uint32 v
  x = 1000000
  epara p.inifunc(obj, func), p.lin, p.depois
    v = txt(p.texto, tfunc)
    v > tempo2 && v < x && (x = v)
  efim
  x == 1000000 && apagar(este)
  v = tempo2
  tempo1 = x - tempo2
  tempo2 = x
  obj.[func + v](perso1, perso2, perso3, este)
