classe area
inttempo reset # Para executar reset quando a área é criada
inttempo resetcont # Tempo para o próximo reset
intexec resetcheca # Para acertar tempo do próximo reset, após mudar a área

func iniclasse
  arg0 != "area" && criar(arg0)

func ini
  reset = 1

func reset_exec # Executa o reset da área
  resetcont = rand(a_tempo * 500, a_tempo * 700)
  prog p
  uint16 x
  debug d
# Reset da área
  x = d.exec
  epara p.iniherdainv("b_" + arg0), p.lin, p.depois
    $[p.texto].a_reset1, d.exec = x
# $[p.texto].a_reset && $reset.sala($[p.texto], $[p.texto].a_reset)
  efim
# Avisa jogadores
  txt100 mres
  mres = a_txtreset
  se mres
    indiceitem i
    ref r
    epara i.ini("un "), txt1(i.txt) == "un", i.depois
      epara r = i.obj.perso.dono, r.dono, r = r.dono
      efim
      "a_" + r.s_area == este && r.msg(mres)
    efim

func resetcont_exec
  resetcont = rand(a_tempo * 500, a_tempo * 700)
  ret !a_reset, nulo # Retorna se modo de reset é nunca
  se a_reset == 1 # Checa reset quando não há jogadores
    prog p
    epara p.iniherdainv("b_" + txt(este, 2)), p.lin, p.depois
      ret $[p.texto].socktot, nulo
    efim
  fimse
  reset_exec # Realiza o reset

func resetcheca_exec
  se resetcont <= 0 || resetcont >= a_tempo * 700
    resetcont = a_tempo * 700


classe sala
herda comum_obj
# Estrutura de uma sala
#
const s_titulo = "Sem nome"
const s_item = 5 # Quantos minutos para começar a apagar itens
inttempo t_item # Tempo para começar a apagar itens da sala
const s_pnj = 1 # PNJs podem entrar
#
uint8 porta_n # Tipo de saída
uint8 porta_s # Tipo de saída
uint8 porta_l # Tipo de saída
uint8 porta_o # Tipo de saída
uint8 porta_c # Tipo de saída
uint8 porta_b # Tipo de saída
uint8 porta_ne # Tipo de saída
uint8 porta_no # Tipo de saída
uint8 porta_se # Tipo de saída
uint8 porta_so # Tipo de saída

func iniclasse
  criar(arg0)

func ini # Objeto foi criado: inicializa variáveis
  porta_n = portaini_n
  porta_s = portaini_s
  porta_l = portaini_l
  porta_o = portaini_o
  porta_c = portaini_c
  porta_b = portaini_b
  porta_ne = portaini_ne
  porta_no = portaini_no
  porta_se = portaini_se
  porta_so = portaini_so
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)

func fim # Objeto foi apagado
  ref r
  r = dono, comum_obj:fim, cmd_fim(r)

func msg # Mensagem para todos da sala
  se socktot
    listaitem i
    epara i = dentro2.ini, i, i.depois
      i.obj.msg(arg0)
    efim

func t_item_exec # Começar a apagar objetos
  se !socktot && s_item # Se pode apagar itens
    telatxt t
    t.msg("APAGAR\n")
    listaitem i
    epara i = dentro1.fim, i, i.antes
      continuar i.obj.mantersala
      apagar(i.obj)
      epara i.antes, i, i.antes
        ret !i.obj.mantersala, t_item = 300 # 30 segundos para apagar o próximo
      efim
      ret
    efim

func descsala # Retorna descrição da sala
# arg0 = objeto que está vendo a descrição
# arg1: +1 se mostra descrição completa, +2 se mostra saídas, +4 se mostra itens
  textotxt t
  casovar 3 & arg0.bitver
  casose "0"
  casose "2"
    t.addfim("Você está ceg" + $mens.sexoA[arg0.sexo] + ".")
    sair
  casose "1"
    t.addfim("Está escuro...")
    sair
  casose
# t.addfim("\b\c6" + txt(este, 2) + " " + s_titulo(arg0) + "\b")
    t.addfim("\b\c6" + s_titulo(arg0) + "\b")
    t.bytes <= 5 && t.limpar
    arg1 & 1 && t.addfim(s_desc(arg0))
    arg1 & 2 && t.addfim(txtsai(arg0))
  casofim
  se arg1 & 4
    textotxt t2
    listaobj l
    l.addfim(dentro2, dentro1)
    l.remove(arg0)
    enquanto l
      l.objini.visivel(arg0) && t2.addfim(txt(l.objini.objtot) + " " + l.objini.descpos)
      l.ini.remove
    efim
    t2.juntalin("(", "x)")
    t.fim.add(t2.ini, t2.linhas)
  fimse
  ret t.remove(1000)

func txtsai # Retorna as saídas existentes
  txt40 sai
  misc:obj = arg0
  sai = "" + tsai2("n") + tsai2("s") + tsai2("l") + tsai2("o")
  sai = sai + tsai2("ne") + tsai2("no") + tsai2("se")
  sai = sai + tsai2("so") + tsai2("c") + tsai2("b")
  ret sai ? "\bSaídas:" + sai : "\bSaídas: Nenhuma"

func tsai2 # Para mostrar as saídas existentes
  se dir_[arg0] && !inv_[arg0]
    casovar int(porta_[arg0])
    casose "0"
    casose "1"
      ret " " + arg0
    casose
      ret " !" + arg0
    casofim

func mudaporta # Muda estado de uma saída; variável porta_[arg0]
# arg0 = nome da saída (até duas letras)
# arg1 = novo valor
# Retorna: 0=saída inexistente, 1=saída foi alterada
  ref r
  ret !(r = dir_[arg0]), 0
  txt10 nome
  nome = misc:d2[arg0]
  r.dir_[nome] == este && r.porta_[nome] == porta_[arg0] && (r.porta_[nome] = arg1)
  porta_[arg0] = arg1
  ret 1

func totalmove # Quantos movimentos consome, conforme o terreno
  casovar int(s_terreno)
  casose "0" # Dentro
    ret 1
  casose "1" # Rua de uma cidade
    ret 1
  casose "2" # Campo
    ret 2
  casose "3" # Pântano
    ret 3
  casose "4" # Floresta densa
    ret 3
  casose "5" # Colina
    ret 4
  casose "6" # Montanha
    ret 6
  casose "7" # Água pode nadar
    ret 4
  casose "8" # Água requer barco
    ret 1
  casose "9" # Em baixo d'água
    ret 5
  casose "10" # Ar
    ret 1
  casofim
  ret 1
# const s_titulo = descr0
# const dir_l = dir_e
# onst dir_o = dir_w
# const dir_c = dir_u
# const dir_b = dir_d
# const dir_so = dir_sw
# const dir_no = dir_nw
# func s_desc
# textotxt t
# uint16 x
# enquanto descr[x += 1]
# t.addfim(descr[x])
# efim
# ret t.remove(1000)
