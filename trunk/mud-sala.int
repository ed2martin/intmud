classe area
func iniclasse
  criar(arg0)

classe sala
herda comum_dentro
# Estrutura de uma sala
#
const s_item = 5 # Quantos minutos para começar a apagar itens
inttempo t_item # Tempo para começar a apagar itens da sala
#
uint8 tipo_n # Tipo de saída
uint8 tipo_s # Tipo de saída
uint8 tipo_l # Tipo de saída
uint8 tipo_o # Tipo de saída
uint8 tipo_c # Tipo de saída
uint8 tipo_b # Tipo de saída
uint8 tipo_ne # Tipo de saída
uint8 tipo_no # Tipo de saída
uint8 tipo_se # Tipo de saída
uint8 tipo_so # Tipo de saída

func iniclasse
  criar(arg0)

func ini # Inicializa variáveis
  tipo_n = tipoini_n
  tipo_s = tipoini_s
  tipo_l = tipoini_l
  tipo_o = tipoini_o
  tipo_c = tipoini_c
  tipo_b = tipoini_b
  tipo_ne = tipoini_ne
  tipo_no = tipoini_no
  tipo_se = tipoini_se
  tipo_so = tipoini_so

func t_item_exec # Começar a apagar objetos
  se !jogtot && s_item # Se pode apagar itens
    listaitem item
    item = dentro.fim
    enquanto item
      se item.obj.item # Checa se é um item que pode apagar
        apagar(item.obj)
        t_item = 300 # 30 segundos para apagar o próximo
        ret
      fimse
      item.antes
    efim

func entrou # Entrou na sala; arg0=objeto do jogador

func descsala # Retorna descrição da sala
# arg0 = objeto que está vendo a descrição
# arg1: +1 se mostra descrição completa, +2 se mostra saídas, +4 se mostra itens
  textotxt t
  casovar 3 & arg0.bitver
  casose "0"
  casose "2"
    t.addfim("Você está ceg" + $mens.sexoA[arg0.sexo] + ".")
  casose "1"
    t.addfim("Está escuro...")
  casose
    #t.addfim("\b\c6" + txt(este, 2) + " " + s_titulo + "\b")
    t.addfim("\b\c6" + s_titulo + "\b")
    (arg1 & 1) && t.addfim(s_desc)
    (arg1 & 2) && t.addfim(txtsai)
  casofim
  se arg1 & 4
    textotxt t2
    listaobj l
    l.addfim(dentro)
    l.remove(arg0)
    enquanto l
      !(~arg0.bitver & l.ini.obj.bitinv) && t2.addfim("1 " + l.ini.obj.descpos)
      l.ini.remove
    efim
    t2.juntalin("(", "x) ")
    t.fim.add(t2.ini, t2.linhas)
  fimse
  ret t.remove(1000)

func txtsai # Retorna as saídas existentes
  txt40 sai
  sai = "" + tsai2("n") + tsai2("s") + tsai2("l") + tsai2("o")
  sai = sai + tsai2("ne") + tsai2("no") + tsai2("se")
  sai = sai + tsai2("so") + tsai2("c") + tsai2("b")
  se sai
    ret "\bSaídas:" + sai
  senao
    ret "\bSaídas: Nenhuma"

func tsai2 # Para mostrar as saídas existentes
  se dir_[arg0] && !inv_[arg0]
    casovar int(tipo_[arg0])
    casose "0"
    casose "1"
      ret " " + arg0
    casose
      ret " !" + arg0
    casofim

func mudatipo # Muda estado de uma saída; variável tipo_[arg0]
# arg0 = nome da saída (duas letras)
# arg1 = novo valor
# Retorna: 0=saída inexistente, 1=saída foi alterada
  ref r
  se !(r = dir_[arg0])
    ret 0
  fimse
  r.dir_n == este && r.tipo_n == tipo_[arg0] && (r.tipo_n = arg1)
  r.dir_s == este && r.tipo_s == tipo_[arg0] && (r.tipo_s = arg1)
  r.dir_l == este && r.tipo_l == tipo_[arg0] && (r.tipo_l = arg1)
  r.dir_o == este && r.tipo_o == tipo_[arg0] && (r.tipo_o = arg1)
  r.dir_c == este && r.tipo_c == tipo_[arg0] && (r.tipo_c = arg1)
  r.dir_b == este && r.tipo_b == tipo_[arg0] && (r.tipo_b = arg1)
  r.dir_ne == este && r.tipo_ne == tipo_[arg0] && (r.tipo_ne = arg1)
  r.dir_no == este && r.tipo_no == tipo_[arg0] && (r.tipo_no = arg1)
  r.dir_se == este && r.tipo_se == tipo_[arg0] && (r.tipo_se = arg1)
  r.dir_so == este && r.tipo_so == tipo_[arg0] && (r.tipo_so = arg1)
  tipo_[arg0] = arg1
  ret 1

#const s_titulo = descr0
#const dir_l = dir_e
#onst dir_o = dir_w
#const dir_c = dir_u
#const dir_b = dir_d
#const dir_so = dir_sw
#const dir_no = dir_nw
#func s_desc
#  textotxt t
#  uint16 x
#  enquanto descr[x += 1]
#    t.addfim(descr[x])
#  efim
#  ret t.remove(1000)
