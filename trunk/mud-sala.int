classe area
inttempo reset # Para executar reset quando a área é criada
inttempo resetcont # Tempo para o próximo reset
intexec resetcheca # Para acertar tempo do próximo reset, após mudar a área

func iniclasse
  arg0 != "area" && criar(arg0)

func ini
  reset = 1

func reset_exec # Executa o reset da área
  resetcont = rand(a_tempo * 500, a_tempo * 700)
  prog p
  uint16 x
  debug d
# Reset da área
  x = d.exec
  epara p.iniherdainv("b_" + txt(este, 2)), p.lin, p.depois
    $[p.texto].a_reset1, d.exec = x
  efim
# Avisa jogadores
  txt100 mres
  mres = a_txtreset
  se mres
    indiceitem i
    ref r
    epara i.ini("un "), txt1(i.txt) == "un", i.depois
      epara r = i.obj.perso.dono, r.dono, r = r.dono
      efim
      "a_" + r.s_area == este && i.obj.msg(mres)
    efim

func resetcont_exec
  resetcont = rand(a_tempo * 500, a_tempo * 700)
  ret !a_reset, nulo # Retorna se modo de reset é nunca
  se a_reset == 1 # Checa reset quando não há jogadores
    prog p
    epara p.iniherdainv("b_" + txt(este, 2)), p.lin, p.depois
      ret $[p.texto].socktot, nulo
    efim
  fimse
  reset_exec # Realiza o reset

func resetcheca_exec
  se resetcont <= 0 || resetcont >= a_tempo * 700
    resetcont = a_tempo * 700


classe sala
herda comum_obj
# Estrutura de uma sala
#
const s_titulo = "Sem nome"
const s_item = 5 # Quantos minutos para começar a apagar itens
inttempo t_item # Tempo para começar a apagar itens da sala
const s_pnj = 10 # Quantidade máxima de PNJs na sala
const s_noite = s_desc(arg0) # Inicialmente descrição de noite e de dia são iguais
const s_recup = 100 # Taxa de recuperação de vida, mana e movimentos
const s_gritar = s_falar # Mensagem ao gritar; se estiver vazia, pode gritar
#
uint8 porta_n # Tipo de saída
uint8 porta_s # Tipo de saída
uint8 porta_l # Tipo de saída
uint8 porta_o # Tipo de saída
uint8 porta_c # Tipo de saída
uint8 porta_b # Tipo de saída
uint8 porta_ne # Tipo de saída
uint8 porta_no # Tipo de saída
uint8 porta_se # Tipo de saída
uint8 porta_so # Tipo de saída
uint8 porta_entrar # Tipo de saída
uint8 porta_sair # Tipo de saída
#
# Ordem que deve organizar as constantes:
const admordem = "s_titulo\n\
s_desc\n\
s_noite\n\
s_falar\n\
s_fome\n\
s_item\n\
s_luta\n\
s_luz\n\
s_morre\n\
s_naoresg\n\
s_ocultar\n\
s_pnj\n\
s_recup\n\
s_reserva\n\
s_semmagia\n\
s_soltar\n\
s_retornar\n\
s_terreno\n\
volmax\n\
objmax\n\
eveste\n\
dir_n portaini_n portanome_n portaartigo_n fechadura_n\n\
fugir_n inv_n fecha_n tranc_n voar_n\n\
dir_s portaini_s portanome_s portaartigo_s fechadura_s\n\
fugir_s inv_s fecha_s tranc_s voar_s\n\
dir_l portaini_l portanome_l portaartigo_l fechadura_l\n\
fugir_l inv_l fecha_l tranc_l voar_l\n\
dir_o portaini_o portanome_o portaartigo_o fechadura_o\n\
fugir_o inv_o fecha_o tranc_o voar_o\n\
dir_c portaini_c portanome_c portaartigo_c fechadura_c\n\
fugir_c inv_c fecha_c tranc_c voar_c\n\
dir_b portaini_b portanome_b portaartigo_b fechadura_b\n\
fugir_b inv_b fecha_b tranc_b voar_b\n\
dir_ne portaini_ne portanome_ne portaartigo_ne fechadura_ne\n\
fugir_ne inv_ne fecha_ne tranc_ne voar_ne\n\
dir_no portaini_no portanome_no portaartigo_no fechadura_no\n\
fugir_no inv_no fecha_no tranc_no voar_no\n\
dir_se portaini_se portanome_se portaartigo_se fechadura_se\n\
fugir_se inv_se fecha_se tranc_se voar_se\n\
dir_so portaini_so portanome_so portaartigo_so fechadura_so\n\
fugir_so inv_so fecha_so tranc_so voar_so\n\
dir_entrar portaini_entrar portanome_entrar portaartigo_entrar fechadura_entrar\n\
fugir_entrar inv_entrar fecha_entrar tranc_entrar voar_entrar\n\
dir_sair portaini_sair portanome_sair portaartigo_sair fechadura_sair\n\
fugir_sair inv_sair fecha_sair tranc_sair voar_sair"

func iniclasse
  criar(arg0)

func ini # Objeto foi criado: inicializa variáveis
  porta_n = portaini_n
  porta_s = portaini_s
  porta_l = portaini_l
  porta_o = portaini_o
  porta_c = portaini_c
  porta_b = portaini_b
  porta_ne = portaini_ne
  porta_no = portaini_no
  porta_se = portaini_se
  porta_so = portaini_so
  porta_entrar = portaini_entrar
  porta_sair = portaini_sair
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)

func msg # Mensagem para todos da sala
  se socktot
    listaitem i
    epara i = dentro2.ini, i, i.depois
      i.obj.msg(arg0)
    efim

func t_item_exec # Começar a apagar objetos
  se !socktot && s_item # Se pode apagar itens
    listaitem i
    epara i = dentro1.fim, i, i.antes
      continuar i.obj.mantersala
      apagar(i.obj)
      t_item = 300 # 30 segundos para apagar o próximo
      ret
    efim
    var.z_moedas = "" # Por último apaga as moedas

func visivel # Informa se a sala está visível (arg0=quem quer ver)
# Se retornar 0, significa que não está visível. Nesse caso, para saber
# se o motivo é estar cego, checar: !(1 & arg0.bitver)
  casovar 3 & arg0.bitver
  casose "0" # Está cego
  casose "2" # Está cego
    ret 0
  casose "1" # Não enxerga no escuro
    casovar s_luz
    casose "2" # Pode estar escuro
      ret misc:luz || luzden
    casose "3" # Está escuro
      ret luzden != 0
    casose # Está claro
      ret 1
    casofim
  casose # Enxerga no escuro
    ret 1
  casofim

func descsala # Retorna descrição da sala
# arg0 = objeto que está vendo a descrição
# arg1: +1 se mostra descrição completa, +2 se mostra saídas, +4 se mostra itens
  textotxt t
  se visivel(arg0)
# t.addfim("\b\c6" + txt(este, 2) + " " + s_titulo(arg0) + "\b")
    t.addfim("\b\c6" + s_titulo(arg0) + "\b")
    t.bytes <= 5 && t.limpar
    se arg1 & 1
      refvar r1 = ref($mens.contr)
      refvar r2 = ref($mens.perso)
      $mens.contr = $mens.perso = arg0
      t.addfim($mens.proc(misc:luz ? s_desc(arg0) : s_noite(arg0), arg0))
      $mens.contr = r1
      $mens.perso = r2
    fimse
    arg1 & 2 && t.addfim(txtsai(arg0))
    arg1 & 4 && var.z_moedas && t.addfim("Aqui há " + misc:txtmoedas(var.z_moedas) + ".")
  senao 1 & arg0.bitver
    t.addfim("Está escuro...")
  senao
    t.addfim("Você está ceg" + (arg0.msexo ? "o" : "a") + ".")
  fimse
  se arg1 & 4
    textotxt t2
    listaobj l
    l.addfim(dentro1, dentro2)
    l.remove(arg0)
    ref r
    enquanto l
      r = l.fim.obj, l.fim.remove
      continuar !r.visivel(arg0)
      refvar n = r.atribs.linhas ? " (" + txttroca(r.atribs.ini.textolin(100), "\n", " ") + ") " \
: " "
      t2.addfim(txt(r.objtot) + n + r.descpos)
    efim
    t2.juntalin("(", "x)")
    t.fim.add(t2.ini, t2.linhas)
  fimse
  ret t.remove(1000)

func txtsai # Retorna as saídas existentes
  txt40 sai
  misc:obj = arg0
  sai = "" + tsai2("n") + tsai2("s") + tsai2("l") + tsai2("o")
  sai = sai + tsai2("ne") + tsai2("no") + tsai2("se") + tsai2("so")
  sai = sai + tsai2("c") + tsai2("b") + tsai2("entrar") + tsai2("sair")
  ret sai ? "\bSaídas:" + sai : "\bSaídas: Nenhuma"

func tsai2 # Para mostrar as saídas existentes
  se dir_[arg0] && !inv_[arg0]
    casovar int(porta_[arg0])
    casose "0"
    casose "1"
      ret " " + arg0
    casose
      ret " !" + arg0
    casofim

func mudaporta # Muda estado de uma saída; variável porta_[arg0]
# arg0 = nome da saída (até duas letras)
# arg1 = novo valor
# arg2 = mensagem enviada para a própria sala, da mesma forma que $mens.mtodos1
# arg3 = mensagem enviada para a sala vizinha, da mesma forma que $mens.mtodos1
# Nas mensagens: $m=nome da porta, $1=abriu ou abriram, $2=fechou ou fecharam
# Retorna: 0=saída inexistente, 1=saída foi alterada
  ref r
  ret !(r = dir_[arg0]), 0 # Retorna se a saída não é uma sala
  refvar nome = misc:d2[arg0]
  se r.dir_[nome] == este && r.porta_[nome] == porta_[arg0]
    r.porta_[nome] = arg1
    se arg3 && r.socktot
      txt200 mporta
      mporta = r.portanome_[nome]
      !mporta && !(mporta = $cmd_[nome].m_porta) && (mporta = "uma porta")
      $mens.mens = mporta
      se r.portaartigo_[nome] & 1
        $mens.o_1 = "abriram", $mens.o_2 = "fecharam"
      senao
        $mens.o_1 = "abriu", $mens.o_2 = "fechou"
      fimse
      listaobj l
      epara l.addfim(r.dentro2), l, l.ini.remove
        l.objini.msginv(arg3)
      efim
    fimse
  fimse
  porta_[arg0] = arg1
  se arg2 && socktot
    txt100 mporta
    mporta = portanome_[arg0]
    !mporta && !(mporta = $cmd_[arg0].m_porta) && (mporta = "uma porta")
    $mens.mens = mporta
    se portaartigo_[arg0] & 1
      $mens.o_1 = "abriram", $mens.o_2 = "fecharam"
    senao
      $mens.o_1 = "abriu", $mens.o_2 = "fechou"
    fimse
    listaobj l
    epara l.addfim(dentro2), l, l.ini.remove
      l.objini.msginv(arg2)
    efim
  fimse
  ret 1

func totalmove # Quantos movimentos consome, conforme o terreno
  casovar int(s_terreno)
  casose "0" # Dentro
    ret 1
  casose "1" # Rua de uma cidade
    ret 2
  casose "2" # Campo
    ret 2
  casose "3" # Pântano
    ret 3
  casose "4" # Floresta densa
    ret 3
  casose "5" # Colina
    ret 4
  casose "6" # Montanha
    ret 6
  casose "7" # Água pode nadar
    ret 4
  casose "8" # Água requer barco
    ret 50
  casose "9" # Em baixo d'água
    ret 10
  casose "10" # Ar
    ret 10
  casose "11" # Deserto
    ret 6
  casofim
  ret 1
# const s_titulo = descr0
# const dir_l = dir_e
# onst dir_o = dir_w
# const dir_c = dir_u
# const dir_b = dir_d
# const dir_so = dir_sw
# const dir_no = dir_nw
# func s_desc
# textotxt t
# uint16 x
# enquanto descr[x += 1]
# t.addfim(descr[x])
# efim
# ret t.remove(1000)
