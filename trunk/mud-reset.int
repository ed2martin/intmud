classe jog_reset
# Comandos de reset
#
# Formato do texto do reset:
# Uma linha por comando, entre:
# P <porcentagem> <personagem> <nível min> <nível max> <limite> [variáveis]
# A <porcentagem> <personagem> <nível min> <nível max> [variáveis]
# I <porcentagem> <item> <nível ou quantidade> [variáveis]
# E <porcentagem> <item> <nível ou quantidade> <lugar> [variáveis]
# S <porcentagem> <item> <nível ou quantidade> <destino ou s se sala> [variáveis]
# R <porcentagem> <item>
# D <porcentagem> <direção> <novo estado>
# F <porcentagem>
#
const adm_reset = "\b\c3Reset\b\n\
\c2LRES\b [nome]\n\
  Lista salas que começam com o nome especificado e possuem algum\n\
  comando de reset.\n\
\c2ARES\b [nome da sala]\n\
  Reset de área. Edita os comandos executados quando ocorre o reset da\n\
  área. Se o nome for omitido, será a sala em que você está.\n\
\c2SRES\b [nome da sala]\n\
  Reset da sala. Edita os comandos executados quando algum jogador entra\n\
  na sala. Se o nome for omitido, será a sala em que você está.\n\
\c2RESET\b [nome da sala ou área]\n\
  Executa o reset de área em uma área ou sala.\n\
  Se o nome for omitido, será a sala em que você está.\n\
\c2CRES\b [nome da sala ou área]\n\
  Refaz as funções de reset a partir da constantes a_reset e s_reset.\n\
  Isso é útil se o reset for mudado sem usar os comandos ARES e SRES.\n\n\
Internamente, o reset são duas constantes da sala: a_reset e s_reset\n\
Cada uma contém um texto, sendo um comando por linha.\n\
A partir dessas constantes são criadas as funções a_reset1 e s_reset1,\n\
que realizam o reset com instruções da linguagem do IntMUD.\n\
O comando CRES recria essas funções.\n\n\
O reset em si é uma sequência de comandos, entre esses:\n\
P Criar personagem\n\
A Criar animal no personagem\n\
Nota: depende do último personagem (comando P) ser criado com sucesso.\n\
I Criar item em animal ou personagem\n\
Nota: depende do último personagem ou animal ser criado com sucesso.\n\
E Equipar animal ou personagem com item\n\
Nota: depende do último personagem ou animal ser criado com sucesso.\n\
S Criar item na sala ou em um item da sala\n\
Nota: não cria se o item já existir.\n\
R Remover item da sala\n\
D Mudar porta em uma direção\n\
F Fim (encerra o reset)\n\
Nota: depende do último animal ou personagem ser criado com sucesso."

func cmd_lres # Listar salas com reset
  txtmais.limpar
  prog p
  txt100 lin
  epara p.iniclasse("s_" + arg0), p.lin, p.depois
    continuar ![p.texto]:s_reset && ![p.texto]:a_reset
    lin = txt(p.texto, 2) + "  "
    [p.texto]:a_reset && (lin += "ares ")
    [p.texto]:s_reset && (lin += "sres ")
    txtmais.addfim(lin + " " + $[p.texto].s_titulo)
    sair txtmais.linhas >= 500
  efim
  txtmais.addini(txtmais.linhas ? "\bSalas:" : "\bNenhuma sala encontrada.")
  txtmostra
  ret 1

func cmd_reset # Executa reset
  se !arg0
    ref r
    epara r = perso, r.dono, r = r.dono
    efim
# $reset.sala(r, r.a_reset)
    r.a_reset1
    msg("Reset efetuado sala " + txt(r, 2))
  senao $a_[arg0]
    $a_[arg0].reset_exec
    msg("Reset efetuado área " + arg0)
  senao $s_[arg0]
# $reset.sala($s_[arg0], $s_[arg0].a_reset)
    $s_[arg0].a_reset1
    msg("Reset efetuado sala " + arg0)
  senao
    msg("Área ou sala inexistente: " + arg0)
  fimse
  ret 1

func cmd_ares
  se !arg0
    se txt(perso.dono, 0, 2) != "s_"
      msg("Você não está em uma sala")
      ret 1
    fimse
    var.opcclasse = perso.dono
  senao $s_[arg0]
    var.opcclasse = "s_" + arg0
  senao
    msg("Sala inexistente: " + arg0)
    ret 1
  fimse
  var.opcnome = "Reset ", var.opcvar = "a_reset"
  ret p_reset("\b")

func cmd_sres
  se !arg0
    se txt(perso.dono, 0, 2) != "s_"
      msg("Você não está em uma sala")
      ret 1
    fimse
    var.opcclasse = perso.dono
  senao $s_[arg0]
    var.opcclasse = "s_" + arg0
  senao
    msg("Sala inexistente: " + arg0)
    ret 1
  fimse
  var.opcnome = "Ao entrar ", var.opcvar = "s_reset"
  ret p_reset("\b")

func cmd_cres
  prog p
  se !arg0
    ref r
    epara r = perso, r.dono, r = r.dono
    efim
    $reset.atualiza(r, "a_reset", $r.a_reset)
    $reset.atualiza(r, "s_reset", $r.s_reset)
    msg("Reset atualizado sala " + txt(r, 2))
  senao $b_[arg0]
    prog p
    debug d
    uint16 x
    x = d.exec
    epara p.iniclasse("s_" + arg0), p.lin, p.depois
      $reset.atualiza(p.texto, "a_reset", [p.texto]:a_reset)
      $reset.atualiza(p.texto, "s_reset", [p.texto]:s_reset)
      d.exec = x
    efim
    msg("Reset atualizado área " + arg0)
  senao $s_[arg0]
    $reset.atualiza($s_[arg0], "a_reset", $s_[arg0].a_reset)
    $reset.atualiza($s_[arg0], "s_reset", $s_[arg0].s_reset)
    msg("Reset atualizado sala " + arg0)
  senao
    msg("Área ou sala inexistente: " + arg0)
  fimse
  ret 1

func p_reset # Menu de reset
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    teditor.limpar
    teditor.addfim([var.opcclasse]:[var.opcvar])
    textopos pos
    epara pos = teditor.ini, pos, pos.texto ? pos.depois : pos.remove
    efim
  casose ""
    passo = "reset"
    msg(var.opcnome + txt(var.opcclasse, 2) + ", tecle O para saber as opções")
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim(var.opcnome + txt(var.opcclasse, 2))
    textopos pos
    epara pos = teditor.ini, pos, pos.depois
      txtmais.addfim(txt(txt(pos.linha + 1) + ". ", 0, 3) + t_resetlin(pos.texto))
    efim
    se pos.linha < 9
      txtmais.addfim(txt(pos.linha + 1) + ". Linha vazia")
    senao
      txtmais.addfim(txt(pos.linha + 1) + ".Linha vazia")
    fimse
    txtmais.addfim("Tecle E editar, I inserir ou A apagar, seguido do número da linha")
    txtmais.addfim("Z Sair, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "m"
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  casose "z"
    ret p_reset_z("")
  casose "a"
    uint16 lin
    lin = txt(arg0, 1)
    se lin > 0 && lin <= teditor.linhas
      var.opclin = lin
      p_reset_a("\b")
    senao teditor.linhas == 0
      msg("Não há nenhuma linha")
    senao teditor.linhas == 1
      msg("Só existe a linha 1")
    senao
      msg("A linha deve ser um número de 1 a " + teditor.linhas)
    fimse
    ret 1
  casose "e"
  casose "i"
    uint16 lin
    lin = txt(arg0, 1)
    se lin > 0 && lin <= teditor.linhas + 1
      var.opclin = lin
      var.opcinserir = txt(arg0, 0, 1) = "i"
      p_reset1("\b")
    senao teditor.linhas == 0
      msg("Só existe a linha 1")
    senao
      msg("A linha deve ser um número de 1 a " + (teditor.linhas + 1))
    fimse
    ret 1
  casofim
  msg("Opção inválida: " + arg0)
  ret 1

func p_reset_z
  se !var.opcmudou || arg0 == "n"
  senao arg0 == "s"
    prog p
    se teditor.bytes < 2
      p.apagar(var.opcclasse, var.opcvar)
      p.apagar(var.opcclasse, var.opcvar + "1")
    senao
      txt100 t1
      t1 = "const " + var.opcvar + "=\""
      p.criar(var.opcclasse, t1 + txtvis(teditor.ini.textolin(1000)) + "\"")
      $reset.atualiza(var.opcclasse, var.opcvar, teditor.ini.textolin(1000))
    fimse
    config:salvar
    msg("Alterações salvas")
  senao arg0 == "z"
    ret p_reset("")
  senao
    passo = "reset_z"
    msg("Salvar as alterações? Tecle S ou N, ou Z para cancelar")
    ret 1
  fimse
  var.opcmudou = ""
  msg("Retornando ao jogo")
  passo = ""
  var.opcnome = "", var.opcclasse = "", var.opcvar = "", var.opclin = ""
  ret 1

func p_reset_a # Apagar uma linha do reset
  textopos pos
  pos = teditor.ini, pos.linha = var.opclin - 1
  casovar txtmin(arg0)
  casose "\b"
    msg("Apagar linha " + var.opclin + "? N não, S sim")
    msg(txt(var.opclin) + ". " + t_resetlin(pos.texto))
    passo = "reset_a"
    ret 1
    ret p_reset("")
  casose "s"
    pos.remove, var.opcmudou = 1
    msg("Linha " + var.opclin + " apagada")
    ret p_reset("")
  casose "n"
    ret p_reset("")
  casose
    msg("Apagar linha " + var.opclin + "? Tecle S ou N.")
    ret 1
  casofim

func p_reset1 # Inserir ou editar linha do reset
  uint8 x
  x = arg0
  se arg0 == "z"
    p_reset("")
  senao txt(x) != arg0 || x > 100
    msg("Chances de acontecer, de 0 (nunca) a 100 (sempre), Z cancela")
    passo = "reset1"
  senao
    var.opclin += " " + x
    p_reset2("\b")
  fimse
  ret 1

func p_reset2 # Tipo
  casovar txtmin(arg0)
  casose
    msg("Opção inválida")
  casose "\b"
  casose ""
    passo = "reset2"
    msg("Entre com o tipo, O mostra as opções, Z cancela")
    ret 1
  casose "z"
    ret p_reset("")
  casose "o"
    txtmais.limpar
    txtmais.addfim(var.opcnome + txt(var.opcclasse, 2))
    txtmais.addfim("Opções:")
    txtmais.addfim("P Criar personagem")
    txtmais.addfim("A Criar animal no personagem")
    txtmais.addfim("I Criar item em animal ou personagem")
    txtmais.addfim("E Equipar animal ou personagem com item")
    txtmais.addfim("S Criar item na sala ou em um item da sala")
    txtmais.addfim("R Remover item da sala")
    txtmais.addfim("D Mudar porta em uma direção")
    txtmais.addfim("F Fim (encerra o reset)")
    txtmostra
    ret 1
  casose "p"
  casose "a"
  casose "i"
  casose "e"
  casose "s"
  casose "r"
  casose "d"
    var.opclin = txt1(var.opclin) + " " + txtmai(arg0) + " " + txt2(var.opclin)
    ret p_reset[arg0]("")
  casose "f"
    textopos pos
    pos = teditor.ini, pos.linha = txt1(var.opclin) - 1
    pos.add("F " + txt2(var.opclin)), var.opcmudou = 1
    ret p_reset("")
  casofim

func p_resetP # Personagem
  uint16 x
  ret arg0 == "z", p_reset("")
  x = arg0, passo = "resetP"
  casovar intsub(var.opclin)
  casose "3" # Personagem
    prog p
    se arg0 == ""
      msg("Entre com o personagem, Z cancela")
    senao !p.existe("p_" + txts(arg0))
      msg("Personagem não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0), p_resetP("")
    fimse
    ret 1
  casose "4" # Nível mínimo
    se arg0 == "0"
      var.opclin += " 0 0", p_resetP("")
    senao txt(x) == arg0
      var.opclin += " " + x, p_resetP("")
    senao
      msg("Entre com o nível mínimo, 0=manter, Z cancela")
    fimse
    ret 1
  casose "5" # Nível máximo
    se txt(x) == arg0 && x >= int(txtsub(var.opclin, 3, 1))
      var.opclin += " " + x, p_resetP("")
    senao
      msg("Entre com o nível máximo, a partir de " + txtsub(var.opclin, 3, 1) + ", Z cancela")
    fimse
    ret 1
  casose "6" # Quantidade máxima
    se txt(x) == arg0
      var.opclin += " " + x, p_resetP("")
    senao
      msg("Entre com a quantidade máxima, Z cancela")
    fimse
    ret 1
  casose "7" # Variáveis
    ret p_resetVar(arg0)
  casofim
  ret p_reset("")

func p_resetA # Animal
  uint16 x
  ret arg0 == "z", p_reset("")
  x = arg0, passo = "resetA"
  casovar intsub(var.opclin)
  casose "3" # Personagem
    prog p
    se arg0 == ""
      msg("Entre com o animal (personagem), Z cancela")
    senao !p.existe("p_" + txts(arg0))
      msg("Personagem não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0), p_resetA("")
    fimse
    ret 1
  casose "4" # Nível mínimo
    se arg0 == "0"
      var.opclin += " 0 0", p_resetA("")
    senao txt(x) == arg0
      var.opclin += " " + x, p_resetA("")
    senao
      msg("Entre com o nível mínimo, 0=manter, Z cancela")
    fimse
    ret 1
  casose "5" # Nível máximo
    se txt(x) == arg0 && x >= int(txtsub(var.opclin, 3, 1))
      var.opclin += " " + x, p_resetA("")
    senao
      msg("Entre com o nível máximo, a partir de " + txtsub(var.opclin, 3, 1) + ", Z cancela")
    fimse
    ret 1
  casose "6" # Variáveis
    ret p_resetVar(arg0)
  casofim
  ret p_reset("")

func p_resetI # Dar item
  uint16 x
  ret arg0 == "z", p_reset("")
  x = arg0, passo = "resetI"
  casovar intsub(var.opclin)
  casose "3" # Item
    prog p
    se arg0 == ""
      msg("Entre com o item, Z cancela")
    senao !p.existe("i_" + txts(arg0))
      msg("Item não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0), p_resetI("")
    fimse
    ret 1
  casose "4" # Nível ou quantidade
    se i_[txtsub(var.opclin, 3, 1)]:item == 2 # Quantidade
      se txt(x) == arg0 && x >= 1 && x <= 255
        var.opclin += " " + x, p_resetI("")
      senao
        msg("Entre com a quantidade de 1 a 255, Z cancela")
      fimse
    senao
      se txt(x) == arg0
        var.opclin += " " + x, p_resetI("")
      senao
        msg("Entre com o nível, 0=manter, Z cancela")
      fimse
    fimse
    ret 1
  casose "5" # Variáveis
    ret p_resetVar(arg0)
  casofim
  ret p_reset("")

func p_resetE # Equipar personagem
  uint16 x
  ret arg0 == "z", p_reset("")
  x = arg0, passo = "resetE"
  casovar intsub(var.opclin)
  casose "3" # Item
    prog p
    se arg0 == ""
      msg("Entre com o item, Z cancela")
    senao !p.existe("i_" + txts(arg0))
      msg("Item não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0)
      i_[arg0]:item == 2 && (var.opclin += " 1") # Quantidade
      p_resetE("")
    fimse
    ret 1
  casose "4" # Nível
    se txt(x) == arg0
      var.opclin += " " + x, p_resetE("")
    senao
      msg("Entre com o nível, 0=manter, Z cancela")
    fimse
    ret 1
  casose "5" # Lugar
    se misc:equip(x) != "desconhecido"
      var.opclin += " " + x, p_resetE("")
    senao arg0 == "o"
      txtmais.limpar
      txtmais.addfim("Opções:")
      uint8 n
      epara n = 1, misc:equip(n) != "desconhecido", n += 1
        txtmais.addfim(txt(n) + " " + misc:equip(n))
      efim
      txtmostra
    senao
      msg("Entre com o lugar, O mostra as opções, Z cancela")
    fimse
    ret 1
  casose "6" # Variáveis
    ret p_resetVar(arg0)
  casofim
  ret p_reset("")

func p_resetS # Criar item na sala ou em outro item
  uint16 x
  ret arg0 == "z", p_reset("")
  x = arg0, passo = "resetS"
  casovar intsub(var.opclin)
  casose "3" # Item
    prog p
    se arg0 == ""
      msg("Entre com o item, Z cancela")
    senao !p.existe("i_" + txts(arg0))
      msg("Item não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0), p_resetS("")
    fimse
    ret 1
  casose "4" # Nível ou quantidade
    se i_[txtsub(var.opclin, 3, 1)]:item == 2 # Quantidade
      se txt(x) == arg0 && x >= 1 && x <= 255
        var.opclin += " " + x, p_resetS("")
      senao
        msg("Entre com a quantidade de 1 a 255, Z cancela")
      fimse
    senao
      se txt(x) == arg0
        var.opclin += " " + x, p_resetS("")
      senao
        msg("Entre com o nível, 0=manter, Z cancela")
      fimse
    fimse
    ret 1
  casose "5" # Destino ou s se sala
    prog p
    se arg0 == ""
      msg("Entre com o item aonde criar, S para essa sala, Z cancela")
    senao arg0 == "s"
      var.opclin += " S", p_resetS("")
    senao !p.existe("i_" + txts(arg0))
      msg("Item não existe: " + txts(arg0) + "; entre com outro")
    senao
      var.opclin += " " + txts(arg0), p_resetS("")
    fimse
    ret 1
  casose "6" # Variáveis
    ret p_resetVar(arg0)
  casofim
  ret p_reset("")

func p_resetR # Remover item da sala
  ret arg0 == "z", p_reset("")
  passo = "resetR"
  prog p
  se arg0 == ""
    msg("Entre com o item, Z cancela")
  senao !p.existe("i_" + txts(arg0))
    msg("Item não existe: " + txts(arg0) + "; entre com outro")
  senao
    textopos pos
    pos = teditor.ini, pos.linha = txt1(var.opclin) - 1
    pos.add(txt2(var.opclin) + " " + txts(arg0)), var.opcmudou = 1
    ret p_reset("")
  fimse
  ret 1

func p_resetD # Porta em uma direção
  ret arg0 == "z", p_reset("")
  passo = "resetD"
  casovar intsub(var.opclin)
  casose "3" # Direção
    se arg0 == ""
      msg("Entre com a direção da porta, Z cancela")
    senao !misc:d1[arg0]
      msg("Direção não existe: " + arg0 + "; entre com outra")
    senao
      var.opclin += " " + misc:d1[arg0], p_resetD("")
    fimse
    ret 1
  casose "4" # Novo estado
    casovar txtmin(arg0)
    casose
      msg("Opção inválida")
    casose ""
      msg("Entre com o tipo, O mostra as opções, Z cancela")
      ret 1
    casose "o"
      msg("Opções: 0 sem porta, 1 aberto, 2 fechado, 3 trancado")
      ret 1
    casose "0"
    casose "1"
    casose "2"
    casose "3"
      textopos pos
      pos = teditor.ini, pos.linha = txt1(var.opclin) - 1
      pos.add(txt2(var.opclin) + " " + arg0), var.opcmudou = 1
      ret p_reset("")
    casofim
  casofim
  ret p_reset("")

func p_resetVar # Entrar com a lista de variáveis
  se txtproc(arg0, " ") >= 0
    msg("A lista de variáveis não pode ter espaço no meio")
    ret 1
  senao arg0 == ""
    msg("Entre com a lista de variáveis, N nenhuma, Z cancela")
    ret 1
  senao arg0 != "n"
    var.opclin += " " + arg0
  fimse
  textopos pos
  pos = teditor.ini, pos.linha = txt1(var.opclin) - 1
  pos.add(txt2(var.opclin)), var.opcmudou = 1
  ret p_reset("")

func t_resetlin # Obtém um texto a partir de uma linha do reset
# arg0 = texto da linha
# Retorna: texto da opção
  txt100 l.8
  txt200 lin
  l.separar(txtremove(arg0, "EMD"), " ") # Pega próxima linha e separa
  se !l.1 || l.1 == 0
    lin += "NÃO "
  senao l.1 == 100
    lin += "    "
  senao
    lin += txt(l.1 + "%    ", 0, 4)
  fimse
  casovar txtmai(l.0)
  casose "P" # <personagem> <nível min> <nível max> <limite> <variáveis>
    lin += "Perso      "
    lin += txt(l.2 + "(" + p_[l.2]:nome, 0, 30) + ")"
    lin += "  N" + (l.3 == l.4 ? l.3 : l.3 + "-" + l.4)
    l.5 && (lin += "  Máx " + l.5)
    l.6 && (lin += "  Var " + l.6)
    ret lin
  casose "A" # <animal> <nível min> <nível max> <variáveis>
    lin += "Animal     "
    lin += txt(l.2 + "(" + p_[l.2]:nome, 0, 30) + ")"
    lin += "  N" + (l.3 == l.4 ? l.3 : l.3 + "-" + l.4)
    l.5 && (lin += "  Var " + l.5)
    ret lin
  casose "I" # Dar item: <item> <nível> <variáveis>
    lin += "Dar item   "
    lin += txt(l.2 + "(" + i_[l.2]:nome, 0, 30) + ")"
    lin += "  " + (i_[l.2]:item == 2 ? l.3 + "x" : "N" + l.3)
    l.4 && (lin += "  Var " + l.4)
    ret lin
  casose "E" # Equipar: <item> <nível> <lugar> <variáveis>
    lin += "Equipar    "
    lin += txt(l.2 + "(" + i_[l.2]:nome, 0, 30) + ")"
    lin += "  " + (i_[l.2]:item == 2 ? l.3 + "x" : "N" + l.3)
    lin += "  " + txtmaimin(misc:equip(l.4))
    l.5 && (lin += "  Var " + l.5)
    ret lin
  casose "S" # Item: <item> <nível> <destino ou s se sala> <variáveis>
    lin += "Item       "
    lin += txt(l.2 + "(" + i_[l.2]:nome, 0, 30) + ")"
    lin += "  " + (i_[l.2]:item == 2 ? l.3 + "x" : "N" + l.3)
    se l.4 == "s"
      lin += "  Nessa sala"
    senao
      lin += "  No item " + txt(l.4 + "(" + i_[l.4]:nome, 0, 30) + ")"
    fimse
    l.5 && (lin += "  Var " + l.5)
    ret lin
  casose "R" # Remover da sala: <item>
    lin += "Apaga item "
    lin += txt(l.2 + "(" + i_[l.2]:nome, 0, 30) + ")"
    sair
  casose "D" # Porta em uma direção
    lin += "Direção    "
    lin += txtmai(l.2)
    casovar l.3
    casose "0"
      lin += "  Sem porta"
      sair
    casose "1"
      lin += "  Porta aberta"
      sair
    casose "2"
      lin += "  Porta fechado"
      sair
    casose "3"
      lin += "  Porta trancado"
      sair
    casose
      lin += "  Estado desconhecido: " + l.3
    casofim
    ret lin
  casose "F" # Fim
    ret lin + "Fim (se criou personagem/animal com sucesso)"
  casose
    ret lin + "Comando desconhecido"
  casofim
  ret lin


classe reset
# Permite executar instruções do reset e criar funções que realizam o reset
#
prog p
debug dbg
uint8 dbgexec
ref perso # Último personagem criado
ref ultimo # Último personagem ou animal criado
ref r
int8 x
textotxt t # Texto do reset
txt100 l.8 # Linha do texto

func iniclasse
  criar(arg0)

func sala # Executa comandos de reset de uma sala
# arg0 = objeto da sala, arg1 = texto do reset
# Nota: é mais eficiente criar o reset com a função atualiza
  dbgexec = dbg.exec, perso = ultimo = nulo, t.limpar, t.addfim(arg1)
  enquanto t.linhas
    l.separar(txtremove(t.remove, "EMD"), " ") # Pega próxima linha e separa
    casovar txtmai(l.0)
    casose "P" # <personagem> <nível min> <nível max> <limite> <variáveis>
      perso = ultimo = nulo
      sair int(l.1) < 100 && rand(100) < l.1 || int(l.5) <= inttotal($p_[l.2])
      se l.3 != l.4
        ultimo = perso = criar("p_" + l.2, arg0, rand(l.3, l.4), l.6)
      senao
        ultimo = perso = criar("p_" + l.2, arg0, l.3, l.6)
      fimse
      sair
    casose "A" # <animal> <nível min> <nível max> <variáveis>
      ultimo = nulo
      sair perso.tipo != 3 || int(l.1) < 100 && rand(100) < l.1
      x = perso.animalnum # Obtém o número do próximo animal
      sair x == 0
      se l.3 != l.4
        ultimo = criar("p_" + l.2, perso, rand(l.3, l.4), l.6)
      senao
        ultimo = criar("p_" + l.2, perso, l.3, l.6)
      fimse
      perso.animal.[x - 1] = ultimo
      sair
    casose "I" # Dar item: <item> <nível> <variáveis>
      sair !ultimo || int(l.1) < 100 && rand(100) < l.1
      criar("i_" + l.2, ultimo, l.3, l.4)
      sair
    casose "E" # Equipar: <item> <nível> <lugar> <variáveis>
      sair !ultimo || int(l.1) < 100 && rand(100) < l.1
      r = criar("i_" + l.2, ultimo, l.3, l.5)
      r.vestir(l.4), u.recalc = 1
      sair
    casose "S" # Item: <item> <nível> <destino ou s se sala> <variáveis>
      sair int(l.1) < 100 && rand(100) < l.1
      r = l.4 == "s" ? arg0 : arg0.dentro1.objini("i_" + l.3)
      sair !r || r.dentro1.objini("i_" + l.2)
      criar("i_" + l.2, r, l.3, l.5)
      sair
    casose "R" # Remover da sala: <item>
      sair int(l.1) < 100 && rand(100) < l.1
      r = arg0.dentro1.objini("i_" + l.2)
      r.apagar
      sair
    casose "D" # Porta em uma direção
      sair int(l.1) < 100 && rand(100) < l.1
      arg0.mudaporta(l.2, l.3) # l.2=direção, l.3=novo valor
      sair
    casose "F" # Fim
      sair !ultimo || int(l.1) < 100 && rand(100) < l.1
      t.limpar
      sair
    casofim
  efim
  dbg.exec = dbgexec

func atualiza # Atualiza reset de sala
# arg0 = nome da sala
# arg1 = nome da constante
# arg2 = texto do reset
  ret !arg2, p.apagar(arg0, arg1 + "1")
  txt512 t
  t = "func " + arg1 + "1 # Realiza o reset\n"
  t += "# Não alterar; função criada automaticamente a partir de " + arg1 + "\n"
  t = p.criar(arg0, t + cmdsala(txt(arg2)))
  se !t
    config:salvar
  senao
    t = "(ERRO) ao criar função " + arg0 + ":" + arg1 + "1:\n" + t
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg(t)
    efim

func cmdsala # Cria conteúdo de uma função conforme os comandos do reset
# arg0 = texto do reset
# Retorna: texto que contém o conteúdo da função, exceto "func xxxx"
  textotxt t1 # Texto recebido
  textotxt t2 # Texto sendo criado
  txt100 l.8 # Linha do texto
  txt512 lin
  uint8 mudou # Que variáveis criar: +1 se p/u, +2 se r, +4 se x
  t1.addfim(arg0)
  enquanto t1.linhas
# t2.addfim("# " + txtremove(t1.ini.texto, "EMD"))
    l.separar(txtremove(t1.remove, "EMD"), " ") # Pega próxima linha e separa
    casovar txtmai(l.0)
    casose "P" # <personagem> <nível min> <nível max> <limite> <variáveis>
      textopos pos
      uint8 m1 # Será =2 se o personagem terá alguma coisa dentro
      epara pos = t1.ini, pos && !m1, pos.depois
        casovar txtmin(pos.texto(0, 1))
        casose "p"
          m1 = 1
          sair
        casose "a"
        casose "i"
        casose "e"
          m1 = 2
          mudou & 1 ? t2.addfim("p=u=nulo") : (mudou = mudou | 1)
          sair
        casofim
      efim
      sair int(l.1) <= 0
      lin = "se inttotal($p_" + txtvis(l.2) + ") < " + int(l.5)
      int(l.1) < 100 && (lin += " && rand(100)<" + int(l.1))
      t2.addfim(lin)
      lin = m1 == 2 ? "  p=u=" : "  "
      lin += "criar(\"p_" + txtvis(l.2) + "\", este, "
      lin += l.3 == l.4 ? int(l.3) : "rand(" + int(l.3) + ", " + int(l.4) + ")"
      lin += l.6 ? ", \"" + txtvis(l.6) + "\")" : ")"
      t2.addfim(lin)
      t2.addfim("fimse")
      sair
    casose "A" # <animal> <nível min> <nível max> <variáveis>
      sair !(mudou & 1) # Sai se não criou nenhum personagem
      textopos pos
      uint8 m1 # Será =2 se o personagem terá alguma coisa dentro
      epara pos = t1.ini, pos && !m1, pos.depois
        casovar txtmin(pos.texto(0, 1))
        casose "p"
        casose "a"
          m1 = 1
          sair
        casose "i"
        casose "e"
          m1 = 2, t2.addfim("u=nulo")
          sair
        casofim
      efim
      sair int(l.1) <= 0
      mudou = mudou | 4 # Usa a variável x
      lin = "se (x=p.animalnum) > 0"
      int(l.1) < 100 && (lin += " && rand(100)<" + int(l.1))
      t2.addfim(lin)
      lin = "  p.animal.[x-1]"
      m1 == 2 && (lin += "u=")
      lin += "criar(\"p_" + txtvis(l.2) + "\", p, "
      lin += l.3 == l.4 ? int(l.3) : "rand(" + int(l.3) + ", " + int(l.4) + ")"
      lin += l.5 ? ", \"" + txtvis(l.5) + "\")" : ")"
      t2.addfim(lin)
      t2.addfim("fimse")
      sair
    casose "I" # Dar item: <item> <nível> <variáveis>
      sair !(mudou & 1) # Sai se não criou nenhum personagem
      sair int(l.1) <= 0
      lin = "u && "
      int(l.1) < 100 && (lin += "rand(100)<" + int(l.1) + " && ")
      lin += "criar(\"i_" + txtvis(l.2) + "\", u, " + txtvis(l.3)
      lin += l.4 ? ", \"" + txtvis(l.4) + "\")" : ")"
      t2.addfim(lin)
      sair
    casose "E" # Equipar: <item> <nível> <lugar> <variáveis>
      sair !(mudou & 1) # Sai se não criou nenhum personagem
      sair int(l.1) <= 0
      mudou = mudou | 2 # Usa a variável r
      lin = "se u"
      int(l.1) < 100 && (lin += " && rand(100)<" + int(l.1))
      t2.addfim(lin)
      lin = "  r=criar(\"i_" + txtvis(l.2) + "\", u, " + int(l.3)
      lin += l.5 ? ", \"" + txtvis(l.5) + "\")" : ")"
      lin += ", r.vestir(" + int(l.4) + "), u.recalc=1"
      t2.addfim(lin)
      t2.addfim("fimse")
      sair
    casose "S" # Item: <item> <nível> <destino ou s se sala> <variáveis>
      sair int(l.1) <= 0
      se l.4 == "s"
        lin = "!dentro1.objini(\"i_" + txtvis(l.2) + "\") && "
        lin += "criar(\"i_" + txtvis(l.2) + "\", este"
      senao
        lin = "$" + txtvis(l.4) + " && !$" + txtvis(l.4)
        lin += ".dentro1.objini(\"i_" + txtvis(l.2) + "\") && "
        lin += "criar(\"i_" + txtvis(l.2) + "\", $" + txtvis(l.4)
      fimse
      lin += ", " + int(l.3)
      lin += l.5 ? ", \"" + txtvis(l.5) + "\")" : ")"
      t2.addfim(lin)
      sair
    casose "R" # Remover da sala: <item>
      sair int(l.1) <= 0
      mudou = mudou | 2 # Usa a variável r
      lin = ""
      int(l.1) < 100 && (lin += "rand(100)<" + int(l.1) + " && ")
      sair int(l.1) < 100 && rand(100) < l.1
      lin += "(r = arg0.dentro1.objini(\"i_" + txtvis(l.2) + "\")) + r.apagar"
      t2.addfim(lin)
      sair
    casose "D" # Porta em uma direção
      sair int(l.1) <= 0
      lin = ""
      int(l.1) < 100 && (lin += "rand(100)<" + int(l.1) + " && ")
      lin += "mudaporta(\"" + txtvis(l.2) + "\", " + int(l.3) + ")"
      t2.addfim(lin)
      sair
    casose "F" # Fim
      sair int(l.1) <= 0
      lin = "ret u"
      int(l.1) < 100 && (lin += " && rand(100)<" + int(l.1))
      lin += ", nulo"
      t2.addfim(lin)
      sair
    casofim
  efim
  mudou & 4 ? t2.addini("int8 x # Usado como rascunho")
  mudou & 2 ? t2.addini("ref r # Usado como rascunho")
  mudou & 1 ? t2.addini("ref u # Último personagem ou animal criado")
  mudou & 1 ? t2.addini("ref p # Último personagem criado")
  ret t2.remove(10000)

const reset1 = "S 100 ini006 1 s\n\
S 30 ini006 10 s abc=1\n\
S 30 ini006 12 ini004 abc=1\n\
R 10 ini002\n\
R 100 ini001\n\
P 100 ini003 31 31 1\n\
I 100 ini001 10\n\
I 90 ini001 10\n\
I 80 ini001 15 abc=d\n\
I 0 ini001 10\n\
P 45 ini003 11 20 1 h_chutar=1\n\
E 80 ini001 15 2\n\
E 80 ini001 15 3 abc=d\n\
A 40 ini002 15 20 h_socar=1\n\
D 100 N 2\n\
D 10 SE 0"
# Exemplo de como testar a função cmdsala
# func ini
# telatxt t1
# t1.msg("func: \n" + cmdsala(reset1))
# prog p
# t1.msg("\n\n>" + p.classe("x", "func n\n" + cmdsala(reset1)) + "\n")
