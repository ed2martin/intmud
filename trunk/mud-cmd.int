classe com2_comum
const nivel = 1 # Nível mínimo para usar o comando
const posic = 8 # Posição mínima para usar o comando
const pode = 1 # Se comando existe para o personagem (arg0=personagem, arg1=texto)
const iniclasse = criar(arg0) # Cria um objeto do comando
func exec # Executa o comando
# arg0=personagem
# arg1=comando que escreveu
# arg2=texto após o comando
  arg0.msg("Você digitou " + arg1 + " " + arg2)

classe com2_move
herda com2_comum
# Movimenta-se em uma direção
const iniclasse = criar(arg0)

func exec1 # Executa o comando
# arg0 = personagem
# arg1 = direção
# arg2 = mensagem de saída
# arg3 = mensagem de chegada
  ref s1
  s1 = arg0.dono
  listaobj l0
  l0.addfim(arg0, arg0.dono, arg0.eventos, arg0.dono.eventos)
  enquanto l0 && !l0.ini.obj.evmover(arg0, arg1)
    l0.ini.remove
  efim
  se l0 # Retorna se lista não estiver vazia
  senao ref(s1.dir_[arg1]) == nulo
    arg0.msg("Impossível seguir nessa direção.")
  senão s1.tipo_[arg1] & 3 >= 2
    arg0.msg("A porta está fechada.")
  senão
    $mens.p(arg0)
    $mens.mvis2("", "$P foi " + arg2)
    arg0.mudasala(s1.dir_[arg1])
    $mens.mvis2("", "$P chegou " + arg3)
    se arg0.dono.s_morre
      arg0.morreu


classe com_n
herda com2_move
const exec = exec1(arg0, "n", "para o norte.", "do sul.")

classe com_s
herda com2_move
const exec = exec1(arg0, "s", "para o sul.", "do norte.")

classe com_l
herda com2_move
const exec = exec1(arg0, "l", "para o leste.", "do oeste.")

classe com_o
herda com2_move
const exec = exec1(arg0, "o", "para o oeste.", "do leste.")

classe com_w
herda com_o

classe com_c
herda com2_move
const exec = exec1(arg0, "c", "para cima.", "de baixo.")

classe com_u
herda com_c

classe com_b
herda com2_move
const exec = exec1(arg0, "b", "para baixo.", "de cima.")

classe com_d
herda com_b

classe com_ne
herda com2_move
const exec = exec1(arg0, "ne", "para o nordeste.", "do noroeste.")

classe com_no
herda com2_move
const exec = exec1(arg0, "no", "para o noroeste.", "do nordeste.")

classe com_nw
herda com_no

classe com_se
herda com2_move
const exec = exec1(arg0, "se", "para o sudeste.", "do sudoeste.")

classe com_so
herda com2_move
const exec = exec1(arg0, "so", "para o sudoeste.", "do sudeste.")

classe com_sw
herda com_so

classe com_abrir
herda com2_comum
func exec
  txt10 dir
  dir = m_tab:d1[arg2]
  se arg0 == ""
    arg0.msg("Abrir o que?")
  senao dir
    se !arg0.dono.dir_[dir]
      arg0.msg("Não há porta nessa direção.")
      ret
    fimse
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
      ret
    casose "1"
      arg0.msg("Porta já está aberta.")
      ret
    casose "2"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] - 1) # Abre a porta
      $mens.p(arg0)
      $mens.mtodos1("$P abriu uma porta.")
      ret
    casose "3"
      arg0.msg("Porta está trancada.")
      ret
    casofim
  senao
    arg0.msg("Não foi possível abrir " + arg2 + ".")

classe com_fechar
herda com2_comum
func exec
  txt10 dir
  dir = m_tab:d1[arg2]
  se arg0 == ""
    msg("Abrir o que?")
  senao dir
    se !arg0.dono.dir_[dir]
      arg0.msg("Não há porta nessa direção.")
      ret
    fimse
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
      ret
    casose "1"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] + 1) # Fecha a porta
      $mens.p(arg0)
      $mens.mtodos1("$P fechou uma porta.")
      ret
    casose "2"
    casose "3"
      arg0.msg("Porta já está fechada.")
      ret
    casofim
  senao
    arg0.msg("Não foi possível fechar " + arg2 + ".")

classe com_falar
herda com2_comum
const posic = 5
func exec
  $mens.p(arg0)
  se txt(arg2, 0, 3) == "..."
    $mens.mtodos1("$P continuou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "?"
    $mens.mtodos1("$P perguntou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "!"
    $mens.mtodos1("$P exclamou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 3) == "..."
    $mens.mtodos1("$P ponderou: " + txttroca(arg2, "$", "$$"))
  senao
    $mens.mtodos1("$P disse: " + txttroca(arg2, "$", "$$"))
  fimse
# Executa eventos
  listaobj l0
  l0.addfim(arg0, arg0.dono, arg0.eventos, arg0.dono.eventos)
  enquanto l0 && l0.ini.obj.evfalar(este, arg0)
    l0.ini.remove
  efim

classe com_chat
herda com2_comum
const posic = 0
func exec
  $mens.p(arg0)
  se !arg2
    arg0.sock.canais = arg0.sock.canais ^ 2
    se arg0.sock.canais & 2
      arg0.msg("Canal chat habilitado.")
    senao
      arg0.msg("Canal chat desabilitado")
    fimse
  senao !(arg0.sock.canais & 2)
    arg0.msg("Canal chat está desabilitado.")
  senao
    listaitem item
    item = $jogcomum.jog.ini
    enquanto item
      (item.obj.canais & 2) && item.obj.msg("(chat) " + arg0.sock.nome + ": " + arg2)
      item.depois
    efim

classe com_quem
herda com2_comum
const posic = 0
func exec
  listaitem item
  textotxt t0
  txt100 t1
# Obtém lista de jogadores
  ref r
  r = $jogador
  enquanto r
    t1 = txt(99999 * 99999 - r.nivel) + " "
    t1 += txtfim("      " + r.nivel, 6) + "  " + r.nome
    r.sock == nulo && (t1 += "  [Desconectado]")
    t0.addfim(t1)
    r = objdepois(r)
  efim
# Ordena
  t0.ordena
# Mostra para o jogador
  arg0.msg("Personagens online: " + t0.linhas)
  enquanto t0.linhas
    arg0.msg("N" + txt2(t0.remove))
  efim

classe com_fim
herda com2_comum
const posic = 0
func exec
  arg0.msg("Até mais. Aguardamos o seu retorno.")
  apagar(arg0)

classe com_quit
herda com_fim

classe com_ver
herda com2_comum
const posic = 5
func exec
  se !arg2
    arg0.msg2(arg0.dono.descsala(arg0, 7))
    ret
  fimse
  listaobj l
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  arg0.itemnome(l, "1 " + arg2)
  se l.ini
    arg0.msg(txtmaimin(l.ini.obj.nome) + ".")
    arg0.msg(l.ini.obj.descver)
    ret
  fimse
  arg0.msg("Você não vê isso.")
  ret

classe com_inv
herda com2_comum
const posic = 5
func exec
  textotxt t
  listaitem item
  item = arg0.dentro1.ini
  enquanto item
    arg0.visivel(item.obj) && t.addfim("1 " + item.obj.nome)
    item.depois
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Você carrega:\n" + t.remove(1000))
  senao
    arg0.msg("Você não está carregando nada.")
  fimse

classe com_equip
herda com2_comum
const posic = 5
func exec
  textotxt t
  listaitem item
  item = arg0.dentro2.ini
  enquanto item
    se arg0.visivel(item.obj)
      t.addfim("1 (" + equip(item.obj.vestpos) + ") " + item.obj.nome)
    fimse
    item.depois
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Equipado com:\n" + t.remove(1000))
  senao
    arg0.msg("Não está vestindo/usando nada.")
  fimse
func equip
  casovar arg0
  casose "1"
    ret "como luz"
  casose "2"
    ret "na cabeça"
  casose "3"
    ret "sobre o rosto"
  casose "4"
    ret "nos olhos"
  casose "5"
    ret "nas orelhas"
  casose "6"
    ret "no pescoço"
  casose "7"
    ret "no corpo"
  casose "8"
    ret "sobre o corpo"
  casose "9"
    ret "nas costas"
  casose "10"
    ret "nos braços"
  casose "11"
    ret "nas mãos"
  casose "12"
    ret "no pulso direito"
  casose "13"
    ret "no pulso esquerdo"
  casose "14"
    ret "no dedo direito"
  casose "15"
    ret "no dedo esquerdo"
  casose "16"
    ret "empunhando"
  casose "17"
    ret "escudo"
  casose "18"
    ret "na cintura"
  casose "19"
    ret "nas pernas"
  casose "20"
    ret "calçando"
  casose
    ret "desconhecido"
  casofim

classe com_pegar
herda com2_comum
func exec
  se !arg2
    arg0.msg("Pegar o que?")
    ret
  fimse
  listaobj l
  l.addfim(arg0.dono.dentro1)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não vê isso.")
    ret
  fimse
  enquanto l
    l.ini.obj.dono = arg0
    $mens.p(arg0, l.ini.obj)
    $mens.mvis1("$P pega $r $a.")
    l.ini.remove
  efim

classe com_soltar
herda com2_comum
func exec
  se !arg2
    arg0.msg("Soltar o que?")
    ret
  fimse
  listaobj l
  l.addfim(arg0.dentro1)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não vê isso.")
    ret
  fimse
  enquanto l
    l.ini.obj.dono = arg0.dono
    $mens.p(arg0, l.ini.obj)
    $mens.mvis1("$P solta $r $a.")
    l.ini.remove
  efim

classe com_vestir
herda com2_comum
func exec
  se !arg2
    arg0.msg("Vestir o que?")
    ret
  fimse
  listaobj l
  listaitem item
  int32 vest
# Checa o que quer vestir
  l.addfim(arg0.dentro1)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não vê isso.")
    ret
  fimse
# Preenche vest com o que está vestindo
  item = arg0.dentro2
  enquanto item
    vest = vest | (1 << item.obj.vestpos)
    item.depois
  efim
  vest = vest >> 1
# Tenta vestir
  int1 ajustar
  enquanto l
    ref r
    r = l.ini.obj
    se (~vest & r.vestir) == 0
      arg0.msg("Você não consegue vestir " + r.nome)
    senao
      uint32 x
      x = ~vest & r.vestir
      r.vestpos = 0
      !(x & 65535) && (x = x >> 16) + (r.vestpos += 16)
      !(x & 255) && (x = x >> 8) + (r.vestpos += 8)
      !(x & 15) && (x = x >> 4) + (r.vestpos += 4)
      !(x & 3) && (x = x >> 2) + (r.vestpos += 2)
      !(x & 1) && (x = x >> 1) + (r.vestpos += 1)
      vest = vest | (1 << r.vestpos)
      r.vestpos += 1
      r.idono.remove
      r.idono = arg0.dentro2.addini(r)
      $mens.p(arg0, r)
      $mens.mvis1("$P veste $r $a.")
      ajustar = 1
    fimse
    l.ini.remove
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar

classe com_remover
herda com2_comum
func exec
  se !arg2
    arg0.msg("Remover o que?")
    ret
  fimse
  listaobj l
  ref r
  l.addfim(arg0.dentro2)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não está usando isso.")
    ret
  fimse
  int1 ajustar
  enquanto l
    r = l.ini.obj
    r.idono.remove
    r.idono = arg0.dentro1.addini(r)
    r.vestpos = 0
    $mens.p(arg0, r)
    $mens.mvis1("$P remove $r.")
    l.ini.remove
    ajustar = 1
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar

classe com_hora
herda com2_comum
const posic = 0
func exec
  datahora d
  d.agora
  arg0.msg("Hora atual MUD:      " + $jogcomum.hora + ":" + $jogcomum.min)
  arg0.msg("Hora atual servidor: " + d.hora + ":" + d.min)

classe com2_debug
herda com2_comum
const posic = 0
func exec
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.ini.obj + "/" + l0.ini.obj.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  listaitem item
  item = $jogcomum.jog.ini
  enquanto item
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
    item.depois
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  ref r
  r = $jogador
  enquanto r
    arg0.msg("> " + r.nome + " (" + r.sock.nome + ")")
    r = objdepois(r)
  efim

classe com_info
herda com2_comum
const posic = 0
func exec
  txt100 lin
  lin = "vida " + arg0.vida + "/" + arg0.vidamax
  lin += "  mana " + arg0.mana + "/" + arg0.manamax
  lin += "  vigor " + arg0.move + "/" + arg0.movemax
  lin += "  nível " + arg0.nivel
  lin += "  experiência " + arg0.exp + "/" + arg0.expmax
  arg0.msg(lin)

classe com2_golpe
herda com2_comum
const posic = 7
const tipo = 0 # Tipo de golpe
const precisao = 100 # Precisão do golpe, 100 significa 100%
const forca = 100 # Força do golpe, 100 significa 100%
const veloc = 100 # Velocidade do golpe, 100 significa 100%
const msgatk = "$P ataca $A"

func exec
  se arg0.batalhaini(arg2) # Inicia batalha
    txt200 msg1
    velgolpe(arg0, arg0.b_alvo) # Tempo do golpe
    msg1 = execgolpe(arg0, arg0.b_alvo, 1, 3) # Danos do golpe
    $mens.p(arg0, arg0.b_alvo)
    $mens.mvis1(msgatk + ", " + arg0.b_alvo.vida + " " + msgefeito(msg1))
    arg0.batalhadepois # Procedimentos depois que atacou

func msgefeito
  casovar arg0
  casose "0"
    ret " errou"
  casose "1"
    ret " nada acontece"
  casose "2"
    ret " pouco efeito"
  casose "3"
    ret ""
  casose "4"
    ret " muito efeito"
  casofim

func velgolpe # Acerta o tempo de espera conforme o golpe
# arg0 = personagem que está atacando
# arg1 = personagem alvo
  uint8 tempo
  # Se velocidades dos MOBs iguais e velocidade do golpe=100, tempo=25
  tempo = 10 + arg1.veloc * 1500 / (arg1.veloc * veloc + 1)
  tempo < 5 && (tempo = 5)
  tempo > 60 && (tempo = 60)
  arg0.p_espera = tempo

func execgolpe # Realiza um ataque
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2,arg3 = ataque mínimo e máximo da arma usada no golpe
# Retorna: 0=errou, 1=sem efeito, 2=pouco efetivo, 3=normal, 4=muito efetivo
  real dano
# Checa se acertou o alvo
  dano = rand(1, 20)
  se dano == 20 || arg1.posicao == 4 # Acertou automaticamente
  senao dano == 1 # Errou o alvo automaticamente
    ret 0
  senao # Checa se acertou
    dano += precisao * arg0.precisao / 100 - arg1.evasao
    !arg0.visivel(arg1) && (dano -= 5) # Invisível é mais difícil de acertar
    se dano <= 0
      ret 0
    fimse
  fimse
# Calcula dano sem modificadores
  se m_tab:aktipo(tipo) # Checa se golpe normal ou especial
    dano = arg0.atkmag * forca / (arg1.defmag * 9000)
  senao
    dano = arg0.atknorm * forca / (arg1.defnorm * 9000)
  fimse
  dano = pos(dano + arg0.nivel - arg1.nivel) # Adiciona diferença de níveis
  dano += rand(arg2, arg3) # Adiciona ataque da arma
# Modificadores de posição
  casovar arg1.posicao
  casose "0" # Morto
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    dano *= 2.666
    sair
  casose "3" # Muito fraco
    dano *= 2.333
    sair
  casose "4" # dormindo
    dano *= 2
    sair
  casose "5" # descansando
    dano *= 1.666
    sair
  casose "6" # sentado
    dano *= 1.333
    sair
  casofim
# Modificadores de tipo de golpe
  int8 rettipo
  rettipo = arg1.deftipo[tipo]
  casovar rettipo
  casose "-8"
    rettipo = 4, dano *= 16
    sair
  casose "-7"
    rettipo = 4, dano *= 11.2
    sair
  casose "-6"
    rettipo = 4, dano *= 8
    sair
  casose "-5"
    rettipo = 4, dano *= 5.6
    sair
  casose "-4"
    rettipo = 4, dano *= 4
    sair
  casose "-3"
    rettipo = 4, dano *= 2.8
    sair
  casose "-2"
    rettipo = 4, dano *= 2
    sair
  casose "-1"
    rettipo = 3, dano *= 1.4
    sair
  casose "0"
    rettipo = 3
    sair
  casose "1"
    rettipo = 3, dano /= 1.4
    sair
  casose "2"
    rettipo = 3, dano /= 2
    sair
  casose "3"
    rettipo = 2, dano /= 2.8
    sair
  casose "4"
    rettipo = 2, dano /= 4
    sair
  casose "5"
    rettipo = 2, dano /= 5.6
    sair
  casose "6"
    rettipo = 2, dano /= 8
    sair
  casose "7"
    rettipo = 2, dano /= 11.2
    sair
  casose "8"
    rettipo = 2, dano /= 16
    sair
  casose
    se rettipo < 0
      rettipo = 4, dano *= 16 # Danos demais
    senao
      rettipo = 1, dano = 0 # Imune ao ataque
    fim
  casofim
# Atualiza pontos de vida conforme os danos
  dano < 1 && (dano = 1) # Pelo menos 1 de dano
  arg1.vida -= dano
  ret rettipo

classe com_atk
herda com2_golpe
