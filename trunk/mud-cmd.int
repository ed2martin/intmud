classe comando_comum
const posic = 8 # Posição mínima para usar o comando
const objcmd = este # Objeto que processa o comando, ou nulo se não existe
# const ultimo = 1 # Deve estar definido se comando tem baixa prioridade

func escr # Processa o comando
# arg0 = objeto do personagem
# arg1 = texto digitado após o nome do comando

func iniclasse
  criar(arg0)


classe comando_mover
herda comando_comum
const m_entra = "$P chegou"
const m_sai = "$P foi embora"
const dir = ""
const comando_mover = 1 # Para indicar que é comando de movimentação do jogador

func escr # Executa o comando
# arg0 = personagem
  ref s1 # Sala aonde está
  ref s2 # Sala para onde vai
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_[dir](arg0), nulo
  efim
  misc:obj = arg0
  s1 = arg0.dono, s2 = s1.dir_[dir]
  ret s2 == nulo, arg0.msg("Impossível seguir nessa direção.")
  ret s1.tipo_[dir] & 3 >= 2, arg0.msg("A porta está fechada.")
  uint8 total
  total = s1.totalmove + s2.totalmove
  se arg0.move < total
    arg0.msg("Você está cansad" + misc:sletra[arg0.sexo] + " demais.")
    ret
  fimse
  arg0.move -= total / 2
  total -= 1 # Para garantir pelo menos 2 movimentos (total é uint8)
  arg0.p_espera = total * 2 + 2
  $mens.p(arg0)
  $mens.mvis2("", m_sai)
  arg0.mudasala(s2)
  $mens.mvis2("", m_entra)
  arg0.dono.s_morre && arg0.morreu


classe cmd_n
herda comando_mover
const m_entra = "$P chegou do sul."
const m_sai = "$P foi para o norte."
const dir = "n"


classe cmd_s
herda comando_mover
const m_entra = "$P chegou do norte."
const m_sai = "$P foi para o sul."
const dir = "s"


classe cmd_l
herda comando_mover
const m_entra = "$P chegou do oeste."
const m_sai = "$P foi para leste."
const dir = "l"


classe cmd_e
const obj = $cmd_l.obj(arg0, arg1)


classe cmd_o
herda comando_mover
const m_entra = "$P chegou do leste."
const m_sai = "$P foi para oeste."
const dir = "o"


classe cmd_w
const obj = $cmd_o.obj(arg0, arg1)


classe cmd_c
herda comando_mover
const m_entra = "$P chegou de baixo."
const m_sai = "$P subiu."
const dir = "c"


classe cmd_u
const obj = $cmd_c.obj(arg0, arg1)


classe cmd_b
herda comando_mover
const m_entra = "$P chegou de cima."
const m_sai = "$P desceu."
const dir = "b"


classe cmd_d
const obj = $cmd_b.obj(arg0, arg1)


classe cmd_ne
herda comando_mover
const m_entra = "$P chegou do sudoeste."
const m_sai = "$P foi para o nordeste."
const dir = "ne"


classe cmd_no
herda comando_mover
const m_entra = "$P chegou do sudeste."
const m_sai = "$P foi para o noroeste."
const dir = "no"


classe cmd_nw
const obj = $cmd_no.obj(arg0, arg1)


classe cmd_se
herda comando_mover
const m_entra = "$P chegou do noroeste."
const m_sai = "$P foi para o sudeste."
const dir = "se"


classe cmd_so
herda comando_mover
const m_entra = "$P chegou do nordeste."
const m_sai = "$P foi para o sudoeste."
const dir = "se"


classe cmd_sw
const obj = $cmd_so.obj(arg0, arg1)


classe cmd_abrir
herda comando_comum

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_abrir(arg0, arg1), nulo
  efim
  txt10 dir
  dir = misc:d1[arg1]
  se arg0 == ""
    arg0.msg("Abrir o que?")
  senao !dir
    arg0.msg("Não foi possível abrir " + arg2 + ".")
  senao !arg0.dono.dir_[dir]
    arg0.msg("Não há porta nessa direção.")
  senao
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
    casose "1"
      arg0.msg("Porta já está aberta.")
    casose "2"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] - 1) # Abre a porta
      $mens.p(arg0)
      $mens.mtodos1("$P abriu uma porta.")
    casose "3"
      arg0.msg("Porta está trancada.")
    casofim


classe cmd_fechar
herda comando_comum

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_fechar(arg0, arg1), nulo
  efim
  txt10 dir
  dir = misc:d1[arg1]
  se arg0 == ""
    msg("Abrir o que?")
  senao !dir
    arg0.msg("Não foi possível fechar " + arg2 + ".")
  senao !arg0.dono.dir_[dir]
    arg0.msg("Não há porta nessa direção.")
  senao
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
    casose "1"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] + 1) # Fecha a porta
      $mens.p(arg0)
      $mens.mtodos1("$P fechou uma porta.")
    casose "2"
    casose "3"
      arg0.msg("Porta já está fechada.")
    casofim


classe cmd_falar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Falar\b\n\
Sintaxe: falar <mensagem>\n\
Envia mensagem para todos os personagens que estiverem na mesma sala."

func escr
  $mens.p(arg0)
  se txt(arg2, 0, 3) == "..."
    $mens.mtodos1("$P continuou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "?"
    $mens.mtodos1("$P perguntou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "!"
    $mens.mtodos1("$P exclamou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 3) == "..."
    $mens.mtodos1("$P ponderou: " + txttroca(arg2, "$", "$$"))
  senao
    $mens.mtodos1("$P disse: " + txttroca(arg2, "$", "$$"))
  fimse
# Executa eventos
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_falou(arg0, arg2)
  efim


classe cmd_chat
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Canal chat\b\n\
Sintaxe: chat <mensagem>\n\
Envia mensagem para os jogadores que estiverem com esse canal habilitado.\n\
Sintaxe: chat\n\
Habilita ou desabilita esse canal."

func escr
  $mens.p(arg0)
  se !arg2
    arg0.sock.canais = arg0.sock.canais ^ 2
    se arg0.sock.canais & 2
      arg0.msg("Canal chat habilitado.")
    senao
      arg0.msg("Canal chat desabilitado")
    fimse
  senao !(arg0.sock.canais & 2)
    arg0.msg("Canal chat está desabilitado.")
  senao
    listaitem item
    epara item = $jogcomum.jog.ini, item, item.depois
      item.obj.canais & 2 && item.obj.msg("(chat) " + arg0.sock.nome + ": " + arg2)
    efim


classe cmd_quem
herda comando_comum
const posic = 0

func escr
  listaitem item
  textotxt t0
  txt100 t1
# Obtém lista de jogadores
  ref r
  epara r = $jogador, r, r = objdepois(r)
    t1 = txt(99999 * 99999 - r.nivel) + " "
    t1 += txtfim("      " + r.nivel, 6) + "  " + r.nome
    r.sock == nulo && (t1 += "  [Desconectado]")
    t0.addfim(t1)
  efim
# Ordena
  t0.ordena
# Mostra para o jogador
  arg0.msg("Personagens online: " + t0.linhas)
  enquanto t0.linhas
    arg0.msg("N" + txt2(t0.remove))
  efim


classe cmd_fim
herda comando_comum
const posic = 0

func escr
  se arg0.b_tempo && arg0.senha
    arg0.msg("Você está ocupad" + misc:sletra[arg0.sexo] + " demais para isso.")
  senao
    arg0.msg("Até mais. Aguardamos o seu retorno.")
    apagar(arg0)


classe cmd_quit
herda cmd_fim


classe cmd_ver
herda comando_comum
const posic = 5

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_ver(arg0, arg1), nulo
  efim
  ret !arg2, arg0.msg2(arg0.dono.descsala(arg0, 7))
  nomeobj n
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  n.ini(arg1, 1)
  epara nulo, l, l.ini.remove
    se arg0.visivel(l.objini) && n.nome(l.objini.ident)
      arg0.msg(txtmaimin(l.objini.nome) + ".")
      arg0.msg(l.objini.descver)
      ret
    fimse
  efim
  arg0.msg("Você não vê isso.")


classe cmd_inv
herda comando_comum
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro1.ini, item, item.depois
    arg0.visivel(item.obj) && t.addfim(txt(item.obj.objtot) + " " + item.obj.nome)
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Você carrega:\n" + t.remove(1000))
  senao
    arg0.msg("Você não está carregando nada.")
  fimse


classe cmd_equip
herda comando_comum
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro2.ini, item, item.depois
    continuar !arg0.visivel(item.obj)
    t.addfim("1 (" + equip(item.obj.vestpos) + ") " + item.obj.nome)
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Equipado com:\n" + t.remove(1000))
  senao
    arg0.msg("Não está vestindo/usando nada.")
  fimse

func equip
  casovar arg0
  casose "1"
    ret "como luz"
  casose "2"
    ret "na cabeça"
  casose "3"
    ret "sobre o rosto"
  casose "4"
    ret "nos olhos"
  casose "5"
    ret "nas orelhas"
  casose "6"
    ret "no pescoço"
  casose "7"
    ret "no corpo"
  casose "8"
    ret "sobre o corpo"
  casose "9"
    ret "nas costas"
  casose "10"
    ret "nos braços"
  casose "11"
    ret "nas mãos"
  casose "12"
    ret "no pulso direito"
  casose "13"
    ret "no pulso esquerdo"
  casose "14"
    ret "no dedo direito"
  casose "15"
    ret "no dedo esquerdo"
  casose "16"
    ret "empunhando"
  casose "17"
    ret "escudo"
  casose "18"
    ret "na cintura"
  casose "19"
    ret "nas pernas"
  casose "20"
    ret "calçando"
  casose
    ret "desconhecido"
  casofim


classe cmd_pegar
herda comando_comum
const posic = 5
#
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_pegar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.container
      ret arg0.msg("Não é possível pegar nada de " + sala.nome + ".")
    fimse
    mens = " de $r $a."
  fimse
# Pega os itens
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  n.ini(misc:sep1, 1000000)
  epara l.addfim(sala.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, l.objini.evento, sala.evento), e, e.ini.remove
      sair e.objini.cmd_pegar1(arg0, l.objini, sala, total)
    efim
    se !e
      l.objini.mudadono(arg0, total)
      nomes.addfim(txt(total) + " " + l.objini.nome)
    fimse
    sair nomes.linhas >= 10
  efim
# Mensagem para o jogador
  nomes.juntalin("", "x ")
  se !nomes
    arg0.msg("Você não vê isso.")
  senao
    $mens.p(arg0, sala)
    $mens.mvis1("$P pega " + txttroca(nomes.remove(10), "\n", ", ") + mens)


classe cmd_soltar
herda comando_comum
#
ref sala # Aonde soltar os itens
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.container
      ret arg0.msg("Não é possível soltar nada em " + sala.nome + ".")
    fimse
    mens = " em $r $a."
  fimse
# Solta os itens
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  n.ini(misc:sep1, 1000000)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, l.objini.evento, sala.evento), e, e.ini.remove
      sair e.objini.cmd_soltar1(arg0, l.objini, sala, total)
    efim
    se !e
      l.objini.mudadono(sala, total)
      nomes.addfim(txt(total) + " " + l.objini.nome)
    fimse
    sair nomes.linhas >= 10
  efim
# Mensagem para o jogador
  nomes.juntalin("", "x")
  se !nomes
    arg0.msg("Você não vê isso.")
  senao
    $mens.p(arg0, sala)
    $mens.mvis1("$P solta " + txttroca(nomes.remove(10), "\n", ", ") + mens)


classe cmd_dar
herda comando_comum
#
ref sala # Para quem dar os itens
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_dar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  ret !misc:sep2, arg0.msg("Dar itens para quem?")
  sala = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
  se !sala
    ret arg0.msg("Você não vê " + misc:sep2 + ".")
  senao !sala.container
    ret arg0.msg("Não é possível dar nada para " + sala.nome + ".")
  fimse
# Dá os itens
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  n.ini(misc:sep1, 1000000)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, l.objini.evento, sala.evento), e, e.ini.remove
      sair e.objini.cmd_dar1(arg0, l.objini, sala, total)
    efim
    se !e
      l.objini.mudadono(sala, total)
      nomes.addfim(txt(total) + " " + l.objini.nome)
    fimse
    sair nomes.linhas >= 10
  efim
# Mensagem para o jogador
  nomes.juntalin("", "x ")
  se !nomes
    arg0.msg("Você não vê isso.")
  senao
    $mens.p(arg0, sala)
    $mens.mvis1("$P dá " + txttroca(nomes.remove(10), "\n", ", ") + " para $r $a.")


classe cmd_vestir
herda comando_comum

func escr
  se !arg2
    arg0.msg("Vestir o que?")
    ret
  fimse
  listaobj l
  listaitem item
  int32 vest
# Checa o que quer vestir
  l.addfim(arg0.dentro1)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não vê isso.")
    ret
  fimse
# Preenche vest com o que está vestindo
  epara item = arg0.dentro2, item, item.depois
    vest = vest | 1 << item.obj.vestpos
  efim
  vest = vest >> 1
# Tenta vestir
  int1 ajustar
  enquanto l
    ref r
    r = l.objini
    se ~vest & r.vestir == 0
      arg0.msg("Você não consegue vestir " + r.nome)
    senao
      uint32 x
      x = ~vest & r.vestir
      r.vestpos = 0
      !(x & 65535) && (x = x >> 16) + (r.vestpos += 16)
      !(x & 255) && (x = x >> 8) + (r.vestpos += 8)
      !(x & 15) && (x = x >> 4) + (r.vestpos += 4)
      !(x & 3) && (x = x >> 2) + (r.vestpos += 2)
      !(x & 1) && (x = x >> 1) + (r.vestpos += 1)
      vest = vest | 1 << r.vestpos
      r.vestpos += 1
      r.idono.remove
      r.idono = arg0.dentro2.addini(r)
      $mens.p(arg0, r)
      $mens.mvis1("$P veste $r $a.")
      ajustar = 1
    fimse
    l.ini.remove
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar


classe cmd_remover
herda comando_comum

func escr
  se !arg2
    arg0.msg("Remover o que?")
    ret
  fimse
  listaobj l
  ref r
  l.addfim(arg0.dentro2)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não está usando isso.")
    ret
  fimse
  int1 ajustar
  enquanto l
    r = l.objini
    r.idono.remove
    r.idono = arg0.dentro1.addini(r)
    r.vestpos = 0
    $mens.p(arg0, r)
    $mens.mvis1("$P remove $r.")
    l.ini.remove
    ajustar = 1
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar


classe cmd_hora
herda comando_comum
const posic = 0

func escr
  datahora d
  d.agora
  arg0.msg("Hora atual MUD:      " + $jogcomum.hora + ":" + $jogcomum.min)
  arg0.msg("Hora atual servidor: " + d.hora + ":" + d.min)


classe cmd_debug
herda comando_comum
const posic = 0

func escr
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.objini + "/" + l0.objini.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  listaitem item
  epara item = $jogcomum.jog.ini, item, item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  ref r
  epara r = $jogador, r, r = objdepois(r)
    arg0.msg("> " + r.nome + " (" + r.sock.nome + ")")
  efim


classe cmd_vida
herda comando_comum, comando_ajuda
const posic = 0

func escr
  txt100 lin
  lin = "Vida " + arg0.vida + "/" + arg0.vidamax
  lin += "  Mana " + arg0.mana + "/" + arg0.manamax
  lin += "  Vigor " + arg0.move + "/" + arg0.movemax
  lin += "  Nível " + arg0.nivel
  lin += "  Experiência " + arg0.exp + "/" + arg0.expmax
  arg0.msg(lin)


classe comando_golpe
herda comando_comum
const posic = 7
const tipo = 0 # Tipo de golpe
const precisao = 100 # Precisão do golpe, 100 significa 100%
const forca = 100 # Força do golpe, 100 significa 100%
const veloc = 100 # Velocidade do golpe, 100 significa 100%
const msgatk = "$P ataca $A"

func escr
  se arg0.batalhaini(arg2) # Inicia batalha
    txt200 msg1
    velgolpe(arg0, arg0.b_alvo) # Tempo do golpe
    msg1 = execgolpe(arg0, arg0.b_alvo, 1, 3) # Danos do golpe
    $mens.p(arg0, arg0.b_alvo)
    $mens.mvis1(msgatk + ", " + arg0.b_alvo.vida + " " + msgefeito(msg1))
    arg0.batalhadepois # Procedimentos depois que atacou

func msgefeito
  casovar arg0
  casose "0"
    ret " errou"
  casose "1"
    ret " nada acontece"
  casose "2"
    ret " pouco efeito"
  casose "3"
    ret ""
  casose "4"
    ret " muito efeito"
  casofim

func velgolpe # Acerta o tempo de espera conforme o golpe
# arg0 = personagem que está atacando
# arg1 = personagem alvo
  uint8 tempo
# Se velocidades dos MOBs iguais e velocidade do golpe=100, tempo=25
  tempo = 10 + arg1.veloc * 1500 / (arg1.veloc * veloc + 1)
  tempo < 5 && (tempo = 5)
  tempo > 60 && (tempo = 60)
  arg0.p_espera = tempo

func execgolpe # Realiza um ataque
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2,arg3 = ataque mínimo e máximo da arma usada no golpe
# Retorna: 0=errou, 1=sem efeito, 2=pouco efetivo, 3=normal, 4=muito efetivo
  real dano
# Checa se acertou o alvo
  dano = rand(1, 20)
  se dano == 20 || arg1.posicao == 4 # Acertou automaticamente
  senao dano == 1 # Errou o alvo automaticamente
    ret 0
  senao # Checa se acertou
    dano += precisao * arg0.precisao / 100 - arg1.evasao
    !arg0.visivel(arg1) && (dano -= 5) # Invisível é mais difícil de acertar
    se dano <= 0
      ret 0
    fimse
  fimse
# Calcula dano sem modificadores
  se misc:aktipo(tipo) # Checa se golpe normal ou especial
    dano = arg0.atkmag * forca / (arg1.defmag * 9000)
  senao
    dano = arg0.atknorm * forca / (arg1.defnorm * 9000)
  fimse
  dano = pos(dano + arg0.nivel - arg1.nivel) # Adiciona diferença de níveis
  dano += rand(arg2, arg3) # Adiciona ataque da arma
# Modificadores de posição
  casovar arg1.posicao
  casose "0" # Morto
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    dano *= 2.666
    sair
  casose "3" # Muito fraco
    dano *= 2.333
    sair
  casose "4" # dormindo
    dano *= 2
    sair
  casose "5" # descansando
    dano *= 1.666
    sair
  casose "6" # sentado
    dano *= 1.333
    sair
  casofim
# Modificadores de tipo de golpe
  int8 rettipo
  rettipo = arg1.deftipo[tipo]
  casovar rettipo
  casose "-8"
    rettipo = 4, dano *= 16
    sair
  casose "-7"
    rettipo = 4, dano *= 11.2
    sair
  casose "-6"
    rettipo = 4, dano *= 8
    sair
  casose "-5"
    rettipo = 4, dano *= 5.6
    sair
  casose "-4"
    rettipo = 4, dano *= 4
    sair
  casose "-3"
    rettipo = 4, dano *= 2.8
    sair
  casose "-2"
    rettipo = 4, dano *= 2
    sair
  casose "-1"
    rettipo = 3, dano *= 1.4
    sair
  casose "0"
    rettipo = 3
    sair
  casose "1"
    rettipo = 3, dano /= 1.4
    sair
  casose "2"
    rettipo = 3, dano /= 2
    sair
  casose "3"
    rettipo = 2, dano /= 2.8
    sair
  casose "4"
    rettipo = 2, dano /= 4
    sair
  casose "5"
    rettipo = 2, dano /= 5.6
    sair
  casose "6"
    rettipo = 2, dano /= 8
    sair
  casose "7"
    rettipo = 2, dano /= 11.2
    sair
  casose "8"
    rettipo = 2, dano /= 16
    sair
  casose
    se rettipo < 0
      rettipo = 4, dano *= 16 # Danos demais
    senao
      rettipo = 1, dano = 0 # Imune ao ataque
      ret
    fimse
  casofim
# Atualiza pontos de vida conforme os danos
  dano < 1 && (dano = 1) # Pelo menos 1 de dano
  arg1.vida -= dano
  ret rettipo


classe cmd_atk
herda comando_golpe
