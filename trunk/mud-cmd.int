classe com2_comum
const nivel = 1 # Nível mínimo para usar o comando
const posic = 8 # Posição mínima para usar o comando
const pode = 1 # Se comando existe para o personagem (arg0=personagem, arg1=texto)
const iniclasse = criar(arg0) # Cria um objeto do comando

func exec # Executa o comando
# arg0=personagem
# arg1=comando que escreveu
# arg2=texto após o comando
  arg0.msg("Você digitou " + arg1 + " " + arg2)


classe com2_move
herda com2_comum
# Movimenta-se em uma direção
const iniclasse = criar(arg0)

func exec1 # Executa o comando
# arg0 = personagem
# arg1 = direção
# arg2 = mensagem de saída
# arg3 = mensagem de chegada
  ref s1 # Sala aonde está
  ref s2 # Sala para onde vai
  listaobj l0
  l0.addfim(arg0.evento)
  enquanto l0 && !l0.objini.e_mover(arg0, arg1)
    l0.ini.remove
  efim
  se l0
    ret
  fimse
  misc:obj = arg0
  s1 = arg0.dono
  s2 = s1.dir_[arg1]
  se l0 # Retorna se lista não estiver vazia
  senao s2 == nulo
    arg0.msg("Impossível seguir nessa direção.")
  senao s1.tipo_[arg1] & 3 >= 2
    arg0.msg("A porta está fechada.")
  senao
    uint8 total
    total = s1.totalmove + s2.totalmove
    se arg0.move < total
      arg0.msg("Você está cansad" + misc:sletra[arg0.sexo] + " demais.")
      ret
    fimse
    arg0.move -= total / 2
    total -= 1 # Para garantir pelo menos 2 movimentos (total é uint8)
    arg0.p_espera = total * 2 + 2
    $mens.p(arg0)
    $mens.mvis2("", "$P foi " + arg2)
    arg0.mudasala(s2)
    $mens.mvis2("", "$P chegou " + arg3)
    arg0.dono.s_morre && arg0.morreu


classe com_n
herda com2_move
const exec = exec1(arg0, "n", "para o norte.", "do sul.")


classe com_s
herda com2_move
const exec = exec1(arg0, "s", "para o sul.", "do norte.")


classe com_l
herda com2_move
const exec = exec1(arg0, "l", "para o leste.", "do oeste.")


classe com_o
herda com2_move
const exec = exec1(arg0, "o", "para o oeste.", "do leste.")


classe com_w
herda com_o


classe com_c
herda com2_move
const exec = exec1(arg0, "c", "para cima.", "de baixo.")


classe com_u
herda com_c


classe com_b
herda com2_move
const exec = exec1(arg0, "b", "para baixo.", "de cima.")


classe com_d
herda com_b


classe com_ne
herda com2_move
const exec = exec1(arg0, "ne", "para o nordeste.", "do noroeste.")


classe com_no
herda com2_move
const exec = exec1(arg0, "no", "para o noroeste.", "do nordeste.")


classe com_nw
herda com_no


classe com_se
herda com2_move
const exec = exec1(arg0, "se", "para o sudeste.", "do sudoeste.")


classe com_so
herda com2_move
const exec = exec1(arg0, "so", "para o sudoeste.", "do sudeste.")


classe com_sw
herda com_so


classe com_abrir
herda com2_comum

func exec
  txt10 dir
  dir = misc:d1[arg2]
  se arg0 == ""
    arg0.msg("Abrir o que?")
  senao dir
    se !arg0.dono.dir_[dir]
      arg0.msg("Não há porta nessa direção.")
      ret
    fimse
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
      ret
    casose "1"
      arg0.msg("Porta já está aberta.")
      ret
    casose "2"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] - 1) # Abre a porta
      $mens.p(arg0)
      $mens.mtodos1("$P abriu uma porta.")
      ret
    casose "3"
      arg0.msg("Porta está trancada.")
      ret
    casofim
  senao
    arg0.msg("Não foi possível abrir " + arg2 + ".")


classe com_fechar
herda com2_comum

func exec
  txt10 dir
  dir = misc:d1[arg2]
  se arg0 == ""
    msg("Abrir o que?")
  senao dir
    se !arg0.dono.dir_[dir]
      arg0.msg("Não há porta nessa direção.")
      ret
    fimse
    casovar 3 & arg0.dono.tipo_[dir]
    casose "0"
      arg0.msg("Não há porta nessa direção.")
      ret
    casose "1"
      arg0.dono.mudatipo(dir, arg0.dono.tipo_[dir] + 1) # Fecha a porta
      $mens.p(arg0)
      $mens.mtodos1("$P fechou uma porta.")
      ret
    casose "2"
    casose "3"
      arg0.msg("Porta já está fechada.")
      ret
    casofim
  senao
    arg0.msg("Não foi possível fechar " + arg2 + ".")


classe com_falar
herda com2_comum
const posic = 5

func exec
  $mens.p(arg0)
  se txt(arg2, 0, 3) == "..."
    $mens.mtodos1("$P continuou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "?"
    $mens.mtodos1("$P perguntou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 1) == "!"
    $mens.mtodos1("$P exclamou: " + txttroca(arg2, "$", "$$"))
  senao txtfim(arg2, 3) == "..."
    $mens.mtodos1("$P ponderou: " + txttroca(arg2, "$", "$$"))
  senao
    $mens.mtodos1("$P disse: " + txttroca(arg2, "$", "$$"))
  fimse
# Executa eventos
  listaobj l0
  l0.addfim(arg0.evento)
  enquanto l0 && l0.objini.e_falar(arg0, arg2)
    l0.ini.remove
  efim


classe com_chat
herda com2_comum
const posic = 0

func exec
  $mens.p(arg0)
  se !arg2
    arg0.sock.canais = arg0.sock.canais ^ 2
    se arg0.sock.canais & 2
      arg0.msg("Canal chat habilitado.")
    senao
      arg0.msg("Canal chat desabilitado")
    fimse
  senao !(arg0.sock.canais & 2)
    arg0.msg("Canal chat está desabilitado.")
  senao
    listaitem item
    epara item = $jogcomum.jog.ini, item, item.depois
      item.obj.canais & 2 && item.obj.msg("(chat) " + arg0.sock.nome + ": " + arg2)
    efim


classe com_quem
herda com2_comum
const posic = 0

func exec
  listaitem item
  textotxt t0
  txt100 t1
# Obtém lista de jogadores
  ref r
  epara r = $jogador, r, r = objdepois(r)
    t1 = txt(99999 * 99999 - r.nivel) + " "
    t1 += txtfim("      " + r.nivel, 6) + "  " + r.nome
    r.sock == nulo && (t1 += "  [Desconectado]")
    t0.addfim(t1)
  efim
# Ordena
  t0.ordena
# Mostra para o jogador
  arg0.msg("Personagens online: " + t0.linhas)
  enquanto t0.linhas
    arg0.msg("N" + txt2(t0.remove))
  efim


classe com_fim
herda com2_comum
const posic = 0

func exec
  se arg0.b_tempo && arg0.senha
    arg0.msg("Você está ocupad" + misc:sletra[arg0.sexo] + " demais para isso.")
  senao
    arg0.msg("Até mais. Aguardamos o seu retorno.")
    apagar(arg0)


classe com_quit
herda com_fim


classe com_ver
herda com2_comum
const posic = 5

func exec
  se !arg2
    arg0.msg2(arg0.dono.descsala(arg0, 7))
    ret
  fimse
  listaobj l
  nomeobj n
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  n.ini(arg2, 1)
  epara nulo, l, l.ini.remove
    se arg0.visivel(l.objini) && n.nome(l.objini.ident)
      arg0.msg(txtmaimin(l.objini.nome) + ".")
      arg0.msg(l.objini.descver)
      ret
    fimse
  efim
  arg0.msg("Você não vê isso.")


classe com_inv
herda com2_comum
const posic = 5

func exec
  textotxt t
  listaitem item
  epara item = arg0.dentro1.ini, item, item.depois
    arg0.visivel(item.obj) && t.addfim("1 " + item.obj.nome)
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Você carrega:\n" + t.remove(1000))
  senao
    arg0.msg("Você não está carregando nada.")
  fimse


classe com_equip
herda com2_comum
const posic = 5

func exec
  textotxt t
  listaitem item
  epara item = arg0.dentro2.ini, item, item.depois
    continuar !arg0.visivel(item.obj)
    t.addfim("1 (" + equip(item.obj.vestpos) + ") " + item.obj.nome)
  efim
  t.juntalin("(", "x) ")
  se t.linhas
    arg0.msg2("Equipado com:\n" + t.remove(1000))
  senao
    arg0.msg("Não está vestindo/usando nada.")
  fimse

func equip
  casovar arg0
  casose "1"
    ret "como luz"
  casose "2"
    ret "na cabeça"
  casose "3"
    ret "sobre o rosto"
  casose "4"
    ret "nos olhos"
  casose "5"
    ret "nas orelhas"
  casose "6"
    ret "no pescoço"
  casose "7"
    ret "no corpo"
  casose "8"
    ret "sobre o corpo"
  casose "9"
    ret "nas costas"
  casose "10"
    ret "nos braços"
  casose "11"
    ret "nas mãos"
  casose "12"
    ret "no pulso direito"
  casose "13"
    ret "no pulso esquerdo"
  casose "14"
    ret "no dedo direito"
  casose "15"
    ret "no dedo esquerdo"
  casose "16"
    ret "empunhando"
  casose "17"
    ret "escudo"
  casose "18"
    ret "na cintura"
  casose "19"
    ret "nas pernas"
  casose "20"
    ret "calçando"
  casose
    ret "desconhecido"
  casofim


classe com_pegar
herda com2_comum
const posic = 5

func exec
  ref r # De onde pegar
  misc:separa(arg2) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    r = arg0.dono
  senao
    r = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !r
      arg0.msg("Você não vê " + t.1 + ".")
      ret
    senao !r.container
      arg0.msg("Não é possível pegar nada de " + r.nome + ".")
      ret
    fimse
  fimse
  nomeobj n # Para reconhecer os itens
  listaobj l # A lista de itens
  int1 pegou # Se pegou algum item
  l.addfim(r.dentro1)
  n.ini(arg2, 10)
# Pega os itens
  epara nulo, l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident)
    pegou = 1
    listaobj e
    e.addfim(arg0.evento, l.objini.evento, r.evento)
    enquanto e && !e.objini.e_pegar(arg0, l.objini, r)
      e.ini.remove
    efim
    se !e && t.1
      l.objini.dono = arg0
      $mens.p(arg0, r, l.objini)
      $mens.mvis1("$P pega $s $o de $r $a.")
    senao !e
      l.objini.dono = arg0
      $mens.p(arg0, r, l.objini)
      $mens.mvis1("$P pega $s $o.")
    fimse
  efim
  !pegou && arg0.msg("Você não vê isso.")


classe com_soltar
herda com2_comum

func exec
  ref r # Aonde soltar
  misc:separa(arg2) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    r = arg0.dono
  senao
    r = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !r
      arg0.msg("Você não vê " + t.1 + ".")
      ret
    senao !r.container
      arg0.msg("Não é possível colocar nada em " + r.nome + ".")
      ret
    fimse
  fimse
  nomeobj n # Para reconhecer os itens
  listaobj l # A lista de itens
  int1 soltou # Se soltou algum item
  l.addfim(arg0.dentro1)
  n.ini(misc:sep1, 10)
  epara nulo, l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident)
    soltou = 1
    listaobj e
    e.addfim(arg0.evento, l.objini.evento, r.evento)
    enquanto e && !e.objini.e_soltar(arg0, l.objini, r)
      e.ini.remove
    efim
    se !e && t.1
      l.objini.dono = r
      $mens.p(arg0, r, l.objini)
      $mens.mvis1("$P coloca $s $o em $r $a.")
    senao !e
      l.objini.dono = r
      $mens.p(arg0, r, l.objini)
      $mens.mvis1("$P solta $s $o.")
    fimse
  efim
  !soltou && arg0.msg("Você não vê " + misc:sep1 + ".")


classe com_dar
herda com2_comum

func exec
  ref r # Para quem dar
  misc:separa(arg2) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    arg0.msg("Dar itens para quem?")
    ret
  senao
    r = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
    se !r
      arg0.msg("Você não vê " + t.1 + ".")
      ret
    senao !r.container
      arg0.msg("Não é possível dar nada para " + r.nome + ".")
      ret
    fimse
  fimse
  nomeobj n # Para reconhecer os itens
  listaobj l # A lista de itens
  int1 soltou # Se deu algum item
  l.addfim(arg0.dentro1)
  n.ini(misc:sep1, 10)
  epara nulo, l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident)
    soltou = 1
    listaobj e
    e.addfim(arg0.evento, l.objini.evento, r.evento)
    enquanto e && !e.objini.e_dar(arg0, l.objini, r)
      e.ini.remove
    efim
    continuar e
    l.objini.dono = r
    $mens.p(arg0, r, l.objini)
    $mens.mvis1("$P dá $s $o para $r $a.")
  efim
  !soltou && arg0.msg("Você não vê " + misc:sep1 + ".")


classe com_vestir
herda com2_comum

func exec
  se !arg2
    arg0.msg("Vestir o que?")
    ret
  fimse
  listaobj l
  listaitem item
  int32 vest
# Checa o que quer vestir
  l.addfim(arg0.dentro1)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não vê isso.")
    ret
  fimse
# Preenche vest com o que está vestindo
  epara item = arg0.dentro2, item, item.depois
    vest = vest | 1 << item.obj.vestpos
  efim
  vest = vest >> 1
# Tenta vestir
  int1 ajustar
  enquanto l
    ref r
    r = l.objini
    se ~vest & r.vestir == 0
      arg0.msg("Você não consegue vestir " + r.nome)
    senao
      uint32 x
      x = ~vest & r.vestir
      r.vestpos = 0
      !(x & 65535) && (x = x >> 16) + (r.vestpos += 16)
      !(x & 255) && (x = x >> 8) + (r.vestpos += 8)
      !(x & 15) && (x = x >> 4) + (r.vestpos += 4)
      !(x & 3) && (x = x >> 2) + (r.vestpos += 2)
      !(x & 1) && (x = x >> 1) + (r.vestpos += 1)
      vest = vest | 1 << r.vestpos
      r.vestpos += 1
      r.idono.remove
      r.idono = arg0.dentro2.addini(r)
      $mens.p(arg0, r)
      $mens.mvis1("$P veste $r $a.")
      ajustar = 1
    fimse
    l.ini.remove
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar


classe com_remover
herda com2_comum

func exec
  se !arg2
    arg0.msg("Remover o que?")
    ret
  fimse
  listaobj l
  ref r
  l.addfim(arg0.dentro2)
  arg0.itemnome(l, arg2)
  se !l.ini
    arg0.msg("Você não está usando isso.")
    ret
  fimse
  int1 ajustar
  enquanto l
    r = l.objini
    r.idono.remove
    r.idono = arg0.dentro1.addini(r)
    r.vestpos = 0
    $mens.p(arg0, r)
    $mens.mvis1("$P remove $r.")
    l.ini.remove
    ajustar = 1
  efim
# Ajusta variáveis
  ajustar && arg0.ajustavar


classe com_hora
herda com2_comum
const posic = 0

func exec
  datahora d
  d.agora
  arg0.msg("Hora atual MUD:      " + $jogcomum.hora + ":" + $jogcomum.min)
  arg0.msg("Hora atual servidor: " + d.hora + ":" + d.min)


classe com2_debug
herda com2_comum
const posic = 0

func exec
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.objini + "/" + l0.objini.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  listaitem item
  epara item = $jogcomum.jog.ini, item, item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  ref r
  epara r = $jogador, r, r = objdepois(r)
    arg0.msg("> " + r.nome + " (" + r.sock.nome + ")")
  efim


classe com_info
herda com2_comum
const posic = 0

func exec
  txt100 lin
  lin = "vida " + arg0.vida + "/" + arg0.vidamax
  lin += "  mana " + arg0.mana + "/" + arg0.manamax
  lin += "  vigor " + arg0.move + "/" + arg0.movemax
  lin += "  nível " + arg0.nivel
  lin += "  experiência " + arg0.exp + "/" + arg0.expmax
  arg0.msg(lin)


classe com2_golpe
herda com2_comum
const posic = 7
const tipo = 0 # Tipo de golpe
const precisao = 100 # Precisão do golpe, 100 significa 100%
const forca = 100 # Força do golpe, 100 significa 100%
const veloc = 100 # Velocidade do golpe, 100 significa 100%
const msgatk = "$P ataca $A"

func exec
  se arg0.batalhaini(arg2) # Inicia batalha
    txt200 msg1
    velgolpe(arg0, arg0.b_alvo) # Tempo do golpe
    msg1 = execgolpe(arg0, arg0.b_alvo, 1, 3) # Danos do golpe
    $mens.p(arg0, arg0.b_alvo)
    $mens.mvis1(msgatk + ", " + arg0.b_alvo.vida + " " + msgefeito(msg1))
    arg0.batalhadepois # Procedimentos depois que atacou

func msgefeito
  casovar arg0
  casose "0"
    ret " errou"
  casose "1"
    ret " nada acontece"
  casose "2"
    ret " pouco efeito"
  casose "3"
    ret ""
  casose "4"
    ret " muito efeito"
  casofim

func velgolpe # Acerta o tempo de espera conforme o golpe
# arg0 = personagem que está atacando
# arg1 = personagem alvo
  uint8 tempo
# Se velocidades dos MOBs iguais e velocidade do golpe=100, tempo=25
  tempo = 10 + arg1.veloc * 1500 / (arg1.veloc * veloc + 1)
  tempo < 5 && (tempo = 5)
  tempo > 60 && (tempo = 60)
  arg0.p_espera = tempo

func execgolpe # Realiza um ataque
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2,arg3 = ataque mínimo e máximo da arma usada no golpe
# Retorna: 0=errou, 1=sem efeito, 2=pouco efetivo, 3=normal, 4=muito efetivo
  real dano
# Checa se acertou o alvo
  dano = rand(1, 20)
  se dano == 20 || arg1.posicao == 4 # Acertou automaticamente
  senao dano == 1 # Errou o alvo automaticamente
    ret 0
  senao # Checa se acertou
    dano += precisao * arg0.precisao / 100 - arg1.evasao
    !arg0.visivel(arg1) && (dano -= 5) # Invisível é mais difícil de acertar
    se dano <= 0
      ret 0
    fimse
  fimse
# Calcula dano sem modificadores
  se misc:aktipo(tipo) # Checa se golpe normal ou especial
    dano = arg0.atkmag * forca / (arg1.defmag * 9000)
  senao
    dano = arg0.atknorm * forca / (arg1.defnorm * 9000)
  fimse
  dano = pos(dano + arg0.nivel - arg1.nivel) # Adiciona diferença de níveis
  dano += rand(arg2, arg3) # Adiciona ataque da arma
# Modificadores de posição
  casovar arg1.posicao
  casose "0" # Morto
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    dano *= 2.666
    sair
  casose "3" # Muito fraco
    dano *= 2.333
    sair
  casose "4" # dormindo
    dano *= 2
    sair
  casose "5" # descansando
    dano *= 1.666
    sair
  casose "6" # sentado
    dano *= 1.333
    sair
  casofim
# Modificadores de tipo de golpe
  int8 rettipo
  rettipo = arg1.deftipo[tipo]
  casovar rettipo
  casose "-8"
    rettipo = 4, dano *= 16
    sair
  casose "-7"
    rettipo = 4, dano *= 11.2
    sair
  casose "-6"
    rettipo = 4, dano *= 8
    sair
  casose "-5"
    rettipo = 4, dano *= 5.6
    sair
  casose "-4"
    rettipo = 4, dano *= 4
    sair
  casose "-3"
    rettipo = 4, dano *= 2.8
    sair
  casose "-2"
    rettipo = 4, dano *= 2
    sair
  casose "-1"
    rettipo = 3, dano *= 1.4
    sair
  casose "0"
    rettipo = 3
    sair
  casose "1"
    rettipo = 3, dano /= 1.4
    sair
  casose "2"
    rettipo = 3, dano /= 2
    sair
  casose "3"
    rettipo = 2, dano /= 2.8
    sair
  casose "4"
    rettipo = 2, dano /= 4
    sair
  casose "5"
    rettipo = 2, dano /= 5.6
    sair
  casose "6"
    rettipo = 2, dano /= 8
    sair
  casose "7"
    rettipo = 2, dano /= 11.2
    sair
  casose "8"
    rettipo = 2, dano /= 16
    sair
  casose
    se rettipo < 0
      rettipo = 4, dano *= 16 # Danos demais
    senao
      rettipo = 1, dano = 0 # Imune ao ataque
      ret
    fimse
  casofim
# Atualiza pontos de vida conforme os danos
  dano < 1 && (dano = 1) # Pelo menos 1 de dano
  arg1.vida -= dano
  ret rettipo


classe com_atk
herda com2_golpe
