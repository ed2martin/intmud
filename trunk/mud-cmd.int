classe comando_comum
const posic = 8 # Posição mínima para usar o comando
const objcmd = este # Objeto que processa o comando, ou nulo se não existe
# const ultimo = 1 # Deve estar definido se comando tem baixa prioridade

func escr # Processa o comando
# arg0 = objeto do personagem
# arg1 = texto digitado após o nome do comando

func iniclasse
  criar(arg0)


classe comando_mover
herda comando_comum
const m_entra = "$P chegou"
const m_sai = "$P foi embora"
const dir = ""
const comando_mover = 1 # Para indicar que é comando de movimentação do jogador

func escr # Executa o comando
# arg0 = personagem
  ref s1 # Sala aonde está
  ref s2 # Sala para onde vai
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_[dir](arg0), nulo
  efim
  misc:obj = arg0
  s1 = arg0.dono, s2 = s1.dir_[dir]
  ret s2 == nulo, arg0.msg("Impossível seguir nessa direção.")
  ret s1.porta_[dir] & 3 >= 2, arg0.msg("A porta está fechada.")
  uint8 total
  total = s1.totalmove + s2.totalmove
  se arg0.move < total
    arg0.msg("Você está cansad" + misc:sletra[arg0.sexo] + " demais.")
    ret
  fimse
  arg0.move -= total / 2
  total -= 1 # Para garantir pelo menos 2 movimentos (total é uint8)
  arg0.p_espera = total * 2 + 2
  $mens.p(arg0)
  $mens.mvis2("", m_sai)
  arg0.mudadono(s2)
  $mens.mvis2("", m_entra)
  arg0.dono.s_morre && arg0.morreu


classe cmd_n
herda comando_mover
const m_entra = "$P chegou do sul."
const m_sai = "$P foi para o norte."
const dir = "n"


classe cmd_s
herda comando_mover
const m_entra = "$P chegou do norte."
const m_sai = "$P foi para o sul."
const dir = "s"


classe cmd_l
herda comando_mover
const m_entra = "$P chegou do oeste."
const m_sai = "$P foi para leste."
const dir = "l"


classe cmd_e
const obj = $cmd_l.obj(arg0, arg1)


classe cmd_o
herda comando_mover
const m_entra = "$P chegou do leste."
const m_sai = "$P foi para oeste."
const dir = "o"


classe cmd_w
const obj = $cmd_o.obj(arg0, arg1)


classe cmd_c
herda comando_mover
const m_entra = "$P chegou de baixo."
const m_sai = "$P subiu."
const dir = "c"


classe cmd_u
const obj = $cmd_c.obj(arg0, arg1)


classe cmd_b
herda comando_mover
const m_entra = "$P chegou de cima."
const m_sai = "$P desceu."
const dir = "b"


classe cmd_d
const obj = $cmd_b.obj(arg0, arg1)


classe cmd_ne
herda comando_mover
const m_entra = "$P chegou do sudoeste."
const m_sai = "$P foi para o nordeste."
const dir = "ne"


classe cmd_no
herda comando_mover
const m_entra = "$P chegou do sudeste."
const m_sai = "$P foi para o noroeste."
const dir = "no"


classe cmd_nw
const obj = $cmd_no.obj(arg0, arg1)


classe cmd_se
herda comando_mover
const m_entra = "$P chegou do noroeste."
const m_sai = "$P foi para o sudeste."
const dir = "se"


classe cmd_so
herda comando_mover
const m_entra = "$P chegou do nordeste."
const m_sai = "$P foi para o sudoeste."
const dir = "se"


classe cmd_sw
const obj = $cmd_so.obj(arg0, arg1)


classe cmd_abrir
herda comando_comum

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Abrir um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1, i, i.depois
    sair arg0.visivel(i.obj) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair arg0.visivel(i.obj) && n.nome(i.obj.ident, i.obj.objtot)
    efim
  fimse
# Gera eventos
  listaobj l
  ref r
  r = i.obj
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_abrirobj(arg0, r, arg1), nulo
  efim
# Tenta abrir o item
  se arg0 == ""
    arg0.msg("Abrir o que?")
  senao !r
    arg0.msg("Você não vê " + arg1 + ".")
  senao
    casovar r.abrir
    casose "2"
      arg0.msg(txtmaimin(arg0) + " já está aberto.")
      sair
    casose "3"
      r.abrir = 2
      $mens.p(arg0, r)
      $mens.mtodos1("$P abriu $A.")
      epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
        l.objini.cmd_abriuobj(arg0, r, arg1)
      efim
      sair
    casose "4"
      arg0.msg(txtmaimin(r.nome) + " está trancado.")
      sair
    casose
      arg0.msg("Não foi possível abrir " + r.nome + ".")
      sair
    casofim

func escrdir # Abrir uma porta
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_abrirdir(arg0, arg0.dono, arg1), nulo
  efim
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    arg0.msg("Não há porta nessa direção.")
    sair
  casose "1"
    arg0.msg("Porta já está aberta.")
    sair
  casose "2"
    arg0.dono.mudaporta(arg1, 1) # Abre a porta
    $mens.p(arg0)
    $mens.mtodos1("$P abriu uma porta.")
    epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
      l.objini.cmd_abriudir(arg0, arg0.dono, arg1)
    efim
    sair
  casose "3"
    arg0.msg("Porta está trancada.")
    sair
  casofim


classe cmd_fechar
herda comando_comum

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Fechar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1, i, i.depois
    sair arg0.visivel(i.obj) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair arg0.visivel(i.obj) && n.nome(i.obj.ident, i.obj.objtot)
    efim
  fimse
# Gera eventos
  listaobj l
  ref r
  r = i.obj
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_fecharobj(arg0, r, arg1), nulo
  efim
# Tenta abrir o item
  se arg0 == ""
    arg0.msg("Fechar o que?")
  senao !r
    arg0.msg("Você não vê " + arg1 + ".")
  senao
    casovar r.abrir
    casose "3"
    casose "4"
      arg0.msg(txtmaimin(r.nome) + " já está fechado.")
      sair
    casose "2"
      r.abrir = 3
      $mens.p(arg0, r)
      $mens.mtodos1("$P fechou $A.")
      epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
        l.objini.cmd_fechouobj(arg0, r, arg1)
      efim
      sair
    casose
      arg0.msg("Não foi possível fechar " + r.nome + ".")
      sair
    casofim

func escrdir # Fechar uma porta
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_fechardir(arg0, arg0.dono, arg1), nulo
  efim
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    arg0.msg("Não há porta nessa direção.")
    sair
  casose "1"
    arg0.dono.mudaporta(arg1, 2) # Fecha a porta
    $mens.p(arg0)
    $mens.mtodos1("$P fechou uma porta.")
    epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
      l.objini.cmd_fechoudir(arg0, arg0.dono, arg1)
    efim
    sair
  casose "2"
  casose "3"
    arg0.msg("Porta já está fechada.")
    sair
  casofim


classe cmd_falar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Falar\b\n\
Sintaxe: falar <mensagem>\n\
Envia mensagem para todos os personagens que estiverem na mesma sala."

func escr
  $mens.p(arg0)
  se txt(arg1, 0, 3) == "..."
    $mens.mtodos1("$P continuou: " + txttroca(arg1, "$", "$$"))
  senao txtfim(arg1, 1) == "?"
    $mens.mtodos1("$P perguntou: " + txttroca(arg1, "$", "$$"))
  senao txtfim(arg1, 1) == "!"
    $mens.mtodos1("$P exclamou: " + txttroca(arg1, "$", "$$"))
  senao txtfim(arg1, 3) == "..."
    $mens.mtodos1("$P ponderou: " + txttroca(arg1, "$", "$$"))
  senao
    $mens.mtodos1("$P disse: " + txttroca(arg1, "$", "$$"))
  fimse
# Executa eventos
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_falou(arg0, arg1)
  efim


classe cmd_chat
herda comando_comum, comando_ajuda
const posic = 0
const ultimo = 1 # Tem baixa prioridade
const txtajuda = "\b\c3Canal chat\b\n\
Sintaxe: chat <mensagem>\n\
Envia mensagem para os jogadores que estiverem com o canal CHAT habilitado.\n\
Para habilitar ou desabilitar esse canal, use o comando CONFIG."

func escr
  $mens.p(arg0)
  se !arg0.jogconfig.4
    arg0.msg("Canal CHAT está desabilitado.")
  senao !arg1
    arg0.msg("Tecle a mensagem após CHAT.")
  senao
    listaitem item
    epara item = $jogcomum.jog.ini, item, item.depois
      item.obj.jogconfig.4 && item.obj.msg("(chat) " + arg0.sock.nome + ": " + arg1)
    efim


classe cmd_quem
herda comando_comum
const posic = 0

func escr
  listaitem item
  textotxt t0
  txt100 t1
# Obtém lista de jogadores
  ref r
  epara r = $jogador, r, r = objdepois(r)
    continuar r.jogconfig.17 && !arg0.jogconfig.17
    t1 = txt(99999 * 99999 - r.pnivel) + " "
    t1 += txtfim("      " + r.pnivel, 6) + "  " + r.nome
    r.sock == nulo && (t1 += "  [Desconectado]")
    r.jogconfig.17 && (t1 += "  [Invis]")
    t0.addfim(t1)
  efim
# Ordena
  t0.ordena
# Mostra para o jogador
  arg0.msg("Personagens online: " + t0.linhas)
  enquanto t0.linhas
    arg0.msg("N" + txt2(t0.remove))
  efim


classe cmd_fim
herda comando_comum
const posic = 0

func escr
  se arg0.atkenv && arg0.senha
    arg0.msg("Você está ocupad" + misc:sletra[arg0.sexo] + " demais para isso.")
  senao
    arg0.msg("Até mais. Aguardamos o seu retorno.")
    apagar(arg0)


classe cmd_quit
herda cmd_fim


classe cmd_ver
herda comando_comum
const posic = 5

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_ver(arg0, arg1), nulo
  efim
  se !arg1
    se arg0.jogconfig.16
      arg0.msg2(txt(arg0.dono, 2) + "  " + arg0.dono.descsala(arg0, 7))
    senao
      arg0.msg2(arg0.dono.descsala(arg0, 7))
    fimse
    ret
  fimse
  ret arg0.dono.ver_[arg1](arg0), nulo
  nomeobj n
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  n.ini(arg1, 1)
  epara nulo, l, l.ini.remove
    se arg0.visivel(l.objini) && n.nome(l.objini.ident)
      arg0.msg(txtmaimin(l.objini.nome) + ".")
      arg0.msg(l.objini.descver)
      ret
    fimse
  efim
  arg0.msg("Você não vê isso.")


classe comando_var
herda comando_comum

func lista # Lista de itens, como habilidades, idiomas, etc.
# arg0 = personagem
# arg1 = variável textovar
# arg2 = prefixo que identifica o tipo de variável (duas letras)
# arg3 = mensagem se nada for encontrado
# arg4 = mensagem se alguma coisa for encontrada
  textotxt h
  txt100 t1
  txt100 t2
  t1 = arg1.ini(arg2)
  enquanto txt(t1, 0, 2) == arg2
    t2 = txttroca(txt(t1, 2), "_", " ")
    se arg1.valor(t1) == "1"
      h.addfim(t2)
    senao
      h.addfim(arg1.valor(t1) + "x " + t2)
    fimse
    t1 = arg1.depois(t1)
  efim
  se h.linhas
    h.addfim(txttroca(h.remove(1000), "\n", ", "))
    h.addini(arg4)
    arg0.msg(h.remove(1000))
  senao
    arg0.msg(arg3)
  fimse
  ret 1


classe cmd_hab
herda comando_var

func escr
  txt100 n
  arg0.persoesc != arg0 && (n = " de " + arg0.persoesc.nome)
  lista(arg0, arg0.persoesc.var, "h_", "Nenhuma habilidade" + n, "Habilidades" + n)


classe cmd_idioma
herda comando_var

func escr
  lista(arg0, arg0.var, "l_", "Nenhum idioma", "Idiomas")


classe cmd_outros
herda comando_var

func escr
  se !exevento(este, arg0, arg1)
    lista(arg0, arg0.var, "o_", "Nenhum item extra", "Itens extra")


classe cmd_inv
herda comando_comum
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro1.ini, item, item.depois
    arg0.visivel(item.obj) && t.addfim(txt(item.obj.objtot) + " " + item.obj.nome)
  efim
  t.juntalin("(", "x)")
  se t
    arg0.msg2("Você carrega:\n" + t.remove(1000))
  senao
    arg0.msg("Você não está carregando nada.")
  fimse


classe cmd_equip
herda comando_comum
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro2.ini, item, item.depois
    continuar !arg0.visivel(item.obj)
    t.addfim("1 (" + equip(item.obj.vestpos) + ") " + item.obj.nome)
  efim
  t.juntalin("(", "x)")
  se t.linhas
    arg0.msg2("Equipado com:\n" + t.remove(1000))
  senao
    arg0.msg("Não está vestindo/usando nada.")
  fimse

func equip
  casovar arg0
  casose "1"
    ret "como luz"
  casose "2"
    ret "na cabeça"
  casose "3"
    ret "sobre o rosto"
  casose "4"
    ret "nos olhos"
  casose "5"
    ret "nas orelhas"
  casose "6"
    ret "no pescoço"
  casose "7"
    ret "no corpo"
  casose "8"
    ret "sobre o corpo"
  casose "9"
    ret "nas costas"
  casose "10"
    ret "nos braços"
  casose "11"
    ret "nas mãos"
  casose "12"
    ret "no pulso direito"
  casose "13"
    ret "no pulso esquerdo"
  casose "14"
    ret "no dedo direito"
  casose "15"
    ret "no dedo esquerdo"
  casose "16"
    ret "empunhando"
  casose "17"
    ret "escudo"
  casose "18"
    ret "na cintura"
  casose "19"
    ret "nas pernas"
  casose "20"
    ret "calçando"
  casose
    ret "desconhecido"
  casofim


classe cmd_config
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = arg0.sock.admin ? txtajuda1 + txtajuda2 : txtajuda1
const txtajuda1 = "\b\c3Config\b\n\
Sintaxe: config +<opção>\n\
         config -<opção>\n\
Altera algumas preferências do seu personagem. Um sinal de + ou de -\n\
seguido de uma opção ativa ou desativa a opção. Para saber as atuais\n\
preferências, tecle apenas CONFIG, sem parâmetros.\n\n\
As opções são:\n\
  \c2DESC\b     Mostra descrições completas (como ao digitar VER)\n\
  \c2SAIDAS\b   Mostra as saídas visíveis após a descrição da sala\n\
  \c2CORES\b    Recebe sequência de cores no padrão ANSI (somente Telnet)\n\
  \c2ACENTO\b   Recebe letras com acentuação (codificação ISO8859-1)\n\
  \c2CHAT\b     Participa do canal de comunicação CHAT"
const txtajuda2 = "\n\
  \c2SALA\b     Mostra o nome da sala cadastrada antes do título\n\
  \c2QUEM\b     Ocultar a presença no comando quem\n\
  \c2INVIS\b    Invisível a não administradores\n\
  \c2AC\b       Participa do canal de comunicação AC (administração)"
# As próximas constantes são as opções do comando CONFIG
# Cada constante contém o índice da variável de jogconfig
# As variáveis "opc_" contém o int1 de jogconfig que correspondente à opção
# Números de 0 a 15 são as opções disponíveis a todos
# Números de 16 a 31 são as opções disponíveis aos administradores
const opc_desc = 0
const opc_saidas = 1
const opc_cores = 2
const opc_acento = 3
const opc_chat = 4
const opc_sala = 16
const opc_quem = 17
const opc_invis = 18
const opc_ac = 19

func escr
  prog p
  txt512 x
  txt512 y
  int1 opc.32
  opc.bits = arg0.jogconfig.bits
  se !arg1
    epara p.inifunc(este, "opc_"), p.lin, p.depois
      se opc.[[p.texto]]
        x += " +" + txtmai(txt(p.texto, 4))
      senao [p.texto] < 16 || arg0.sock.admin
        y += " -" + txtmai(txt(p.texto, 4))
      fimse
    efim
    arg0.msg("CONFIG" + x + y)
    ret
  fimse
  x = txttroca(arg1, "+", " +")
  x = txttroca(x, "-", " -")
  x = txtremove(x, "EMD")
  txt512 mudou
  enquanto x
    epara p.inifunc(este, "opc_" + txt(txt1(x), 1)), p.lin, p.depois
      sair [p.texto] < 16 || arg0.sock.admin
    efim
    se !p.lin
      y += " " + txt1(x)
    senao txt(x, 0, 1) == "+"
      opc.[[p.texto]] = 1
      mudou += " +" + txtmai(txt(p.texto, 4))
    senao txt(x, 0, 1) == "-"
      opc.[[p.texto]] = 0
      mudou += " -" + txtmai(txt(p.texto, 4))
    senao
      y += " " + txt1(x)
    fimse
    x = txt2(x)
  efim
  ret y, arg0.msg("Opção inexistente:" + y)
  arg0.jogconfig.bits = opc.bits
  arg0.sock.jogconfig.bits = opc.bits
  arg0.msg("Configuração alterada:" + mudou)


classe cmd_pegar
herda comando_comum
const posic = 5
#
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_pegar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.container
      ret arg0.msg("Não é possível pegar nada de " + sala.nome + ".")
    fimse
    mens = " de $t $a."
  fimse
# Pega os itens
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  n.ini(misc:sep1, 1000000)
  achou = 0
  epara l.addfim(sala.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_pegarobj(arg0, sala, l.objini, total)
    efim
    se !e
      $mens.p(arg0, sala, l.objini)
      se total <= 1
        $mens.mvis1("$P pega $O" + mens)
      senao
        $mens.mvis1("$P pega " + total + "x $O" + mens)
      fimse
      l.objini.mudadono(arg0, total)
    fimse
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_pegouobj(arg0, sala, l.objini, total)
    efim
    sair (achou += 1) >= 10
  efim
  !achou && arg0.msg("Você não vê isso.")


classe cmd_soltar
herda comando_comum
#
ref sala # Aonde soltar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.container
      ret arg0.msg("Não é possível soltar nada em " + sala.nome + ".")
    fimse
    mens = " em $t $a."
  fimse
# Solta os itens
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_soltarobj(arg0, sala, l.objini, total)
    efim
    se !e
      $mens.p(arg0, sala, l.objini)
      se total <= 1
        $mens.mvis1("$P solta $O" + mens)
      senao
        $mens.mvis1("$P solta " + total + "x $O" + mens)
      fimse
      l.objini.mudadono(sala, total)
    fimse
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_soltouobj(arg0, sala, l.objini, total)
    efim
    sair (achou += 1) >= 10
  efim
  !achou && arg0.msg("Você não vê isso.")


classe cmd_dar
herda comando_comum
#
ref sala # Para quem dar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_dar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  ret !misc:sep2, arg0.msg("Dar itens para quem?")
  sala = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
  se !sala
    ret arg0.msg("Você não vê " + misc:sep2 + ".")
  senao !sala.container
    ret arg0.msg("Não é possível dar nada para " + sala.nome + ".")
  fimse
# Dá os itens
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !arg0.visivel(l.objini) || !n.nome(l.objini.ident, l.objini.objtot)
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_darobj(arg0, sala, l.objini, total)
    efim
    se !e
      $mens.p(arg0, sala, l.objini)
      se total <= 1
        $mens.mvis1("$P dá $O para $t $a.")
      senao
        $mens.mvis1("$P dá " + total + "x $O para $t $a.")
      fimse
      l.objini.mudadono(sala, total)
    fimse
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_deuobj(arg0, sala, l.objini, total)
    efim
    sair (achou += 1) >= 10
  efim
  !achou && arg0.msg("Você não vê isso.")


classe cmd_vestir
herda comando_comum

func escr
  ret !arg1, arg0.msg("Vestir o que?")
# Preenche a variável vest com o que está vestindo
  listaitem item
  int1 vest.32
  vest.0 = 1
  epara item = arg0.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos] = 1
  efim
# Veste
  int8 total # Quantidade de itens encontrados
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !arg0.visivel(r) || !n.nome(r.ident, r.objtot)
    uint8 x
    epara x = n, x, x -= 1
      total += 1
      se !vest.[r.vestir1]
        r.vestir(r.vestir1)
      senao !vest.[r.vestir2]
        r.vestir(r.vestir2)
      senao !vest.[r.vestir3]
        r.vestir(r.vestir3)
      senao r.vestir1 || r.vestir2 || r.vestir3
        arg0.msg("Já está vestindo algo em cima.")
        sair
      senao
        arg0.msg("Você não consegue vestir " + r.nome + ".")
        sair
      fimse
      vest.[r.vestpos] = 1
      $mens.p(arg0, r)
      $mens.mvis1("$P veste $t $a.")
    efim
  efim
# Ajusta variáveis
  !total && arg0.msg("Você não vê isso.")


classe cmd_remover
herda comando_comum

func escr
  ret !arg1, arg0.msg("Remover o que?")
# Remove
  uint8 total
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  epara l.addfim(arg0.dentro2), l, l.ini.remove
    r = l.objini
    continuar !arg0.visivel(r) || !n.nome(r.ident, r.objtot)
    uint8 x
    epara x = n, x, x -= 1
      total += 1
      r.vestir(0)
      $mens.p(arg0, r)
      $mens.mvis1("$P remove $t $a.")
    efim
  efim
# Ajusta variáveis
  !total && arg0.msg("Você não está usando isso.")


classe cmd_hora
herda comando_comum
const posic = 0

func escr
  datahora d
  d.agora
  arg0.msg("Hora atual MUD:      " + $jogcomum.hora + ":" + $jogcomum.min)
  arg0.msg("Hora atual servidor: " + d.hora + ":" + d.min)


classe cmd_debug
herda comando_comum
const posic = 0

func escr
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.objini + "/" + l0.objini.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  listaitem item
  epara item = $jogcomum.jog.ini, item, item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  ref r
  epara r = $jogador, r, r = objdepois(r)
    arg0.msg("> " + r.nome + " (" + r.sock.nome + ")")
  efim


classe cmd_vida
herda comando_comum, comando_ajuda
const posic = 0

func escr
  txt100 lin
  lin = "Vida " + arg0.pvida + "/" + arg0.pvidamax
  lin += "  Mana " + arg0.pmana + "/" + arg0.pmanamax
  lin += "  Vigor " + arg0.pmove + "/" + arg0.pmovemax
  lin += "  Nível " + arg0.pnivel
  lin += "  Experiência " + arg0.expatual + "/" + arg0.expmax
  arg0.msg(lin)
