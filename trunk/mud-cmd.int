classe comando_comum
const posic = 8 # Posição mínima para usar o comando
const objcmd = este # Objeto que processa o comando, ou nulo se não existe

func escr # Processa o comando
# arg0 = objeto do personagem
# arg1 = texto digitado após o nome do comando

func iniclasse
  criar(arg0)


classe cmd_lancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Lançar\b\nSintaxe: LANÇAR <nome da magia>\nLança uma magia."
const posic = 0
const lancamagia = 1 # Para indicar ao personagem que é comando de lançar magia
# Nota: a função escr aqui é desnecessária


classe cmd_fim
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Fim\b\n\
Sintaxe: FIM\n\
Sai do jogo, retirando também o seu personagem. Você pode usar esse\n\
comando a qualquer momento, exceto se estiver lutando. E quando entrar\n\
novamente no jogo, voltar aonte estava.\n\
Simplesmente sair do jogo sem teclar FIM pode deixar seu personagem\n\
\"pendurado\" no jogo por alguns minutos, à mercê de qualquer perigo.\n\
Mas isso não significa que ele está totalmente indefeso. Se atacado,\n\
lutará como qualquer personagem não jogador."
const posic = 0

func escr
  se arg0.atkenv && arg0.senha
    arg0.msg("Você está ocupad" + (arg0.msexo ? "o" : "a") + " demais para isso.")
  senao
    arg0.msg("Até mais. Aguardamos o seu retorno.")
    apagar(arg0)


classe cmd_quit
herda cmd_fim


classe cmd_config
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = arg0.jogconfig.23 ? txtajuda1 + txtajuda2 : txtajuda1
const txtajuda1 = aj1 + (config:chattipo ? aj2) + (config:novatostipo ? aj3) + (config:emocaotipo\
 ? aj4) + aj5
const aj1 = "\b\c3Config\b\n\
Sintaxe: CONFIG +<opção>\n\
         CONFIG -<opção>\n\
Altera algumas preferências do seu personagem. Um sinal de + ou de -\n\
seguido de uma opção ativa ou desativa a opção. Para saber as atuais\n\
preferências, tecle apenas CONFIG, sem parâmetros.\n\n\
As opções são:\n\
  \c2DESC\b      Mostra descrições completas (como ao digitar OLHAR)\n\
  \c2SAIDAS\b    Mostra as saídas visíveis após a descrição da sala\n\
  \c2CORES\b     Recebe sequência de cores no padrão ANSI (somente Telnet)\n\
  \c2ACENTO\b    Recebe letras com acentuação (codificação ISO8859-1)\n\
  \c2TELEPATIA\b Recebe mensagens com o comando PVT\n"
const aj2 = "  \c2CHAT\b      Participa do canal de comunicação CHAT\n"
const aj3 = "  \c2NOVATOS\b   Participa do canal de comunicação NOVATOS\n"
const aj4 = "  \c2EMOÇÃO\b    Mostra (e) nas mensagens geradas com esse comando\n"
const aj5 = "  \c2SEGUIR\b    Se outros personagens podem escolher seguir você\n\
  \c2MOEDAS\b    Pega as moedas do corpo do personagem após vencer uma batalha\n\
  \c2PROMPT\b    Ativa o prompt normal\n\
  \c2BROMPT\b    Ativa o prompt de batalha"
const txtajuda2 = "\n\
Opções para administradores:\n\
  \c2IMORTAL\b   Não morre em batalha, sempre consegue fugir, enxerga tudo exceto\n\
            cego e no escuro, tranca e destranca tudo, atravessa coisas\n\
            fechadas, anda sem gastar movimento\n\
  \c2SALA\b      Mostra o nome da sala cadastrada antes do título\n\
  \c2QUEM\b      O comando QUEM mostra onde cada jogador está no MUD\n\
  \c2INVQUEM\b   Ocultar a presença no comando quem\n\
  \c2INVSALA\b   Invisível a não administradores\n\
  \c2AC\b        Participa do canal de comunicação AC (administração)\n\
  \c2ADMLOG\b    Canal ADMLOG - é informado sobre mudanças online no MUD\n\
  \c2CMDLOG\b    Canal CMDLOG - é informado quando alguém usar CMD, CMDP\n\
            ou CMDJs e o comando possuir alguma letra\n\
  \c2EXECLOG\b   Canal EXECLOG - só tem utilidade para programadores\n\
            informa quando a variável exec chegar a 0 (bug no programa)"
# As próximas constantes são as opções do comando CONFIG
# Cada constante contém o índice da variável de jogconfig
# As variáveis "opc_" contém o int1 de jogconfig que correspondente à opção
# Números de 0 a 13 são as opções disponíveis a todos
# Números de 14 a 23 são as opções disponíveis aos administradores
const opc_desc = 0
const opc_saidas = 1
const opc_cores = 2
const opc_acento = 3
const opc_chat = config:chattipo ? 4
const opc_seguir = 5
const opc_prompt = 6
const opc_bprompt = 7
const opc_telepatia = 8
const opc_emocao = config:emocaotipo ? 9
const opc_moedas = 10
const opc_novatos = config:novatostipo ? 11
const opc_imortal = 14
const opc_execlog = 15
const opc_sala = 16
const opc_invquem = 17
const opc_invsala = 18
const opc_ac = 19
const opc_quem = 20
const opc_admlog = 21
const opc_cmdlog = 22
# Nota: o bit 23 é reservado para indicar se é administrador

func escr
  prog p
  txt512 x
  txt512 y
  int1 opc.32
  opc.bits = arg0.jogconfig.bits
  se !arg1
    epara p.inifunc(este, "opc_"), p.lin, p.depois
      se !txt([p.texto])
      senao opc.[[p.texto]]
        x += " +" + txtmai(txt(p.texto, 4))
      senao [p.texto] < 14 || arg0.jogconfig.23
        y += " -" + txtmai(txt(p.texto, 4))
      fimse
    efim
    arg0.msg("CONFIG" + x + y)
    ret
  fimse
  x = txttroca(arg1, "+", " +")
  x = txttroca(x, "-", " -")
  x = txtremove(x, "EMD")
  txt512 mudou
  enquanto x
    epara p.inifunc(este, "opc_" + txt(txt1(x), 1)), p.lin, p.depois
      sair ([p.texto] < 14 || arg0.jogconfig.23) && txt([p.texto])
    efim
    se !p.lin
      y += " " + txt1(x)
    senao txt(x, 0, 1) == "+"
      opc.[[p.texto]] = 1
      mudou += " +" + txtmai(txt(p.texto, 4))
    senao txt(x, 0, 1) == "-"
      opc.[[p.texto]] = 0
      mudou += " -" + txtmai(txt(p.texto, 4))
    senao
      y += " " + txt1(x)
    fimse
    x = txt2(x)
  efim
  ret y, arg0.msg("Opção inexistente:" + y)
# Checa a propriedade INVIS
  se arg0.jogconfig.18 != opc.18 # Se a propriedade INVIS mudou
    arg0.recalc = 1 # Deverá atualizar bitinv
  fimse
# Checa a propriedade IMORTAL
  se arg0.jogconfig.14 != opc.14 # Se a propriedade IMORTAL mudou
    arg0.recalc = 1 # Deverá atualizar bitver
  fimse
# Checa a propriedade SEGUIR
  se !opc.5 # Se não pode ser seguido
    epara nulo, arg0.lseguir, arg0.lseguir.ini.remove
      arg0.lseguir.objini.msg("Você pára de seguir " + arg0.descnome + ".")
    efim
  fimse
# Atualiza a configuração
  arg0.jogconfig.bits = opc.bits
  arg0.sock.jogconfig.bits = opc.bits
  arg0.msg("Configuração alterada:" + mudou)


classe cmd_prompt
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Prompt\b\n\
Sintaxe: PROMPT  [texto]\n\
         BPROMPT [texto]\n\n\
PROMPT é uma ou mais linhas para indicar a você que o MUD já enviou todas\n\
as mensagens pendentes. Com essa opção pode-se personalisar as mensagens,\n\
inclusive adicionando algumas variáveis, como pontos de vida, hora, etc.\n\n\
BPROMPT funciona de forma idêntica ao PROMPT, porém corresponde à\n\
mensagem durante a batalha.\n\
Sem nenhum texto, essas opções mostram o prompt atual.\n\
Se o texto for a palavra ini (exemplo: PROMPT INI), o prompt será\n\
redefinido para o padrão do MUD.\n\n\
Nota: para a mensagem de prompt aparecer, deve estar habilitada no\n\
comando CONFIG.\n\n\
As seguintes sequências de caracteres têm um significado especial:\n\n\
 \c2%n\b  Nome do seu personagem usado nas batalhas\n\
 \c2%N\b  Nome do seu oponente (se estiver batalhando)\n\
 \c2%h\b  Pontos de vida atuais\n\
 \c2%H\b  Total de pontos de vida\n\
 \c2%p\b  Pontos de vida em porcentagem\n\
 \c2%P\b  Pontos de vida em uma barra de 10 caracteres\n\
 \c2%o\b  Pontos de vida do oponente em porcentagem\n\
 \c2%O\b  Pontos de vida do oponente em uma barra de 10 caracteres\n\
 \c2%m\b  Pontos de mana atuais\n\
 \c2%M\b  Pontos de mana totais\n\
 \c2%v\b  Pontos de vigor atuais\n\
 \c2%V\b  Pontos de vigor totais\n\
 \c2%g\b  Quantidade de moedas que seu personagem possui\n\
 \c2%l\b  Nível do seu personagem\n\
 \c2%L\b  Nível do seu oponente\n\
 \c2%x\b  Experiência do seu personagem\n\
 \c2%X\b  Experiência necessária para o próximo nível\n\
 \c2%T\b  Conforme o sol: amanhecendo, manhã, tarde, anoitecendo, noite\n\
 \c2%d\b  Hora no MUD\n\
 \c2%D\b  Hora no servidor\n\
 \c2%z\b  Uma quebra de linha (para definir prompts de várias linhas)\n\
 \c2%Z\b  O caracter %\n\
 \c2%t\b  O mesmo que um espaço em branco\n\n\
Exemplos (considerando 30 pontos de vida, 45 de mana e 50 de vigor):\n\n\
PROMPT %h%m                =  3045\n\
PROMPT %h %m %v            =  30 45 50\n\
PROMPT <%hhp %mmn %vmv>    =  <30hp 45mn 50mv>\n\
PROMPT <%c3%hhp %c2%mmn %c6%vmv%b>  = <\c330hp \c245mn \c650mv\b>  (com cores)\n\n\
Veja também: AJUDA CORES"

func escr
  ret !arg1, arg0.msg("Prompt:\n" + arg0.var.z_prompt)
  txt100 lin
  lin = arg1 == "ini" ? "<%c3%hhp %c2%mmn %c6%vmv%b> " : arg1
  arg0.var.z_prompt = lin
  arg0.msg("Prompt alterado para:\n" + lin)


classe cmd_bprompt
herda cmd_prompt

func escr
  ret !arg1, arg0.msg("Prompt de batalha:\n" + arg0.var.z_bprompt)
  txt100 lin
  lin = arg1 == "ini" ? "<%c3%hhp %c2%mmn %c6%vmv%b> " : arg1
  arg0.var.z_bprompt = lin
  arg0.msg("Prompt de batalha alterado para:\n" + lin)


classe cmd_salvar
herda comando_comum, comando_ajuda
const objcmd = config:salvartipo ? este
const objajuda = config:salvartipo ? este
const posic = 5
const txtajuda = "\b\c3Salvar\b\n\
Sintaxe: SALVAR\n\
O MUD já salva o seu personagem de tempos em tempos e quando seu personagem\n\
sai do jogo. Esse comando permite salvar novamente a qualquer momento.\n\
Se o personagem nunca foi salvo, será solicitada uma nova senha.\n\
Veja também o comando SENHA (muda a senha do seu personagem)"

func escr
  ref r
  $mens.p(arg0)
  $mens.mens = arg1
  se arg0.senha
    arg0.p_espera = 10
    ret arg0.msg(arg0.salvar ? "Jogo salvo com sucesso" : "Erro ao salvar o jogo")
  senao int(config:salvarnivel) > 65535
    ret arg0.msg("Para poder salvar, você precisa já ter salvo o jogo uma vez.")
  senao arg0.pnivel < config:salvarnivel
    ret arg0.msg("Para salvar você precisa estar no nível " + config:salvarnivel + ".")
  senao
    ret arg0.mudasenha


classe cmd_senha
herda comando_comum, comando_ajuda
const objcmd = config:salvartipo ? este
const objajuda = config:salvartipo ? este
const posic = 5
const txtajuda = "\b\c3Senha\b\n\
Sintaxe: SALVAR\n\
Muda a senha do seu personagem e salva em seguida.\n\
Veja também o comando SALVAR (salva o seu personagem)"

func escr
  ref r
  $mens.p(arg0)
  $mens.mens = arg1
  ret arg0.senha, arg0.mudasenha
  arg0.msg("Seu personagem não possui senha. Tecle SALVAR para salvar o jogo.")


classe cmd_ver
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Ver\b\n\
Sintaxe: VER\n\
         VER <personagem ou objeto>\n\
Olha de relance para o lugar aonde você está ou para um personagem ou\n\
objeto. É semelhante ao comando olhar, mas dá menos informações."
const posic = 5
const completo = 0 # No comando olhar, essa variável é 1

func escr
  se !arg1
    se arg0.jogconfig.16
      arg0.msg2(txt(arg0.dono, 2) + "  " + arg0.dono.descsala(arg0, completo ? 7 : 6))
    senao
      arg0.msg2(arg0.dono.descsala(arg0, completo ? 7 : 6))
    fimse
    ret
  fimse
  nomeobj n
  prog p
  ref r
  n.ini(arg1, 1)
  r = arg0.dono
  epara p.inifunc(r, "ver_"), p.lin, p.depois
    continuar !r.[p.texto](arg0, 0) || !n.nome(txt(p.texto, 4))
    arg0.msg(r.[p.texto](arg0, 1))
    ret
  efim
  listaobj l
  l.addfim(r.dentro1, r.dentro2, arg0.dentro1)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ret arg0 == l.objini, arg0.msg("Olhar para você mesm" + (arg0.msexo ? "o?" : "a?"))
    r = l.objini
# Gera eventos
    l.limpar
    se completo
      epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
        ret l.objini.cmd_olhar(arg0, r), nulo
      efim
    senao
      epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
        ret l.objini.cmd_ver(arg0, r), nulo
      efim
    fimse
# O que o personagem está vestindo
    textotxt t
    se r.perso
      se completo
        int1 vest.32 # Aonde está vestindo
        ref pos.55
        listaitem item
        epara item = r.dentro2.ini, item, item.depois
          vest.[item.obj.vestpos - 1] = 1, pos.[item.obj.vestpos] = item.obj
        efim
        txt512 lin
        txt100 nomepos
        epara lin = config:equip_ordem, lin, lin = txt2(lin)
          refvar obj = pos.[1 + txt1(lin)]
          continuar !obj.vestpos || !obj.visivel(arg0)
# continuar vest.bits & config:vestir[obj.vestpos - 1]
          nomepos = "\c2(" + misc:equip(obj.vestpos) + ")\b "
          nomepos += txtesp(20 - inttotal(nomepos))
          t.addfim(nomepos + txtcopiamai(obj.descnome, "A"))
        efim
        t.linhas && t.addini("Equipado com:")
      fimse
# O que o container possui
    senao r.i_aberto == 5
    senao r.i_aberto
      se r.i_aberto < 3 || arg0.jogconfig.14
        r.var.z_moedas && t.addfim("1 " + txtcopiamai(misc:txtmoedas(r.var.z_moedas), "A"))
        listaitem item
        epara item = r.dentro1.ini, item, item.depois
          continuar !item.obj.visivel(arg0)
          t.addfim(txt(item.obj.objtot) + " " + txtcopiamai(item.obj.descnome, "A"))
        efim
        se !t.linhas
          t.addfim(r.msexo ? "Está vazio." : "Está vazia.")
        senao completo
          t.juntalin("(", "x)")
          t.addini("Dentro você vê:")
        senao
          t.limpar
        fimse
      fimse
      se r.i_aberto >= 3
        t.addini(r.msexo ? "Está fechado." : "Está fechada.")
      fimse
    fimse
# Nome, nível, situação atual e animal que escolheu
    r.descver(arg0) && t.addini(r.descver(arg0))
    txt200 t2
    t2 = (completo ? "\b\c6" : "\b") + txtcopiamai(r.descnome, "A")
    se r.perso
      t2 += niveltipo(r) + ", " + estado(r)
      se r.persobat && r.persobat != r
        t2 += ".\b\nEscolheu " + r.persobat.nome + niveltipo(r.persobat)
        t2 += ", " + estado(r.persobat)
      fimse
    senao r.pnivel
      t2 += ", é um objeto do nível " + r.pnivel
    fimse
# Luz
    se int(r.luztempo.abs) >= 25
      int32 tempo
      tempo = r.luztempo.abs / 50
      r.luztempo > 0 && (t2 += r.msexo ? ", aceso" : ", acesa")
      t2 += ", produz luz por " + tempo + (tempo == 1 ? " minuto" : " minutos")
# t2 += r.luztempo
    fimse
# Envia mensagem
    ret !completo, arg0.msg(t2 + ".\b")
    se r.perso
      $mens.p(arg0, r)
      $mens.mvis2("", "$P olha para $a.")
    senao r.dono != arg0
      $mens.p(arg0, nulo, r)
      $mens.mvis2("", "$P olha para $o.")
    fimse
    ret t.linhas, arg0.msg2(t2 + ".\b\n" + t.remove(1000))
    ret arg0.msg(t2 + ".\b\nVocê não vê nada de especial.")
  efim
  arg0.msg("Você não vê isso.")

func estado # Retorna texto que contém o estado atual do personagem
  ret !arg0.pvidamax, "perfeitamente saudável"
  casovar intdiv(arg0.pvida * 6 / arg0.pvidamax)
  casose "0"
    ret arg0.pvida ? "à beira da morte" : "demaiad" + (arg0.msexo ? "o" : "a")
  casose "1"
    ret "sangrando bastante"
  casose "2"
    ret "muito machucad" + (arg0.msexo ? "o" : "a")
  casose "3"
    ret "bastante machucad" + (arg0.msexo ? "o" : "a")
  casose "4"
    ret "um pouco machucad" + (arg0.msexo ? "o" : "a")
  casose "5"
    ret "possui algumas escoriações"
  casose
    ret "perfeitamente saudável"
  casofim

func niveltipo # Usado para informar nível, raça e classe do personagem
  txt100 t
  arg0.jog ? (t = " jogador")
  se config:olhartipo
    arg0.tipo1 && (t += " " + txtcopiamai(arg0.tipo1, "A"))
    arg0.tipo2 && (t += " " + txtcopiamai(arg0.tipo2, "A"))
    arg0.tipo3 && (t += " " + txtcopiamai(arg0.tipo3, "A"))
  fimse
  config:olharnivel && (t += " nível " + arg0.pnivel)
  ret t ? "," + t : ""


classe cmd_olhar
herda cmd_ver
const completo = 1
const txtajuda = "\b\c3Olhar\b\n\
Sintaxe: OLHAR\n\
         OLHAR <personagem ou objeto>\n\
Mostra a descrição completa do lugar aonde você está ou informações\n\
sobre um personagem ou um objeto."


classe cmd_falar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Falar\b\n\
Sintaxe: FALAR <mensagem>\n\
         '<mensagem>\n\
Envia mensagem para todos os personagens que estiverem na mesma sala.\n\
A mensagem pode aparecer diferente se for iniciada com reticências ou\n\
terminada com reticências, interrogação ou exclamação."

func escr
  ret !arg1, arg0.msg("Tecle a mensagem após FALAR.")
  ret arg0.dono.s_falar, arg0.msg(arg0.dono.s_falar)
  $mens.p(arg0)
  $mens.mens = $miscbebida.msgperso(arg1, arg0.p_bebida)
  se txt(arg1, 0, 3) == "..."
    $mens.mtodos1(config:continuarmsg)
  senao txtfim(arg1, 1) == "?"
    $mens.mtodos1(config:perguntarmsg)
  senao txtfim(arg1, 1) == "!"
    $mens.mtodos1(config:exclamarmsg)
  senao txtfim(arg1, 3) == "..."
    $mens.mtodos1(config:ponderarmsg)
  senao
    $mens.mtodos1(config:falarmsg)
  fimse
# Executa eventos
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_falou(arg0, arg1)
  efim


classe cmd_gritar
herda comando_comum, comando_ajuda
const objcmd = config:gritartipo ? este
const objajuda = config:gritartipo ? este
const posic = 5
const txtajuda = "\b\c3Gritar\b\n\
Sintaxe: GRITAR <mensagem>\n\
Envia mensagem para todos os personagens que estiverem na mesma área."

func escr
  ref r
  txt100 area
  se arg0.pnivel < config:gritarnivel
    ret arg0.msg("Para gritar você precisa estar no nível " + config:gritarnivel + ".")
  senao !arg1
    ret arg0.msg("Tecle a mensagem após GRITAR.")
  senao arg0.pmove < config:gritarmove
    ret arg0.msg("Você está cansad" + (arg0.msexo ? "o" : "a") + " demais.")
  fimse
  epara r = arg0.dono, r, r = r.dono
    area = r.s_area
    ret r.s_gritar, arg0.msg(r.s_gritar)
  efim
  arg0.pmove -= config:gritarmove
  $mens.p(arg0)
  $mens.mens = $miscbebida.msgperso(arg1, arg0.p_bebida)
  indiceitem item
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    continuar item.obj.var.u_[arg0.nome]
    epara r = item.obj.dono, r.dono, r = r.dono
      r.s_gritar && (r = nulo)
    efim
    r.s_gritar && (r = nulo)
    r.s_area == area && item.obj.msg($mens.proc(config:gritarmsg, item.obj))
  efim
# Executa eventos
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_gritou(arg0, arg1)
  efim


classe cmd_sussurrar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sussurrar\b\n\
Sintaxe: SUSSURRAR <personagem> <mensagem>\n\
Sussurra uma mensagem para um personagem que está na mesma sala.\n\
A mensagem é enviada reservadamente para o personagem escolhido.\n\
Os outros apenas ficam sabendo que você sussurrou alguma coisa."

func escr
  $mens.mens = ""
  $mens.p(arg0)
  ret !arg1, arg0.msg("Sussurrar para quem?")
  ret !txt2(arg1), arg0.msg("Sussurrar o que?")
  ret arg0.dono.s_falar, arg0.msg(arg0.dono.s_falar)
  nomeobj n
  listaobj l
  n.ini(txt1(arg1), 1)
  l.addfim(arg0.dono.dentro2)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    se l.objini.var.u_[arg0.nome]
      arg0.msg(l.objini.nome + " ignora suas palavras.")
    senao arg0.var.u_[l.objini.nome]
      arg0.msg("Você está ignorando " + l.objini.nome)
    senao arg0 == l.objini
      $mens.p(arg0, l.objini)
      $mens.mtodos1(config:sussurrar1msg)
    senao
      $mens.p(arg0, l.objini)
      $mens.mens = $miscbebida.msgperso(txt2(arg1), arg0.p_bebida)
      $mens.mtodos3(config:sussurrar2msg, config:sussurrar2msg, config:sussurrar3msg)
    fimse
    sair
  efim
# Executa eventos
  ref r
  r = l.objini
  l.remove
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_sussurrou(arg0, r, arg1)
  efim
# Mensagem se não encontrou o personagem
  !r && arg0.msg("Você não vê " + txt1(arg1) + ".")


classe cmd_emocao
herda comando_comum, comando_ajuda
const objcmd = config:emocaotipo ? este
const objajuda = config:emocaotipo ? este
const posic = 5
const txtajuda = "\b\c3Emoção\b\n\
Sintaxe: EMOÇÃO <mensagem>\n\
Mostra para os jogadores na mesma sala o que você está sentindo.\n\
Esse comando mostra o nome do seu personagem seguido da mensagem.\n\
Por exemplo, se seu personagem se chamar Joaquim e você teclar:\n\
emoção está contente hoje.\n\
Os outros jogadores receberão a mensagem:\n\
Joaquim está contente hoje.\n\
Veja também o comando CONFIG"

func escr
  ret !arg0.contr.dono.socktot, nulo
  se arg0.pnivel < config:emocaonivel
    arg0.msg("Para usar o comando EMOÇÃO você precisa estar no nível " + config:emocaonivel + \
".")
  senao !arg1
    arg0.msg("Tecle a mensagem após EMOÇÃO.")
  senao
    refvar lin = "$P " + txttroca(arg1, "$", "$$")
    $mens.p(arg0)
    listaobj l0
    epara l0.addfim(arg0.contr.dono.dentro2), l0, l0.ini.remove
      l0.objini.msginv(l0.objini.jogconfig.9 ? "(e) " + lin : lin)
    efim


classe cmdfim_rezar
herda comando_comum, comando_ajuda
const objcmd = config:rezartipo ? este
const objajuda = config:rezartipo ? este
const txtajuda = "\b\c3Rezar\b\n\
Sintaxe: REZAR <mensagem>\n\
Envia mensagem para os administradores que estiverem no jogo."

func escr
  se arg0.pnivel < config:rezarnivel
    arg0.msg("Para usar o comando REZAR você precisa estar no nível " + config:rezarnivel + \
".")
  senao !arg1
    arg0.msg("Tecle a mensagem após REZAR.")
  senao
    $mens.p(arg0)
    $mens.mens = arg1
    arg0.msginv(config:rezar2msg)
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      continuar !item.obj.jogconfig.23 || item.obj.perso.var.u_[arg0.nome]
      item.obj.msg($mens.proc(config:rezar1msg, item.obj.perso))
    efim


classe cmdfim_chat
herda comando_comum, comando_ajuda
const objcmd = config:chattipo ? este
const objajuda = config:chattipo ? este
const posic = 0
const txtajuda = config:chattipo == 1 ? aj1 + aj2 : aj1
const aj1 = "\b\c3Canal Chat\b\n\
Sintaxe: CHAT <mensagem>\n\
         .<mensagem>\n\
Envia mensagem para os jogadores que estiverem com o canal CHAT habilitado.\n\
Para habilitar ou desabilitar esse canal, use o comando CONFIG."
const aj2 = "\n\
Nota: quando o jogo é ativado em um chat, mensagens de uma sala do chat\n\
não irão para as outras outras salas."

func escr
  $mens.p(arg0)
  $mens.mens = arg1
  se arg0.pnivel < config:chatnivel
    arg0.msg("Para escrever no canal CHAT você precisa estar no nível " + config:chatnivel + \
".")
  senao !arg0.jogconfig.4
    arg0.msg("Canal CHAT está desabilitado.")
  senao !arg1
    arg0.msg("Tecle a mensagem após CHAT.")
  senao config:chattipo == 2 # Escrever para todos
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      continuar !item.obj.jogconfig.4 || item.obj.perso.var.u_[arg0.nome]
      item.obj.msg($mens.proc(config:chatmsg, item.obj.perso))
    efim
  senao # Escrever para quem estiver na mesma sala
    listaobj l
    epara arg0.sock.salaobj(l), l, l.ini.remove
      continuar !l.objini.jogconfig.4 || l.objini.perso.var.u_[arg0.nome]
      l.objini.msg($mens.proc(config:chatmsg, l.objini.perso))
    efim


classe cmdfim_novatos
herda comando_comum, comando_ajuda
const objcmd = config:novatostipo ? este
const objajuda = config:novatostipo ? este
const posic = 0
const txtajuda = config:chattipo == 1 ? aj1 + aj2 : aj1
const aj1 = "\b\c3Canal Novatos\b\n\
Sintaxe: NOVATOS <mensagem>\n\
Envia mensagem para os jogadores que estiverem com o canal NOVATOS\n\
habilitado. Esse canal é destinado a dúvidas de iniciantes.\n\
Para habilitar ou desabilitar esse canal, use o comando CONFIG."
const aj2 = "\n\
Nota: quando o jogo é ativado em um chat, mensagens de uma sala do chat\n\
não irão para as outras outras salas."

func escr
  $mens.p(arg0)
  $mens.mens = arg1
  se arg0.pnivel < config:novatosnivel
    arg0.msg("Para escrever no canal NOVATOS você precisa estar no nível " + config:novatosnivel \
+ ".")
  senao !arg0.jogconfig.11
    arg0.msg("Canal NOVATOS está desabilitado.")
  senao !arg1
    arg0.msg("Tecle a mensagem após NOVATOS.")
  senao config:novatostipo == 2 # Escrever para todos
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      continuar !item.obj.jogconfig.11 || item.obj.perso.var.u_[arg0.nome]
      item.obj.msg($mens.proc(config:novatosmsg, item.obj.perso))
    efim
  senao # Escrever para quem estiver na mesma sala
    listaobj l
    epara arg0.sock.salaobj(l), l, l.ini.remove
      continuar !l.objini.jogconfig.11 || l.objini.perso.var.u_[arg0.nome]
      l.objini.msg($mens.proc(config:novatosmsg, l.objini.perso))
    efim


classe cmdfim_telepatia
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Telepatia\b\n\
Sintaxe: TELEPATIA <personagem> <mensagem>\n\
Envia uma mensagem telepática (privativa) a outro jogador, independente\n\
da sala em que ele estiver.\n\
Veja também os comandos CONFIG e IGNORAR."

func escr
  ret !arg0.jogconfig.8, arg0.msg("Canal Telepatia está desabilitado.")
  ret !arg1, arg0.msg("Escrever para quem?")
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg1)))
  $mens.p(arg0, item.obj)
  $mens.mens = txt2(arg1)
  se !item.obj || item.obj.jogconfig.17 && !arg0.jogconfig.23
    arg0.msg("Jogador inexistente ou ausente: " + txt1(arg1))
  senao item.obj == arg0
    arg0.msginv("Escrever para você mesm$s?")
  senao item.obj.var.u_[arg0.nome]
    arg0.msginv("$C está ignorando você.")
  senao arg0.var.u_[item.obj.nome]
    arg0.msginv("Você está ignorando $C.")
  senao !item.obj.jogconfig.8
    arg0.msginv("$C desabilitou o canal Telepatia.")
  senao arg0.jogconfig.17 && !item.obj.jogconfig.23
    arg0.msginv("Você está invisível para $C.")
  senao !txt2(arg1)
    arg0.msginv("Escrever o quê?")
  senao
    item.obj.msginv(config:telepatia2)
    arg0.msginv(config:telepatia1)


classe cmdfim_ignorar
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Ignorar\b\n\
Sintaxe: ignorar [personagem]\n\
Permite ignorar todas as mensagens do personagem de outro jogador.\n\
Se o jogador já estiver sendo ignorado, esse comando deixa de ignorar.\n\
Digitanto apenas ignorar, sem nenhum nome, mostra quem você está ignorando."

func escr
  se !arg1
    textotxt t
    txt100 nome
    nome = arg0.var.ini("u_")
    enquanto txt(nome, 0, 2) == "u_"
      t.addfim(txt(nome, 2)), nome = arg0.var.depois(nome)
    efim
    ret t.linhas == 0, arg0.msg("Não está ignorando ninguém.")
    arg0.msg("Está ignorando: " + txttroca(t.remove(1000), "\n", ", "))
  senao arg0.var.u_[arg1]
    arg0.var.u_[arg1] = ""
    arg0.msg("Você deixa de ignorar " + arg1 + ".")
  senao
    int8 total
    txt100 nome
    nome = arg0.var.ini("u_")
    enquanto txt(nome, 0, 2) == "u_" && total < 20
      nome = arg0.var.depois(nome), total += 1
    efim
    ret total >= 20, arg0.msg("Atingido o limite de usuários ignorados.")
    arg0.var.u_[arg1] = 1
    arg0.msg("Você ignora " + arg1 + ".")


classe cmd_atalho
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Atalho\b\n\
Sintaxe: ATALHO\n\
         ATALHO <nome>\n\
         ATALHO <nome> <comandos>\n\
         ATALHO LIMPAR\n\
         !\n\n\
O sinal de exclamação repete o último comando que você digitou.\n\n\
Já o comando ATALHO, permite definir atalhos para os comandos que você usa\n\
frequentemente. Para criar um atalho, basta teclar a palavra atalho seguido\n\
de um nome qualquer e o comando. Assim, sempre que você digitar o nome,\n\
o efeito será o mesmo que digitar o comando correspondente.\n\n\
Para apagar um atalho, basta digitar a palavra atalho seguido do nome.\n\n\
Para apagar todos os atalhos, digite atalho limpar.\n\n\
Digitando apenas a palavra atalho, mostra todos os atalhos definidos.\n\n\
As seguintes sequências de caracteres tem um significado especial:\n\
 \c2$1\b  Primeira palavra digitada após o nome do atalho\n\
 \c2$2\b  Segunda palavra digitada após o nome do atalho\n\
 \c2$3\b a \c2$9\b  Terceira à nona palavra digitada após o nome do atalho\n\
 \c2$0\b  Todas as palavras\n\
 \c2$S\b  Da segunda palavra em diante\n\
 \c2$T\b  Da terceira palavra em diante\n\
 \c2$Z\b  Uma quebra de linha (para separar dois comandos)\n\
 \c2$$\b  O Caracter $\n\n\
Exemplos:\n\n\
atalho med sentar $Z meditar\n\
  Cria o atalho med. Depois disso, digitar med terá o mesmo efeito\n\
  de digitar sentar, e em seguida, digitar meditar.\n\n\
atalho con lançar \"raio confusão\" $1\n\
  Cria o atalho chamado con. Digitando, por exemplo, con silva,\n\
  terá o mesmo efeito de digitar lançar \"raio confusão\" silva.\n\n\
atalho med\n\
  Apaga o atalho med, se existir."

func escr
  se !arg1
    textotxt t
    txt100 nome
    nome = arg0.var.ini("t_")
    enquanto txt(nome, 0, 2) == "t_"
      t.addfim(txt(nome, 2) + " " + arg0.var.[nome])
      nome = arg0.var.depois(nome)
    efim
    ret t.linhas == 0, arg0.msg("Nenhum atalho definido.")
    arg0.msg("Atalhos:\n" + t.remove(1000))
  senao arg1 == "limpar"
    ret !arg0.var.ini("t_"), arg0.msg("Nenhum atalho definido.")
    arg0.var.limpar("t_")
    arg0.msg("Atalhos apagados.")
  senao !txt2(arg1)
    ret !arg0.var.t_[arg1], arg0.msg("Atalho não foi definido: " + arg1)
    arg0.var.t_[arg1] = ""
    arg0.msg("Atalho apagado: " + arg1)
  senao txt1(arg1) == "atalho"
    arg0.msg("Não é possível criar um atalho chamado atalho.")
  senao arg0.var.t_[txt1(arg1)]
    arg0.var.t_[txt1(arg1)] = txt2(arg1)
    arg0.msg("Atalho mudado: " + arg1)
  senao
    uint16 total
    txt100 nome
    total = 50, nome = arg0.var.ini("t_")
    enquanto txt(nome, 0, 2) == "t_"
      ret !(total -= 1), arg0.msg("Atingido limite de atalhos.")
      nome = arg0.var.depois(nome)
    efim
    arg0.var.t_[txt1(arg1)] = txt2(arg1)
    arg0.msg("Criado atalho: " + arg1)


classe cmd_debug
herda comando_comum
const posic = 0
const objcmd = nulo # Comentar essa linha para o esse comando funcionar

func escr
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.objini + "/" + l0.objini.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.sock.nome + ")")
  efim
