classe comando_comum
const posic = 8 # Posição mínima para usar o comando
const objcmd = este # Objeto que processa o comando, ou nulo se não existe

func escr # Processa o comando
# arg0 = objeto do personagem
# arg1 = texto digitado após o nome do comando

func iniclasse
  criar(arg0)


classe cmd_lancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Lançar\b\nSintaxe: LANÇAR <nome da magia>\nLança uma magia."
const posic = 0
const lancamagia = 1 # Para indicar ao personagem que é comando de lançar magia
# Nota: a função escr aqui é desnecessária


classe cmd_lançar
herda cmd_lancar


classe cmd_quem
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Quem\b\n\
Sintaxe: QUEM\n\
Mostra quem está conectado no MUD e jogando."
const posic = 0

func escr
  textotxt t0
  txt100 t1
# Lista de personagens dos jogadores
  indiceitem item
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    continuar item.obj.jogconfig.17 && !arg0.jogconfig.23
    t1 = txt(999000 - item.obj.pnivel) + " N"
    t1 += txt(txt(item.obj.pnivel) + "      ", 0, 6) + item.obj.nome
    item.obj.sock == nulo && (t1 += "  [Desconectado]")
    se arg0.jogconfig.23
      item.obj.jogconfig.23 && (t1 += "  [ADM]")
      item.obj.jogconfig.17 && (t1 += "  [INVQUEM]")
      item.obj.sock.imonit && (t1 += "  [MONIT " + item.obj.sock.imonit.objlista.perso.nome + \
"]")
    fimse
    arg0.jogconfig.20 && (t1 += "  " + txt(item.obj.dono, 2))
    t0.addfim(t1)
  efim
# Lista de jogadores sem personagem
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    continuar item.obj.perso.jog # Continuar se personagem é jogador
    continuar item.obj.jogconfig.17 && !arg0.jogconfig.23
    t1 = "999001 N?     " + item.obj.nome
    item.obj.jogconfig.17 && (t1 += "  [Invis]")
    t0.addfim(t1)
  efim
# Ordena e mostra para o jogador
  t0.ordena
  textopos pos
  epara pos = t0.ini, pos, pos.depois
    pos.mudar("", 0, 7)
  efim
  arg0.msg2("Personagens online: " + t0.linhas + "\n" + t0.remove(1000))


classe cmd_fim
herda comando_comum
const posic = 0

func escr
  se arg0.atkenv && arg0.senha
    arg0.msg("Você está ocupad" + misc:sletra[arg0.sexo] + " demais para isso.")
  senao
    arg0.msg("Até mais. Aguardamos o seu retorno.")
    apagar(arg0)


classe cmd_quit
herda cmd_fim


classe cmd_hab
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Hab\b\n\
Sintaxe: HAB  [nome da habilidade]\n\
Sem argumentos mostra as habilidades do seu personagem.\n\
Seguido de um nome, mostra informações sobre a habilidade.\n\
Geralmente pode-se usar uma habilidade teclando-se o nome dela."

func escr
  ref r
  r = arg0.persoesc
  se arg1
    ref obj
    prog p
    epara p.iniclasse("cmd_" + txt1(arg1)), p.lin, p.depois
      obj = $[p.texto].atkajuda(r)
      ret obj, arg0.msg2(obj.txtajuda(r))
    efim
    ret arg0.msg("Nenhuma informação sobre a habilidade: " + arg1)
  fimse
  txt100 n
  r.persoesc != arg0 && (n = " de " + r.nome)
  textotxt h
  txt100 t1
  txt100 t2
  epara t1 = r.var.ini("h_"), txt(t1, 0, 2) == "h_", t1 = r.var.depois(t1)
    t2 = txte(txt(t1, 2)) # , t2 += txtesp(30 - inttotal(t2))
    t2 += " / " + txtsublin(misc:aulas, r.var.[t1], 1)
    h.addfim(t2)
  efim
  ret !h.linhas, arg0.msg("Nenhuma habilidade.")
  h.addini("Habilidades" + n + ":")
  arg0.msg(h.remove(1000))


classe cmd_magia
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Magia\b\n\
Sintaxe: MAGIA  [nome da magia]\n\
Sem argumentos mostra as magias do seu personagem.\n\
Seguido de um nome, mostra informações sobre a magia.\n\
Geralmente pode-se usar uma magia teclando-se lançar e o nome dela."

func escr
  ref r
  r = arg0.persoesc
  se arg1
    ref obj
    prog p
    epara p.iniclasse("magia_" + txt1(arg1)), p.lin, p.depois
      obj = $[p.texto].atkajuda(r)
      ret obj, arg0.msg2(obj.txtajuda(r))
    efim
    ret arg0.msg("Nenhuma informação sobre a magia: " + arg1)
  fimse
  txt100 n
  r.persoesc != arg0 && (n = " de " + r.nome)
  textotxt h
  txt100 t1
  txt100 t2
  epara t1 = r.var.ini("m_"), txt(t1, 0, 2) == "m_", t1 = r.var.depois(t1)
    t2 = txte(txt(t1, 2)) # , t2 += txtesp(30 - inttotal(t2))
    t2 += " / " + txtsublin(misc:aulas, r.var.[t1], 1)
    h.addfim(t2)
  efim
  ret !h.linhas, arg0.msg("Nenhuma magia.")
  h.addini("Magias" + n + ":")
  arg0.msg(h.remove(1000))


classe cmd_idioma
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Idioma\b\n\
Sintaxe: IDIOMA\n\
Mostra os idiomas que o seu personagem conhece."

func escr
  txt100 n
  ref r
  r = arg0.persoesc
  r.persoesc != arg0 && (n = " de " + r.nome)
  textotxt h
  txt100 t1
  txt100 t2
  epara t1 = r.var.ini("i_"), txt(t1, 0, 2) == "i_", t1 = r.var.depois(t1)
    t2 = txte(txt(t1, 2)) # , t2 += txtesp(30 - inttotal(t2))
    t2 += " / " + txtsublin(misc:aulas, r.var.[t1], 1)
    h.addfim(t2)
  efim
  ret !h.linhas, arg0.msg("Nenhum idioma.")
  h.addini("Idiomas" + n + ":")
  arg0.msg(h.remove(1000))


classe cmd_outros
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Outros\b\n\
Sintaxe: OUTROS\n\
Mostra itens e habilidades extras. Geralmente são permanentes (não pode-se\n\
pegar, soltar, dar e vestir)."

func escr
  txt100 n
  ref r
  r = arg0.persoesc
  r != arg0 && (n = " de " + r.nome)
  textotxt h
  txt100 t1
  txt100 t2
  epara t1 = r.var.ini("i_"), txt(t1, 0, 2) == "i_", t1 = r.var.depois(t1)
    t2 = txte(txt(t1, 2)) # , t2 += txtesp(30 - inttotal(t2))
    se txt(int(r.var.[t1])) == t.var.[t1]
      t2 += " / " + txtsublin(misc:aulas, r.var.[t1], 1)
    senao
      t2 += " / " + r.var.[t1]
    fimse
    h.addfim(t2)
  efim
  ret !h.linhas, arg0.msg("Nenhum item.")
  h.addini("Outros" + n + ":")
  arg0.msg(h.remove(1000))


classe cmd_inv
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Inv\b\n\
Sintaxe: INV\n\
Mostra os itens que o seu personagem está carregando."
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro1.fim, item, item.antes
    continuar !item.obj.visivel(arg0)
    t.addfim(txt(item.obj.objtot) + " " + item.obj.atribs + txtcopiamai(item.obj.descnome, \
"A"))
  efim
  t.juntalin("(", "x)")
  se t
    arg0.msg2("Você carrega:\n" + t.remove(1000))
  senao
    arg0.msg("Você não está carregando nada.")
  fimse


classe cmd_equip
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Equip\b\n\
Sintaxe: EQUIP\n\
Mostra os itens que o seu personagem está vestindo ou usando."
const posic = 5

func escr
  textotxt t
  listaitem item
  epara item = arg0.dentro2.fim, item, item.antes
    continuar !item.obj.vestpos || !item.obj.visivel(arg0)
    t.addfim("(" + misc:equip(item.obj.vestpos) + ") " + item.obj.atribs + txtcopiamai(item.obj.d\
escnome, "A"))
  efim
  se t.linhas
    arg0.msg2("Equipado com:\n" + t.remove(1000))
  senao
    arg0.msg("Não está vestindo/usando nada.")
  fimse


classe cmd_vida
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Vida\b\n\
Sintaxe: VIDA\n\
Mostra os pontos de vida, mana, vigor, nível e experiência do seu personagem."
const posic = 0

func escr
  se arg0.persoesc == arg0
    arg0.msg(vidalin(arg0))
  senao
    arg0.msg(txtcopiamai(arg0.persoesc.nome, "A") + ": " + vidalin(arg0.persoesc))

func vidalin
  txt100 lin
  lin = "Vida " + arg0.pvida + "/" + arg0.pvidamax
  lin += "  Mana " + arg0.pmana + "/" + arg0.pmanamax
  lin += "  Vigor " + arg0.pmove + "/" + arg0.pmovemax
  lin += "  Nível " + arg0.pnivel
  lin += "  Experiência " + arg0.expatual + "/" + arg0.expmax
  ret lin


classe cmd_hora
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Hora\b\n\
Sintaxe: HORA\n\
Mostra a hora atual, no calendário do MUD e no servidor."
const posic = 0

func escr
  txt100 t1
  datahora d
  d.agora
  t1 = "  (" + semanamud(misc:dia) + ")"
  arg0.msg("Hora atual MUD:      " + misc:hora + ":" + misc:min + t1)
  arg0.msg("Hora atual servidor: " + d.hora + ":" + d.min)
  t1 = "Tempo total de jogo: "
  arg0.tempojogo2 == 1 && (t1 += "1 dia ")
  arg0.tempojogo2 > 1 && (t1 += txt(arg0.tempojogo2) + " dias ")
  t1 += intdiv((864000 - arg0.tempojogo1) / 36000)
  t1 += ":"
  t1 += intdiv((864000 - arg0.tempojogo1) / 600) % 60
  arg0.msg(t1 + " horas")
  se arg0.sock
    int32 x
    x = arg0.sock.tempojogo
    se x >= 24 * 36000
      t1 = "Mais de 24 horas"
    senao
      t1 = intdiv(x / 36000)
      t1 += ":" + intdiv(x / 600) % 60 + " horas"
    fimse
    arg0.msg("Tempo dessa sessão:  " + t1)

func semanamud
  casovar arg0
  casose "0"
    ret "Domingo"
  casose "1"
    ret "Segunda-feira"
  casose "2"
    ret "Terça-feira"
  casose "3"
    ret "Quarta-feira"
  casose "4"
    ret "Quinta-feira"
  casose "5"
    ret "Sexta-feira"
  casose "6"
    ret "Sábado"
  casofim


classe cmd_config
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = arg0.jogconfig.23 ? txtajuda1 + txtajuda2 : txtajuda1
const txtajuda1 = "\b\c3Config\b\n\
Sintaxe: config +<opção>\n\
         config -<opção>\n\
Altera algumas preferências do seu personagem. Um sinal de + ou de -\n\
seguido de uma opção ativa ou desativa a opção. Para saber as atuais\n\
preferências, tecle apenas CONFIG, sem parâmetros.\n\n\
As opções são:\n\
  \c2DESC\b     Mostra descrições completas (como ao digitar VER)\n\
  \c2SAIDAS\b   Mostra as saídas visíveis após a descrição da sala\n\
  \c2CORES\b    Recebe sequência de cores no padrão ANSI (somente Telnet)\n\
  \c2ACENTO\b   Recebe letras com acentuação (codificação ISO8859-1)\n\
  \c2CHAT\b     Participa do canal de comunicação CHAT\n\
  \c2SEGUIR\b   Se outros personagens podem escolher seguir você\n\
  \c2PROMPT\b   Ativa o prompt normal\n\
  \c2BROMPT\b   Ativa o prompt de batalha"
const txtajuda2 = "\n\
  \c2SALA\b     Mostra o nome da sala cadastrada antes do título\n\
  \c2QUEM\b     O comando QUEM mostra onde cada jogador está no MUD\n\
  \c2INVQUEM\b  Ocultar a presença no comando quem\n\
  \c2INVSALA\b  Invisível a não administradores\n\
  \c2AC\b       Participa do canal de comunicação AC (administração)\n\
  \c2ADMLOG\b   Canal ADMLOG - é informado sobre mudanças online no MUD\n\
  \c2ADMCMD\b   Canal ADMCMD - é informado quando alguém usar CMD, CMDP\n\
           ou CMDJs e o comando possuir alguma letra"
# As próximas constantes são as opções do comando CONFIG
# Cada constante contém o índice da variável de jogconfig
# As variáveis "opc_" contém o int1 de jogconfig que correspondente à opção
# Números de 0 a 15 são as opções disponíveis a todos
# Números de 16 a 23 são as opções disponíveis aos administradores
const opc_desc = 0
const opc_saidas = 1
const opc_cores = 2
const opc_acento = 3
const opc_chat = 4
const opc_seguir = 5
const opc_prompt = 6
const opc_bprompt = 7
const opc_sala = 16
const opc_invquem = 17
const opc_invsala = 18
const opc_ac = 19
const opc_quem = 20
const opc_admlog = 21
const opc_admcmd = 22
# Nota: o bit 23 é reservado para indicar se é administrador

func escr
  prog p
  txt512 x
  txt512 y
  int1 opc.32
  opc.bits = arg0.jogconfig.bits
  se !arg1
    epara p.inifunc(este, "opc_"), p.lin, p.depois
      se opc.[[p.texto]]
        x += " +" + txtmai(txt(p.texto, 4))
      senao [p.texto] < 16 || arg0.jogconfig.23
        y += " -" + txtmai(txt(p.texto, 4))
      fimse
    efim
    arg0.msg("CONFIG" + x + y)
    ret
  fimse
  x = txttroca(arg1, "+", " +")
  x = txttroca(x, "-", " -")
  x = txtremove(x, "EMD")
  txt512 mudou
  enquanto x
    epara p.inifunc(este, "opc_" + txt(txt1(x), 1)), p.lin, p.depois
      sair [p.texto] < 16 || arg0.jogconfig.23
    efim
    se !p.lin
      y += " " + txt1(x)
    senao txt(x, 0, 1) == "+"
      opc.[[p.texto]] = 1
      mudou += " +" + txtmai(txt(p.texto, 4))
    senao txt(x, 0, 1) == "-"
      opc.[[p.texto]] = 0
      mudou += " -" + txtmai(txt(p.texto, 4))
    senao
      y += " " + txt1(x)
    fimse
    x = txt2(x)
  efim
  ret y, arg0.msg("Opção inexistente:" + y)
# Checa a propriedade INVIS
  se arg0.jogconfig.18 != opc.18 # Se a propriedade INVIS mudou
    arg0.recalc = 1 # Deverá atualizar bitinv
  fimse
# Checa a propriedade SEGUIR
  se !opc.5 # Se não pode ser seguido
    epara nulo, arg0.lseguir, arg0.lseguir.ini.remove
      arg0.lseguir.objini.msg("Você pára de seguir " + arg0.descnome + ".")
    efim
  fimse
# Atualiza a configuração
  arg0.jogconfig.bits = opc.bits
  arg0.sock.jogconfig.bits = opc.bits
  arg0.msg("Configuração alterada:" + mudou)


classe cmd_prompt
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Prompt\b\n\
Sintaxe: PROMPT  [texto]\n\
         BPROMPT [texto]\n\n\
PROMPT é uma ou mais linhas para indicar a você que o MUD já enviou todas\n\
as mensagens pendentes. Com essa opção pode-se personalisar as mensagens,\n\
inclusive adicionando algumas variáveis, como pontos de vida, hora, etc.\n\n\
BPROMPT funciona de forma idêntica ao PROMPT, porém corresponde à\n\
mensagem durante a batalha.\n\
Sem nenhum texto, essas opções mostram o prompt atual.\n\
Se o texto for a palavra ini (exemplo: PROMPT INI), o prompt será\n\
redefinido para o padrão do MUD.\n\n\
Nota: para a mensagem de prompt aparecer, deve estar habilitada no\n\
comando CONFIG.\n\n\
As seguintes sequências de caracteres têm um significado especial:\n\n\
 \c2%n\b  Nome do seu personagem usado nas batalhas\n\
 \c2%N\b  Nome do seu oponente (se estiver batalhando)\n\
 \c2%h\b  Pontos de vida atuais\n\
 \c2%H\b  Total de pontos de vida\n\
 \c2%p\b  Pontos de vida em porcentagem\n\
 \c2%P\b  Pontos de vida em uma barra de 10 caracteres\n\
 \c2%o\b  Pontos de vida do oponente em porcentagem\n\
 \c2%O\b  Pontos de vida do oponente em uma barra de 10 caracteres\n\
 \c2%m\b  Pontos de mana atuais\n\
 \c2%M\b  Pontos de mana totais\n\
 \c2%v\b  Pontos de vigor atuais\n\
 \c2%V\b  Pontos de vigor totais\n\
 \c2%g\b  Quantidade de moedas que seu personagem possui\n\
 \c2%l\b  Nível do seu personagem\n\
 \c2%L\b  Nível do seu oponente\n\
 \c2%x\b  Experiência do seu personagem\n\
 \c2%X\b  Experiência necessária para o próximo nível\n\
 \c2%T\b  Conforme o sol: amanhecendo, manhã, tarde, anoitecendo, noite\n\
 \c2%d\b  Hora no MUD\n\
 \c2%D\b  Hora no servidor\n\
 \c2%z\b  Uma quebra de linha (para definir prompts de várias linhas)\n\
 \c2%Z\b  O caracter %\n\
 \c2%t\b  O mesmo que um espaço em branco\n\n\
Exemplos (considerando 30 pontos de vida, 45 de mana e 50 de vigor):\n\n\
PROMPT %h%m                =  3045\n\
PROMPT %h %m %v            =  30 45 50\n\
PROMPT <%hhp %mmn %vmv>    =  <30hp 45mn 50mv>"

func escr
  ret !arg1, arg0.msg("Prompt:\n" + arg0.var.z_prompt)
  txt100 lin
  lin = arg1 == "ini" ? "<%hhp %mmn %vmv> " : arg1
  arg0.var.z_prompt = lin
  arg0.msg("Prompt alterado para:\n" + lin)


classe cmd_bprompt
herda cmd_prompt

func escr
  ret !arg1, arg0.msg("Prompt de batalha:\n" + arg0.var.z_bprompt)
  txt100 lin
  lin = arg1 == "ini" ? "<%hhp %mmn %vmv> " : arg1
  arg0.var.z_bprompt = lin
  arg0.msg("Prompt de batalha alterado para:\n" + lin)


classe cmd_ver
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Ver\b\n\
Sintaxe: VER\n\
         VER <personagem ou objeto>\n\
Olha de relance para o lugar aonde você está ou para um personagem ou\n\
objeto. É semelhante ao comando olhar, mas dá menos informações."
const posic = 5
const completo = 0 # No comando olhar, essa variável é 1

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_ver(arg0, arg1, completo), nulo
  efim
  se !arg1
    se arg0.jogconfig.16
      arg0.msg2(txt(arg0.dono, 2) + "  " + arg0.dono.descsala(arg0, completo ? 7 : 6))
    senao
      arg0.msg2(arg0.dono.descsala(arg0, completo ? 7 : 6))
    fimse
    ret
  fimse
  nomeobj n
  prog p
  ref r
  n.ini(arg1, 1)
  r = arg0.dono
  epara p.inifunc(r, "ver_"), p.lin, p.depois
    continuar !r.[p.texto](arg0, 0) || !n.nome(txt(p.texto, 4))
    arg0.msg(r.[p.texto](arg0, 1))
    ret
  efim
  l.addfim(r.dentro1, r.dentro2, arg0.dentro1)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ret arg0 == l.objini, arg0.msg("Olhar para você mesmo?")
    r = l.objini
    textotxt t
# O que o personagem está vestindo
    se r.perso
      $mens.p(arg0, r)
      $mens.mvis2("", "$P olha para $a.")
      se completo
        listaitem item
        epara item = r.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos || !item.obj.visivel(arg0)
          t.addfim("(" + misc:equip(item.obj.vestpos) + ") " + item.obj.descnome)
        efim
        t.linhas && t.addini("Equipado com:")
      fimse
# O que o container possui
    senao i_aberto == 5
    senao int(r.i_aberto) >= 3
      t.addfim(txtcopiamai(r.descnome, "A") + (r.sexo ? " está fechado." : " está fechada."))
    senao r.i_aberto
      r.z_moedas && t.addfim(txtcopiamai(misc:txtmoedas(r.z_moedas) + ".", "A"))
      listaitem item
      epara item = r.dentro1.ini, item, item.depois
        continuar !item.obj.visivel(arg0)
        t.addfim(txt(item.obj.objtot) + " " + txtcopiamai(item.obj.descnome, "A"))
      efim
      se !t.linhas
        t.addfim(r.sexo ? "Está vazio." : "Está vazia.")
      senao completo
        t.juntalin("(", "x)")
        t.addini("Dentro você vê:")
      senao
        t.limpar
      fimse
    fimse
# Nome, nível, situação atual e animal que escolheu
    r.descver(arg0) && t.addini(r.descver(arg0))
    txt200 t2
    t2 = txtcopiamai(r.descnome, "A")
    se r.perso
      t2 += (r.jog ? ", jogador nível " : ", nível ") + r.pnivel + ", " + estado(r)
      se r.persobat && r.persobat != r
        t2 += "\nEscolheu " + r.persobat.nome + ", nível " + r.persobat.pnivel
        t2 += ", " + estado(r.persobat)
      fimse
    senao r.pnivel
      t2 += ", é um objeto do nível " + r.pnivel
    fimse
# Luz
    se int(r.luztempo.abs) >= 25
      int32 tempo
      tempo = r.luztempo.abs / 50
      r.luztempo > 0 && (t2 += r.sexo ? ", aceso" : ", acesa")
      t2 += ", produz luz por " + tempo + (tempo == 1 ? " minuto" : " minutos")
# t2 += r.luztempo
    fimse
# Envia mensagem
    ret !completo, arg0.msg(t2 + ".")
    ret t.linhas, arg0.msg2(t2 + ".\n" + t.remove(1000))
    ret arg0.msg(t2 + ".\nVocê não vê nada de especial.")
  efim
  arg0.msg("Você não vê isso.")

func estado # Retorna texto que contém o estado atual do personagem
  ret !arg0.pvidamax, "perfeitamente saudável"
  casovar intdiv(arg0.pvida * 6 / arg0.pvidamax)
  casose "0"
    ret arg0.pvida ? "à beira da morte" : "demaiad" + misc:sletra[arg0.sexo]
  casose "1"
    ret "sangrando bastante"
  casose "2"
    ret "muito machucad" + misc:sletra[arg0.sexo]
  casose "3"
    ret "bastante machucad" + misc:sletra[arg0.sexo]
  casose "4"
    ret "um pouco machucad" + misc:sletra[arg0.sexo]
  casose "5"
    ret "possui algumas escoriações"
  casose
    ret "perfeitamente saudável"
  casofim


classe cmd_olhar
herda cmd_ver
const completo = 1
const txtajuda = "\b\c3Olhar\b\n\
Sintaxe: OLHAR\n\
         OLHAR <personagem ou objeto>\n\
Mostra a descrição completa do lugar aonde você está ou informações\n\
sobre um personagem ou um objeto."


classe cmd_falar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Falar\b\n\
Sintaxe: FALAR <mensagem>\n\
         '<mensagem>\n\
Envia mensagem para todos os personagens que estiverem na mesma sala.\n\
A mensagem pode aparecer diferente se for iniciada com reticências ou\n\
terminada com reticências, interrogação ou exclamação."

func escr
  $mens.p(arg0)
  se !arg1
    arg0.msg("Tecle a mensagem após FALAR.")
    ret
  senao arg0.dono.s_falar
    arg0.msg(arg0.dono.s_falar)
    ret
  senao txt(arg1, 0, 3) == "..."
    $mens.mtodos1("$P continuou '" + txttroca(arg1, "$", "$$") + "'")
  senao txtfim(arg1, 1) == "?"
    $mens.mtodos1("$P perguntou '" + txttroca(arg1, "$", "$$") + "'")
  senao txtfim(arg1, 1) == "!"
    $mens.mtodos1("$P exclamou '" + txttroca(arg1, "$", "$$") + "'")
  senao txtfim(arg1, 3) == "..."
    $mens.mtodos1("$P ponderou '" + txttroca(arg1, "$", "$$") + "'")
  senao
    $mens.mtodos1("$P falou '" + txttroca(arg1, "$", "$$") + "'")
  fimse
# Executa eventos
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_falou(arg0, arg1)
  efim


classe cmd_sussurrar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sussurrar\b\n\
Sintaxe: SUSSURRAR <personagem> <mensagem>\n\
Sussurra uma mensagem para um personagem que está na mesma sala.\n\
A mensagem é enviada reservadamente para o personagem escolhido.\n\
Os outros apenas ficam sabendo que você sussurrou alguma coisa."

func escr
  $mens.p(arg0)
  se !arg1
    arg0.msg("Sussurrar para quem?")
    ret
  senao !txt2(arg1)
    arg0.msg("Sussurrar o que?")
    ret
  senao arg0.dono.s_falar
    arg0.msg(arg0.dono.s_falar)
    ret
  fimse
  nomeobj n
  listaobj l
  n.ini(txt1(arg1), 1)
  l.addfim(arg0.dono.dentro2)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    $mens.p(arg0, l.objini)
    se arg0 == l.objini
      $mens.mtodos1("$P sussurrou algumas palavras.")
    senao
      txt500 m1
      m1 = "$P sussurou para $a '" + txttroca(txt2(arg1), "$", "$$") + "'"
      $mens.mtodos3(m1, m1, "$P sussurou algumas palavras para $a.")
    fimse
    sair
  efim
# Executa eventos
  ref r
  r = l.objini
  l.remove
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_sussurrou(arg0, r, arg1)
  efim
# Mensagem se não encontrou o personagem
  !r && arg0.msg("Você não vê " + txt1(arg1) + ".")


classe cmdfim_chat
herda comando_comum, comando_ajuda
const posic = 0
const txtajuda = "\b\c3Canal chat\b\n\
Sintaxe: CHAT <mensagem>\n\
         .<mensagem>\n\
Envia mensagem para os jogadores que estiverem com o canal CHAT habilitado.\n\
Para habilitar ou desabilitar esse canal, use o comando CONFIG."

func escr
  $mens.p(arg0)
  se !arg0.jogconfig.4
    arg0.msg("Canal CHAT está desabilitado.")
  senao !arg1
    arg0.msg("Tecle a mensagem após CHAT.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.4 && item.obj.msg("(chat) " + arg0.sock.nome + " '" + arg1 + "'")
    efim


classe cmd_debug
herda comando_comum
const posic = 0
const objcmd = nulo # Comentar essa linha para o esse comando funcionar

func escr
  arg0.msg("Sala: " + arg0.dono)
  listaobj l0
  l0.addfim(arg0.dono.dentro1, arg0.dono.dentro2)
  l0.remove(arg0)
  enquanto l0
    arg0.msg(" usr: " + l0.objini + "/" + l0.objini.jog)
    l0.ini.remove
  efim
  arg0.msg("ver=" + arg0.bitver + " inv=" + arg0.bitinv)
  arg0.msg("visível? " + !(~bitver & bitinv))
  arg0.msg("JOGADORES:")
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.perso.nome + ")")
  efim
  listar("jogolocal", arg0)
  listar("jogoserv", arg0)
  listar("jogobot_usr", arg0)
  arg0.msg("PERSONAGENS:")
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    arg0.msg("> " + item.obj.nome + " (" + item.obj.sock.nome + ")")
  efim


classe cmd_onde
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Onde\b\n\
Sintaxe: ONDE\n\
Mostra a área em que você está e os jogadores que estiverem por perto."
const posic = 0

func escr
  textotxt t0
  txt100 area
  ref r
  epara r = arg0.dono, r.dono, r = r.dono
  efim
  area = r.s_area
# Checa se pode ver a sala
  se !r.visivel(arg0)
    se 1 & arg0.bitver
      arg0.msg("Está escuro...")
    senao
      arg0.msg("Você está ceg" + $mens.sexoA[arg0.sexo] + ".")
    fimse
    ret
  fimse
# Dados da área
  t0.addfim("Área " + $a_[area].a_nome)
# Lista de personagens dos jogadores
  indiceitem item
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
# continuar item.obj.jogconfig.18 && !arg0.jogconfig.18
    continuar !item.obj.visivel(arg0)
    epara r = item.obj.dono, r.dono, r = r.dono
    efim
    continuar area != r.s_area
    misc:obj = arg0
    t0.addfim(item.obj.nome + "    " + item.obj.dono.s_titulo)
  efim
  t0.txtmostra
  arg0.msg2(t0.remove(1000))


classe cmd_estat
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta1 : ta2
const posic = 5
const ta1 = "\b\c3Estat\b\n\
Sintaxe: ESTAT\n\
Mostra as estatísticas e diversas informações sobre o seu personagem ou\n\
o animal você escolheu."
const ta2 = "\b\c3Estat\b\n\
Sintaxe: ESTAT\n\
Mostra as estatísticas e diversas informações sobre o seu personagem."

func escr
  textotxt t
  textotxt h
  txt100 t1
  txt100 t2
  ref r
  r = arg0.persoesc
  t.addfim("\b\c2Estatísticas de \"" + r.nome + "\"\b")
# Vida, mana e vigor
  t1 = "Vida " + r.pvida + "/" + r.pvidamax
  t1 += "  Mana " + r.pmana + "/" + r.pmanamax
  t1 += "  Vigor " + r.pmove + "/" + r.pmovemax
  t.addfim(t1)
# Tipo
  r.tipo1 && h.addfim(txtcopiamai(r.tipo1, "A"))
  r.tipo2 && h.addfim(txtcopiamai(r.tipo2, "A"))
  r.tipo3 && h.addfim(txtcopiamai(r.tipo3, "A"))
  h.linhas && t.addfim("Tipo/raça/classe: " + txttroca(h.remove(10), "\n", ", "))
  t.addfim("Sexo:             " + (r.sexo ? "Masculino" : "Feminino"))
# Quem pegou
  se r != arg0
    t.addfim("Pego por:         " + r.var.z_dono + " (no nível " + r.var.z_pnivel + ")")
  fimse
# Moedas
  r.var.z_moedas && t.addfim("Moedas:           " + r.var.z_moedas)
# Nível
  t.addfim("Nível atual:      " + r.pnivel)
  t.addfim("Experiência:      " + r.expatual + "/" + r.expmax)
# Batalha
  t.addfim("Ataque/defesa:    " + r.atknorm + "/" + r.defnorm)
  t.addfim("Atq/def especial: " + r.atkesp + "/" + r.defesp)
  t.addfim("Precisão/evasão:  " + r.precisao + "/" + r.evasao)
  t.addfim("Velocidade:       " + r.pveloc)
# Mortes
  se r == arg0
    t.addfim("Mortes:           " + r.mortes)
  senao
    t.addfim("Desmaios:         " + r.mortes)
  fimse
# Carregando
  t.addfim("Peso total:       " + txtnum((r.pesoden + r.pesoobj) / 1000, "0") + " Kg")
  t1 = "Carregando:       " + r.dentro1.total + "/" + r.objmax
  t1 += r.objmax == 1 ? " item" : " itens"
  t1 += ", " + txtnum((r.pesoden - r.pesoveste) / 1000, "0")
  t1 += "/" + txtnum(r.pesomax / 1000, "0") + " Kg"
  t.addfim(t1)
# Mensagem para o usuário
  arg0.msg2(t.remove(1000))
