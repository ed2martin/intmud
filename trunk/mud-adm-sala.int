classe adm_area
herda comando_adm
const txtajuda = "\b\c3Comandos de áreas\b\n\
  \c2LAREA\b     Lista áreas existentes\n\
  \c2CAREA\b     Cria uma área\n\
  \c2EAREA\b     Edita uma área\n\
  \c2AAREA\b     Apaga uma área"


classe adm_sala
herda comando_adm
#
const txt_terreno = "Dentro, lugar fechado - 1mv\n\
Rua de uma cidade - 2mv\n\
Campo, um campo aberto - 2mv\n\
Pântano, itens afundam - 3mv\n\
Floresta densa - 3mv\n\
Colina - 4mv\n\
Montanha, excessivamente montanhoso - 6mv\n\
Água, pode nadar - 4mv\n\
Água, requer barco para passar - 50mv\n\
Em baixo d'água - 10mv\n\
Ar, itens e personagens caem - 10mv\n\
Deserto, 3x mais sede, 6mv"
#
const txt_luta = "Pacífico\nExceto entre jogadores\nQualquer luta"
#
const txt_luz = "Claro com eventos de tempo\n\
Claro sem eventos de tempo\n\
Luz do sol\nEscuro"
#
const txt_porta = "Sem porta\nPorta aberta\nPorta fechada\nPorta trancada"
#
const txtajuda = "\b\c3Comandos de salas\b\n\
  \c2LSALA\b     Lista salas existentes\n\
  \c2CSALA\b     Cria sala\n\
  \c2CDIR\b      Cria sala em uma direção\n\
  \c2ESALA\b     Edita sala\n\
  \c2ASALA\b     Apaga uma ou mais salas\n\
  \c2LDESC\b     Lista descrições extras da sala\n\
  \c2EDESC\b     Edita uma descrição extra da sala\n\
  \c2ADESC\b     Apaga uma descrição extra da sala\n\
  \c2LSAI\b      Mostra saídas da sala\n\
  \c2CSAI\b      Cria saída em uma direção\n\
  \c2CSAI2\b     Mesmo que CSAI, mas cria também uma saída no sentido contrário\n\
  \c2ESAI\b      Edita tipo de saída em uma direção\n\
  \c2ASAI\b      Apaga saída em uma direção"


classe adm_larea
herda comando_adm, comando_comum
const txtajuda = "\b\c3Larea\b\n\
Sintaxe: LAREA [nome]\n\
Lista as áreas que começam com o nome especificado."

func escr # Listar áreas
  prog p
  se !p.iniclasse("a_" + arg1)
    ret arg0.msg("\bNenhuma área encontrada.")
  fimse
  textotxt t
  t.addfim("\b\c6Áreas (prefixo, nome, autor):\b")
  enquanto p.lin
    t.addfim(txt(p.texto, 2) + ", " + [p.texto]:a_nome + ", " + [p.texto]:a_autor)
    p.depois
  efim
  arg0.msg2(t.remove(1000))


classe adm_carea
herda comando_adm, comando_comum
const txtajuda = "\b\c3Carea\b\n\
Sintaxe: CAREA <nome>\n\
Cria uma área com o nome especificado.\n\
Nota: Nomes de área devem ter de 2 a 16 letras de A a Z."

func escr # Criar área
  txt100 prefixo
  prefixo = txtmin(txtremove(arg1, "EMDCT7"))
  se $a_[prefixo]
    arg0.msg("\bÁrea já existe: " + prefixo)
  senao inttotal(prefixo) < 2 || inttotal(prefixo) > 10
    arg0.msg("\bNome de área deve ter de 2 a 10 caracteres")
  senao prefixo != txtsepara(prefixo, "DEO+DEOL,DEOL+DEO")
    arg0.msg("\bNome de área deve ter apenas letras de a a z.")
  senao
    prog p
    p.criar("a_" + prefixo + "\na-" + prefixo + "\nherda area")
    p.criar("b_" + prefixo + "\na-" + prefixo + "\nherda sala\nconst s_area=\"" + prefixo + \
"\"")
    config:salvar, arg0.msg("\bÁrea criada: " + prefixo)
    admlog(arg0, "criou área " + prefixo)
  fimse


classe adm_aarea
herda comando_adm, comando_comum
const txtajuda = "\b\c3Aarea\b\n\
Sintaxe: AAREA <nome>\n\
Apaga a área com o nomes especificado, desde que esteja vazia\n\
(nenhuma sala, personagem, item ou casa)."

func escr # Apagar área
  txt100 prefixo
  prog p
  prefixo = txtmin(txtremove(arg1, "EMDCT7"))
  se !$a_[prefixo]
    ret arg0.msg("\bÁrea não existe: " + prefixo)
# senao p.iniherdainv("b_" + prefixo)
# ret arg0.msg("\bÁrea contém pelo menos uma sala: " + txt(p.texto, 2))
  fimse
  epara p.iniarq("a-" + prefixo), p.lin, p.depois
    se p.texto != "a_" + prefixo && p.texto != "b_" + prefixo
      casovar txt(p.texto, 0, 2)
      casose "c_"
        arg0.msg("\bÁrea " + prefixo + " contém pelo menos uma casa")
        ret 1
      casose "s_"
        arg0.msg("\bÁrea " + prefixo + " contém pelo menos uma sala")
        ret 1
      casose "p_"
        arg0.msg("\bÁrea " + prefixo + " contém pelo menos um personagem")
        ret 1
      casose "i_"
        arg0.msg("\bÁrea " + prefixo + " contém pelo menos um item")
        ret 1
      casofim
      arg0.msg("\bÁrea " + prefixo + " contém pelo menos uma classe do IntMUD")
      ret 1
    fimse
  efim
  p.apagar("a_" + prefixo)
  p.apagar("b_" + prefixo)
  config:salvar, arg0.msg("\bÁrea apagada: " + prefixo)
  admlog(arg0, "apagou área " + prefixo)


classe adm_earea
herda comando_adm, comando_comum
const txtajuda = "\b\c3Earea\b\n\
Sintaxe: EAREA [nome]\n\
Edita a área com o nome especificado. Se o nome for omitido, edita a área\n\
em que você está."

func escr # Editar área
  txt100 prefixo
  prog p
  prefixo = txtmin(txtremove(arg1, "EMDCT7"))
  se prefixo == ""
    prefixo = txt(arg0.dono, 2, inttotal(txt(arg0.dono)) - 5)
  fimse
  se !$a_[prefixo]
    arg0.msg("\bÁrea não existe: " + prefixo)
  senao
    arg0.sock.var.classe1 = "a_" + prefixo
    arg0.sock.var.classe2 = "b_" + prefixo
    arg0.sock.m_menu("menu_area")
  fimse


classe adm_lsala
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lsala\b\n\
Sintaxe: LSALA [nome]\n\
Lista as salas que começam com o nome especificado."

func escr # Listar salas
  prog p
  se !p.iniclasse("s_" + txtremove(arg1, "EMDCT7"))
    arg0.msg("\bNenhuma sala encontrada.")
  senao
    textotxt t
    t.addfim("\b\c6Salas:\b")
    enquanto p.lin && t.linhas < 500
      t.addfim(txt(p.texto, 2) + "  " + $[p.texto].s_titulo)
      p.depois
    efim
    arg0.msg2(t.remove(500))
  fimse


classe adm_cdir
herda comando_adm, comando_comum
const txtajuda = "\b\c3Cdir\b\n\
Sintaxe: CDIR <direção>\n\
Cria sala na direção especificada. Cria automaticamente uma saída com\n\
a sala em que você está.\n\
Exemplo: cdir ne"

func escr # Criar sala na direção especificada
  se arg1 == ""
    ret arg0.msg("Tecle o nome da sala ou a direção após CDIR")
  senao !misc:d1[arg1]
    ret arg0.msg("Direção inválida: " + arg1)
  fimse
  prog p
  uint16 num
  txt40 nome
  txt20 dir
  dir = misc:d1[arg1]
# Obtém prefixo da área
  nome = txt(arg0.dono, 0, inttotal(txt(arg0.dono)) - 3)
  se txt(nome, 0, 2) != "s_"
    ret arg0.msg("Você não está em uma sala")
  fimse
# Checa se já existe sala nessa direção
  se p.existe(arg0.dono, "dir_" + dir) == 1
    ret arg0.msg("Já existe sala na direção " + dir)
  fimse
# Obtém número da sala
  epara num = 1001, p.existe(nome + txtfim(num, 3)), num += 1
    continuar num < 2000
    ret arg0.msg("Atingido limite de salas na área " + txt(nome, 2))
  efim
# Cria sala
  txt300 nome2
  nome2 = nome + txtfim(num, 3) + "\n" # Nome da classe
  nome2 += "a-" + txt(nome, 2) + "\n" # Nome do arquivo
  nome2 += "herda b_" + txt(nome, 2) + "\n" # Herda propriedades da área
  nome2 += "const s_titulo=\"Sem nome\"\nconst s_desc=\"\"\n"
  nome2 += "const dir_" + misc:d2[dir] + "=$" + arg0.dono # Saída da sala
  p.criar(nome2)
  p.criar(arg0.dono, "const dir_" + dir + "=$" + nome + txtfim(num, 3))
  criar("admordena", "a-" + txt(nome, 2))
  criar("admmudou", arg0.dono)
# config:salvar
  arg0.msg("\bSala criada em " + dir + ": " + txt(nome, 2) + txtfim(num, 3))
  admlog(arg0, "criou sala " + txt(nome, 2) + txtfim(num, 3))


classe adm_csala
herda comando_adm, comando_comum
const txtajuda = "\b\c3Csala\b\n\
Sintaxe: CSALA <nome>\n\
Cria uma sala. Nome deve ser o nome de uma área da sala.\n\
Nomes de sala são sempre nomes de área seguido de um número de 001 a 999."

func escr # Criar sala
  prog p
  txt40 nome
  uint16 num
# Checa se digitou nome da sala
  se arg1 == ""
    ret arg0.msg("Tecle o nome da sala ou área após CSALA")
  fimse
# Checa nome completo
  nome = txtmin(txtremove(arg1, "EMDCT7"))
  num = int(txtfim(nome, 3)) + 1000
  se num > 1000 && txtfim(num, 3) == txtfim(arg1, 3)
    se !p.existe("a_" + txt(nome, 0, inttotal(nome) - 3))
      ret arg0.msg("Área não existe: " + txt(nome, 0, inttotal(nome) - 3))
    senao p.existe("s_" + nome)
      ret arg0.msg("Sala já existe: " + nome)
    fimse
# Checa nome de área
  senao !p.existe("a_" + nome)
    ret arg0.msg("Área não existe: " + nome)
  senao
    epara num = 1001, p.existe("s_" + nome + txtfim(num, 3)), num += 1
      continuar num < 2000
      ret arg0.msg("Atingido limite de salas na área " + nome)
    efim
    nome += txtfim(num, 3)
  fimse
# Cria sala
  txt200 area
  area = txt(nome, 0, inttotal(nome) - 3)
  criar("admordena", "a-" + area)
  area = "s_" + nome + "\na-" + area + "\nherda b_" + area
  p.criar(area + "\nconst s_titulo=\"Sem nome\"\nconst s_desc=\"\"")
# config:salvar
  arg0.msg("\bSala criada: " + nome)
  admlog(arg0, "criou sala " + nome)


classe adm_asala
herda comando_adm, comando_comum
const txtajuda = "\b\c3Asala\b\n\
Sintaxe: ASALA <nomes das salas>\n\
Apaga uma ou mais salas, mas não apaga as saídas das outras salas para\n\
as que forem apagadas."

func escr # Apagar sala
  prog p
  refvar nome = txtmin(txtremove(arg1, "EMDCT7"))
  se nome == ""
    ret arg0.msg("Tecle um ou mais nomes da sala após ASALA")
  fimse
  uint16 x
  enquanto txtsub(nome, x, 1)
    se !p.existe("s_" + txtsub(nome, x, 1))
      ret arg0.msg("Sala não existe: " + txtsub(nome, x, 1))
    fimse
    x += 1
  efim
  arg0.sock.tpasso = nome
  passo(arg0.sock, "")

func passo # Confirmar que quer apagar sala
  arg0.passo = ""
  se arg1 == "n"
    arg0.msg("Cancelado")
  senao arg1 == "s"
    prog p
    uint16 x
    enquanto txtsub(arg0.tpasso, x, 1)
      p.apagar("s_" + txtsub(arg0.tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      arg0.msg("Sala apagada: " + arg0.tpasso)
      admlog(arg0, "apagou sala " + arg0.tpasso)
    senao
      arg0.msg("Salas apagadas: " + arg0.tpasso)
      admlog(arg0, "apagou salas " + arg0.tpasso)
    fimse
  senao
    txt10 m1
    arg0.passo = este
    txt2(arg0.tpasso) && (m1 = "s")
    arg0.msg("Apagar sala" + m1 + " " + arg0.tpasso + "? Tecle S ou N")
  fimse
  ret 1


classe adm_esala
herda comando_adm, comando_comum
const txtajuda = "\b\c3Esala\b\n\
Sintaxe: ESALA [nome]\n\
Edita a sala com o nome especificado. Se o nome for omitido, edita a sala\n\
em que você está."

func escr # Editar sala
  txt100 nome
  prog p
  nome = txtmin(txtremove(arg1, "EMDCT7"))
  nome == "" && (nome = txt(arg0.dono, 2))
  se !$s_[nome]
    arg0.msg("\bSala não existe: " + nome)
  senao
    arg0.sock.var.classe1 = "s_" + nome
    arg0.sock.m_menu("menu_sala")
  fimse


classe adm_ldesc
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ldesc\b\n\
Sintaxe: LDESC\n\
Lista as descrições extras sala sala aonde você está."

func escr # Listar descrições extras
  prog p
  se !p.inifunc(arg0.dono, "ver_")
    arg0.msg("\bNenhuma descrição encontrada.")
  senao
    textotxt t
    t.addfim("\b\c6Descrições:\b")
    enquanto p.lin && t.linhas < 500
      t.addfim(txt(p.texto, 4))
      p.depois
    efim
    arg0.msg2(t.remove(500))
  fimse


classe adm_edesc
herda comando_adm, comando_comum
const txtajuda = "\b\c3Edesc\b\n\
Sintaxe: EDESC <nome da descrição>\n\
Edita uma descrição extra da sala aonde você está.\n\
Para criar descrições somente diurnas ou somente noturnas, acrescentar\n\
@d ou @n, respectivamente, no final dos nomes das descrições.\n\
Exemplo, se quiser uma descrição diurna e outra noturna para uma janela,\n\
criar as descrições janela@d e janela@n ao invés de janela.\n\
Por outro lado, se você criar, por exemplo, somente janela@d, a descrição\n\
da janela só existirá durante o dia."

func escr # Editar descrição extra
  prog p
  txt80 nome
  nome = txtmin(txtremove(txte(arg1), "EMDCT"))
  se !arg0.dono
    arg0.msg("\bVocê não está em uma sala")
  senao !arg1
    arg0.msg("\bDigite o nome da descrição após EDESC")
  senao txttroca(nome, "@", "") != txtsepara(txttroca(nome, "@", ""), "LV+DO", "DO+LV")
    arg0.msg("Nomes de descrições só podem ter letras e espaço")
  senao
    arg0.sock.var.opcnome = "Descrição " + nome
    arg0.sock.var.opcclasse = txt(arg0.dono)
    arg0.sock.var.opcvar = "ver_" + txts(nome)
    arg0.sock.var.opcpasso = ""
    $opc_texto.passo(arg0.sock, "\b")
  fimse


classe adm_adesc
herda comando_adm, comando_comum
const txtajuda = "\b\c3Adesc\b\n\
Sintaxe: ADESC <nome da descrição>\n\
Apaga uma descrição extra da sala aonde você está."

func escr # Apagar descrição extra
  prog p
  se !arg0.dono
    arg0.msg("\bVocê não está em uma sala")
  senao !arg1
    arg0.msg("\bDigite o nome da descrição após ADESC")
  senao !p.existe(arg0.dono, "ver_" + arg1)
    arg0.msg("\bDescrição não existe: " + arg1)
  senao
    p.apagar(arg0.dono, "ver_" + arg1)
    config:salvar, arg0.msg("\bDescrição apagada: " + arg1)
    admlog(arg0, "apagou descrição " + arg1 + " de " + txt(arg0.dono, 2))
  fimse


classe adm_lsai
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lsai\b\nSintaxe: LSAI\nMostra as saídas da sala aonde você está."

func escr # Listar saídas
  se !arg0.dono
    ret arg0.msg("\bVocê não está em uma sala")
  fimse
  prog p
  txt80 dir
  txt80 lin
  arg0.msg("\b\c6Saídas de " + txt(arg0.dono, 2) + ":\b")
  epara dir = misc:listadir, dir, dir = txt2(dir)
    continuar !p.existe(arg0.dono, "dir_" + txt1(dir))
    lin = txtmai(txt1(dir)) + "  "
    lin += $opc_sala.menu(arg0.dono, "dir_" + txt1(dir))
    arg0.msg(lin)
  efim
  !lin && arg0.msg("Nenhuma")


classe adm_asai
herda comando_adm, comando_comum
const txtajuda = "\b\c3Asai\b\n\
Sintaxe: ASAI <direção>\n\
Apaga a saída na direção especificada."

func escr # Apagar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg1)]
  se !arg0.dono
    arg0.msg("\bVocê não está em uma sala")
  senao !arg1
    arg0.msg("\bDigite a direção após ASAI")
  senao !dir
    arg0.msg("\bSaída não existe: " + arg1)
  senao
    p.apagar(arg0.dono, "dir_" + dir)
    p.apagar(arg0.dono, "portaini_" + dir)
    p.apagar(arg0.dono, "inv_" + dir)
    p.apagar(arg0.dono, "tranc_" + dir)
    p.apagar(arg0.dono, "fechadura_" + dir)
    p.apagar(arg0.dono, "comechave_" + dir)
    p.apagar(arg0.dono, "voar_" + dir)
    p.apagar(arg0.dono, "fugir_" + dir)
    p.apagar(arg0.dono, "portanome_" + dir)
    p.apagar(arg0.dono, "portaartigo_" + dir)
    config:salvar, arg0.msg("\bSaída apagada: " + dir)
    admlog(arg0, "apagou saída " + dir + " de " + txt(arg0.dono, 2))
  fimse


classe adm_csai
herda comando_adm, comando_comum
const txtajuda = "\b\c3Csai\b\n\
Sintaxe: CSAI <direção> <sala>\n\
Cria uma saída na sala aonde você está, na direção especificada.\n\
Exemplo, se quiser que a saída para o norte vá para a sala teste001, tecle:\n\
csai n teste001"
const escr = escr1(arg0, arg1) # Criar saída

func escr1
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg1)]
  se !arg0.dono
    arg0.msg("\bVocê não está em uma sala")
  senao !arg1
    arg0.msg("\bDigite a direção após CSAI" + arg1)
  senao !dir
    arg0.msg("\bSaída não existe: " + txt1(arg1))
  senao !txt2(arg1)
    arg0.msg("\bDigite a sala após CSAI" + arg1 + " " + arg1)
  senao !p.existe("s_" + txt2(arg1))
    arg0.msg("\bSala não existe: " + txt2(arg1))
  senao
    p.criar(arg0.dono, "const dir_" + dir + "=$s_" + txtmin(txt2(arg1)))
    se arg2
      p.criar("s_" + txt2(arg1), "const dir_" + misc:d2[dir] + "=$" + arg0.dono)
      arg0.msg("\bSaída completa criada: " + dir + " para " + txtmin(txt2(arg1)))
    senao
      arg0.msg("\bSaída criada: " + dir + " para " + txtmin(txt2(arg1)))
    fimse
    config:salvar
    criar("admmudou", arg0.dono)
    admlog(arg0, "criou saída " + dir + " de " + txt(arg0.dono, 2))
  fimse


classe adm_csai2
herda adm_csai
const txtajuda = "\b\c3Csai2\b\n\
Sintaxe: CSAI2 <direção> <sala>\n\
Cria uma saída na sala aonde você está, na direção especificada, e cria\n\
também uma saída no sentido contrário, da outra sala para essa."
const escr = escr1(arg0, arg1, "2") # Criar saída completa


classe adm_esai
herda comando_adm, comando_comum

func escr # Editar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg1)]
  se !arg0.dono
    arg0.msg("\bVocê não está em uma sala")
  senao !arg1
    arg0.msg("\bDigite a direção após ESAI")
  senao !dir
    arg0.msg("\bSaída não existe: " + arg1)
  senao !p.existe(arg0.dono, "dir_" + dir)
    arg0.msg("Não existe saída na direção " + txtmai(dir))
  senao
    arg0.sock.var.classe1 = arg0.dono
    arg0.sock.var.saida1 = txtmin(dir)
    arg0.sock.m_menu("menu_saida")
  fimse


classe opc_saiinicio
herda opc_opcao

func passo
  opc_opcao:passo(arg0, arg1)
  casovar arg1
  casose "0"
  casose "1"
  casose "2"
  casose "3"
    $[arg0.var.classe1].mudaporta(arg0.var.saida1, arg1)
  casofim
  ret 1


classe opc_saiagora
herda opc_opcao
const menu = menu2($[arg0].[arg1], adm_sala:txt_porta)

func passo # Mudar o estado atual
  casovar arg1
  casose "z"
    sair
  casose "0"
  casose "1"
  casose "2"
  casose "3"
    arg0.msg(">" + arg1)
    se $[arg0.var.classe1].mudaporta(arg0.var.saida1, arg1)
      textotxt t
      t.addfim(adm_sala:txt_porta), t.remove(arg1)
      arg0.msg("Saída mudou para: " + arg1 + " " + t.remove)
    senao
      arg0.msg("Não foi possível mudar a saída")
    fimse
    sair
  casose
    arg0.passo = este
    ret arg0.msg("Escolha: 0 Sem porta, 1 Aberto, 2 Fechado, 3 Trancado, Z Cancela")
  casofim
  ret passosair(arg0)


classe menu_area
herda comando_menu
const titulo = "Área " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Nome"
const tipo1 = "opc_linha-"
const clas1 = var.classe1
const vari1 = "a_nome"
#
const nome2 = "Autor"
const tipo2 = "opc_linha-"
const clas2 = var.classe1
const vari2 = "a_autor"
#
const nome3 = "Tempo de reset"
const info3 = "Tempo aproximado em minutos"
const tipo3 = "opc_numero"
const clas3 = var.classe1
const vari3 = "a_tempo"
const exec3 = "reset_atualiza"
#
const nome4 = "Modo de reset"
const tipo4 = "opc_opcao"
const clas4 = var.classe1
const vari4 = "a_reset"
const extr4 = "Nunca\nQuando não há jogadores\nNormal"
#
const nome5 = "Mensagem de reset"
const tipo5 = "opc_linha"
const clas5 = var.classe1
const vari5 = "a_txtreset"
const extr5 = "Enviada para os jogadores na área quando ocorre reset"
#
const nome6 = "Terreno"
const tipo6 = "opc_opcao"
const clas6 = var.classe2
const vari6 = "s_terreno"
const extr6 = adm_sala:txt_terreno
#
const nome7 = "Luz"
const tipo7 = "opc_opcao"
const clas7 = var.classe2
const vari7 = "s_luz"
const extr7 = adm_sala:txt_luz
#
const nome8 = "Recuperação"
const info8 = "Taxa de recuperação de vida, mana e movimentos\n\
Quanto maior, mais recupera; 0 não recupera"
const tipo8 = "opc_numero"
const clas8 = var.classe2
const vari8 = "s_recup"
#
const nome9 = "Fome e sede"
const tipo9 = "opc_opcao"
const clas9 = var.classe2
const vari9 = "s_fome"
const extr9 = "Presente\nAusente\nSome aos poucos"
#
const nome10 = "Apagar itens"
const info10 = "Em quantos minutos sem jogador na sala deve começar a apagar os itens"
const tipo10 = "opc_numero"
const clas10 = var.classe2
const vari10 = "s_item"
#
const nome11 = "Morre ao entrar"
const tipo11 = "opc_opcao"
const clas11 = var.classe2
const vari11 = "s_morre"
const extr11 = "Não\nSim\nSim e perde itens e dinheiro"
#
const nome12 = "Ao tentar falar"
const info12 = "Mensagem recebida ao usar o comando falar; se nulo permite falar"
const tipo12 = "opc_linha"
const clas12 = var.classe2
const vari12 = "s_falar"
#
const nome13 = "Ao tentar gritar"
const info13 = "Mensagem recebida ao usar o comando gritar; se nulo permite gritar"
const tipo13 = "opc_linha"
const clas13 = var.classe2
const vari13 = "s_gritar"
#
const nome14 = "Batalha"
const tipo14 = "opc_opcao"
const clas14 = var.classe2
const vari14 = "s_luta"
const extr14 = adm_sala:txt_luta
#
const nome15 = "Sem resgate"
const info15 = "Se não é possível resgatar outro jogador"
const tipo15 = "opc_simnao"
const clas15 = var.classe2
const vari15 = "s_naoresg"
#
const nome16 = "Sem magia"
const tipo16 = "opc_simnao"
const clas16 = var.classe2
const vari16 = "s_semmagia"
#
const nome17 = "Comando retornar"
const tipo17 = "opc_opcao"
const clas17 = var.classe2
const vari17 = "s_retornar"
const extr17 = "Permitido\n\
Não permitido\n\
Muda o ponto de retorno para essa sala\n\
Muda o ponto de retorno se não possuir"
#
const nome18 = "Comando reserva"
const tipo18 = "opc_simnao"
const clas18 = var.classe2
const vari18 = "s_reserva"
#
const nome19 = "Sala ao voltar"
const info19 = "Quando um jogador sair do jogo e voltar, para qual sala deve voltar"
const tipo19 = "opc_sala"
const clas19 = var.classe2
const vari19 = "s_voltar"
#
const nome20 = "PNJs na sala"
const info20 = "Quantidade máxima de PNJs na sala; não afeta o reset"
const tipo20 = "opc_numero"
const clas20 = var.classe2
const vari20 = "s_pnj"
#
const nome21 = "Soltar itens"
const tipo21 = "opc_opcao"
const clas21 = var.classe2
const vari21 = "s_soltar"
const extr21 = "Permitido\nNão permitido\nDestrói afundando\nDestrói caindo\nDesintegra"
#
const nome22 = "Volume dentro"
const tipo22 = "opc_numero"
const clas22 = var.classe2
const vari22 = "volmax"
#
const nome23 = "Objetos máximo"
const tipo23 = "opc_numero"
const clas23 = var.classe2
const vari23 = "objmax"


classe menu_sala
herda comando_menu
const titulo = "Sala " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Título"
const tipo1 = "opc_linha"
const clas1 = var.classe1
const vari1 = "s_titulo"
#
const nome2 = "Descrição"
const info2 = "Aceita caracteres especiais do personagem; vide adm mens"
const tipo2 = "opc_texto"
const clas2 = var.classe1
const vari2 = "s_desc"
#
const nome3 = "Desc de noite"
const info3 = "Se quiser uma descrição diferente quando etiver de noite"
const tipo3 = "opc_texto"
const clas3 = var.classe1
const vari3 = "s_noite"
#
const nome4 = "Desc completa"
const info4 = "Se quiser substituir a descrição completa, mostrada ao teclar 'olhar'"
const tipo4 = "opc_texto"
const clas4 = var.classe1
const vari4 = "descsala"
#
const nome5 = "Ocultar desc"
const info5 = "Se não deve mostrar descrição ao entrar na sala"
const tipo5 = "opc_simnao"
const clas5 = var.classe1
const vari5 = "s_ocultar"
#
const nome6 = "Terreno"
const tipo6 = "opc_opcao"
const clas6 = var.classe1
const vari6 = "s_terreno"
const extr6 = adm_sala:txt_terreno
#
const nome7 = "Luz"
const tipo7 = "opc_opcao"
const clas7 = var.classe1
const vari7 = "s_luz"
const extr7 = adm_sala:txt_luz
#
const nome8 = "Recuperação"
const info8 = "Taxa de recuperação de vida, mana e movimentos\n\
Quanto maior, mais recupera; 0 não recupera"
const tipo8 = "opc_numero"
const clas8 = var.classe1
const vari8 = "s_recup"
#
const nome9 = "Fome e sede"
const tipo9 = "opc_opcao"
const clas9 = var.classe1
const vari9 = "s_fome"
const extr9 = "Presente\nAusente\nSome aos poucos"
#
const nome10 = "Apagar itens"
const info10 = "Em quantos minutos sem jogador na sala deve começar a apagar os itens"
const tipo10 = "opc_numero"
const clas10 = var.classe1
const vari10 = "s_item"
#
const nome11 = "Morre ao entrar"
const tipo11 = "opc_opcao"
const clas11 = var.classe1
const vari11 = "s_morre"
const extr11 = "Não\nSim\nSim e perde itens e dinheiro"
#
const nome12 = "Ao tentar falar"
const info12 = "Mensagem recebida ao usar o comando falar; se nulo permite falar"
const tipo12 = "opc_linha"
const clas12 = var.classe1
const vari12 = "s_falar"
#
const nome13 = "Ao tentar gritar"
const info13 = "Mensagem recebida ao usar o comando gritar; se nulo permite gritar"
const tipo13 = "opc_linha"
const clas13 = var.classe1
const vari13 = "s_gritar"
#
const nome14 = "Batalha"
const tipo14 = "opc_opcao"
const clas14 = var.classe1
const vari14 = "s_luta"
const extr14 = adm_sala:txt_luta
#
const nome15 = "Sem resgate"
const info15 = "Se não é possível resgatar outro jogador"
const tipo15 = "opc_simnao"
const clas15 = var.classe1
const vari15 = "s_naoresg"
#
const nome16 = "Sem magia"
const tipo16 = "opc_simnao"
const clas16 = var.classe1
const vari16 = "s_semmagia"
#
const nome17 = "Comando retornar"
const tipo17 = "opc_opcao"
const clas17 = var.classe1
const vari17 = "s_retornar"
const extr17 = "Permitido\n\
Não permitido\n\
Muda o ponto de retorno para essa sala\n\
Muda o ponto de retorno se não possuir"
#
const nome18 = "Comando reserva"
const tipo18 = "opc_simnao"
const clas18 = var.classe1
const vari18 = "s_reserva"
#
const nome19 = "Sala ao voltar"
const info19 = "Quando um jogador sair do jogo e voltar, para qual sala deve voltar"
const tipo19 = "opc_sala"
const clas19 = var.classe1
const vari19 = "s_voltar"
#
const nome20 = "PNJs na sala"
const info20 = "Quantidade máxima de PNJs na sala; não afeta o reset"
const tipo20 = "opc_numero"
const clas20 = var.classe1
const vari20 = "s_pnj"
#
const nome21 = "Soltar itens"
const tipo21 = "opc_opcao"
const clas21 = var.classe1
const vari21 = "s_soltar"
const extr21 = "Permitido\nNão permitido\nDestrói afundando\nDestrói caindo\nDesintegra"
#
const nome22 = "Volume dentro"
const tipo22 = "opc_numero"
const clas22 = var.classe1
const vari22 = "volmax"
#
const nome23 = "Objetos máximo"
const tipo23 = "opc_numero"
const clas23 = var.classe1
const vari23 = "objmax"
#
const nome24 = "Eventos sala"
const info24 = "Se recebe eventos da própria sala"
const tipo24 = "opc_simnao"
const clas24 = var.classe1
const vari24 = "eveste"
const exec24 = "ajustaobj"


classe menu_saida
herda comando_menu
const titulo = "Saída " + txtmai(var.saida1) + " de " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Estado inicial"
const tipo1 = "opc_saiinicio"
const clas1 = var.classe1
const vari1 = "portaini_" + var.saida1
const extr1 = adm_sala:txt_porta
#
const nome2 = "Estado atual"
const tipo2 = "opc_saiagora--"
const clas2 = var.classe1
const vari2 = "porta_" + var.saida1
#
const nome3 = "Invisível"
const tipo3 = "opc_simnao"
const clas3 = var.classe1
const vari3 = "inv_" + var.saida1
#
const nome4 = "Fecha ao passar"
const tipo4 = "opc_simnao"
const clas4 = var.classe1
const vari4 = "fecha_" + var.saida1
#
const nome5 = "Trancar"
const tipo5 = "opc_opcao"
const clas5 = var.classe1
const vari5 = "tranc_" + var.saida1
const extr5 = "Não pode ser trancado\nPode ser trancado\nTranca ao fechar"
#
const nome6 = "Fechadura"
const info6 = "Código da chave que tranca e destranca a porta\n\
Se for o nome de uma casa (vide comando lcasa), a chave da casa também serve"
const tipo6 = "opc_linha"
const clas6 = var.classe1
const vari6 = "fechadura_" + var.saida1
#
const nome7 = "Come chave"
const info7 = "Se o personagem perde a chave ao abrir a porta"
const tipo7 = "opc_simnao"
const clas7 = var.classe1
const vari7 = "comechave_" + var.saida1
#
const nome8 = "Voar"
const info8 = "Se é preciso estar voando ou flutuando"
const tipo8 = "opc_simnao"
const clas8 = var.classe1
const vari8 = "voar_" + var.saida1
#
const nome9 = "Sem fuga"
const info9 = "Se não existe a possibilidade de fugir de uma luta nessa direção"
const tipo9 = "opc_simnao"
const clas9 = var.classe1
const vari9 = "fugir_" + var.saida1
#
const nome10 = "Nome da porta"
const tipo10 = "opc_linha"
const clas10 = var.classe1
const vari10 = "portanome_" + var.saida1
#
const nome11 = "Artigo porta"
const tipo11 = "opc_opcao"
const clas11 = var.classe1
const vari11 = "portaartigo_" + var.saida1
const extr11 = "a (porta)\nas (portas)\no (portão)\nos (portões)"
