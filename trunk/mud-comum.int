classe comum_obj
# Comum a todos os personagens, itens e salas
#
ref contr # Quem está controlando; mesmo que: (dono.perso ? dono : este)
ref donoantes # Dono anterior
sav listaitem idono # Uso interno: aonde o objeto está
sav listaobj dentro1 # Lista de objetos que possui
sav listaobj dentro2 # Lista de personagens ou de objetos que está vestindo
listaobj evento # Objetos que recebem eventos desse
listaitem evrec.2 # Usado internamente, para receber eventos
uint8 socktot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
const objtot = 1 # Quantidade de objetos que esse objeto representa
const objmax = 100 # Quantos itens pode ter (objetos em dentro1)
uint16 objnum # Quantidade total de itens que representa é: (objnum>>1)
sav textovar var # Variáveis criadas sob demanda
#
uint32 pesoden # Somente leitura: quanto peso tem dentro
uint32 pesotot # Somente leitura: peso total
const pesoobj = 1 # Peso do objeto (em gramas)
const pesoadd = 1 # Se falso, está voando/flutuando (pesotot será 0)
#
uint32 volden # Somente leitura: volume do que tem dentro
uint32 voltot # Somente leitura: volume total do objeto
const volobj = 1 # Volume do objeto quando estiver vazio
const volmax = 1000000 # Volume máximo do que pode ter dentro
const volexp = 0 # Diferente de 0 se expande com os itens que tem dentro
#
uint16 luzden # Somente leitura: quantas fontes de luz dentro
uint16 luztot # Somente leitura: quantidade total de fontes de luz
# const luztipo = 0 # 0=não repassa a luz, 1=não é fonte de luz, 2=é fonte de luz
#
# const eveste = 1 # Receber eventos do próprio objeto
# const evperso = 1 # Receber eventos do dono se o dono for personagem
# const evitem = 1 # Receber eventos do dono se o dono for item
# const evsala = 1 # Receber eventos do dono se o dono for sala

func ini # Objeto é criado, acerta eventos, peso, volume e luz
  eveste && (evrec.0 = evento.addfim(este))
  pesoadd && (pesotot = pesoobj * objtot) # Acerta o peso
  voltot = volobj * objtot # Acerta o volume
  luztipo > 1 && (luztot = 1) # Acerta a luz

func fim # Objeto vai sair do jogo
  idono && (dono = nulo)
  listaobj l
  l.addfim(evento), evento.limpar, atkrec.limpar
  enquanto l
    l.objini.cmd_fim(este), l.ini.remove
  efim
  cmd_objfim, idono && (dono = nulo)

func ajustapeso # Acerta peso e volume (pesoden, pesotot, volden, voltot)
  real2 x
  ref r
# Acerta o peso (pesoden e pesotot)
  x = pesoadd ? pesoden + pesoobj * objtot - pesotot : -pesotot
  se x
    pesotot += x, r = idono.objlista, r.pesoden += x
    enquanto r.pesoadd
      r.pesotot += x, r = r.idono.objlista, r.pesoden += x
    efim
  fimse
# Acerta o volume (volden e voltot)
  x = volexp ? volden + volobj * objtot - voltot : volobj * objtot - voltot
  se x
    voltot += x, r = idono.objlista, r.volden += x
    enquanto r.volexp
      r.voltot += x, r = r.idono.objlista, r.volden += x
    efim
  fimse
# Acerta a luz (luzden e luztot)
  x = !luztipo ? -luztot : (luztipo > 1) + luzden - luztot
  se x
    luztot += x, r = idono.objlista, r.luzden += x
    enquanto r.luztipo
      r.luztot += x, r = r.idono.objlista, r.luzden += x
    efim
  fimse
# Acerta a quantidade de itens (objnum)
  se objnum & 1
  senao item
    objnum += 3, r = idono.objlista
    epara r.objnum += 2, r.item, r.objnum += 2
      r = r.idono.objlista
    efim
  senao
    objnum += 1
  fimse

func ajustaev # Acerta eventos
  evrec.0.remove, evrec.1.remove, eveste && (evrec.0 = evento.addfim(este))
  contr = idono.objlista
  (contr.perso ? evperso : contr.item ? evitem : evsala) && (evrec.1 = contr.addfim(este))
  !contr.perso && (contr = este)

varfunc dono # O dono do personagem/item
  ret !args, idono.objlista # Checa se é leitura
  ret (donoantes = idono.objlista) == ref(arg0), nulo # Retorna se o dono não vai mudar
  ref r
# Se não está voando: retira o peso total
  se pesotot
    r = donoantes, r.pesoden -= pesotot
    enquanto r.pesoadd
      r.pesotot -= pesotot, r = r.idono.objlista, r.pesoden -= pesotot
    efim
  fimse
# Retira o volume
  r = donoantes, r.volden -= voltot
  enquanto r.volexp
    r.voltot -= voltot, r = r.idono.objlista, r.volden -= voltot
  efim
# Retira a luz
  se luztot
    r = donoantes, r.luzden -= luztot
    enquanto r.luztipo
      r.luztot -= luztot, r = r.idono.objlista, r.luzden -= luztot
    efim
  fimse
# Retira a quantidade de itens (objnum)
  epara r = este, r.item, r.objnum -= objnum & ~1
    r = idono.objlista
  efim
# Acerta se tem jogador dentro
  se socktot
    epara r = donoantes, r, r = r.idono.objlista
      r.socktot -= socktot
    efim
  fimse
# Muda de dono e acerta eventos
  evrec.0.remove, evrec.1.remove, eveste && (evrec.0 = evento.addfim(este))
  r = arg0, idono.remove # Retira do dono atual
  se !r
    ret
  senao perso
    idono = r.dentro2.addfim(este) # Adiciona personagem
  senao
    idono = r.dentro1.addfim(este) # Adiciona item
  fimse
  (r.perso ? evperso : r.item ? evitem : evsala) && (evrec.1 = r.evento.addfim(este))
  contr = (r.perso ? r : este)
# Se não está voando: acrescenta o peso total
  se pesotot
    r.pesoden += pesotot # Nota: r já é idono.objlista
    enquanto r.pesoadd
      r.pesotot += pesotot, r = r.idono.objlista, r.pesoden += pesotot
    efim
  fimse
# Acrescenta o volume
  r = idono.objlista, r.volden += voltot
  enquanto r.volexp
    r.voltot += voltot, r = r.idono.objlista, r.volden += voltot
  efim
# Acrescenta a luz
  se luztot
    r = idono.objlista, r.luzden += luztot
    enquanto r.luztipo
      r.luztot += luztot, r = r.idono.objlista, r.luzden += luztot
    efim
  fimse
# Acrescenta a quantidade de itens (objnum)
  epara r = este, r.item, r.objnum += objnum & ~1
    r = idono.objlista
  efim
# Acerta se tem jogador dentro
  se socktot
    epara r = idono.objlista, r, r = r.idono.objlista
      r.socktot += socktot
    efim
  fimse
# Limpa outras variáveis
  perso && atkenv.remove + atkrec.limpar
  var.limpar("d_")


classe comum_persoitem
herda comum_obj
# Comum a todos os personagens e itens
int16 bitver # O que o personagem/item pode ver
int16 bitinv # Grau de invisibilidade do personagem/item
intexec recalc # Se deve recalcular variáveis do personagem/item

func visivel # Informa se esse objeto está visível (arg0=quem quer ver)
  ret arg0.idono.objlista.luzden, !(~(arg0.bitver | 2) & bitinv)
  casovar arg0.idono.objlista.s_luz
  casose "2" # Pode estar escuro
    ret !(~(misc:luz ? arg0.bitver | 2 : arg0.bitver) & bitinv)
  casose "3" # Escuro
    ret !(~arg0.bitver & bitinv)
  casose # Claro
    ret !(~(arg0.bitver | 2) & bitinv)
  casofim

func atribs # Retorna texto com os atributos do item ou personagem
  ret bitinv & 2 ? "" : "(brilhando) "
