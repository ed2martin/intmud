classe mens
ref contr # Mesmo que perso.contr
ref perso # Personagem que está enviando a mensagem
ref alvo # Personagem ou objeto alvo da ação
ref obj # Objeto secundário
ref r # Objeto que vai receber a mensagem
txt512 mens # Mensagem usada em $M
txt100 o_1 # Texto de $1
txt100 o_2 # Texto de $2
txt100 o_3 # Texto de $3
txt100 o_4 # Texto de $4
txt100 o_5 # Texto de $5
const iniclasse = !$[arg0] && criar(arg0)

func p # Define os personagens
  contr = arg0.contr, perso = arg0, alvo = arg1, obj = arg2

func mperso # Mensagem só para o personagem
  contr.dono.socktot && arg0 && contr.msginv(arg0)

func mtodos1 # Mensagem só para quem estiver acordado
# arg0 = mensagem para todos
  se contr.dono.socktot && arg0
    listaobj l0
    l0.addfim(contr.dono.dentro2)
    enquanto l0
      l0.objini.msginv(arg0), l0.ini.remove
    efim

func mtodos2 # Mensagem só para quem estiver acordado
# arg0 = mensagem para personagem, arg1 = mensagem para outros
  se contr.dono.socktot
    arg0 && contr.msginv(arg0)
    se arg1
      listaobj l0
      l0.addfim(contr.dono.dentro2)
      l0.remove(contr)
      enquanto l0
        l0.objini.msginv(arg1), l0.ini.remove
      efim

func mtodos3 # Mensagem só para quem estiver acordado
# arg0,arg1,arg2 = mensagens para personagem, alvo e outros
  se contr.dono.socktot
    arg0 && contr.msginv(arg0)
    arg1 && alvo.contr != contr && alvo.contr.msginv(arg1)
    se arg2
      listaobj l0
      l0.addfim(contr.dono.dentro2)
      l0.remove(contr, alvo.contr)
      enquanto l0
        l0.objini.msginv(arg2), l0.ini.remove
      efim

func mvis1 # Mensagem só para quem pode ver o personagem e estiver acordado
# arg0 = mensagem para todos
  se contr.dono.socktot && arg0
    contr.msginv(arg0)
    listaobj l0
    l0.addfim(contr.dono.dentro2)
    l0.remove(contr)
    enquanto l0
      l0.objini.msgvis(arg0), l0.ini.remove
    efim

func mvis2 # Mensagem só para quem pode ver o personagem e estiver acordado
# arg0 = mensagem para personagem, arg1 = mensagem para outros
  se contr.dono.socktot
    arg0 && contr.msginv(arg0)
    se arg1
      listaobj l0
      l0.addfim(contr.dono.dentro2)
      l0.remove(contr)
      enquanto l0
        l0.objini.msgvis(arg1), l0.ini.remove
      efim

func mvis3 # Mensagem só para quem pode ver o personagem e estiver acordado
# arg0,arg1,arg2 = mensagens para personagem, alvo e outros
  se contr.dono.socktot
    arg0 && contr.msginv(arg0)
    arg1 && alvo.contr != contr && alvo.contr.msgvis(arg1)
    se arg2
      listaobj l0
      l0.addfim(contr.dono.dentro2)
      l0.remove(contr, alvo.contr)
      enquanto l0
        l0.objini.msgvis(arg2), l0.ini.remove
      efim

func mmud1 # Mensagem para todos do MUD
# arg0 = mensagem para todos
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.msg($mens.proc(arg0, item.obj.perso))
  efim

func mmudtodos1 # Mensagem para todos que estiverem acordados no MUD
# arg0 = mensagem para todos
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.perso.msginv(arg0)
  efim

func marea1 # Mensagem para todos que estiverem na mesma área
# arg0 = mensagem para todos
  ref r
  epara r = contr, r.dono, r = r.dono
  efim
  refvar area = r.s_area
  indiceitem item
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    epara r = item.obj.dono, r.dono, r = r.dono
    efim
    r.s_area == area && item.obj.msg($mens.proc(arg0, item.obj))
  efim

func mareatodos1 # Mensagem para todos que estiverem acordados na mesma área
# arg0 = mensagem para todos
  ref r
  epara r = contr, r.dono, r = r.dono
  efim
  refvar area = r.s_area
  indiceitem item
  epara item.ini("pn "), txt1(item.txt) == "pn", item.depois
    epara r = item.obj.dono, r.dono, r = r.dono
    efim
    r.s_area == area && item.obj.msginv(arg0)
  efim

func proc # Prepara e retorna mensagem
# arg0=mensagem, arg1=a quem se destina a mensagem
  r = arg1
  refvar t = vartroca(txttroca(arg0, "$$", "$@"), "$", "o_")
  ret txtdec(vartroca(txtcod(t), "@d", "x_"))

const x_a = "De"
const x_a@_a@_ = "Da "
const x_a@_as@_ = "Das "
const x_a@_o@_ = "Do "
const x_a@_os@_ = "Dos "
const x_b = "de"
const x_b@_a@_ = "da "
const x_b@_as@_ = "das "
const x_b@_o@_ = "do "
const x_b@_os@_ = "dos "
const x_c = "Em"
const x_c@_a@_ = "Na "
const x_c@_as@_ = "Nas "
const x_c@_o@_ = "No "
const x_c@_os@_ = "Nos "
const x_d = "em"
const x_d@_a@_ = "na "
const x_d@_as@_ = "nas "
const x_d@_o@_ = "no "
const x_d@_os@_ = "nos "
#
const x_e = "De"
const x_e@_a@_ = "Da "
const x_e@_as@_ = "Das "
const x_e@_o@_ = "Do "
const x_e@_os@_ = "Dos "
const x_e@_uma@_ = "Da "
const x_e@_umas@_ = "Das "
const x_e@_um@_ = "Do "
const x_e@_uns@_ = "Dos "
const x_f = "de"
const x_f@_a@_ = "da "
const x_f@_as@_ = "das "
const x_f@_o@_ = "do "
const x_f@_os@_ = "dos "
const x_f@_uma@_ = "da "
const x_f@_umas@_ = "das "
const x_f@_um@_ = "do "
const x_f@_uns@_ = "dos "
const x_g = "Em"
const x_g@_a@_ = "Na "
const x_g@_as@_ = "Nas "
const x_g@_o@_ = "No "
const x_g@_os@_ = "Nos "
const x_g@_uma@_ = "Na "
const x_g@_umas@_ = "Nas "
const x_g@_um@_ = "No "
const x_g@_uns@_ = "Nos "
const x_h = "em"
const x_h@_a@_ = "na "
const x_h@_as@_ = "nas "
const x_h@_o@_ = "no "
const x_h@_os@_ = "nos "
const x_h@_uma@_ = "na "
const x_h@_umas@_ = "nas "
const x_h@_um@_ = "no "
const x_h@_uns@_ = "nos "
#
const o_@ = "$"
const o_d = arg0 === "D" ? "\da" : "\db"
const o_e = arg0 === "E" ? "\dc" : "\dd"
const o_f = arg0 === "F" ? "\de" : "\df"
const o_g = arg0 === "G" ? "\dg" : "\dh"
const o_h = txtcopiamai(perso.msexo ? "um" : "uma", arg0)
const o_i = txtcopiamai(alvo.msexo ? "um" : "uma", arg0)
const o_j = txtcopiamai(obj.msexo ? "um" : "uma", arg0)
const o_m = arg0 === "M" ? txtcopiamai(mens, "A") : mens
const o_s = txtcopiamai(perso.msexo ? "o" : "a", arg0)
const o_t = txtcopiamai(alvo.msexo ? "o" : "a", arg0)
const o_u = txtcopiamai(obj.msexo ? "o" : "a", arg0)
const o_v = txtcopiamai(perso.msexo ? "e" : "a", arg0)
const o_w = txtcopiamai(alvo.msexo ? "e" : "a", arg0)
const o_x = txtcopiamai(obj.msexo ? "e" : "a", arg0)

func o_p
  se perso == perso.contr
    se r == perso
      ret txtcopiamai("você", arg0)
    senao perso.visivel(r)
      ret arg0 === "P" ? txtcopiamai(perso.descnome, "A") : perso.descnome
    senao
      ret txtcopiamai(perso.perso ? "alguém" : "alguma coisa", arg0)
    fimse
  senao r == perso.contr
    ret txtcopiamai(perso.msexo ? "seu " : "sua ", arg0) + perso.nome
  senao perso.contr.visivel(r)
    refvar m = arg0 === "P" ? txtcopiamai(perso.descnome, "A") : perso.descnome
    ret m + " de " + perso.contr.descnome
  senao perso.visivel(r)
    ret (arg0 === "P" ? txtcopiamai(perso.descnome, "A") : perso.descnome) + " de alguém"
  senao
    ret txtcopiamai(perso.perso ? "alguém" : "alguma coisa", arg0)

func o_a
  se alvo == alvo.contr
    se r == alvo
      ret txtcopiamai("você", arg0)
    senao alvo.visivel(r)
      ret arg0 === "A" ? txtcopiamai(alvo.descnome, "A") : alvo.descnome
    senao
      ret txtcopiamai(alvo.perso ? "alguém" : "alguma coisa", arg0)
    fimse
  senao r == alvo.contr
    ret txtcopiamai(alvo.msexo ? "seu " : "sua ", arg0) + alvo.nome
  senao alvo.contr.visivel(r)
    refvar m = arg0 === "A" ? txtcopiamai(alvo.descnome, "A") : alvo.descnome
    ret m + " de " + alvo.contr.descnome
  senao alvo.visivel(r)
    ret (arg0 === "A" ? txtcopiamai(alvo.descnome, "A") : alvo.descnome) + " de alguém"
  senao
    ret txtcopiamai(alvo.perso ? "alguém" : "alguma coisa", arg0)

func o_q # Nome do personagem sem citar o dono
  se r == perso
    ret txtcopiamai("você", arg0)
  senao perso.visivel(r)
    ret arg0 === "Q" ? txtcopiamai(perso.descnome, "A") : perso.descnome
  senao
    ret txtcopiamai(perso.perso ? "alguém" : "alguma coisa", arg0)

func o_r # Nome do personagem no comando QUEM
  ret arg0 === "r", perso.sock ? perso.sock.nome : perso.nome
  ret txtcopiamai(perso.sock ? perso.sock.nome : perso.nome, "A")

func o_b # Nome do alvo sem citar o dono
  se r == alvo
    ret txtcopiamai("você", arg0)
  senao alvo.visivel(r)
    ret arg0 === "B" ? txtcopiamai(alvo.descnome, "A") : alvo.descnome
  senao
    ret txtcopiamai(alvo.perso ? "alguém" : "alguma coisa", arg0)

func o_c # Nome do alvo no comando QUEM
  ret arg0 === "c", alvo.sock ? alvo.sock.nome : alvo.nome
  ret txtcopiamai(alvo.sock ? alvo.sock.nome : alvo.nome, "A")

func o_o # Nome do objeto
  se r == obj
    ret txtcopiamai("você", arg0)
  senao obj.visivel(r)
    ret arg0 === "O" ? txtcopiamai(obj.descnome, "A") : obj.descnome
  senao
    ret txtcopiamai(obj.perso ? "alguém" : "alguma coisa", arg0)


classe mens_antigo
# Exemplo de código da versão anterior da classe mens
#
ref contr # Mesmo que perso.contr
ref perso # Personagem que está enviando a mensagem
ref alvo # Personagem ou objeto alvo da ação
ref obj # Objeto secundário
ref r # Objeto que vai receber a mensagem
txt512 mens # Mensagem usada em $M
textotxt t0 # Usado em proc: texto que será enviado
textopos p0 # Usado em proc: linha atual
int16 i # Posição em p0 # Usado em proc: posição em p0
txt1 opc # Usado em proc: opção
txt100 lin # Usado em proc: linha
const iniclasse = !$[arg0] && criar(arg0)

func p # Define os personagens
  contr = arg0.contr, perso = arg0, alvo = arg1, obj = arg2

func proc # Prepara e retorna mensagem
# arg0=mensagem, arg1=objeto
  t0.limpar, t0.addfim(arg0)
  p0 = t0.ini, i = 0, r = arg1
  enquanto (i = p0.txtproc("$", i)) >= 0
    opc = p0.texto(i + 1, 1)
    se opc === "$"
      p0.mudar("", i, 1)
      i += 1
    senao opc === txtmai(opc)
      lin = p0.texto(i + 2)
      p0.mudar(opcmai_[opc](lin), i, inttotal(lin) + 2)
    senao opc === txtmin(opc)
      lin = p0.texto(i + 2)
      p0.mudar(opcmin_[opc](lin), i, inttotal(lin) + 2)
    senao
      p0.mudar("", i, 2)
    fimse
  efim
  ret t0.remove(1000)

func opcmai_p # Nome do personagem
  se r == perso
    ret "Você" + arg0
  senao perso.visivel(r)
    ret txtcopiamai(perso.descnome, "A") + arg0
  senao perso.perso
    ret "Alguém" + arg0
  senao
    ret "Alguma coisa" + arg0
# func opcmai_a
# # arg0 é o que vem depois de "$A", até 100 caracteres e sem "\n"
# ret "teste" + arg0 # Substitui "$a" por "teste"
# func opcmin_a
# ret "R$$" + arg0 # Um $ no texto deve ser retornado com o$$
# # Ou assim: ret txttroca("R$", "$", "$$") + arg0


classe mens_prompt
# Monta mensagem do prompt a partir do prompt e do personagem
# Chamar com:
# $mens_prompt.mens(mensagem, personagem)
#
ref p1 # O próprio personagem
ref p2 # O animal usado por p1
ref a1 # Quem está batalhando com o personagem
ref a2 # O animal de quem está batalhando com o personagem
const iniclasse = !$[arg0] && criar(arg0)

func mens
# arg0 = mensagem
# arg1 = personagem
  p1 = ref(arg1), p2 = ref(p1.persoesc)
  a1 = ref(p1.atkenv.objlista), a2 = ref(a1.persobat)
  ret vartroca(arg0, "%", "m_")

func m_d
  se arg0 === "d" # Hora no MUD
    ret txt(misc:hora) + ":" + misc:min
  senao # Hora no servidor
    datahora d
    d.agora
    ret txt(d.hora) + ":" + d.min

const m_g = p1.var.z_moedas_
const m_h = arg0 === "h" ? p2.pvida : p2.pvidamax
const m_l = arg0 === "l" ? p2.pnivel : a2.pnivel
const m_m = arg0 === "m" ? p2.pmana : p2.pmanamax

func m_n
  se arg0 === "n" # Nome do seu personagem
    ret p1 == p2 ? p1.descnome : p2.descnome + " de " + p1.descnome
  senao # Nome do seu oponente
    ret a1 == a2 ? a1.descnome : a2.descnome + " de " + a1.descnome

func m_o
  se !a2
  senao arg0 === "o" # Pontos de vida do oponente em porcentagem
    ret int(a2.pvida * 100 / a2.pvidamax)
  senao # Pontos de vida do oponente em uma barra de 10 caracteres
    uint8 x
    x = int(a2.pvida * 10 / a2.pvidamax)
    ret x >= 10 ? ">>>>>>>>>>" : txtrepete(">", x) + txtrepete(" ", 10 - x)

func m_p
  se arg0 === "p" # Pontos de vida em porcentagem
    ret int(p2.pvida * 100 / p2.pvidamax)
  senao # Pontos de vida em uma barra de 10 caracteres
    uint8 x
    x = int(p2.pvida * 10 / p2.pvidamax)
    ret x >= 10 ? ">>>>>>>>>>" : txtrepete(">", x) + txtrepete(" ", 10 - x)

func m_t # Conforme o sol: amanhecendo, manhã, tarde, anoitecendo, noite
  ret arg0 === "t", " "
  casovar misc:hora
  casose "6"
    ret "amanhecendo"
  casose "7"
  casose "8"
  casose "9"
  casose "10"
  casose "11"
    ret "manhã"
  casose "12"
  casose "13"
  casose "14"
  casose "15"
  casose "16"
    ret "tarde"
  casose "17"
    ret "escurecendo"
  casose
    ret "noite"
  casofim

const m_v = arg0 === "v" ? p2.pmove : p2.pmovemax
const m_x = arg0 === "x" ? p2.expatual : p2.expmax - p2.expatual
const m_z = arg0 === "z" ? "\n" : "%"
const m_b = "\b"
const m_c0 = "\c0"
const m_c1 = "\c1"
const m_c2 = "\c2"
const m_c3 = "\c3"
const m_c4 = "\c4"
const m_c5 = "\c5"
const m_c6 = "\c6"
const m_c7 = "\c7"
const m_c8 = "\c8"
const m_c9 = "\c9"
const m_ca = "\ca"
const m_cb = "\cb"
const m_cc = "\cc"
const m_cd = "\cd"
const m_ce = "\ce"
const m_cf = "\cf"
const m_cg = "\cg"
const m_ch = "\ch"
const m_ci = "\ci"
const m_cj = "\cj"
const m_ck = "\ck"
const m_cl = "\cl"
const m_f0 = "\d0"
const m_f1 = "\d1"
const m_f2 = "\d2"
const m_f3 = "\d3"
const m_f4 = "\d4"
const m_f5 = "\d5"
const m_f6 = "\d6"
const m_f7 = "\d7"


classe mens_porta
# Monta mensagem para avisar sobre portas abertas e fechadas
#
# Chamar com:
# $mens_porta.mens(mensagem, sala, direção, mensagem)
#
# Exemplo:
# $mens_porta.mens("$P est$o fechad$a.", dono, "s")
#
# Caracteres usados na mensagem:
# $A = a,o,as,os, conforme a porta
# $M = um texto vazio (no singular) ou "m" (no plural)
# $O = "á" (no singular) ou "ão" (no plural)
# $P = nome da porta
#
txt100 n # Nome da porta
txt2 tsexo # Pode ser a,as,o,os
txt2 tplural # Pode ser á,ão
txt2 tm # Pode ser "" ou "m"
txt100 tnome # Nome da porta
const iniclasse = !$[arg0] && criar(arg0)

func mens
  tnome = arg1.portanome_[arg2]
  !tnome && !(tnome = $cmd_[arg2].m_porta) && (tnome = "uma porta")
  casovar arg1.portaartigo_[arg2]
  casose # Feminino singular
    tplural = "á", tsexo = "a", tm = ""
    sair
  casose "1" # Feminino plural
    tplural = "ão", tsexo = "as", tm = "m"
    sair
  casose "2" # Masculino plural
    tplural = "á", tsexo = "o", tm = ""
    sair
  casose "3" # Masculino plural
    tplural = "ão", tsexo = "os", tm = "m"
    sair
  casofim
  ret vartroca(arg0, "$", "m_")

const m_a = arg0 === "a" ? tsexo : txtcopiamai(tsexo, "A")
const m_m = arg0 === "m" ? tm : txtcopiamai(tm, "A")
const m_o = arg0 === "o" ? tplural : txtcopiamai(tplural, "A")
const m_p = arg0 === "p" ? tnome : txtcopiamai(tnome, "A")
