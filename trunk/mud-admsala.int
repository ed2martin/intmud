classe jog_admsala
# Comandos de sala e de área
const txt_reset = "Nunca\nQuando não há jogadores\nNormal"
const txt_terreno = "Dentro, lugar fechado - 1mv\n\
Rua de uma cidade - 1mv\n\
Campo, um campo aberto - 2mv\n\
Pântano, itens afundam - 3mv\n\
Floresta densa - 3mv\n\
Colina - 4mv\n\
Montanha, excessivamente montanhoso - 6mv\n\
Água, pode nadar - 4mv\n\
Água, requer barco para passar - 1mv\n\
Em baixo d'água - 5mv\n\
Ar, itens e mobs caem - 1mv"
const txt_luz = "Claro com eventos de tempo\n\
Claro sem eventos de tempo\n\
Luz do sol\nEscuro"
const adm_area = "\b\c3Comandos de áreas\b\n\
\c2LAREA\b [nome]\n\
  Lista áreas que começam com o nome especificado. Nome pode ser omitido.\n\
\c2CAREA\b <nome>\n\
  Cria área. Nomes de área devem ter de 2 a 16 letras de A a Z.\n\
\c2EAREA\b [nome]\n\
  Edita área. Se o nome for omitido, edita a área em que você está.\n\
\c2AAREA\b <nome>\n\
  Apaga área, desde que não tenha nenhuma sala."
const adm_sala = "\b\c3Comandos de salas\b\n\
\c2ISALA\b <nome>\n\
  Vai para a sala especificada.\n\
\c2LSALA\b <nome>\n\
  Lista salas que começam com o nome especificado.\n\
\c2CSALA\b <nome>\n\
  Cria sala com o nome especificado. Nomes de sala devem ser o nome\n\
  da área seguido de um número de 001 a 999 (três dígitos).\n\
\c2CSALA\b <direção>\n\
  Cria sala na direção especificada. Cria automaticamente uma saída\n\
  com a sala em que você está. Exemplo: csala ne\n\
\c2ESALA\b [nome]\n\
  Edita sala. Se o nome for omitido, edita a sala em que você está.\n\
\c2ASALA\b <um ou mais nomes>\n\
  Apaga uma ou mais salas. Atenção: não apaga as saídas das outras salas\n\
  para as que forem apagadas."
const adm_sai = "\b\c3Comandos de saídas das sala\b\n\
\c2LSAI\b\n\
  Mostra saídas da sala em que você está.\n\
\c2CSAI\b <direção> <sala>\n\
  Cria saída na direção especificada.\n\
\c2CSAI2\b <direção> <sala>\n\
  Mesmo que CSAI, mas cria também uma saída no sentido contrário.\n\
\c2ESAI\b <direção>\n\
  Edita tipo de saída na direção especificada.\n\
\c2ASAI\b <direção>\n\
  Apaga saída na direção especificada."

func com_larea # Listar áreas
  prog p
  se !p.iniclasse("a_" + arg0)
    msg("\bNenhuma área encontrada.")
  senao
    textotxt t
    t.addfim("\bÁreas (prefixo, nome, autor):")
    enquanto p.lin
      t.addfim(txt(p.texto, 2) + ", " + [p.texto]:a_nome + ", " + [p.texto]:a_autor)
      p.depois
    efim
    msg2(t.remove(1000))
  fimse
  ret 1

func com_carea # Criar área
  txt100 prefixo
  prefixo = txtmin(arg0)
  se $a_[prefixo]
    msg("\bÁrea já existe: " + prefixo)
  senao inttotal(prefixo) < 2 || inttotal(prefixo) > 10
    msg("\bNome de área deve ter de 2 a 10 caracteres")
  senao
    uint8 pos
    enquanto pos < inttotal(prefixo)
      se txt(prefixo, pos, 1) < "a" || txt(prefixo, pos, 1) > "z"
        msg("\bNome de área deve ter apenas letras de a a z.")
        ret 1
      fimse
      pos += 1
    efim
    prog p
    p.criar("a_" + prefixo + "\na-" + prefixo + "\nherda area")
    p.criar("b_" + prefixo + "\na-" + prefixo + "\nherda sala")
    p.salvar(config:progsalvar)
    msg("\bÁrea criada: " + prefixo)
  fimse
  ret 1

func com_aarea # Apagar área
  txt100 prefixo
  prog p
  prefixo = txtmin(arg0)
  se !$a_[prefixo]
    msg("\bÁrea não existe: " + prefixo)
  senao p.iniherdainv("b_" + prefixo)
    msg("\bÁrea contém pelo menos uma sala: " + txt(p.texto, 2))
  senao
    p.apagar("a_" + prefixo)
    p.apagar("b_" + prefixo)
    p.salvar(config:progsalvar)
    msg("\bÁrea apagada: " + prefixo)
  fimse
  ret 1

func com_earea # Editar área
  txt100 prefixo
  prog p
  prefixo = txtmin(arg0)
  se prefixo == ""
    prefixo = txt(perso.dono, 2, inttotal(txt(perso.dono)) - 5)
  fimse
  se !$a_[prefixo]
    msg("\bÁrea não existe: " + prefixo)
  senao
    msg("Área " + prefixo + ", tecle O para saber as opções")
    passo = "area"
    tpasso = "a_" + prefixo
  fimse
  ret 1

func p_area # Editando área
  teditor.limpar
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  fimse
  casovar txtmin(arg0)
  casose "o"
    txtmais.limpar
    txtmais.addfim("\bÁrea " + txt(tpasso, 2))
    txtmais.addfim("1. Nome            : " + m_linha("a_nome"))
    txtmais.addfim("2. Autor           : " + m_linha("a_autor"))
    txtmais.addfim("3. Tempo de reset  : " + m_numero("a_tempo"))
    txtmais.addfim("4. Modo de reset   : " + m_opcao("a_reset", txt_reset))
    tpasso = "b_" + txt(tpasso, 2)
    txtmais.addfim("5. Terreno         : " + m_opcao("s_terreno", txt_terreno))
    txtmais.addfim("6. Luz             : " + m_opcao("s_luz", txt_luz))
    txtmais.addfim("7. Apagar itens em : " + m_numero("s_item") + " min")
    txtmais.addfim("8. Morre ao entrar : " + m_simnao("s_morre"))
    txtmais.addfim("9. Silencioso      : " + m_simnao("s_silencio"))
    txtmais.addfim("10.Sem violência   : " + m_simnao("s_pacifico"))
    txtmais.addfim("11.Sem magia       : " + m_simnao("s_semmagia"))
    txtmais.addfim("12.MOBs não entram : " + m_simnao("s_semmob"))
    tpasso = "a_" + txt(tpasso, 2)
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casose "1"
    msg("Nome: " + m_linha("a_nome"))
    tpasso += " a_nome area Nome"
    ret p_linha("")
  casose "2"
    msg("Autor: " + m_linha("a_autor"))
    tpasso += " a_autor area Autor"
    ret p_linha("")
  casose "3"
    msg("Tempo de reset: " + m_numero("a_tempo"))
    tpasso += " a_tempo area Tempo de reset"
    ret p_numero("")
  casose "4"
    msg("Modo de reset: " + m_opcao("a_reset", txt_reset))
    teditor.addfim(txt_reset)
    tpasso += " a_reset area Modo de reset"
    ret p_opcao("")
  casose "5"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Terreno: " + m_opcao("s_terreno", txt_terreno))
    teditor.addfim(txt_terreno)
    tpasso += " s_terreno area Tipo de terreno"
    ret p_opcao("")
  casose "6"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Luz: " + m_opcao("s_luz", txt_luz))
    teditor.addfim(txt_luz)
    tpasso += " s_luz area Quantidade de luz"
    ret p_opcao("")
  casose "7"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Sem jogador na sala apaga itens após: " + m_numero("s_item") + " min")
    tpasso += " s_item area Apagar itens em"
    ret p_numero("")
  casose "8"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Morre ao entrar: " + m_simnao("s_morre"))
    tpasso += " s_morre area Morre ao entrar"
    ret p_simnao("")
  casose "9"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Silencioso: " + m_simnao("s_silencio"))
    tpasso += " s_silencio area Silencioso"
    ret p_simnao("")
  casose "10"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Sem violência: " + m_simnao("s_pacifico"))
    tpasso += " s_pacifico area Sem violência"
    ret p_simnao("")
  casose "11"
    tpasso = "b_" + txt(tpasso, 2)
    msg("Sem magia: " + m_simnao("s_semmagia"))
    tpasso += " s_semmagia area Sem magia"
    ret p_simnao("")
  casose "12"
    tpasso = "b_" + txt(tpasso, 2)
    msg("MOBs não entram: " + m_simnao("s_semmob"))
    tpasso += " s_semmob area Se MOBs não entram"
    ret p_simnao("")
  casose "f1"
    tpasso += " a_nome area Nome"
    ret p_func("\n")
  casose "f2"
    tpasso += " a_autor area Autor"
    ret p_func("\n")
  casose "f3"
    tpasso += " a_tempo area Tempo de reset"
    ret p_func("\n")
  casose "f4"
    tpasso += " a_reset area Modo de reset"
    ret p_func("\n")
  casose "f5"
    tpasso = "b_" + txt(tpasso, 2) + " s_terreno area Tipo de terreno"
    ret p_func("\n")
  casose "f6"
    tpasso = "b_" + txt(tpasso, 2) + " s_luz area Quantidade de luz"
    ret p_func("\n")
  casose "f7"
    tpasso = "b_" + txt(tpasso, 2) + " s_item area Apagar itens em"
    ret p_func("\n")
  casose "f8"
    tpasso = "b_" + txt(tpasso, 2) + " s_morre area Morre ao entrar"
    ret p_func("\n")
  casose "f9"
    tpasso = "b_" + txt(tpasso, 2) + " s_silencio area Silencioso"
    ret p_func("\n")
  casose "f10"
    tpasso = "b_" + txt(tpasso, 2) + " s_pacifico area Sem violência"
    ret p_func("\n")
  casose "f11"
    tpasso = "b_" + txt(tpasso, 2) + " s_semmagia area Sem magia"
    ret p_func("\n")
  casose "f12"
    tpasso = "b_" + txt(tpasso, 2) + " s_semmob area Se MOBs não entram"
    ret p_func("\n")
  casose
    msg("Opção inválida: " + arg0)
  casose ""
    passo = "area"
    tpasso = "a_" + txt(txt1(tpasso), 2)
    msg("Área " + txt(tpasso, 2) + ", O opções, Z sair")
    ret 1
  casofim
  ret 1

func com_lsala # Listar salas
  prog p
  se !p.iniclasse("s_" + arg0)
    msg("\bNenhuma sala encontrada.")
  senao
    textotxt t
    t.addfim("\bSalas:")
    enquanto p.lin && t.linhas < 500
      t.addfim(txt(p.texto, 2) + "  " + $[p.texto].s_titulo)
      p.depois
    efim
    msg2(t.remove(500))
  fimse
  ret 1

func com_isala # Ir para uma sala específica
  se !$s_[arg0]
    msg("\bSala não existe: " + arg0)
  senao !perso
    msg("Você deve estar controlando um personagem para isso")
  senao
    perso.mudasala($s_[arg0])
  fimse
  ret 1

func com_csala # Criar sala
  prog p
  txt40 nome
  uint16 num
  se arg0 == ""
    msg("Tecle o nome da sala ou a direção após CSALA")
    ret 1
# Criar sala em uma direção
  senao misc:d1[arg0]
    txt2 dir
    dir = misc:d1[arg0]
# Obtém prefixo da área
    nome = txt(perso.dono, 0, inttotal(txt(perso.dono)) - 3)
    se txt(nome, 0, 2) != "s_"
      msg("Você não está em uma sala")
      ret 1
    fimse
# Checa se já existe sala nessa direção
    se p.existe(perso.dono, "dir_" + dir) == 1
      msg("Já existe sala na direção " + dir)
      ret 1
    fimse
# Obtém número da sala
    num = 1001
    enquanto num < 2000 && p.existe(nome + txtfim(num, 3))
      num += 1
    efim
    se num >= 2000
      msg("Sem espaço para criar sala na área " + txt(nome, 2))
      ret 1
    fimse
# Cria sala
    txt300 nome2
    nome2 = nome + txtfim(num, 3) + "\n" # Nome da classe
    nome2 += "a-" + txt(nome, 2) + "\n" # Nome do arquivo
    nome2 += "herda b_" + txt(nome, 2) + "\n" # Herda propriedades da área
    nome2 += "const dir_" + misc:d2[dir] + "=$" + perso.dono # Saída da sala
    p.criar(nome2)
    p.criar(perso.dono, "const dir_" + dir + "=$" + nome + txtfim(num, 3))
    p.salvar(config:progsalvar)
    msg("\bSala criada em " + dir + ": " + txt(nome, 2) + txtfim(num, 3))
    ret 1
  fimse
# Tenta criar sala com o nome especificado
  num = int(txtfim(arg0, 3)) + 1000
  nome = txt(arg0, 0, inttotal(txt(arg0)) - 3)
  se num <= 1000 || txtfim(num, 3) != txtfim(arg0, 3)
    msg("Nome de sala ou direção inválida: " + arg0)
  senao p.existe("s_" + nome + txtfim(num, 3))
    msg("Sala já existe: " + arg0)
  senao !p.existe("b_" + nome)
    msg("Área não existe: " + nome)
  senao
    p.iniclasse("b_" + nome)
    nome = txt(p.texto, 2)
    p.criar("s_" + nome + txtfim(num, 3) + "\na-" + nome + "\nherda b_" + nome)
    p.salvar(config:progsalvar)
    msg("\bSala criada: " + nome + txtfim(num, 3))
  fimse
  ret 1

func com_asala # Apagar sala
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes da sala após ASALA")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("s_" + txtsub(arg0, x, 1))
      msg("Sala não existe: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_asala
  ret 1

func p_asala # Confirmar que quer apagar sala
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("s_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    p.salvar(config:progsalvar)
    se x < 2
      msg("Sala apagada: " + tpasso)
    senao
      msg("Salas apagadas: " + tpasso)
    fimse
  senao
    txt10 m1
    passo = "asala"
    txt2(tpasso) && (m1 = "s")
    msg("Apagar sala" + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func com_esala # Editar sala
  txt100 nome
  prog p
  nome = txtmin(arg0)
  nome == "" && (nome = txt(perso.dono, 2))
  se !$s_[nome]
    msg("\bSala não existe: " + nome)
  senao
    passo = "sala"
    tpasso = $s_[nome]
    msg("Sala " + txt(tpasso, 2) + ", tecle O para saber as opções")
  fimse
  ret 1

func p_sala # Editando sala
  teditor.limpar
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  fimse
  casovar txtmin(arg0)
  casose "o"
    txtmais.limpar
    txtmais.addfim("\bSala " + txt(tpasso, 2))
    txtmais.addfim("1. Título          : " + m_linha("s_titulo"))
    txtmais.addfim("2. Descrição       : " + m_texto("s_desc"))
    txtmais.addfim("3. Terreno         : " + m_opcao("s_terreno", txt_terreno))
    txtmais.addfim("4. Luz             : " + m_opcao("s_luz", txt_luz))
    txtmais.addfim("5. Apagar itens em : " + m_numero("s_item") + " min")
    txtmais.addfim("6. Morre ao entrar : " + m_simnao("s_morre"))
    txtmais.addfim("7. Silencioso      : " + m_simnao("s_silencio"))
    txtmais.addfim("8. Sem violência   : " + m_simnao("s_pacifico"))
    txtmais.addfim("9. Sem magia       : " + m_simnao("s_semmagia"))
    txtmais.addfim("10.MOBs não entram : " + m_simnao("s_semmob"))
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casose "1"
    msg("Nome: " + m_linha("s_titulo"))
    tpasso += " s_titulo sala Título"
    ret p_linha("")
  casose "2"
    tpasso += " s_desc sala Descrição"
    ret p_texto("\n")
  casose "3"
    msg("Terreno: " + m_opcao("s_terreno", txt_terreno))
    teditor.addfim(txt_terreno)
    tpasso += " s_terreno sala Tipo de terreno"
    ret p_opcao("")
  casose "4"
    msg("Luz: " + m_opcao("s_luz", txt_luz))
    teditor.addfim(txt_luz)
    tpasso += " s_luz sala Quantidade de luz"
    ret p_opcao("")
  casose "5"
    msg("Sem jogador na sala apaga itens após: " + m_numero("s_item") + " min")
    tpasso += " s_item area Apagar itens em"
    ret p_numero("")
  casose "6"
    msg("Morre ao entrar: " + m_simnao("s_morre"))
    tpasso += " s_morre sala Morre ao entrar"
    ret p_simnao("")
  casose "7"
    msg("Silencioso: " + m_simnao("s_silencio"))
    tpasso += " s_silencio sala Silencioso"
    ret p_simnao("")
  casose "8"
    msg("Sem violência: " + m_simnao("s_pacifico"))
    tpasso += " s_pacifico sala Sem violência"
    ret p_simnao("")
  casose "9"
    msg("Sem magia: " + m_simnao("s_semmagia"))
    tpasso += " s_semmagia sala Sem magia"
    ret p_simnao("")
  casose "10"
    msg("MOBs não entram: " + m_simnao("s_semmob"))
    tpasso += " s_semmob sala Se MOBs não entram"
    ret p_simnao("")
  casose "f1"
    tpasso += " s_titulo sala Título"
    ret p_func("\n")
  casose "f2"
    tpasso += " s_desc sala Título"
    ret p_func("\n")
  casose "f3"
    tpasso += " s_terreno sala Tipo de terreno"
    ret p_func("\n")
  casose "f4"
    tpasso += " s_luz sala Quantidade de luz"
    ret p_func("\n")
  casose "f5"
    tpasso += " s_item area Apagar itens em"
    ret p_func("\n")
  casose "f6"
    tpasso += " s_morre sala Morre ao entrar"
    ret p_func("\n")
  casose "f7"
    tpasso += " s_silencio sala Silencioso"
    ret p_func("\n")
  casose "f8"
    tpasso += " s_pacifico sala Sem violência"
    ret p_func("\n")
  casose "f9"
    tpasso += " s_semmagia sala Sem magia"
    ret p_func("\n")
  casose "f10"
    tpasso += " s_semmob sala Se MOBs não entram"
    ret p_func("\n")
  casose
    msg("Opção inválida: " + arg0)
  casose ""
    passo = "sala"
    tpasso = txt1(tpasso)
    msg("Sala " + txt(tpasso, 2) + ", O opções, Z sair")
    ret 1
  casofim
  ret 1

func com_lsai # Listar saídas
  se !perso.dono
    msg("\bVocê não está em uma sala")
    ret 1
  fimse
  prog p
  txt80 dir
  txt80 lin
  dir = "n s l o ne no se so c b"
  tpasso = perso.dono
  msg("\bSaídas de " + txt(tpasso, 2) + ":")
  enquanto dir
    se p.existe(tpasso, "dir_" + txt1(dir))
      lin = txtmai(txt1(dir)) + "  "
      lin += m_sala("dir_" + txt1(dir))
      msg(lin)
    fimse
    dir = txt2(dir)
  efim
  !lin && msg("Nenhuma")
  ret 1

func com_asai # Apagar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após ASAI")
  senao !dir
    msg("\bSaída não existe: " + arg0)
  senao
    p.apagar(perso.dono, "dir_" + dir)
    p.apagar(perso.dono, "tipoini_" + dir)
    p.apagar(perso.dono, "inv_" + dir)
    p.apagar(perso.dono, "tranc_" + dir)
    p.apagar(perso.dono, "chave_" + dir)
    p.salvar(config:progsalvar)
    msg("\bSaída apagada: " + dir)
  fimse
  ret 1

func com_csai # Criar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após CSAI" + arg1)
  senao !dir
    msg("\bSaída não existe: " + txt1(arg0))
  senao !txt2(arg0)
    msg("\bDigite a sala após CSAI" + arg1 + " " + arg0)
  senao !p.existe("s_" + txt2(arg0))
    msg("\bSala não existe: " + txt2(arg0))
  senao
    p.criar(perso.dono, "const dir_" + dir + "=$s_" + txtmin(txt2(arg0)))
    se arg1
      p.criar("s_" + txt2(arg0), "const dir_" + misc:d2[dir] + "=$" + perso.dono)
      msg("\bSaída completa criada: " + dir + " para " + txtmin(txt2(arg0)))
    senao
      msg("\bSaída criada: " + dir + " para " + txtmin(txt2(arg0)))
    fimse
    p.salvar(config:progsalvar)
  fimse
  ret 1

const com_csai2 = com_csai(arg0, "2") # Criar saída completa

func com_esai # Editar saída
  prog p
  txt10 dir
  dir = misc:d1[txt1(arg0)]
  se !perso.dono
    msg("\bVocê não está em uma sala")
  senao !arg0
    msg("\bDigite a direção após ESAI")
  senao !dir
    msg("\bSaída não existe: " + arg0)
  senao !p.existe(perso.dono, "dir_" + dir)
    msg("Não existe saída na direção " + txtmai(dir))
  senao
    passo = "sai"
    opasso = dir
    tpasso = txt(perso.dono)
    dir = txtmai(dir)
    msg("Saída " + dir + " de " + txt(tpasso, 2) + ", tecle O para saber as opções")
  fimse
  ret 1

const txt_tipo = "Não há porta\nPorta aberta\nPorta fechada\nPorta trancada"
const txt_tipo2 = "Escolha: 0 Sem porta, 1 Aberto, 2 Fechado, 3 Trancado, Z Cancela"
const txt_tranc = "Normal\n\
Fecha ao passar\n\
Tranca ao fechar\n\
Tranca ao fechar ou passar"

func p_sai # Editando saída
  txt10 dir
  teditor.limpar
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  fimse
  casovar txtmin(arg0)
  casose "o"
    uint16 agora
    agora = $[txt1(tpasso)].tipo_[opasso]
    txtmais.limpar
    txtmais.addfim("\bSaída " + txtmai(opasso) + " de " + txt(tpasso, 2))
    txtmais.addfim("1. Estado inicial  : " + m_opcao("tipoini_" + opasso, txt_tipo))
    txtmais.addfim("2. Estado atual    : " + m_opcaomostra(agora, txt_tipo))
    txtmais.addfim("3. Invisível       : " + m_simnao("inv_" + opasso))
    txtmais.addfim("4. Trancar         : " + m_opcao("tranc_" + opasso, txt_tranc))
    txtmais.addfim("5. Chave           : " + m_linha("chave_" + opasso))
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casose "1"
    msg("Estado inicial: " + m_opcao("tipoini_" + opasso, txt_tipo))
    teditor.addfim(txt_tipo)
    tpasso += " tipoini_" + opasso + " saitipo Estado inicial"
    ret p_opcao("")
  casose "2"
    uint16 agora
    agora = $[tpasso].tipo_[opasso]
    msg("Estado atual: " + m_opcaomostra(agora, txt_tipo))
    ret p_saiagora("")
  casose "3"
    msg("Invisível: " + m_simnao("inv_" + opasso))
    tpasso += " inv_" + opasso + " sai Invisível"
    ret p_simnao("")
  casose "4"
    msg("Trancar: " + m_opcao("tranc_" + opasso, txt_tipo))
    teditor.addfim(txt_tranc)
    tpasso += " tranc_" + opasso + " sai Tracar"
    ret p_opcao("")
  casose "5"
    msg("Chave: " + m_linha("chave_" + opasso))
    tpasso += " chave_" + opasso + " sai Chave"
    ret p_linha("")
  casose "f1"
    tpasso += " tipoini_" + opasso + " saitipo Estado inicial"
    ret p_func("\n")
  casose "f2"
    tpasso += " tipo_" + opasso + " saitipo Estado atual"
    ret p_func("\n")
  casose "f3"
    tpasso += " inv_" + opasso + " sai Invisível"
    ret p_func("\n")
  casose "f4"
    tpasso += " tranc_" + opasso + " sai Tracar"
    ret p_func("\n")
  casose "f5"
    tpasso += " chave_" + opasso + " sai Chave"
    ret p_func("\n")
  casose
    msg("Opção inválida: " + arg0)
  casose ""
    passo = "sai"
    tpasso = txt1(tpasso)
    msg("\bSaída " + txtmai(opasso) + " de " + txt(tpasso, 2) + ", O opções, Z sair")
    ret 1
  casofim
  ret 1

func p_saitipo # Acerta a saída após mudar o tipo de saída
  ref r
  r = $[txt1(tpasso)]
  se r && r.tipo == 0 != (r.tipoini == 0)
    r.tipo = r.tipoini
  fimse
  ret p_sai("")

func p_saiagora # Mudar o estado atual
  textotxt t
  uint16 num
  t.addfim(txt_tipo), num = arg0
  se arg0 == ""
    passo = "saiagora"
    msg(txt_tipo2)
  senao arg0 == "z"
    passo = "sai"
    p_sai("")
  senao arg0 != txt(num) || num < 0 || num >= t.linhas
    msg("Entre com um número de 0 a " + (t.linhas - 1))
  senao
    $[tpasso].mudatipo(opasso, num)
# $[tpasso].tipo_[opasso] = num
    t.remove(num)
    se t.linhas
      msg("Saída mudou para: " + num + " " + t.remove(1))
    senao
      msg("Saída mudou para: " + num + " <inválido>")
    fimse
    p_sai("")
  fimse
  ret 1
