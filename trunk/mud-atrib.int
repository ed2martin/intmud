classe jog_atrib
# Funções para mudar atributos de personagens e itens

func t_atribcomum # Retorna a quantidade de atributos comuns
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt1(p.texto) != "#" && txtsub(p.texto, 1, 1) != "*=" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func t_atribatk # Retorna a quantidade de ataques
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "atktipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func t_atribdef # Retorna a quantidade de defesas
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "deftipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

const p_atribcomum = p_atrib(arg0, "atribcomum") # Editando atributos comuns
const p_atribatk = p_atrib(arg0, "atribatk") # Editando atributos de ataque
const p_atribdef = p_atrib(arg0, "atribdef") # Editando atributos de defesa

func p_atrib # Editando atributos
  uint16 linha
  linha = arg0, passo = arg1
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg0 == "n" && !var.opcvalido
    real valor.80
    p_atrib_ler(valor)
    casovar arg1
    casose "atribcomum" # Atributos comuns
      epara linha = 0, linha < p_atrib_tipo, linha += 1
        valor.[linha] = 0
      efim
      sair
    casose "atribatk" # Ataques
      linha = p_atrib_tipo + intsublin(p_atrib_atk1) * 2 - 2
      enquanto linha >= p_atrib_tipo
        valor.[linha] = 100, linha -= 2
      efim
      sair
    casose "atribdef" # Defesas
      linha = p_atrib_tipo + intsublin(p_atrib_atk1) * 2 - 1
      enquanto linha >= p_atrib_tipo
        valor.[linha] = 100, linha -= 2
      efim
      sair
    casofim
    p_atrib_salvar(valor)
    msg("Apagado: " + var.opcnome)
    passo = var.opcpasso, p_[passo]("\b")
  senao arg0 == "z"
    passo = var.opcpasso, p_[passo]("\b")
  senao txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao arg0 == "o"
    real valor.80
    p_atrib_ler(valor)
    txtmais.limpar
    txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    casovar arg1
    casose "atribcomum" # Atributos comuns
      epara t1.addfim(p_atrib_txt), linha < p_atrib_valor, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se valor.[linha]
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[linha] + "\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      epara nulo, linha < p_atrib_tipo, linha += 1
        lin = "\b\c2" + txt(linha + 1) + "\b." + t1.remove
        se valor.[linha]
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribatk" # Ataques
      int16 indice
      indice = p_atrib_tipo
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se valor.[indice] != 100
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[indice] + "%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribdef" # Defesas
      int16 indice
      indice = p_atrib_tipo + 1
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se valor.[indice] != 100
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[indice] + "%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casofim
    t2.linhas && txtmais.addfim(t2.remove(100))
    txtmostra
  senao txt(linha) != arg0
    msg("Opção inexistente: " + txt1(arg0))
  senao !linha || linha > p_atrib_tipo + intsublin(p_atrib_atk1) * 2
    msg("Opção inexistente: " + txt1(arg0))
  senao arg1 == "atribcomum" # Atributos comuns
    se !linha || linha > p_atrib_tipo
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha
    se linha < p_atrib_valor
      msg(txtsublin(p_atrib_txt, linha, 1) + ": " + valor.[linha])
      ret p_atrib2("\b")
    senao
      valor.[linha] = !valor.[linha]
      p_atrib_salvar(valor)
      txt100 lin
      lin = valor.[linha] ? "Sim" : "Não"
      msg(txtsublin(p_atrib_txt, linha, 1) + " mudou para: " + lin)
      ret 1
    fimse
  senao arg1 == "atribatk" # Atributos de ataque
    se !linha || linha > intsublin(p_atrib_atk1)
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha * 2 + p_atrib_tipo
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    msg("Danos " + nomedano + ": " + valor.[var.opclin] + "%")
    ret p_atrib2("\b")
  senao # Atributos de defesa
    se !linha || linha > intsublin(p_atrib_atk1)
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha * 2 + p_atrib_tipo + 1
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    msg("Danos " + nomedano + ": " + valor.[var.opclin] + "%")
    ret p_atrib2("\b")
  fimse
  ret 1

func p_atrib2 # Usado por p_atrib; editando um atributo
  real num
  num = arg0, passo = "atrib2"
  se arg0 == "" || arg0 == "\b"
    se var.opclin_ >= p_atrib_tipo
      msg("Entre com a porcentagem, 100=danos normais, Z cancela")
    senao
      msg("Entre com a quantidade, 0=não alterar, Z cancela")
    fimse
  senao arg0 == "z"
    p_atrib("", var.opcpasso2)
    var.opcpasso2 = "", var.opclin = ""
  senao txt(num) != arg0
    msg("Opção inválida, entre com outra")
  senao num < 0 && var.opclin_ >= p_atrib_tipo
    msg("A porcentagem não pode ser menor que zero, entre com outra")
  senao
    real valor.80
    p_atrib_ler(valor)
    valor.[var.opclin] = num
    p_atrib_salvar(valor)
    p_atrib("", var.opcpasso2)
    var.opcpasso2 = "", var.opclin = ""
  fimse
  ret 1

func p_atrib2txt # Usado internamente em p_atrib2
# arg0 e arg1 = variáveis
  ret !arg1, txt(arg0) # Exemplo: 5
  ret !arg0, txt(arg1) + "*pnivel" # Exemplo: 10*pnivel
  ret arg0 < 0, txt(arg1) + "*pnivel" + txt(arg0) # Exemplo: 10*pnivel-5
  ret txt(arg1) + "*pnivel+" + txt(arg0) # Exemplo: 10*pnivel+5

func p_atrib_ler # Extrai os atributos de uma função
# var.opcclasse e var.opcvar = nomes da classe e da função
# arg0 = variável "real valor.80"
  int32 x
  arg0.limpar(100)
  epara x = p_atrib_tipo - 1, x >= 0, x -= 1
    arg0.[x] = 0
  efim
  prog p
  epara p.inilinha(var.opcclasse, var.opcvar), p.lin, p.depois
    casovar txtsub(p.texto, 0, 2)
    casose "pvidamax +="
      p_atrib_ler2(p.texto, arg0.0, arg0.1)
      sair
    casose "pmanamax +="
      p_atrib_ler2(p.texto, arg0.2, arg0.3)
      sair
    casose "pmovemax +="
      p_atrib_ler2(p.texto, arg0.4, arg0.5)
      sair
    casose "pveloc1 +="
      p_atrib_ler2(p.texto, arg0.6, arg0.7)
      sair
    casose "atknorm +="
      p_atrib_ler2(p.texto, arg0.8, arg0.9)
      sair
    casose "defnorm +="
      p_atrib_ler2(p.texto, arg0.10, arg0.11)
      sair
    casose "atkesp +="
      p_atrib_ler2(p.texto, arg0.12, arg0.13)
      sair
    casose "defesp +="
      p_atrib_ler2(p.texto, arg0.14, arg0.15)
      sair
    casose "evasao +="
      p_atrib_ler2(p.texto, arg0.16, arg0.17)
      sair
    casose "precisao +="
      p_atrib_ler2(p.texto, arg0.18, arg0.19)
      sair
    casose "pesomax +="
      p_atrib_ler2(p.texto, arg0.20, arg0.21)
      sair
    casose "bitver ="
      x = txtsub(p.texto, 2)
      x & 2 && (arg0.22 = 1) # Visão noturna
      x & 4 && (arg0.23 = 1) # Pode ver invisível
      x & 8 && (arg0.24 = 1) # Pode ver oculto
      x & 256 && (arg0.28 = 1) # Anda em silêncio
      x & 512 && (arg0.29 = 1) # Voando ou flutuando
      sair
    casose "bitinv ="
      x = txtsub(p.texto, 2)
      x & 4 && (arg0.25 = 1) # Torna invisível
      x & 8 && (arg0.26 = 1) # Torna oculto
      x & 128 && (arg0.27 = 1) # Invisível a não admin
      sair
    casose
      se txt(p.texto, 0, 8) == "atktipo." && txtsub(p.texto, 1, 1) == "*="
        arg0.[int(txt(p.texto, 8)) * 2 + p_atrib_tipo] = 100 * txtsub(p.texto, 2)
      senao txt(p.texto, 0, 8) == "deftipo." && txtsub(p.texto, 1, 1) == "*="
        arg0.[int(txt(p.texto, 8)) * 2 + p_atrib_tipo + 1] = 100 * txtsub(p.texto, 2)
      fimse
    casofim
  efim

func p_atrib_ler2 # Usado internamente em p_atrib_ler
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  se txtsub(arg0, 3, 3) == "* pnivel -"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = -1 * txtsub(arg0, 6)
  senao txtsub(arg0, 3, 2) == "* pnivel"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = txtsub(arg0, 6)
  senao
    arg1 = txtsub(arg0, 2)

func p_atrib_salvar # Salva os atributos em função
# var.opcclasse e var.opcvar = nomes da classe e da função
# arg0 = variável "real valor.80"
  textotxt t
  t.addfim("func " + var.opcvar + " # Altera atributos do personagem")
  t.addfim("# Não alterar; função criada automaticamente")
  (arg0.0 || arg0.1) && t.addfim("pvidamax+=" + p_atrib2txt(arg0.0, arg0.1))
  (arg0.2 || arg0.3) && t.addfim("pmanamax+=" + p_atrib2txt(arg0.2, arg0.3))
  (arg0.4 || arg0.5) && t.addfim("pmovemax+=" + p_atrib2txt(arg0.4, arg0.5))
  (arg0.6 || arg0.7) && t.addfim("pveloc1+=" + p_atrib2txt(arg0.6, arg0.7))
  (arg0.8 || arg0.9) && t.addfim("atknorm+=" + p_atrib2txt(arg0.8, arg0.9))
  (arg0.10 || arg0.11) && t.addfim("defnorm+=" + p_atrib2txt(arg0.10, arg0.11))
  (arg0.12 || arg0.13) && t.addfim("atkesp+=" + p_atrib2txt(arg0.12, arg0.13))
  (arg0.14 || arg0.15) && t.addfim("defesp+=" + p_atrib2txt(arg0.14, arg0.15))
  (arg0.16 || arg0.17) && t.addfim("evasao+=" + p_atrib2txt(arg0.16, arg0.17))
  (arg0.18 || arg0.19) && t.addfim("precisao+=" + p_atrib2txt(arg0.18, arg0.19))
  (arg0.20 || arg0.21) && t.addfim("pesomax+=" + p_atrib2txt(arg0.20, arg0.21))
  se arg0.22 || arg0.23 || arg0.24 || arg0.28 || arg0.29
    int32 x
    arg0.22 && (x += 2) # Visão noturna
    arg0.23 && (x += 4) # Pode ver invisível
    arg0.24 && (x += 8) # Pode ver oculto
    arg0.28 && (x += 256) # Anda em silêncio
    arg0.29 && (x += 512) # Voando ou flutuando
    t.addfim("bitver=" + x + "|bitver")
  fimse
  se arg0.25 || arg0.26 || arg0.27
    int32 x
    arg0.25 && (x += 4) # Torna invisível
    arg0.26 && (x += 8) # Torna oculto
    arg0.27 && (x += 128) # Invisível a não admin
    t.addfim("bitinv=" + x + "|bitinv")
  fimse
  uint16 linha
  txt100 lin
  refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_tipo
  epara linha = p_atrib_tipo, linha < total, linha += 2
    continuar arg0.[linha] == 100
    refvar indice = (linha - p_atrib_tipo) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("atktipo." + indice + "*=" + arg0.[linha] / 100 + lin)
  efim
  epara linha = p_atrib_tipo + 1, linha < total, linha += 2
    continuar arg0.[linha] == 100
    refvar indice = (linha - p_atrib_tipo - 1) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("deftipo." + indice + "*=" + arg0.[linha] / 100 + lin)
  efim
# msg("----------\n" + t.ini.textolin(10000) + "\n----------")
  prog p
  se t.linhas > 2
    p.criar(var.opcclasse, t.remove(10000))
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)

const p_atrib_valor = 22 # Quantidade de opções que recebem valor numérico
const p_atrib_tipo = 30 # Quantidade de opções antes de ataque e defesa
# Depois disso vem as opções de p_atrib_atk1, e são em porcentagem
const p_atrib_txt = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Carrega (gramas)\n\
Carrega (gramas) por nível\n\
Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Torna invisível\n\
Torna oculto\n\
Invisível a não admin\n\
Anda em silêncio\n\
Está flutuando"
const p_atrib_atk1 = "Tipos Normais\nTipos Especiais\n" + config:atknomes


classe comando_identificar
herda comando_hab, jog_atrib
const posic = 8
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\nIdentifica um objeto."
const cmdmenu = "identif" # Editável via "menu_hab_identif" e "menu_magia_identif"
const tipoatk = 100 # Para não aparecer nenhum nome no tipo de habilidade
textovar var
const p_atrib_atk1 = "normais\nespeciais\n" + config:atknomes
const p_atrib_def1 = "normal\nespecial\n" + config:atknomes
const p_atrib_def2 = "ataques normais\nataques especiais\n" + config:atknomes

func escr
  ret !arg1, arg0.msg("Identificar o quê?")
  ret !checahab(arg0), nulo
  nomeobj n
  listaobj l
  n.ini(arg1, 1)
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2, arg0.dentro1)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_ident(arg0, r), nulo
    efim
# Checa se pode identificar
    arg0.pvida -= int(usavida)
    arg0.pmana -= int(usamana)
    arg0.pmove -= int(usamove)
    arg0.p_espera < 15 && (arg0.p_espera = 15)
    se rand(10) >= 2 + arg0.persobat.var.[nomevar] # Checa o quanto conhece (vai até 10)
      ret arg0.msg("Por algum motivo, a magia falhou.")
    fimse
# Identificar personagem
    textotxt t
    txt100 lin
    se r.perso
      lin = "Identificado: " + txtcopiamai(r.persobat.descnome, "A")
      se r != r.persobat
        lin += " de " + r.descnome, r = r.persobat
      fimse
      lin += ", nível " + r.pnivel
      r.tipo1 && (lin += ", " + txtcopiamai(r.tipo1, "A"))
      r.tipo2 && (lin += ", " + txtcopiamai(r.tipo2, "A"))
      r.tipo3 && (lin += ", " + txtcopiamai(r.tipo3, "A"))
      t.addfim(lin)
      r.descident && t.addfim(r.descident)
      arg0.msg(t.remove(1000))
      ret
    fimse
# Nível do item
    t.addfim("Identificando " + r.descnome + ":")
    r.nivel && t.addfim("É um objeto do nível " + r.nivel)
# Peso e valor
    refvar peso = r.pesoobj + r.pesoden
    lin = peso < 10000 ? txt(peso) + "g" : txt(peso / 1000) + "Kg"
    se !r.valor
    senao r.valor == 1
      lin += " e vale uma moeda"
    senao r.valor == 2
      lin += " e vale duas moedas"
    senao
      lin += " e vale " + r.valor + " moedas"
    fimse
    t.addfim("Isso pesa " + lin + ".")
# Se é arma
    se r.armatipo && config:atktipo
      lin = "É uma arma do tipo \"" + txtsublin(config:arma_txt, r.armatipo, 1)
      lin += "\" de ataque " + r.armamin
      r.armamin != r.armamax && (lin += " a " + r.armamax)
      lin += " e precisão " + r.armaprecisao + "."
      t.addfim(lin)
    fimse
# Aonde pode ser vestido
    se 1
      uint8 x
      int32 valor
      lin = "", valor = r.vestir1
      r.armatipo && (lin += ", empunhando")
      enquanto x < 30 && valor
        valor & 1 && (lin += ", " + txtsublin(config:equip_txt, x, 1))
        x += 1, valor = valor >> 1
      efim
      lin && t.addfim("Pode ser usado em: " + txt(lin, 2) + ".")
    fimse
# Quem não pode vestir
    se r.vestirnao
      t.addfim("Não pode ser usado por: " + txttroca(r.vestirnao, "\n", ",") + ".")
    fimse
# Diversos
    r.i_chave && t.addfim("É um tipo de chave.")
    r.i_captura && t.addfim("Pode ser usado para capturar animais.")
# Obtém os efeitos
    var.opcclasse = r
    var.opcvar = "recalc_auto"
    real valor.80
    p_atrib_ler(valor) # Extrai os atributos de uma função
# Efeitos comuns
    int8 x
    epara nulo, x < p_atrib_valor, x += 1
      continuar !valor.[x]
      lin = txtmin(txtsublin(p_atrib_txt, x, 1))
      t.addfim("Afeta " + lin + " em " + valor.[x] + ".")
    efim
    lin = ""
    epara nulo, x < p_atrib_tipo, x += 1
      continuar !valor.[x]
      lin += ", " + txtmin(txtsublin(p_atrib_txt, x, 1))
    efim
    lin && t.addfim("Propriedades:" + txt(lin, 1) + ".")
# Efeitos de ataque
    refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_tipo
    epara x = p_atrib_tipo, x < total, x += 2
      continuar valor.[x] == 100
      lin = txtsublin(p_atrib_atk1, x - p_atrib_tipo >> 1, 1)
      se valor.[x] == 0
        t.addfim("Anula ataques " + lin + ".")
      senao valor.[x] < 100
        t.addfim("Reduz ataques " + lin + " em " + int(100 - valor.[x]) + "%.")
      senao
        t.addfim("Aumenta ataques " + lin + " em " + int(valor.[x] - 100) + "%.")
      fimse
    efim
# Efeitos de defesa
    epara x = p_atrib_tipo + 1, x < total, x += 2
      continuar valor.[x] == 100
      se valor.[x] == 0
        lin = txtsublin(p_atrib_def2, x - p_atrib_tipo >> 1, 1)
        t.addfim("Torna imune a " + lin + ".")
      senao valor.[x] < 100
        lin = txtsublin(p_atrib_def1, x - p_atrib_tipo >> 1, 1)
        t.addfim("Melhora defesa " + lin + " em " + int(10000 / valor.[x] - 100) + "%.")
      senao
        lin = txtsublin(p_atrib_def1, x - p_atrib_tipo >> 1, 1)
        t.addfim("Piora defesa " + lin + " em " + int(100 - 10000 / valor.[x]) + "%.")
      fimse
    efim
# Identificação
    r.descident && t.addfim(r.descident)
# Envia mensagem
    arg0.msg2(t.remove(1000))
    arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
    ret
  efim
  arg0.msg("Você não vê isso.")


classe menu_hab_identif
herda menu_magia_identif
const titulo = "Hab Identificar"


classe menu_magia_identif
herda menu_hab_comum
const titulo = "Magia Identificar"
const colunas = 23


classe comando_curar
herda comando_hab
const posic = 7
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\nCura um personagem."
const cmdmenu = "curar" # Editável via "menu_hab_curar" e "menu_magia_curar"
const tipoatk = 100 # Para não aparecer nenhum nome no tipo de habilidade
const msgacertou1 = "$R se cura"
const msgnulo1 = "$R tenta se curar"
const msgacertou2 = "$R cura $c"
const msgnulo2 = "$R tenta curar $c"

func escr
  ret !checahab(arg0), nulo
# Obtém o personagem que será curado
  ref r
  r = arg0
  se arg1
    nomeobj n
    listaobj l
    n.ini(arg1, 1)
    l.addfim(arg0.dono.dentro2)
    epara nulo, l, l.ini.remove
      sair l.objini.visivel(arg0) && n.nome(l.objini.ident, l.objini.objtot)
    efim
    r = l.objini
  fimse
# Eventos
  l.limpar
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_curar(arg0, r), nulo
  efim
# Checa se pode curar
  ret !r, arg0.msg("Você não vê isso.")
  arg0.pvida -= int(usavida)
  arg0.pmana -= int(usamana)
  arg0.pmove -= int(usamove)
  arg0.p_espera < 15 && (arg0.p_espera = 15)
# Cura
  uint32 valor # O quanto vai curar
  refvar maximo = r.persobat.pvidamax - r.persobat.pvida # Até quanto pode curar
  se maximo > 0
    valor = 2 + arg0.persobat.var.[nomevar]
    valor = (curabase + arg0.pnivel * curanivel) * valor / 10
    valor < 1 && (valor = 1) # Garante um ponto de cura
    curamax && valor > curamax && (valor = curamax) # Não pode passar de curamax
    valor > maximo && (valor = maximo) # Não pode passar dos pontos de vida máximos
    r.persobat.pvida += valor
  fimse
  $mens.p(arg0, r)
  se r == arg0
    $mens.mtodos1(valor ? msgacertou1 + ", " + valor : msgnulo1)
  senao
    $mens.mtodos1(valor ? msgacertou2 + ", " + valor : msgnulo2)
  fimse
  arg0.acertapos(1) # Porque os pontos de vida podem ter mudado


classe menu_hab_curar
herda menu_magia_curar
const titulo = "Hab de cura " + txt(var.classe1, 4)


classe menu_magia_curar
herda menu_hab_comum
const titulo = "Magia de cura " + txt(var.classe1, 6)
const colunas = 23
#
const nome1 = "Pontos de cura"
const info1 = "Quantos pontos de vida cura no nível perito"
const tipo1 = "numero"
const clas1 = var.classe1
const vari1 = "curabase"
#
const nome2 = "Cura por nível"
const info2 = "Quantos pontos de vida cura no nível perito, para cada nível do personagem"
const tipo2 = "numreal"
const clas2 = var.classe1
const vari2 = "curanivel"
#
const nome3 = "Cura máxima"
const info3 = "Até quantos pontos de vida pode curar; ou 0 se não há limite"
const tipo3 = "numero"
const clas3 = var.classe1
const vari3 = "curamax"
#
const nome10 = "Msg curou perso"
const tipo10 = "linha"
const clas10 = var.classe1
const vari10 = "msgacertou2"
#
const nome11 = "Msg não curou"
const tipo11 = "linha"
const clas11 = var.classe1
const vari11 = "msgnulo2"
#
const nome12 = "Msg se curou"
const tipo12 = "linha"
const clas12 = var.classe1
const vari12 = "msgacertou1"
#
const nome13 = "Msg não se curou"
const tipo13 = "linha"
const clas13 = var.classe1
const vari13 = "msgnulo1"
