classe adm_atrib
# Funções para mudar atributos de personagens e itens

func t_atribnum # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txtsub(p.texto, 1, 1) == "+=" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func t_atribbit # Retorna a quantidade de atributos sim/não
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 3) == "bit" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func t_atribatk # Retorna a quantidade de ataques
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "atktipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func t_atribdef # Retorna a quantidade de defesas
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "deftipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

const p_atribnum = p_atrib(arg0, "atribnum") # Editando atributos numéricos
const p_atribbit = p_atrib(arg0, "atribbit") # Editando atributos sim/não
const p_atribatk = p_atrib(arg0, "atribatk") # Editando atributos de ataque
const p_atribdef = p_atrib(arg0, "atribdef") # Editando atributos de defesa

func p_atrib # Editando atributos
  uint16 linha
  linha = arg0, passo = arg1
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg0 == "n" && !var.opcvalido
    real2 valor.80
    p_atrib_ler(valor)
    casovar arg1
    casose "atribnum" # Atributos numéricos
      epara linha = 0, linha < p_atrib_bit, linha += 1
        valor.[linha] = 0
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara linha = p_atrib_bit, linha < p_atrib_atk, linha += 1
        valor.[linha] = 0
      efim
      sair
    casose "atribatk" # Ataques
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 2
      enquanto linha >= p_atrib_atk
        valor.[linha] = 100, linha -= 2
      efim
      sair
    casose "atribdef" # Defesas
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 1
      enquanto linha >= p_atrib_atk
        valor.[linha] = 100, linha -= 2
      efim
      sair
    casofim
    p_atrib_salvar(valor)
    msg("Apagado: " + var.opcnome)
    passo = var.opcpasso, p_[passo]("\b")
  senao arg0 == "z"
    passo = var.opcpasso, p_[passo]("\b")
  senao txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao arg0 == "o"
    real2 valor.80
    p_atrib_ler(valor)
    txtmais.limpar
    txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    casovar arg1
    casose "atribnum" # Atributos numéricos
      epara t1.addfim(p_atrib_txtnum), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se valor.[linha]
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[linha] + "\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara t1.addfim(p_atrib_txtbit), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se valor.[linha + p_atrib_bit]
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribatk" # Ataques
      int16 indice
      indice = p_atrib_atk
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se valor.[indice] != 100
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[indice] + "%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribdef" # Defesas
      int16 indice
      indice = p_atrib_atk + 1
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se valor.[indice] != 100
          txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + valor.[indice] + "%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casofim
    t2.linhas && txtmais.addfim(t2.remove(100))
    txtmostra
  senao txt(linha) != arg0
    msg("Opção inexistente: " + txt1(arg0))
  senao !linha || linha > p_atrib_atk + intsublin(p_atrib_atk1) * 2
    msg("Opção inexistente: " + txt1(arg0))
  senao arg1 == "atribnum" # Atributos numéricos
    se !linha || linha > p_atrib_bit
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real2 valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha
    msg(txtsublin(p_atrib_txtnum, linha, 1) + ": " + valor.[linha])
    ret p_atrib2("\b")
  senao arg1 == "atribbit" # Atributos sim/não
    se !linha || linha > p_atrib_atk - p_atrib_bit
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real2 valor.80
    p_atrib_ler(valor)
    linha += p_atrib_bit - 1
    valor.[linha] = !valor.[linha]
    p_atrib_salvar(valor)
    refvar lin = valor.[linha] ? "Sim" : "Não"
    msg(txtsublin(p_atrib_txtbit, linha - p_atrib_bit, 1) + " mudou para: " + lin)
    ret 1
  senao arg1 == "atribatk" # Atributos de ataque
    se !linha || linha > intsublin(p_atrib_atk1)
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real2 valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha * 2 + p_atrib_atk
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    msg("Danos " + nomedano + ": " + valor.[var.opclin] + "%")
    ret p_atrib2("\b")
  senao # Atributos de defesa
    se !linha || linha > intsublin(p_atrib_atk1)
      msg("Opção inexistente: " + txt1(arg0))
      ret 1
    fimse
    real2 valor.80
    p_atrib_ler(valor)
    linha -= 1
    var.opcpasso2 = arg1
    var.opclin = linha * 2 + p_atrib_atk + 1
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    msg("Danos " + nomedano + ": " + valor.[var.opclin] + "%")
    ret p_atrib2("\b")
  fimse
  ret 1

func p_atrib2 # Usado por p_atrib; editando um atributo
  real2 num
  num = arg0, passo = "atrib2"
  se arg0 == "" || arg0 == "\b"
    se var.opclin_ >= p_atrib_atk
      msg("Entre com a porcentagem, 100=danos normais, Z cancela")
    senao
      msg("Entre com a quantidade, 0=não alterar, Z cancela")
    fimse
  senao arg0 == "z"
    p_atrib("", var.opcpasso2)
    var.opcpasso2 = "", var.opclin = ""
  senao txt(num) != arg0
    msg("Opção inválida, entre com outra")
  senao num < 0 && var.opclin_ >= p_atrib_atk
    msg("A porcentagem não pode ser menor que zero, entre com outra")
  senao
    real2 valor.80
    p_atrib_ler(valor)
    valor.[var.opclin] = num
    p_atrib_salvar(valor)
    p_atrib("", var.opcpasso2)
    var.opcpasso2 = "", var.opclin = ""
  fimse
  ret 1

func p_atrib2txt # Usado internamente em p_atrib2
# arg0 e arg1 = variáveis
  ret !arg1, txt(arg0) # Exemplo: 5
  ret !arg0, txt(arg1) + "*pnivel" # Exemplo: 10*pnivel
  ret arg0 < 0, txt(arg1) + "*pnivel" + txt(arg0) # Exemplo: 10*pnivel-5
  ret txt(arg1) + "*pnivel+" + txt(arg0) # Exemplo: 10*pnivel+5

func p_atrib_ler # Extrai os atributos de uma função
# var.opcclasse e var.opcvar = nomes da classe e da função
# arg0 = variável "real2 valor.80"
  int32 x
  arg0.limpar(100)
  epara x = p_atrib_atk - 1, x >= 0, x -= 1
    arg0.[x] = 0
  efim
  prog p
  epara p.inilinha(var.opcclasse, var.opcvar), p.lin, p.depois
    casovar txtsub(p.texto, 0, 2)
    casose "pvidamax +="
      p_atrib_ler2(p.texto, arg0.0, arg0.1)
      sair
    casose "pmanamax +="
      p_atrib_ler2(p.texto, arg0.2, arg0.3)
      sair
    casose "pmovemax +="
      p_atrib_ler2(p.texto, arg0.4, arg0.5)
      sair
    casose "pveloc1 +="
      p_atrib_ler2(p.texto, arg0.6, arg0.7)
      sair
    casose "atknorm +="
      p_atrib_ler2(p.texto, arg0.8, arg0.9)
      sair
    casose "defnorm +="
      p_atrib_ler2(p.texto, arg0.10, arg0.11)
      sair
    casose "atkesp +="
      p_atrib_ler2(p.texto, arg0.12, arg0.13)
      sair
    casose "defesp +="
      p_atrib_ler2(p.texto, arg0.14, arg0.15)
      sair
    casose "evasao +="
      p_atrib_ler2(p.texto, arg0.16, arg0.17)
      sair
    casose "precisao +="
      p_atrib_ler2(p.texto, arg0.18, arg0.19)
      sair
    casose "pesomax +="
      p_atrib_ler2(p.texto, arg0.20, arg0.21)
      sair
    casose "bitver ="
    casose "bitver &="
    casose "bitver |="
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        x = txt(txtsub(p.texto, 2), 1)
        x & 1 && (arg0.29 = 1) # Está cego
        x & 16 && (arg0.26 = 1) # Não pode ver voando
        x & 32 && (arg0.28 = 1) # Não pode ver voando alto
      senao
        x = txtsub(p.texto, 2)
        x & 2 && (arg0.22 = 1) # Visão noturna
        x & 4 && (arg0.23 = 1) # Pode ver invisível
        x & 8 && (arg0.24 = 1) # Pode ver oculto
        x & 16 && (arg0.25 = 1) # Pode ver voando
        x & 32 && (arg0.27 = 1) # Pode ver voando alto
        x & 256 && (arg0.34 = 1) # Anda em silêncio
        x & 512 && (arg0.35 = 1) # Voando ou flutuando
        x & 1024 && (arg0.38 = 1) # Dormindo
        x & 2048 && (arg0.39 = 1) # Imune a dormir
      fimse
      sair
    casose "bitinv ="
    casose "bitinv &="
    casose "bitinv |="
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        arg0.33 = 1 # Visível no escuro
      senao
        x = txtsub(p.texto, 2)
        x & 4 && (arg0.30 = 1) # Torna invisível
        x & 8 && (arg0.31 = 1) # Torna oculto
        x & 16 && (arg0.36 = 1) # Voando
        x & 32 && (arg0.37 = 1) # Voando alto
        x & 128 && (arg0.32 = 1) # Invisível a não admin
      fimse
      sair
    casose
      se txt(p.texto, 0, 8) == "atktipo." && txtsub(p.texto, 1, 1) == "*="
        arg0.[int(txt(p.texto, 8)) * 2 + p_atrib_atk] = 100 * txtsub(p.texto, 2)
      senao txt(p.texto, 0, 8) == "deftipo." && txtsub(p.texto, 1, 1) == "*="
        arg0.[int(txt(p.texto, 8)) * 2 + p_atrib_atk + 1] = 100 * txtsub(p.texto, 2)
      fimse
    casofim
  efim

func p_atrib_ler2 # Usado internamente em p_atrib_ler
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  se txtsub(arg0, 3, 3) == "* pnivel -"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = -1 * txtsub(arg0, 6)
  senao txtsub(arg0, 3, 2) == "* pnivel"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = txtsub(arg0, 6)
  senao
    arg1 = txtsub(arg0, 2)

func p_atrib_salvar # Salva os atributos em função
# var.opcclasse e var.opcvar = nomes da classe e da função
# arg0 = variável "real2 valor.80"
  textotxt t
  t.addfim("func " + var.opcvar + " # Altera atributos do personagem")
  t.addfim("# Não alterar; função criada automaticamente")
  (arg0.0 || arg0.1) && t.addfim("pvidamax+=" + p_atrib2txt(arg0.0, arg0.1))
  (arg0.2 || arg0.3) && t.addfim("pmanamax+=" + p_atrib2txt(arg0.2, arg0.3))
  (arg0.4 || arg0.5) && t.addfim("pmovemax+=" + p_atrib2txt(arg0.4, arg0.5))
  (arg0.6 || arg0.7) && t.addfim("pveloc1+=" + p_atrib2txt(arg0.6, arg0.7))
  (arg0.8 || arg0.9) && t.addfim("atknorm+=" + p_atrib2txt(arg0.8, arg0.9))
  (arg0.10 || arg0.11) && t.addfim("defnorm+=" + p_atrib2txt(arg0.10, arg0.11))
  (arg0.12 || arg0.13) && t.addfim("atkesp+=" + p_atrib2txt(arg0.12, arg0.13))
  (arg0.14 || arg0.15) && t.addfim("defesp+=" + p_atrib2txt(arg0.14, arg0.15))
  (arg0.16 || arg0.17) && t.addfim("evasao+=" + p_atrib2txt(arg0.16, arg0.17))
  (arg0.18 || arg0.19) && t.addfim("precisao+=" + p_atrib2txt(arg0.18, arg0.19))
  (arg0.20 || arg0.21) && t.addfim("pesomax+=" + p_atrib2txt(arg0.20, arg0.21))
  arg0.33 && t.addfim("bitinv &= ~2") # Visível no escuro
  se 1
    int32 x
    arg0.26 && (x += 16) # Não pode ver voando
    arg0.28 && (x += 32) # Não pode ver voando alto
    arg0.29 && (x += 1) # Está cego
    x && t.addfim("bitver&=~" + x)
    x = 0
    arg0.22 && (x += 2) # Visão noturna
    arg0.23 && (x += 4) # Pode ver invisível
    arg0.24 && (x += 8) # Pode ver oculto
    arg0.25 && (x += 16) # Pode ver voando
    arg0.27 && (x += 32) # Pode ver voando alto
    arg0.34 && (x += 256) # Anda em silêncio
    arg0.35 && (x += 512) # Voando ou flutuando
    arg0.38 && (x += 1024) # Dormindo
    arg0.39 && (x += 2048) # Imune a dormir
    x && t.addfim("bitver|=" + x)
    x = 0
    arg0.30 && (x += 4) # Torna invisível
    arg0.31 && (x += 8) # Torna oculto
    arg0.36 && (x += 16) # Voando
    arg0.37 && (x += 32) # Voando alto
    arg0.32 && (x += 128) # Invisível a não admin
    x && t.addfim("bitinv|=" + x)
  fimse
  uint16 linha
  txt100 lin
  refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_atk
  epara linha = p_atrib_atk, linha < total, linha += 2
    continuar arg0.[linha] == 100
    refvar indice = (linha - p_atrib_atk) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("atktipo." + indice + "*=" + arg0.[linha] / 100 + lin)
  efim
  epara linha = p_atrib_atk + 1, linha < total, linha += 2
    continuar arg0.[linha] == 100
    refvar indice = (linha - p_atrib_atk - 1) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("deftipo." + indice + "*=" + arg0.[linha] / 100 + lin)
  efim
# msg("----------\n" + t.ini.textolin(10000) + "\n----------")
  prog p
  se t.linhas > 2
    p.criar(var.opcclasse, t.remove(10000))
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)

const p_atrib_bit = 22 # A partir de que opção começam atributos de bit
const p_atrib_atk = 40 # A partir de que opção começam atributos de ataque/defesa
# Depois disso vem as opções de p_atrib_atk1, e são em porcentagem
#
const p_atrib_txtnum = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Carrega (gramas)\n\
Carrega (gramas) por nível"
#
const p_atrib_txtbit = "Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Pode ver voando\n\
Não pode ver voando\n\
Pode ver voando alto\n\
Não pode ver voando alto\n\
Está cego\n\
Torna invisível\n\
Torna oculto\n\
Invisível a não admin\n\
Visível no escuro\n\
Anda em silêncio\n\
Está flutuando\n\
Está voando\n\
Está voando alto\n\
Está dormindo\n\
Imune a dormir"
#
const p_atrib_atk1 = "Tipos Normais\nTipos Especiais\n" + config:atknomes


classe comando_identificar
herda comando_hab, adm_atrib
const posic = 8
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\nIdentifica um objeto."
const cmdmenu = "identif" # Editável via "menu_hab_identif" e "menu_magia_identif"
const tipoalvo = 4 # Não agressivo
const c_espera = 15 # Tempo de esperar após usar esse comando
textovar var
const p_atrib_atk1 = "normais\nespeciais\n" + config:atknomes
const p_atrib_def1 = "normal\nespecial\n" + config:atknomes
const p_atrib_def2 = "ataques normais\nataques especiais\n" + config:atknomes

func escr
  ret !arg1, arg0.msg("Identificar o quê?")
  ret !checahab(arg0.persobat), nulo
  nomeobj n
  listaobj l
  n.ini(arg1, 1)
  l.addfim(arg0.dono.dentro1, arg0.dono.dentro2, arg0.dentro1)
  epara nulo, l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_ident(arg0, r), nulo
    efim
# Checa se pode identificar
    custohab(arg0.persobat)
    msgini && $mens.p(arg0, nulo, r) + $mens.mtodos1(msgini)
    arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
    ret rand(100) >= precisao, arg0.msg("Por algum motivo, a magia falhou.")
# Identificar personagem
    textotxt t
    txt100 lin
    se r.perso
      lin = "Identificado: " + txtcopiamai(r.persobat.descnome, "A")
      se r != r.persobat
        lin += " de " + r.descnome, r = r.persobat
      fimse
      lin += ", nível " + r.pnivel
      r.tipo1 && (lin += ", " + txtcopiamai(r.tipo1, "A"))
      r.tipo2 && (lin += ", " + txtcopiamai(r.tipo2, "A"))
      r.tipo3 && (lin += ", " + txtcopiamai(r.tipo3, "A"))
      t.addfim(lin)
      r.descident && t.addfim(r.descident)
      arg0.msg(t.remove(1000))
      ret
    fimse
# Nível do item
    t.addfim("Identificando " + r.descnome + ":")
    r.nivel && t.addfim("É um objeto do nível " + r.nivel)
# Peso e valor
    refvar peso = r.pesoobj + r.pesoden
    lin = peso < 10000 ? txt(peso) + "g" : txt(peso / 1000) + "Kg"
    se !r.valor
    senao r.valor == 1
      lin += " e vale uma moeda"
    senao r.valor == 2
      lin += " e vale duas moedas"
    senao
      lin += " e vale " + r.valor + " moedas"
    fimse
    t.addfim("Isso pesa " + lin + ".")
# Se é arma
    se r.armatipo && config:atktipo
      lin = "É uma arma do tipo \"" + txtsublin(config:arma_txt, r.armatipo, 1)
      lin += "\" de ataque " + r.armamin
      r.armamin != r.armamax && (lin += " a " + r.armamax)
      lin += " e precisão " + r.armaprecisao + "."
      t.addfim(lin)
    fimse
# Aonde pode ser vestido
    se 1
      uint8 x
      int32 valor
      lin = "", valor = r.vestir1
      r.armatipo && (lin += ", empunhando")
      enquanto x < 30 && valor
        valor & 1 && (lin += ", " + txtsublin(config:equip_txt, x, 1))
        x += 1, valor = valor >> 1
      efim
      lin && t.addfim("Pode ser usado em: " + txt(lin, 2) + ".")
    fimse
# Quem não pode vestir
    se r.vestirnao
      t.addfim("Não pode ser usado por: " + txttroca(r.vestirnao, "\n", ",") + ".")
    fimse
# Diversos
    r.i_chave && t.addfim("É um tipo de chave.")
    r.i_captura && t.addfim("Pode ser usado para capturar animais.")
# Obtém os efeitos
    var.opcclasse = r
    var.opcvar = "recalc_auto"
    real2 valor.80
    p_atrib_ler(valor) # Extrai os atributos de uma função
# Efeitos numéricos
    int8 x
    epara nulo, x < p_atrib_bit, x += 1
      continuar !valor.[x]
      lin = txtmin(txtsublin(p_atrib_txtnum, x, 1))
      t.addfim("Afeta " + lin + " em " + valor.[x] + ".")
    efim
# Efeitos sim/não
    lin = ""
    epara nulo, x < p_atrib_atk, x += 1
      continuar !valor.[x]
      lin += ", " + txtmin(txtsublin(p_atrib_txtbit, x - p_atrib_bit, 1))
    efim
    lin && t.addfim("Propriedades:" + txt(lin, 1) + ".")
# Efeitos de ataque
    refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_atk
    epara x = p_atrib_atk, x < total, x += 2
      continuar valor.[x] == 100
      lin = txtsublin(p_atrib_atk1, x - p_atrib_atk >> 1, 1)
      se valor.[x] == 0
        t.addfim("Anula ataques " + lin + ".")
      senao valor.[x] < 100
        t.addfim("Reduz ataques " + lin + " em " + int(100 - valor.[x]) + "%.")
      senao
        t.addfim("Aumenta ataques " + lin + " em " + int(valor.[x] - 100) + "%.")
      fimse
    efim
# Efeitos de defesa
    epara x = p_atrib_atk + 1, x < total, x += 2
      continuar valor.[x] == 100
      se valor.[x] == 0
        lin = txtsublin(p_atrib_def2, x - p_atrib_atk >> 1, 1)
        t.addfim("Torna imune a " + lin + ".")
      senao valor.[x] < 100
        lin = txtsublin(p_atrib_def1, x - p_atrib_atk >> 1, 1)
        t.addfim("Melhora defesa " + lin + " em " + int(10000 / valor.[x] - 100) + "%.")
      senao
        lin = txtsublin(p_atrib_def1, x - p_atrib_atk >> 1, 1)
        t.addfim("Piora defesa " + lin + " em " + int(100 - 10000 / valor.[x]) + "%.")
      fimse
    efim
# Identificação
    r.descident && t.addfim(r.descident)
# Envia mensagem
    arg0.msg2(t.remove(1000))
    arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
    ret
  efim
  arg0.msg("Você não vê isso.")


classe menu_hab_identif
herda menu_magia_identif
const titulo = "Hab Identificar"


classe menu_magia_identif
herda menu_hab_comum
const titulo = "Magia Identificar"
const colunas = 23
