classe jogcomum
listaobj jog # Lista de jogadores conectados (objetos jogsock e derivados)
int1 luz # Se tem luz do dia
int8 hora # Hora MUD (1 dia MUD = 2 horas)
inttempo imin # Quantos segundos faltam para completar 1 hora MUD

func iniclasse
  criar(arg0)

func ini
  hora = 23
  imin_exec

func imin_exec
  imin = 3000 # 60 minutos * 60 segundos * 10 décimos / 12
  hora = (hora + 1) % 24
  luz = (t_hora >= 6 && t_hora < 18)

func min # Retorna os minutos no horário MUD
  uint8 num
  num = 60 - imin / 50
  num >= 60 && (num = 59)
  ret num


classe jogsock
herda jog_entra, jog_adm, jog_admcod, jog_admsala
# Comunicação com o jogador
# Funções predefinidas:
# ini = objeto foi criado
# fim = objeto está sendo apagado
# info = tipo (l=local, t=telnet, p=papovox, b=bot) + espaço + extra
# sendo que extra pode ser o endereço IP ou o nome da sala
# msg(texto) = envia mensagem para jogador
# msgsala(texto) = envia mensagem para todos da sala
# msgtodos(texto) = envia mensagem para todos os jogadores
# recebe(texto) = executado sempre que receber mensagem do jogador
#
ref perso # Personagem controlado pelo jogador
indiceobj cnome # "un " + nome codificado
txt20 nome # Nome do personagem
inttempo vazio # Tempo sem comunicação para desconectar do MUD
textotxt txtmais # Texto do tecle M para mais
const admin = 1 # Se é administrador
uint8 canais # Canais: +1 se recebe pvt, +2 se recebe chat
#
txt20 passo # Passo atual; "" se estiver jogando
txt100 tpasso # Texto usado no passo atual
txt100 opasso # Outras opções usadas no passo atual
txt100 tclasse # Nome da classe escolhida para editar o código
textotxt teditor # Texto usado no editor
textotxt transf # Área de transferência do editor
textopos leditor1 # Início de bloco
textopos leditor2 # Fim de bloco
textopos leditor # Linha atual no editor
txt512 peditor # Texto sendo procurado, opção P do editor

func ini
  reinicia
  $jogcomum.jog.addfim1(este)

func fim
  perso.fechou
  mudaperso(nulo)

func mudaperso # Muda o personagem, arg0=novo personagem
  se perso != arg0
    perso.mudajog(-1)
    perso.sock = nulo
    perso = ref(arg0)
    perso.mudajog(1)
    perso.sock = este

func reinicia # Volta ao início: pede o nome do personagem
  mudaperso(nulo)
  cnome = "", nome = "", senha = ""
  p_perso

func recebe # Recebeu mensagem do jogador
# Checa tempo para sair
  temposair
# Teclar M para mais
  se arg0 == "m" && txtmais.linhas
    txtmostra
    ret
  fimse
# Passo atual / executa comando
  txtmais.limpar
  se !p_[passo](arg0) # Se não for uma função do passo
    se !admin || !com_[txt1(arg0)](txt2(arg0)) # Se não for comando de administração
      perso.teclou(arg0) # Personagem processa comando

func temposair # Acerta variáveis de tempo para sair do MUD
  casovar txt1(info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    perso.vazio1 = 4800 # 8 minutos
    perso.vazio2 = 6000 # 10 minutos
    vazio = 6000
    sair
  casose # Rodando como bot ou independente
    perso.vazio1 = perso.vazio2 = vazio = 0 # Não desconectar
  casofim

func msg2 # Mensagem grande para o jogador
  txtmais.limpar
  txtmais.addfim(arg0)
  txtmostra

func txtmostra # Mostra próximo bloco de txtmais
  se txtmais.linhas <= 10
    msg(txtmais.remove(10))
  senao
    msg(txtmais.remove(9))
    msg("Tecle M para mais")

func vazio_exec
  msg("Muito tempo sem comunicação")
  apagar(este)


classe jog_entra
# Entrando no jogo

func p_perso # Digitar o nome do personagem
  indiceitem ind
  txt20 texto
  arqsav sav1
  passo = "perso", tpasso = ""
  texto = txtnome(arg0)
  se !arg0
    msg("Digite o nome do seu personagem")
  senao inttotal(arg0) < 3 || inttotal(arg0) > 16
    msg("O nome deve ter de 3 a 16 caracteres; digite outro")
  senao intnome(arg0) || txtproc(arg0, " ") >= 0
    msg("Nome inválido; digite outro")
  senao ind.obj("un " + texto)
    msg("Nome já está sendo usado; digite outro")
  senao !sav1.existe("jog-" + texto + ".sav") # Novo personagem
    cnome = "un " + texto
    nome = txtmaimin(arg0)
    msg("Criando personagem " + nome)
    p_sexo
  senao
    tpasso = txtmaimin(arg0)
    p_senha
  fimse
  ret 1

func p_sexo # Digitar O ou A
  passo = "sexo"
  se arg0 != "O" && arg0 != "A"
    msg("Você é homem ou mulher? Tecle O ou A")
    ret 1
  fimse
  passo = ""
  canais = 255 # Habilita todos os canais
  msg("Iniciando jogo; para ajuda tecle AJUDA")
  mudaperso(criar("jogador"))
  perso.cnome = "pn " + txt2(cnome)
  perso.nome = nome
  arg0 == "O" && (perso.sexo = 1)
  perso.canais = canais
  perso.mudasala(config:salaini)
  $mens.p(perso)
  $mens.mvis2("", "$P chegou.")
  temposair # Acerta tempo para sair do MUD
  ret 1

func p_senha # Entrar com a senha para carregar jogo salvo
  indiceitem ind
  txt20 texto
  arqsav sav1
  ref r
#msg(texto + " , " + arg0)
  texto = txtnome(tpasso)
  passo = "senha"
  se !arg0
    msg("Digite a senha do personagem ou z para desistir")
  senao arg0 == "z"
    nome = "", p_perso
  senao ind.obj("un " + texto)
    msg("Outro usuário começou a usar esse personagem")
    p_perso
  senao !sav1.senha("jog-" + texto + ".sav", txtmin(arg0))
    msg("Senha incorreta; digite outra ou z para desistir")
  senao ind.obj("pn " + texto)
    cnome = "un " + texto
    nome = tpasso
    passo = ""
    mudaperso(ind.obj("pn " + texto))
    msg("Reconectado")
    perso.teclou("ver")
    temposair # Acerta tempo para sair do MUD
  senao
    # Primeiro cria personagem
    cnome = "un " + texto
    nome = tpasso
    passo = ""
    mudaperso(criar("jogador"))
    perso.cnome = "pn " + texto
    perso.nome = nome
    perso.senha = txtmin(arg0)
    # Carrega personagem
    listaobj l1
    l1.addfim(perso)
    sav1.ler("jog-" + texto + ".sav", l1)
    # Acerta nome, checa se nome codificado bate
    se txtnome(perso.nome) != texto
      perso.nome = nome
    senao
      nome = perso.nome
    fimse
    # Acerta variáveis
    canais = perso.canais
    msg("Continuando jogo salvo.")
    perso.mudasala($[perso.salanome])
    !perso.dono && perso.mudasala(config:salaini)
    $mens.p(arg0)
    $mens.mvis2("", "$P chegou.")
    perso.salvarev = 3000 # 5 minutos
    temposair # Acerta tempo para sair do MUD
  fimse
  ret 1

func p_senha1 # Digitar a senha atual para mudar a senha
  passo = "senha1"
  se !arg0
    msg("Digite a senha atual do personagem ou z para desistir")
  senao arg0 == "z"
    passo = ""
    msg("Cancelado")
  senao arg0 != senha
    msg("Senha incorreta; cancelado")
    passo = ""
  senao
    p_senha2
  fimse
  ret 1

func p_senha2 # Digitar a nova senha
  passo = "senha2"
  se !arg0
    msg("Digite a nova senha do personagem ou z para desistir")
  senao arg0 == "z"
    passo = ""
    msg("Cancelado")
  senao inttotal(arg0) < 5 || inttotal(arg0) > 16
    msg("A senha deve ter de 5 a 16 caracteres, digite outra")
  senao intsenha(arg0) == 3
    msg("Senha deve ter letras e números, digite outra")
  senao intsenha(arg0)
    msg("Senha inválida, digite outras")
  senao
    tpasso = arg0
    p_senha3
  fimse
  ret 1

func p_senha3 # Repetir a senha digitada
  passo = "senha3"
  se !arg0
    msg("Digite novamente a senha")
  senao tpasso != arg0
    msg("As senhas são diferentes; cancelado")
    passo = ""
  senao
    perso.senha = txtmin(arg0)
    se perso.salvar
      msg("Jogo salvo")
    senao
      msg("Não foi possível salvar")
    fimse
    passo = ""
  fimse
  ret 1


classe jogador
herda comum_perso
# Personagem no jogo
const jog = 1 # Para identificar que é jogador
const ident = nome
indiceobj cnome # "pn " + nome codificado (usado ao reconectar)
sav txt20 nome # Nome do personagem
sav txt40 salanome # Nome da sala
sav int1 sexo # Sexo: 0=feminino, 1=masculino
sav uint8 canais # Para salvar sock.canais
inttempo salaev # Para gerar eventos "entrou" na sala
uint32 salaev2 # salaev2-salaev = Quanto tempo faz que entrou na sala
textovar lvar # Lista de variáveis não salvas no jogo
sav textovar svar # Lista de variáveis que são salvas no jogo
inttempo vazio1 # Tempo para mensagem que vai sair do MUD
inttempo vazio2 # Tempo sem comunicação para desconectar do MUD
txt20 senha # Senha do jogo salvo, ou "" se não estiver salvo
inttempo salvarev # Para salvar o jogo de tempos em tempos

func ini # Objeto foi criado
  nivel = 1
  perso:ini

func fim # Objeto foi apagado
  salvar
  se posicao
    $mens.p(este)
    $mens.mvis2("", "$P foi embora.")
  fimse
  perso:fim

func fechou # Executado quando o objeto sock é apagado
  vazio1 = 1800 # 3 minutos
  vazio2 = 2400 # 4 minutos
  se senha == ""
    apagar(este)

func mudasenha # Usuário escolhe mudar a senha ou salvar pela primeira vez
  se senha
    sock.p_senha1
  senao
    sock.p_senha2

func salvar # Salva o jogo, desde que a senha não seja nula
# Retorna verdadeiro se conseguiu salvar
  se senha
    arqsav sav1
    listaobj l0
    l0.addfim(este)
    salanome = dono
    sock && (canais = sock.canais)
    salvarev = 3000 # 5 minutos
  #msg(txt2(cnome) + " , " + senha)
    ret sav1.salvar("jog-" + txt2(cnome) + ".sav", l0, 30, senha)

func mudasala # Coloca personagem em outra sala (arg0 = sala)
  dono = arg0
  salaev = salaev2 = 1
  sock && msg2(dono.descsala(este, 7))
  dono.entrou(este)

func salaev_exec # Executa eventos entrou
  prog p
  uint32 x
  uint32 v
  x = 1000000, p.inifunc(dono, "entrou")
  enquanto p.lin
    v = txt(p.texto, 6)
    v > salaev2 && v < x && (x = v)
    p.depois
  efim
  v = salaev2
  salaev = x - salaev2
  salaev2 = x
  dono.entrou[v](este)

func salvarev_exec
  salvar

func vazio1_exec # Próximo de sair do MUD
  $mens.p(este)
  $mens.mvis1("$P caminha em direção ao vazio.")

func vazio2_exec # Sair do MUD automaticamente
  apagar(este)
