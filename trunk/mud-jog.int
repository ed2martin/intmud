classe jogsock
# Comunicação com o jogador
# Funções predefinidas:
# ini = objeto foi criado
# fim = objeto está sendo apagado
# info = tipo (l=local, t=telnet, p=papovox, b=bot) + espaço + extra
# infotelnet = 1 (verdadeiro) se estiver conectado via Telnet
# sendo que extra pode ser o endereço IP ou o nome da sala
# msgsock(texto) = envia mensagem para jogador
# msgsala(texto) = envia mensagem para todos da sala
# msgtodos(texto) = envia mensagem para todos os jogadores
# recebe(texto) = executado sempre que receber mensagem do jogador
# salaobj(listaobj) = adicionar na listaobj com os objetos na mesma sala
#
ref perso # Personagem controlado pelo jogador
indiceobj cnome # "un " + nome codificado
txt20 nome # Nome do personagem
txt20 nomefim # Nome ao apresentar quando o usuário sair do jogo
textotxt txtmais # Texto do tecle M para mais
int1 jogconfig.24 # Configurações do personagem
txt512 ultimocom # Último comando digitado pelo usuário
textotxt comandos # Comandos em espera para serem processados
intexec msgprompt # Para enviar mensagens do prompt
intinc tempojogo # Tempo da sessão
intdec msgtot1 # Usado no controle de banda das mensagens para o jogador
real msgtot2 # Usado no controle de banda das mensagens para o jogador
#
txt30 passo # Passo atual; "" se estiver jogando
txt100 tpasso # Texto usado no passo atual
textovar var # Variáveis criadas dinamicamente
textotxt teditor # Texto usado no editor
textopos leditor # Linha atual no editor
textopos leditor1 # Início de bloco
textopos leditor2 # Fim de bloco
listaobj lmonit # Lista de quem está monitorando esse jogador
listaitem imonit # Um item de lmonit
txt512 peditor # Texto sendo procurado, opção P do editor
textotxt transf # Área de transferência do editor

func ini
  jogconfig.bits = 12 # Cores(8) + acentuação(4)
  refvar t = info
  refvar ban = (txt1(t) == "t" || txt1(t) == "p") && $miscban.banido(txt2(t))
  ban ? config:apresban && msg(config:apresban) : config:apres && msg(config:apres)
  reinicia

func fim
  lmonit.limpar
  perso.fechou(txt1(info) == "b")
  mudaperso(nulo)
  nomefim && msgchegou("Saiu: " + nome + ", " + nomefim, nome + " saiu")

func mudaperso # Muda o personagem, arg0=novo personagem
  ret perso == arg0 || arg0.sock, nulo
  lmonit.limpar, imonit.limpar
  ref r
# Indica que o jogador não controla o antigo personagem
  epara r = perso, r, r = r.dono
    r.socktot -= 1
  efim
  perso.sock = nulo
# Indica que o jogador controla o novo personagem
  perso = arg0
  perso.sock = este
  epara r = perso, r, r = r.dono
    r.socktot += 1
  efim

func reinicia # Volta ao início: pede o nome do personagem
  se nomefim
    msgchegou("Personagem saiu: " + nome + ", " + nomefim, "")
    nomefim = ""
  fimse
  jogconfig.bits = 12 # Cores(8) + acentuação(4)
  cnome = "un", nome = ""
  mudaperso(nulo)
  $adm_perso1.passo(este)

func recebe # Recebeu mensagem do jogador
  ret passo || !perso.var.t_[txt1(arg0)], recebe1(arg0)
  $cmdalias.m_0 = txt2(arg0)
  textotxt t
  t.addfim($cmdalias.mens(perso.var.t_[txt1(arg0)]))
  debug d
  enquanto t.linhas
    d.ini
    ret recebe1(t.remove), nulo
  efim

func recebe1 # Função recebe após uso de atalhos
# Retorna verdadeiro se deve cancelar os comandos do alias
# Checa quem está monitorando
  se lmonit
    casovar passo
    casose
      listaitem i
      epara i = lmonit.ini, i, i.depois
        i.obj.msg("<" + arg0, 1), i.obj.msgprompt = 1
      efim
    casose "adm_criasenha1"
    casose "adm_criasenha2"
    casose "adm_entrasenha"
    casose "adm_mudasenha1"
    casose "adm_mudasenha2"
    casose "adm_mudasenha3"
    casose "adm_autoapagar2"
    casofim
  fimse
# Atualiza tempo para sair do MUD
  temposair
# Teclar M para mais
  se arg0 == "m" && txtmais.linhas
    txtmostra
    ret
  fimse
# Passo atual / executa comando
  txtmais.limpar
  se passo && $[passo].passo(este, arg0) # Função do passo
    comandos.limpar
    ret
  senao arg0 && arg0 == config:senhaadm # Administração
    jogconfig.23 = !jogconfig.23 # Administração
    jogconfig.19 = jogconfig.23 # Canal AC
    perso.jogconfig.bits = jogconfig.bits
    perso.recalc = 1 # Para atualizar perso.bitver
    txt100 t1
    se jogconfig.23
      msg("Você virou admin, tecle ADM para saber os comandos.")
      t1 = "*** " + perso.nome + " virou admin."
      $misclog.cmdlog("adm " + arg0.nome + ": Virou admin")
    senao
      msg("Você deixou de ser admin.")
      t1 = "*** " + perso.nome + " deixou de ser admin."
      $misclog.cmdlog("adm " + arg0.nome + ": Deixou de ser admin")
    fimse
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
    efim
    ret
  senao arg0 != "!" # Anota o último comando
    casovar txt(arg0, 0, 1)
    casose "."
      ultimocom = "chat " + txt(arg0, 1)
      sair
    casose "'"
      ultimocom = "falar " + txt(arg0, 1)
      sair
    casose "="
      ultimocom = "telepatia " + txt(arg0, 1)
      sair
    casose
      ultimocom = arg0
    casofim
  fimse
# Comando de administração
  se jogconfig.23 && perso
    refvar r = $adm_[txt1(ultimocom)].objcmd(perso)
    ret r, r.escr(perso, txt2(ultimocom)) + comandos.limpar
  fimse
# Comando para o jogo
  se !perso.p_espera # Checa se pode processar o comando
    perso.teclou(ultimocom) # Personagem processa comando
    perso.p_espera < 2 && (perso.p_espera = 2)
  senao perso.atktempo # Checa se está batalhando
# comandos && msg("Feito, aguarde")
    comandos.limpar
    comandos.addfim(ultimocom)
  senao comandos.bytes < 1024 # Não chegou ao limite de comandos
    comandos.addfim(ultimocom)
  senao # Chegou ao limite de comandos
    msg("Aguarde")
    ret 1

func espera_exec # Chamado por p_espera do personagem
  se comandos
    perso.teclou(comandos.remove(1)) # Personagem processa comando
    perso.p_espera < 2 && (perso.p_espera = 2)

func temposair # Acerta variáveis de tempo para sair do MUD
  casovar txt1(info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    perso.p_tempofim = 30
    sair
  casose # Rodando como bot ou independente
    perso.p_tempofim = 0
  casofim
  !perso.p_tempoatu && (perso.p_tempoatu = 150)

func msg2 # Mensagem grande para o jogador
  txtmais.limpar
  txtmais.addfim(arg0)
  txtmostra

func txtmostra # Mostra próximo bloco de txtmais
  se txtmais.linhas <= 10
    msg(txtmais.remove(10))
  senao
    msg(txtmais.remove(9) + "\nTecle M para mais")

func msg # Envia mensagem
# arg0=mensagem
# arg1 é verdadeiro se deve apenas enviar a mensagem
  se arg1
  senao lmonit
    msgprompt = 1
    listaitem i
    epara i = lmonit.ini, i, i.depois
      i.obj.msg(">" + arg0, 1), i.obj.msgprompt = 1
    efim
  senao
    msgprompt = 1
  fimse
# Controle de banda
  ret msgtot1 >= admbanda:b1, nulo
  msgtot1 += intdiv(msgtot2 += inttotal(arg0) / admbanda:b2)
  msgtot2 -= intdiv(msgtot2)
# Configuração do jogador
  casovar jogconfig.bits & 12
  casose "0" # -CORES -ACENTO
    ret msgsock("\b" + txtremove(arg0, "C7"))
  casose "4" # +CORES -ACENTO
    ret msgsock(txtremove(arg0, "7"))
  casose "8" # -CORES +ACENTO
    ret msgsock("\b" + txtremove(arg0, "C"))
  casose "12" # +CORES +ACENTO
    ret msgsock(arg0)
  casofim

func msgprompt_exec
  se passo || !perso
  senao perso.atkenv
    ret !jogconfig.7, j_t_prompt
    refvar t1 = $mens_prompt.mens(perso.var.z_bprompt, perso) + "\b"
    msg(t1, 1)
  senao
    ret !jogconfig.6, j_t_prompt
    refvar t1 = $mens_prompt.mens(perso.var.z_prompt, perso) + "\b"
    msg(t1, 1)

func msgchegou # Mensagem de usuário chegando ou saindo
# arg0 = mensagem para administradores
# arg1 = mensagem para usuários normais
  $misclog.entrou(arg0)
  se config:entrainfo
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      continuar item.obj == este
      se item.obj.jogconfig.23 # Se usuário é admin...
        arg0 && item.obj.msg("* " + arg0)
      senao config:entrainfo == 2 && !jogconfig.17
        arg1 && item.obj.msg("* " + arg1)
      fimse
    efim

const m_menu = $[arg0].passo(este, "\b")


classe adm_perso1
herda comando_comum
# Entrando no jogo: digitar o nome do personagem

func passo
  indiceitem ind
  txt20 texto
  arqsav sav1
  arg0.passo = este, arg0.tpasso = arg0.nome = arg0.cnome = ""
  texto = txtnome(arg1)
  se !arg1
    arg0.msg("Digite o nome do seu personagem:\cn ")
  senao inttotal(arg1) < 3 || inttotal(arg1) > 16
    arg0.msg("O nome deve ter de 3 a 16 caracteres; digite outro")
  senao intnome(arg1) || txtproc(txtsepara("a" + arg1, "L+D"), " ") >= 0
    arg0.msg("Nome inválido; digite outro")
  senao sav1.existe("sav/" + texto + ".sav") # Carregar jogo salvo
    arg0.msg("Personagem '" + txtmaimin(arg1) + "' já existe")
    arg0.tpasso = txtmaimin(arg1)
    $adm_entrasenha.passo(arg0)
  senao ind.obj("un " + texto)
    arg0.msg("Nome já está sendo usado; digite outro")
  senao # Criar personagem
    refvar t = arg0.info
    se (txt1(t) == "t" || txt1(t) == "p") && $miscban.banido(txt2(t))
      arg0.msg(config:apresban)
      apagar(arg0)
    senao $admnomesnao.nomes.n_[texto] # Checa se nome permitido
      arg0.msg("Nome não permitido para personagem")
    senao
      arg0.cnome = "un " + texto
      arg0.nome = txtmaimin(arg1)
      $adm_perso2.passo(arg0)
    fimse
  fimse
  ret 1


classe adm_perso2
herda comando_comum

func passo
  se arg1 == "N"
    $adm_perso1.passo(arg0)
  senao arg1 == "S"
    se config:salvacria
      $adm_criasenha1.passo(arg0)
    senao config:email
      $adm_email1.passo(arg0)
    senao
      $adm_sexo1.passo(arg0)
    fimse
    arg0.nomefim = arg0.info
    arg0.msgchegou("Criando personagem: " + arg0.nome + ", " + arg0.nomefim)
  senao
    arg0.passo = este
    arg0.msg("Deseja criar o personagem '" + arg0.nome + "'? (tecle S ou N)")


classe adm_criasenha1
herda comando_comum
# Digitar a senha ao criar personagem

func passo
  arg0.passo = este
  arg0.tpasso = txt1(tpasso)
  se !arg1
    arg0.msg("Digite uma senha para o personagem\cm")
  senao inttotal(arg1) < 5 || inttotal(arg1) > 16
    arg0.msg("A senha deve ter de 5 a 16 caracteres, digite outra")
  senao intsenha(arg1) == 3
    arg0.msg("Senha deve ter letras e números, digite outra")
  senao intsenha(arg1)
    arg0.msg("Senha inválida, digite outras")
  senao
    arg0.var.j_senha = arg1
    $adm_criasenha2.passo(arg0)
  fimse
  ret 1


classe adm_criasenha2
herda comando_comum
# Repetir a senha ao criar personagem

func passo
  arg0.passo = este
  se !arg1
    arg0.msg("Digite novamente a senha")
  senao arg1 != arg0.var.j_senha
    arg0.msg("As senhas são diferentes")
    arg0.var.limpar("j_")
    $adm_perso1.passo(arg0)
  senao
    config:email ? $adm_email1.passo(arg0) : $adm_sexo1.passo(arg0)
  fimse
  ret 1


classe adm_email1
herda comando_comum
# Digitar o e-mail

func passo
  arg0.passo = este
  txt100 lin.3
  se !arg1
    se config:email == 1
      arg0.msg("Digite seu e-mail ou N para nenhum\cn")
    senao
      arg0.msg("Digite seu e-mail\cn")
    fimse
  senao arg1 == "n" && config:email == 1
    $adm_sexo1.passo(arg0)
  senao txtproc(arg1, " ") >= 0
    arg0.msg("O e-mail não pode conter espaços; digite outro")
  senao txtremove(arg1, "7") !== arg1
    arg0.msg("E-mail contém caracteres inválidos, digite outro")
  senao lin.separar(arg1, "@") != 2 || lin.0 == ""
    arg0.msg("E-mail inválido; digite outro")
  senao txtfim(lin.1, 1) == "." || txtproc(lin.1, ".") <= 0
    arg0.msg("E-mail inválido; digite outro")
  senao
    arg0.var.j_email = arg1
    $adm_sexo1.passo(arg0)
  fimse
  ret 1


classe adm_sexo1
herda comando_comum
# Digitar H ou M

func passo
  arg0.passo = este
  se arg1 != "H" && arg1 != "M"
    arg0.msg("Você é homem ou mulher? (tecle H ou M)")
    ret 1
  fimse
  arg0.var.j_sexo = arg1 == "H" # 0=feminino, 1=masculino
  ret $adm_raca1.passo(arg0)


classe adm_raca1
herda comando_comum
# Começa a escolha da raça

func passo
  arg0.tpasso = "raça"
  ret $adm_raca2.passo(arg0)


classe adm_raca2
herda comando_comum
# Escolhe a raça

func passo
  txt100 lin
  prog p
  refvar tpasso = arg0.tpasso
# Obtém a lista de raças e checa se escolheu uma raça
  arg0.txtmais.limpar
  epara p.iniclasse("tipo_"), p.lin, p.depois
    continuar txts([p.texto]:menu) != tpasso
    arg0.txtmais.addfim(txt(arg0.txtmais.linhas + 1) + ". " + [p.texto]:nome)
    lin = p.texto
    continuar txt(arg1) != txt(arg0.txtmais.linhas)
    arg0.txtmais.limpar
    arg0.tpasso = p.texto
    arg0.msg2([tpasso]:desc ? [tpasso]:desc : [tpasso]:nome)
    ret $adm_raca3.passo(arg0)
  efim
# Somente uma raça para escolher: escolhe automaticamente
  se arg0.txtmais.linhas == 1
    arg0.txtmais.limpar
    arg0.var.j_tipo1 = txt(lin, 5)
    ret $adm_classe1.passo(arg0)
# Nenhuma raça para escolher: passa para o próximo menu
  senao arg0.txtmais.linhas == 0
    arg0.txtmais.limpar
    arg0.tpasso != "raça" && (arg0.var.j_tipo1 = tpasso)
    ret $adm_classe1.passo(arg0)
# Mais de uma raça: apresenta o menu
  senao
    arg0.passo = este
    se arg1
      arg0.txtmais.addini("Raça inválida; escolha uma:")
    senao tpasso == "raça"
      arg0.txtmais.addini("Escolha uma raça:")
    senao
      arg0.txtmais.addini("Escolha uma sub-raça:")
    fimse
    arg0.txtmostra
    ret 1


classe adm_raca3
herda comando_comum
# Mostra informações da raça e pede confirmação

func passo
  arg0.passo = este
  se arg1 == "S"
    arg0.tpasso = txt(arg0.tpasso, 5)
    ret $adm_raca2.passo(arg0)
  senao arg1 == "N"
    arg0.tpasso = txts([arg0.tpasso]:menu)
    ret $adm_raca2.passo(arg0)
  senao
    arg0.msg("Você quer essa raça? (tecle S ou N)")
    ret 1


classe adm_classe1
herda comando_comum
# Começa a escolha da raça

func passo
  arg0.tpasso = "classe"
  ret $adm_classe2.passo(arg0)


classe adm_classe2
herda comando_comum
# Escolhe a classe

func passo
  txt100 lin
  prog p
  refvar tpasso = arg0.tpasso
# Obtém a lista de classes e checa se escolheu uma classe
  arg0.txtmais.limpar
  epara p.iniclasse("tipo_"), p.lin, p.depois
    continuar txts([p.texto]:menu) != tpasso
    se [p.texto]:racas
      se txtproc("\n" + txts([p.texto]:racas) + "\n", "\n" + arg0.var.j_tipo1 + "\n") < 0
        continuar
      fimse
    fimse
    arg0.txtmais.addfim(txt(arg0.txtmais.linhas + 1) + ". " + [p.texto]:nome)
    lin = p.texto
    continuar txt(arg1) != txt(arg0.txtmais.linhas)
    arg0.txtmais.limpar
    tpasso = p.texto
    msg2([tpasso]:desc ? [tpasso]:desc : [tpasso]:nome)
    ret $adm_classe3.passo(arg0)
  efim
# Somente uma classe para escolher: escolhe automaticamente
  se arg0.txtmais.linhas == 1
    arg0.txtmais.limpar
    arg0.var.j_tipo2 = txt(lin, 5)
    ret $adm_entrajogo.passo(arg0)
# Nenhuma classe para escolher: passa para o próximo menu
  senao arg0.txtmais.linhas == 0
    arg0.txtmais.limpar
    tpasso != "classe" && (arg0.var.j_tipo2 = tpasso)
    ret $adm_entrajogo.passo(arg0)
# Mais de uma classe: apresenta o menu
  senao
    arg0.passo = este
    se arg1
      arg0.txtmais.addini("Classe inválida; escolha uma:")
    senao tpasso == "classe"
      arg0.txtmais.addini("Escolha uma classe:")
    senao
      arg0.txtmais.addini("Escolha uma sub-classe:")
    fimse
    txtmostra
    ret 1


classe adm_classe3
herda comando_comum
# Mostra informações da classe e pede confirmação

func passo
  arg0.passo = este
  se arg1 == "S"
    arg0.tpasso = txt(arg0.tpasso, 5)
    ret $adm_classe2.passo(arg0)
  senao arg1 == "N"
    arg0.tpasso = txts([arg0.tpasso]:menu)
    ret $adm_classe2.passo(arg0)
  senao
    arg0.msg("Você quer essa classe? (tecle S ou N)")
    ret 1


classe adm_entrajogo
herda comando_comum
# Entrar no jogo: cria personagem

func passo
  arg0.passo = ""
  arg0.jogconfig.bits = config:jogconfig # Configurações iniciais
  arg0.msg("Iniciando jogo; para ajuda tecle AJUDA")
  arg0.var.j_inivar = txt(tipo_[arg0.var.j_tipo1]:inivar) + "," + tipo_[arg0.var.j_tipo2]:inivar
  arg0.mudaperso(criar("jogador", nulo, 0, arg0.var.j_inivar))
  arg0.perso.cnome = "pn " + txt2(arg0.cnome)
  arg0.perso.nome = arg0.nome
  arg0.perso.jogconfig.bits = arg0.jogconfig.bits
  arg0.perso.psexo = arg0.var.j_sexo
  arg0.perso.senha = arg0.var.j_senha
  arg0.perso.tipo1 = arg0.var.j_tipo1
  arg0.perso.tipo2 = arg0.var.j_tipo2
  arg0.perso.var.z_email = arg0.var.j_email
  arg0.var.limpar("j_")
  arg0.perso.mudadono(config:salaini)
  arg0.perso.recalc = 1
  arg0.temposair # Acerta tempo para sair do MUD
  se arg0.perso.senha
    !arg0.perso.salvar && arg0.msg("Não foi possível salvar o personagem")
  fimse
  arg0.msgchegou("Criou personagem: " + arg0.nome + ", " + arg0.nomefim, arg0.nome + " entrou")
  $mens.p(arg0.perso)
  $mens.mvis2("", "$P chegou.")
  ret 1


classe adm_entrasenha
herda comando_comum
# Entrar com a senha para carregar jogo salvo

func passo
  indiceitem ind
  txt20 texto
  arqsav sav1
  ref r
# msg(texto + " , " + arg0)
  texto = txtnome(arg0.tpasso)
  arg0.passo = este
  se !arg1
    arg0.msg("Digite a senha ou tecle Z se não for seu: \cm")
  senao arg1 == "z"
    arg0.nome = "", $adm_perso1.passo(arg0)
  senao !sav1.senha("sav/" + texto + ".sav", txtmin(arg1))
    arg0.msg("Senha incorreta")
    casovar txt1(arg0.info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(arg0)
      ret
    casofim
    $adm_perso1.passo(arg0)
  senao ind.obj("pn " + texto)
    r = ind.obj("un " + texto)
    casovar txt1(r.info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(r)
      r.mudaperso(nulo)
      r.msg("Jogador " + arg0.info + " começou a usar seu personagem")
      r.nomefim = ""
    casose ""
      sair
    casose
      r.msg("Jogador " + arg0.info + " começou a usar seu personagem")
      r.reinicia
    casofim
    arg0.passo = ""
    arg0.mudaperso(ind.obj("pn " + texto))
    arg0.nome = arg0.perso.nome
    arg0.cnome = "un " + texto
    arg0.jogconfig.bits = arg0.perso.jogconfig.bits
    arg0.temposair # Acerta tempo para sair do MUD
    arg0.msg("Reconectado\cn")
    txt200 lin
    arg0.nomefim = arg0.info
    lin = "Entrou: " + arg0.nome + ", " + arg0.info + ", N" + arg0.perso.pnivel
    lin += " $" + arg0.perso.var.z_moedas_
    arg0.msgchegou(lin, arg0.nome + " entrou")
    refvar alvo = arg0.perso.atkenv.objlista
    se !alvo
      arg0.perso.teclou("olhar")
    senao alvo.visivel(arg0)
      arg0.msg("Alguém está lutando com você!")
    senao
      arg0.msg(txtcopiamai(alvo.descnome, "A") + " está lutando com você!")
    fimse
  senao
# Primeiro cria personagem
    arg0.passo = ""
    arg0.nome = arg0.tpasso
    arg0.cnome = "un " + texto
    arg0.mudaperso(criar("jogador"))
    arg0.perso.cnome = "pn " + texto
    arg0.perso.nome = arg0.nome
    arg0.perso.senha = txtmin(arg1)
# Carrega personagem
    listaobj l1
    l1.addfim(arg0.perso)
    sav1.ler("sav/" + texto + ".sav", l1)
    arg0.nome = arg0.perso.nome
    arg0.jogconfig.bits = arg0.perso.jogconfig.bits
# Acerta variáveis
    listaitem item
    debug d
    epara item = l1.ini, item, item.depois
      d.ini, item.obj.ajustaobj
    efim
    epara item = l1.fim, item, item.antes
      d.ini
      !item.obj.dono && !item.obj.jog && apagar(item.obj)
      item.obj.var.limpar("d_", "j_")
      item.obj.ajustapeso, item.obj.acertapos, item.obj.recalc = 1
    efim
# Muda de sala e volta ao jogo
    arg0.perso.p_espera = 2 # Para processar um comando do jogador só após mudar de sala
    criar("jogsock_retorna", arg0.perso, $[arg0.perso.salanome]) # Para mudar de sala
    arg0.msg("Continuando jogo salvo\cn")
    txt200 lin
    lin = "Entrou: " + arg0.nome + ", " + arg0.info + ", N" + arg0.perso.pnivel
    lin += " $" + arg0.perso.var.z_moedas_
    arg0.msgchegou(lin, arg0.nome + " entrou")
    arg0.nomefim = arg0.info
  fimse
  ret 1


classe adm_mudasenha1
herda comando_comum
# Digitar a senha atual para mudar a senha

func passo
  arg0.passo = este
  se !arg1
    arg0.msg("Digite a senha atual do personagem ou z para desistir")
  senao arg1 == "z"
    arg0.passo = ""
    arg0.msg("Cancelado")
  senao arg1 != arg0.perso.senha
    arg0.msg("Senha incorreta; cancelado")
    arg0.passo = ""
  senao
    $adm_mudasenha2.passo(arg0)
  fimse
  ret 1


classe adm_mudasenha2
herda comando_comum
# Digitar a nova senha

func passo
  arg0.passo = este
  se !arg1
    arg0.msg("Digite a nova senha do personagem ou Z para desistir")
  senao arg1 == "z"
    arg0.passo = ""
    arg0.msg("Cancelado")
  senao inttotal(arg1) < 5 || inttotal(arg1) > 16
    arg0.msg("A senha deve ter de 5 a 16 caracteres, digite outra")
  senao intsenha(arg1) == 3
    arg0.msg("Senha deve ter letras e números, digite outra")
  senao intsenha(arg1)
    arg0.msg("Senha inválida, digite outras")
  senao
    arg0.tpasso = arg1
    $adm_mudasenha3.passo(arg0)
  fimse
  ret 1


classe adm_mudasenha3
herda comando_comum
# Repetir a senha digitada

func passo
  arg0.passo = este
  se !arg1
    arg0.msg("Digite novamente a senha")
  senao arg0.tpasso != arg1
    arg0.msg("As senhas são diferentes; cancelado")
    arg0.passo = ""
  senao
    arg0.perso.senha = txtmin(arg1)
    arg0.msg(arg0.perso.salvar ? "Jogo salvo" : "Não foi possível salvar")
    arg0.passo = ""
  fimse
  ret 1


classe adm_autoapagar1
herda comando_comum

func passo
  arg0.passo = este
  se !arg1
    arg0.msg("Deseja realmente apagar o personagem " + arg0.perso.nome + "? Tecle S ou N")
  senao arg1 == "s"
    $adm_autoapagar2.passo(arg0)
  senao
    arg0.msg("Autoapagar cancelado")
    arg0.passo = ""
  fimse
  ret 1


classe adm_autoapagar2
herda comando_comum

func passo
  arqsav sav1
  arg0.passo = este
  se !arg1
    arg0.msg("Digite a senha ou tecle Z para cancelar")
  senao arg1 == "z"
    arg0.msg("Autoapagar cancelado")
    passo = ""
  senao arg1 != perso.senha
    arg0.msg("Senha incorreta; autoapagar cancelado")
    arg0.passo = ""
  senao sav1.apagar("sav/" + txt2(arg0.cnome) + ".sav")
    arg0.perso.senha = ""
    apagar(arg0.perso)
    $miscsav.apagousav(txt2(arg0.cnome))
  senao
    arg0.msg("Não foi possível apagar o personagem.")
    arg0.passo = ""
  fimse
  ret 1


classe jogsock_retorna
# Coloca o jogador na sala em que estava, logo após entrar no MUD
ref perso
ref sala
intexec ex

func ini
  perso = arg0, sala = arg1, ex = 1
# telatxt t
# t.msg("Perso " + arg0 + " sala " + arg1 + "\n")

func ex_exec
  apagar(este)
  ref(sala.s_voltar) && (sala = sala.s_voltar)
  perso.mudadono(sala ? sala : config:salasav)
  temposair # Acerta tempo para sair do MUD
  $mens.p(perso)
  $mens.mvis2("", "$P chegou.")


classe jogador
herda comum_persoanimal
# Personagem no jogo
const jog = 1 # Para identificar que é jogador
const ident = nome
indiceobj cnome # "pn " + nome codificado (usado ao reconectar)
sav txt20 nome # Nome do personagem
sav txt40 salanome # Nome da sala
const msexo = psexo # Sexo do personagem
sav int1 jogconfig.24 # Para salvar sock.jogconfig
txt20 senha # Senha do jogo salvo, ou "" se não estiver salvo
sav listaobj dentro3 # Lista de animais reserva
inttempo p_tempoatu # Tempo para atualizar personagem
uint8 p_tempomsg # Para enviar mensagens de fome e sede em tempoatu_exec
uint8 p_tempofim # Para sair do jogo após algum tempo
sav inttempo tempojogo1 # Em décimos de segundo, até 24 horas
sav uint16 tempojogo2 # Dias, para contar o tempo de jogo
const pesoobj = 65000
const p_recebe = 1 # Para poder receber itens de outros personagens
sav txt32 tipo1 # Raça do jogador; vide classes "tipo_*" em mud-b-tipo.int
sav txt32 tipo2 # Classe do jogador; vide classes "tipo_*" em mud-b-tipo.int
const p_naoseguir = !jogconfig.5
const p_imortal = jogconfig.14
sav uint32 p_fugir
sav uint8 p_sede # Sede, quanto menor mais sede tem
sav uint8 p_fome # Fome, quanto menor mais fome tem
sav uint8 p_bebida # Embriagês, quanto maior mais bêbado está
sav uint8 p_diges # Digestão
int1 atklog # Para mostrar os cálculos de batalha no próximo ataque

func ini # Objeto foi criado
  tempojogo1 = 864000
  nivel = 1
  p_sede = p_fome = 30
  var.z_prompt = "<%c3%hhp %c2%mmn %c6%vmv%b> "
  var.z_bprompt = "<%c3%hhp %c2%mmn %c6%vmv%b> "
  comum_persoanimal:ini(arg0, arg1, arg2, arg3, arg4)

func fim # Objeto foi apagado
  salvar
  se posicao
    $mens.p(este)
    $mens.mvis2("", "$P foi embora.")
  fimse
  comum_perso:fim
# Se era o último jogador online, salva todas as casas
  cnome = nome = ""
  indiceitem item
  item.ini("pn ")
  txt1(item.txt) != "pn" && $miscsav.salvartudo

func fechou # Executado quando o objeto sock é apagado
# arg0 é verdadeiro se jogador via bot (deve sair mais rápido do jogo)
  se arg0
    p_tempofim = 7
    !atkenv && apagar(este) # Apaga personagem se não estiver batalhando
  senao
    p_tempofim = 12
  fimse
  senha == "" && apagar(este) # Apaga personagem se não tem jogo salvo

func mudasenha # Usuário quer mudar a senha
  ret sock, senha ? $adm_mudasenha1.passo(sock) : $adm_mudasenha2.passo(sock)

func tempojogo1_exec
  tempojogo1 = 864000, tempojogo2 += 1

func p_tempoatu_exec # Atualiza variáveis e salva o jogo de tempos em tempos
  p_tempoatu = rand(150, 200)
# Checa tempo para sair do jogo
  se !p_tempofim # 0 não faz nada
  senao (p_tempofim -= 1) == 5 # Informa que vai sair do jogo
    $mens.p(este)
    $mens.mvis1("$P caminha em direção ao vazio.")
  senao !p_tempofim # Chegou a 0 apaga o personagem (sai do jogo)
    msg("Muito tempo sem comunicação")
    ret apagar(este)
  fimse
# Restaura status de tempos em tempos
  real2 recup
  casovar posicao
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    p_diges -= 1, vida += 1, acertapos
    sair
  casose "3" # Fraco
    p_diges -= 1, vida += 2, acertapos
    sair
  casose "4" # Dormindo
    recup = contr.dono.s_recup(este) / (poslugar.objlista.i_movel >= 3 ? 500 : 600)
    p_diges -= 3
    sair
  casose "5" # Descansando
    recup = contr.dono.s_recup(este) / (poslugar.objlista.i_movel >= 3 ? 685 : 800)
    p_diges -= 3
    sair
  casose "6" # Sentado
    recup = contr.dono.s_recup(este) / (poslugar.objlista.i_movel >= 3 ? 1000 : 1200)
    p_diges -= 3
    sair
  casose "7" # Lutando
    recup = contr.dono.s_recup(este) / 1400
    p_diges -= 1
    sair
  casose "8" # Em pé
    recup = contr.dono.s_recup(este) / 1400
    p_diges -= 2
    sair
  casose
    p_diges -= 1
  casofim
  se !recup # Sem taxa de recuperação
  senao p_sede && p_fome # Recuperação normal
    pmana < pmanamax && (pmana = intmin(pmanamax, intmax(2, pmana + pmanamax * recup)))
    pmove < pmovemax && (pmove = intmin(pmovemax, intmax(2, pmove + pmovemax * recup)))
    pvida < pvidamax && (pvida = intmin(pvidamax, intmax(2, pvida + pvidamax * recup)))
  senao # Recuperação com muita fome e/ou muita sede
    recup /= 2
    pmana < pmanamax && (pmana = intmin(pmanamax, intmax(2, pmana + pmanamax * recup)))
    pmove < pmovemax && (pmove = intmin(pmovemax, intmax(2, pmove + pmovemax * recup)))
  fimse
# Acerta fome, sede e embriaguês
  se p_bebida == 1 || p_bebida == 2
    msg(msexo ? "Você está sóbrio." : "Você está sóbria.")
  fimse
  se jogconfig.14 # Imortal
    p_sede = intmax($miscfome.semfome, p_sede - 1)
    p_fome = intmax($miscfome.semfome, p_fome - 1)
    p_bebida = intmin(1, p_bebida - 1)
  senao pnivel < config:fomeini || pnivel >= config:fomefim || dono.s_fome == 1 # Não sente
    p_sede = intmax($miscfome.semfome, p_sede - 1)
    p_fome = intmax($miscfome.semfome, p_fome - 1)
    p_bebida -= 2
  senao !dono.s_fome # Sente fome/sede
    p_sede -= dono.s_terreno == 11 ? 3 : 1 # No deserto sente sede 3x mais rápido
    p_fome -= 1
    p_bebida -= 2
  senao # Se recupera de fome/sede aos poucos
    p_sede = intmax(p_sede - 1, intmin($miscfome.semfome, p_sede + 1))
    p_fome = intmax(p_fome - 1, intmin($miscfome.semfome, p_fome + 1))
    p_bebida -= 2
  fimse
# Mensagens de fome e sede e pontos de vida
  se !(p_tempomsg -= 1)
    casovar txtchr(97 + $miscfome.t.[p_fome]) + $miscfome.t.[p_sede]
    casose "a1" # Pouca sede
      p_tempomsg = 5
      msg("Sua boca está um pouco seca.")
      sair
    casose "a2" # Com sede
      p_tempomsg = 5
      msg("Você está com sede.")
      sair !config:fomemsg
      $mens.p(este)
      $mens.mvis2("", "$P está com sede.")
      sair
    casose "a3" # Muita sede
      p_tempomsg = 5
      pvida -= 5
      msg("Você está morrendo de sede, -5")
      $mens.p(este)
      $mens.mvis2("", "$P está morrendo de sede.")
      sair
    casose "b0" # Pouca fome
      p_tempomsg = 5
      msg("Você sente umas pontadas de fome.")
      sair
    casose "b1" # Pouca fome + Pouca sede
      p_tempomsg = 5
      msg("Você sente umas pontadas de fome e a boca um pouco seca.")
      sair
    casose "b2" # Pouca fome + Com sede
      p_tempomsg = 5
      msg("Você está com sede e sente umas pontadas de fome.")
      sair !config:fomemsg
      $mens.p(este)
      $mens.mvis2("", "$P está com sede.")
      sair
    casose "b3" # Pouca fome + Muita sede
      p_tempomsg = 5
      pvida -= 5
      msg("Você está morrendo de sede e sente umas pontadas de fome, -5")
      $mens.p(este)
      sair !config:fomemsg
      $mens.mvis2("", "$P está morrendo de sede.")
      sair
    casose "c0" # Com fome
      p_tempomsg = 5
      msg("Você está com fome.")
      sair !config:fomemsg
      $mens.p(este)
      $mens.mvis2("", "Você ouve o estômago de $P roncar.")
      sair
    casose "c1" # Com fome + Pouca sede
      p_tempomsg = 5
      msg("Você está com fome e sente a boca um pouco seca.")
      sair !config:fomemsg
      $mens.p(este)
      $mens.mvis2("", "Você ouve o estômago de $P roncar.")
      sair
    casose "c2" # Com fome + Com sede
      p_tempomsg = 5
      msg("Você está com fome e sede.")
      sair !config:fomemsg
      $mens.p(este)
      $mens.mvis2("", "$P está com fome e sede.")
      sair
    casose "c3" # Com fome + Muita sede
      p_tempomsg = 5
      pvida -= 5
      msg("Você está morrendo de sede e com fome, -5")
      $mens.p(este)
      se config:fomemsg
        $mens.mvis2("", "$P está morrendo de sede e com fome.")
      senao
        $mens.mvis2("", "$P está morrendo de sede.")
      fimse
      sair
    casose "d0" # Muita fome
      p_tempomsg = 5
      pvida -= 10
      msg("Você está morrendo de fome, -10")
      $mens.p(este)
      $mens.mvis2("", "$P está morrendo de fome.")
      sair
    casose "d1" # Muita fome + Pouca sede
      p_tempomsg = 5
      pvida -= 10
      msg("Você está morrendo de fome e sente a boca um pouco seca, -10")
      $mens.p(este)
      $mens.mvis2("", "$P está morrendo de fome.")
      sair
    casose "d2" # Muita fome + Com sede
      p_tempomsg = 5
      pvida -= 10
      msg("Você está morrendo de fome e com sede, -10")
      $mens.p(este)
      se config:fomemsg
        $mens.mvis2("", "$P está morrendo de fome e com sede.")
      senao
        $mens.mvis2("", "$P está morrendo de fome.")
      fimse
      sair
    casose "d3" # Muita fome + Muita sede
      p_tempomsg = 5
      pvida -= 15
      msg("Você está morrendo de fome e sede, -15")
      $mens.p(este)
      $mens.mvis2("", "$P está morrendo de fome e sede.")
      sair
    casofim
  fimse
# Cair sentado devido à bebida
  se posicao == 8 && p_bebida >= rand($miscfome.bebedir, $miscfome.cheio)
    poslugar.remove
    posicao = 6
    pvida -= 5
    msg("Você se desequilibrou e caiu, -5")
    $mens.p(este)
    $mens.mtodos2("", "$P se desequilibrou e caiu.")
  fimse
# Acerta estado do personagem
  acertapos(1)

func salvar # Salva o jogo, desde que a senha não seja nula
# Retorna verdadeiro se conseguiu salvar
  ret !senha, 0
  listaitem item
  listaobj lista
  debug dbg
  dbg.exec = 50000
  lista.addfim(este, dentro1, dentro2, dentro3)
  item = lista.ini, item.depois
  enquanto item
    se !item.obj.objsav
      item.removedepois
    senao lista.total < 2000
      lista.addfim(item.obj.dentro1, item.obj.dentro2, item.obj.dentro3), item.depois
    senao
      item.depois
    fimse
  efim
  salanome = dono
# msg(txt2(cnome) + " , " + senha)
  dbg.exec = 2000
  ret !lista.total, 0
# Obtém o tempo do jogo salvo, em dias, e salva o jogo
  int32 tempo
  se jogconfig.23
    tempo = config:salvaadmin
  senao pnivel < config:nivelveterano
    tempo = config:salvainiciante
  senao
    tempo = config:salvaveterano
  fimse
  arqsav sav1
  ret sav1.salvar("sav/" + txt2(cnome) + ".sav", lista, tempo, senha)

func dentrocasa # Retorna verdadeiro se o jogador está dentro da própria casa
  ret !dono, nulo
  indiceitem item
  refvar t = "cj " + txt2(cnome)
  epara item.ini(t), txtsub(item.txt, 0, 2) == t, item.depois
    refvar c = item.obj # Casa encontrada
    ret c.s1 == dono || c.s2 == dono || c.s3 == dono || c.s4 == dono || c.s5 == dono, 1
    ret c.s6 == dono || c.s7 == dono || c.s8 == dono || c.s9 == dono, 1
  efim

func cmd_recalc1 # Recalcula variáveis do personagem
# pnivel < 10 && (pvidamax += 50 - pnivel * 5)
  jogconfig.14 && (bitver |= 0x107C) # Propriedade config +imortal
  jogconfig.18 && (bitinv |= 128) # Propriedade config +invsala
  jogconfig.23 && (bitver |= 128) # Se é administrador


classe cmdalias
# Para processar o comando alias
const iniclasse = !$[arg0] && criar(arg0)
txt512 m_0
const m_1 = txt1(m_0)
const m_2 = txtsub(m_0, 1, 1)
const m_3 = txtsub(m_0, 2, 1)
const m_4 = txtsub(m_0, 3, 1)
const m_5 = txtsub(m_0, 4, 1)
const m_6 = txtsub(m_0, 5, 1)
const m_7 = txtsub(m_0, 6, 1)
const m_8 = txtsub(m_0, 7, 1)
const m_9 = txtsub(m_0, 8, 1)
const m_S = txtsub(m_0, 1)
const m_T = txtsub(m_0, 2)
const m_Z = "\n"
const m_@ = "$"
const mens = vartroca(txttroca(arg0, "$$", "$@"), "$", "m_")
