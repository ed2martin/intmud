classe jogsock
herda jog_entra, jog_adm, jog_admatk, jog_admcod, jog_admsala, jog_admperso, jog_admitem, \
jog_admsocial, jog_reset
# Comunicação com o jogador
# Funções predefinidas:
# ini = objeto foi criado
# fim = objeto está sendo apagado
# info = tipo (l=local, t=telnet, p=papovox, b=bot) + espaço + extra
# sendo que extra pode ser o endereço IP ou o nome da sala
# msgsock(texto) = envia mensagem para jogador
# msgsala(texto) = envia mensagem para todos da sala
# msgtodos(texto) = envia mensagem para todos os jogadores
# recebe(texto) = executado sempre que receber mensagem do jogador
#
ref perso # Personagem controlado pelo jogador
indiceobj cnome # "un " + nome codificado
txt20 nome # Nome do personagem
inttempo vazio # Tempo sem comunicação para desconectar do MUD
textotxt txtmais # Texto do tecle M para mais
int1 jogconfig.24 # Configurações do personagem
txt512 ultimocom # Último comando digitado pelo usuário
textotxt comandos # Comandos em espera para serem processados
intexec msgprompt # Para enviar mensagens do prompt
intinc tempojogo # Tempo da sessão
#
txt20 passo # Passo atual; "" se estiver jogando
txt100 tpasso # Texto usado no passo atual
textovar var # Variáveis criadas dinamicamente
textotxt teditor # Texto usado no editor
textopos leditor # Linha atual no editor
textopos leditor1 # Início de bloco
textopos leditor2 # Fim de bloco
listaobj lmonit # Lista de quem está monitorando esse jogador
listaitem imonit # Um item de lmonit
txt512 peditor # Texto sendo procurado, opção P do editor
textotxt transf # Área de transferência do editor

func ini
  reinicia
  cnome = "un"
  jogconfig.bits = 12 # Cores(8) + acentuação(4)

func fim
  perso.fechou
  mudaperso(nulo)

func mudaperso # Muda o personagem, arg0=novo personagem
  ret perso == arg0 || arg0.sock, nulo
  lmonit.limpar, imonit.limpar
  ref r
# Indica que o jogador não controla o antigo personagem
  epara r = perso, r, r = r.dono
    r.socktot -= 1
  efim
  perso.sock = nulo
# Indica que o jogador controla o novo personagem
  perso = arg0
  perso.sock = este
  epara r = perso, r, r = r.dono
    r.socktot += 1
  efim

func reinicia # Volta ao início: pede o nome do personagem
  mudaperso(nulo)
  cnome = "un", nome = ""
  p_perso

func recebe # Recebeu mensagem do jogador
# Checa quem está monitorando
  se lmonit
    casovar passo
    casose
      listaitem i
      epara i = lmonit.ini, i, i.depois
        i.obj.msg("<" + arg0, 1), i.obj.msgprompt = 1
      efim
    casose "criasenha1"
    casose "criasenha2"
    casose "entrasenha"
    casose "mudasenha1"
    casose "mudasenha2"
    casose "mudasenha3"
    casofim
  fimse
# Checa tempo para sair
  temposair
# Teclar M para mais
  se arg0 == "m" && txtmais.linhas
    txtmostra
    ret
  fimse
# Passo atual / executa comando
  txtmais.limpar
  se p_[passo](arg0) # Função do passo
    comandos.limpar
    ret
  senao arg0 && arg0 == config:senhaadm # Administração
    jogconfig.23 = !jogconfig.23 # Administração
    jogconfig.19 = jogconfig.23 # Canal AC
    perso.jogconfig.bits = jogconfig.bits
    perso.recalc = 1 # Para atualizar perso.bitver
    txt100 t1
    se jogconfig.23
      msg("Você virou admin, tecle ADM para saber os comandos.")
      t1 = "*** " + perso.nome + " virou admin."
    senao
      msg("Você deixou de ser admin.")
      t1 = "*** " + perso.nome + " deixou de ser admin."
    fimse
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
    efim
    ret
  senao arg0 != "!" # Anota o último comando
    casovar txt(arg0, 0, 1)
    casose "."
      ultimocom = "chat " + txt(arg0, 1)
      sair
    casose "'"
      ultimocom = "falar " + txt(arg0, 1)
      sair
    casose
      ultimocom = arg0
    casofim
  fimse
# Comando de administração
  se jogconfig.23 && cmd_[txt1(ultimocom)](txt2(ultimocom))
    comandos.limpar
    ret
# Comando para o jogo
  senao !perso.p_espera # Checa se pode processar o comando
    perso.teclou(ultimocom) # Personagem processa comando
    perso.p_espera < 2 && (perso.p_espera = 2)
  senao perso.atktempo # Checa se está batalhando
# comandos && msg("Feito, aguarde")
    comandos.limpar
    comandos.addfim(ultimocom)
  senao comandos.bytes < 1024 # Não chegou ao limite de comandos
    comandos.addfim(ultimocom)
  senao # Chegou ao limite de comandos
    msg("Aguarde")

func espera_exec # Chamado por p_espera do personagem
  se comandos
    perso.teclou(comandos.remove(1)) # Personagem processa comando
    perso.p_espera < 2 && (perso.p_espera = 2)

func temposair # Acerta variáveis de tempo para sair do MUD
  casovar txt1(info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    perso.vazio1 = 4800 # 8 minutos
    perso.vazio2 = 6000 # 10 minutos
    vazio = 6000
    sair
  casose # Rodando como bot ou independente
    perso.vazio1 = perso.vazio2 = vazio = 0 # Não desconectar
  casofim

func msg2 # Mensagem grande para o jogador
  txtmais.limpar
  txtmais.addfim(arg0)
  txtmostra

func txtmostra # Mostra próximo bloco de txtmais
  se txtmais.linhas <= 10
    msg(txtmais.remove(10))
  senao
    msg(txtmais.remove(9) + "\nTecle M para mais")

func msg # Envia mensagem
# arg0=mensagem
# arg1 é verdadeiro se deve apenas enviar a mensagem
  se arg1
  senao lmonit
    msgprompt = 1
    listaitem i
    epara i = lmonit.ini, i, i.depois
      i.obj.msg(">" + arg0, 1), i.obj.msgprompt = 1
    efim
  senao
    msgprompt = 1
  fimse
  casovar jogconfig.bits & 12
  casose "0" # -CORES -ACENTO
    ret msgsock("\b" + txtremove(arg0, "C7"))
  casose "4" # +CORES -ACENTO
    ret msgsock(txtremove(arg0, "7"))
  casose "8" # -CORES +ACENTO
    ret msgsock("\b" + txtremove(arg0, "C"))
  casose "12" # +CORES +ACENTO
    ret msgsock(arg0)
  casofim

func msgprompt_exec
  se !perso
  senao perso.atkenv
    ret !jogconfig.7, nulo
    txt150 t1
    t1 = perso.var.z_bprompt
    t1 = $mens_prompt.mens(t1, perso)
    msg(t1, 1)
  senao
    ret !jogconfig.6, nulo
    txt150 t1
    t1 = perso.var.z_prompt
    t1 = $mens_prompt.mens(t1, perso)
    t1 = $mens_prompt.mens(perso.var.z_prompt, perso)
    msg(t1, 1)

func vazio_exec
  msg("Muito tempo sem comunicação")
  apagar(este)


classe jog_entra
# Entrando no jogo

func p_perso # Digitar o nome do personagem
  indiceitem ind
  txt20 texto
  arqsav sav1
  passo = "perso", tpasso = nome = cnome = ""
  texto = txtnome(arg0)
  se !arg0
    msg("Digite o nome do seu personagem")
  senao inttotal(arg0) < 3 || inttotal(arg0) > 16
    msg("O nome deve ter de 3 a 16 caracteres; digite outro")
  senao intnome(arg0) || txtproc(arg0, " ") >= 0
    msg("Nome inválido; digite outro")
  senao ind.obj("un " + texto)
    msg("Nome já está sendo usado; digite outro")
  senao !sav1.existe("sav/" + texto + ".sav") # Novo personagem
    cnome = "un " + texto
    nome = txtmaimin(arg0)
    msg("Criando personagem " + nome)
    config:salvacria ? p_criasenha1 : p_sexo1
    p_sexo
  senao
    msg("Personagem '" + txtmaimin(arg0) + "' já existe")
    tpasso = txtmaimin(arg0)
    p_entrasenha
  fimse
  ret 1

func p_criasenha1 # Digitar a senha ao criar personagem
  passo = "criasenha1"
  tpasso = txt1(tpasso)
  se !arg0
    msg("Digite uma senha para o personagem")
  senao inttotal(arg0) < 5 || inttotal(arg0) > 16
    msg("A senha deve ter de 5 a 16 caracteres, digite outra")
  senao intsenha(arg0) == 3
    msg("Senha deve ter letras e números, digite outra")
  senao intsenha(arg0)
    msg("Senha inválida, digite outras")
  senao
    var.j_senha = arg0
    p_criasenha2
  fimse
  ret 1

func p_criasenha2 # Repetir a senha ao criar personagem
  passo = "criasenha2"
  se !arg0
    msg("Digite novamente a senha")
  senao arg0 != var.j_senha
    msg("As senhas são diferentes")
    var.limpar("j_")
    p_perso
  senao
    p_sexo1
  fimse
  ret 1

func p_sexo1 # Digitar O ou A
  passo = "sexo1"
  se arg0 != "O" && arg0 != "A"
    msg("Você é homem ou mulher? Tecle O ou A")
    ret 1
  fimse
  var.j_sexo = arg0 == "O" # 0=feminino, 1=masculino
  ret p_raca1

func p_raca1 # Digitar a raça
  passo = "raca1"
  casovar arg0
  casose "1"
    var.j_tipo1 = "Anão"
    sair
  casose "2"
    var.j_tipo1 = "Humano"
    sair
  casose "3"
    var.j_tipo1 = "Elfo"
    sair
  casose "4"
    msg("Anões, além da estatura pequena, são mais fortes fisicamentes, porém")
    msg("mais fracos quando se trata de magia.")
    msg("Já os elfos lidam melhor com magia e são mais rápidos, porém mais")
    msg("fracos fisicamente.")
    msg("Os humanos constituem uma raça mais equilibrada.")
    ret 1
  casose
    msg("Escolha a raça digitando um número de 1 a 4:")
    msg("1. Anão\n2. Humano\n3. Elfo\n4. Mais informações")
    ret 1
  casofim
  ret p_entrajogo

func p_entrajogo # Entrar no jogo: cria personagem
  passo = ""
  jogconfig.bits = 63 # Configurações iniciais
  msg("Iniciando jogo; para ajuda tecle AJUDA")
  mudaperso(criar("jogador"))
  perso.cnome = "pn " + txt2(cnome)
  perso.nome = nome
  perso.jogconfig.bits = jogconfig.bits
  perso.sexo = var.j_sexo
  perso.senha = var.j_senha
  perso.tipo1 = var.j_tipo1
  var.limpar("j_")
  perso.mudadono(config:salaini)
  perso.recalc = 1
  se perso.senha
    !perso.salvar && msg("Não foi possível salvar o personagem")
  fimse
  $mens.p(perso)
  $mens.mvis2("", "$P chegou.")
  temposair # Acerta tempo para sair do MUD
  ret 1

func p_entrasenha # Entrar com a senha para carregar jogo salvo
  indiceitem ind
  txt20 texto
  arqsav sav1
  ref r
# msg(texto + " , " + arg0)
  texto = txtnome(tpasso)
  passo = "entrasenha"
  se !arg0
    msg("Digite a senha ou, se o personagem não for seu, tecle Z")
  senao arg0 == "z"
    nome = "", p_perso
  senao ind.obj("un " + texto)
    msg("Outro jogador começou a usar esse personagem")
    p_perso
  senao !sav1.senha("sav/" + texto + ".sav", txtmin(arg0))
    msg("Senha incorreta")
    casovar txt1(info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(este)
      ret
    casofim
    p_perso
  senao ind.obj("pn " + texto)
    passo = ""
    mudaperso(ind.obj("pn " + texto))
    nome = perso.nome
    cnome = "un " + texto
    jogconfig.bits = perso.jogconfig.bits
    msg("Reconectado")
    perso.teclou("ver")
    temposair # Acerta tempo para sair do MUD
  senao
# Primeiro cria personagem
    passo = ""
    nome = tpasso
    cnome = "un " + texto
    mudaperso(criar("jogador"))
    perso.cnome = "pn " + texto
    perso.nome = nome
    perso.senha = txtmin(arg0)
# Carrega personagem
    listaobj l1
    l1.addfim(perso)
    sav1.ler("sav/" + texto + ".sav", l1)
    nome = perso.nome
    jogconfig.bits = perso.jogconfig.bits
# Acerta variáveis
    listaitem item
    debug d
    epara item = l1.fim, item, item.antes
      d.exec = 5000
      !item.obj.dono && !item.obj.jog && apagar(item.obj)
      item.obj.var.limpar("d_", "j_")
      item.obj.ajustapeso, item.obj.ajustaev
      item.obj.recalc = 1
    efim
# Muda de sala e volta ao jogo
    msg("Continuando jogo salvo.")
    ref r
    r = $[perso.salanome]
    perso.mudadono(r ? r : config:salasav)
    $mens.p(arg0)
    $mens.mvis2("", "$P chegou.")
    perso.salvarev = 3000 # 5 minutos
    temposair # Acerta tempo para sair do MUD
  fimse
  ret 1

func p_mudasenha1 # Digitar a senha atual para mudar a senha
  passo = "mudasenha1"
  se !arg0
    msg("Digite a senha atual do personagem ou z para desistir")
  senao arg0 == "z"
    passo = ""
    msg("Cancelado")
  senao arg0 != perso.senha
    msg("Senha incorreta; cancelado")
    passo = ""
  senao
    p_mudasenha2
  fimse
  ret 1

func p_mudasenha2 # Digitar a nova senha
  passo = "mudasenha2"
  se !arg0
    msg("Digite a nova senha do personagem ou Z para desistir")
  senao arg0 == "z"
    passo = ""
    msg("Cancelado")
  senao inttotal(arg0) < 5 || inttotal(arg0) > 16
    msg("A senha deve ter de 5 a 16 caracteres, digite outra")
  senao intsenha(arg0) == 3
    msg("Senha deve ter letras e números, digite outra")
  senao intsenha(arg0)
    msg("Senha inválida, digite outras")
  senao
    tpasso = arg0
    p_mudasenha3
  fimse
  ret 1

func p_mudasenha3 # Repetir a senha digitada
  passo = "mudasenha3"
  se !arg0
    msg("Digite novamente a senha")
  senao tpasso != arg0
    msg("As senhas são diferentes; cancelado")
    passo = ""
  senao
    perso.senha = txtmin(arg0)
    msg(perso.salvar ? "Jogo salvo" : "Não foi possível salvar")
    passo = ""
  fimse
  ret 1


classe jogador
herda comum_persoanimal, perso_restaurar
# Personagem no jogo
const jog = 1 # Para identificar que é jogador
const ident = nome
indiceobj cnome # "pn " + nome codificado (usado ao reconectar)
sav txt20 nome # Nome do personagem
sav txt40 salanome # Nome da sala
sav int1 jogconfig.24 # Para salvar sock.jogconfig
inttempo vazio1 # Tempo para mensagem que vai sair do MUD
inttempo vazio2 # Tempo sem comunicação para desconectar do MUD
txt20 senha # Senha do jogo salvo, ou "" se não estiver salvo
const jogsav = 1 # Necessário para salvar o personagem do jogador
inttempo salvarev # Para salvar o jogo de tempos em tempos
sav inttempo tempojogo1 # Em décimos de segundo, até 24 horas
sav uint16 tempojogo2 # Dias, para contar o tempo de jogo
const pesoobj = 65000
txt16 tipo1 # Raça do jogador; vide misc:tipo_* em mud-misc.int

func ini # Objeto foi criado
  tempojogo1 = 864000
  nivel = 1
  var.z_prompt = "<%hhp %mmn %vmv> "
  var.z_bprompt = "<%hhp %mmn %vmv> "
  comum_persoanimal:ini

func fim # Objeto foi apagado
  salvar
  se posicao
    $mens.p(este)
    $mens.mvis2("", "$P foi embora.")
  fimse
  comum_persoanimal:fim

func fechou # Executado quando o objeto sock é apagado
  vazio1 = 1800 # 3 minutos
  vazio2 = 2400 # 4 minutos
  senha == "" && apagar(este)

func mudasenha # Usuário escolhe mudar a senha ou salvar pela primeira vez
  senha ? sock.p_mudasenha1 : sock.p_mudasenha2

func tempojogo1_exec
  tempojogo1 = 864000, tempojogo2 += 1

func salvar # Salva o jogo, desde que a senha não seja nula
# Retorna verdadeiro se conseguiu salvar
  ret !senha, 0
  listaitem item
  listaobj lista
  arqsav sav1
  debug dbg
  lista.addfim(este)
  dbg.exec = 20000
  item = lista.ini
  enquanto item
    se !item.obj.jogsav
      item.removedepois
    senao lista.total < 1000
      lista.addfim(item.obj.dentro1, item.obj.dentro2), item.depois
    senao
      item.depois
    fimse
  efim
  salanome = dono
  salvarev = 3000 # 5 minutos
# msg(txt2(cnome) + " , " + senha)
  dbg.exec = 2000
  ret !lista.total, 0
  ret sav1.salvar("sav/" + txt2(cnome) + ".sav", lista, 30, senha)

func salvarev_exec
  salvar

func vazio1_exec # Próximo de sair do MUD
  $mens.p(este)
  $mens.mvis1("$P caminha em direção ao vazio.")

func vazio2_exec # Sair do MUD automaticamente
  apagar(este)

func cmd_recalc1 # Recalcula variáveis do personagem
  pnivel < 10 && (pvidamax += 50 - pnivel * 5)
  jogconfig.18 && (bitinv = bitinv | 128) # Propriedade config +invsala
  jogconfig.23 && (bitver = bitver | 128) # Se é administrador
