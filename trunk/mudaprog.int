classe mudaprog
# Recarrega os arquivos que mudaram (checa pela data dos arquivos)
# Para recarregar os arquivos:
# $mudaprog.exec
# As mensagens com o resultado são enviadas para a função msg dessa classe
#
prog p
debug d
real datamudou # Quando os arquivos foram atualizados pela última vez
textotxt arqmudou # Sufixo dos arquivos que mudaram
textovar apagarcl # Classes que serão apagadas
textovar mudarcl # Novo conteúdo das classes
textovar inicl # Classes que serão inicializadas (funçao iniclasse)
intexec passofunc # Para mudar classes
uint8 passonum # Número do passo atual

func iniclasse
  criar(arg0)

func ini
  datahora dh
  dh.agora, datamudou = dh.numtotal

func exec # Recarrega arquivos
  passonum = 1, passofunc = 1
# msg("[" + datamudou + "]")

func msg
  telatxt tela
  tela.msg(arg0 + "\n")

func passofunc_exec # Próximo passo para alterar programa
  se passo[passonum]
    passofunc = 1, passonum += 1

func passo1 # Atualiza lista de arquivos que mudaram
# Acerta variável: textotxt arqmudou
  datahora dh
  arqdir dir
  txt100 nomeint
  txt100 t1
  arqmudou.limpar
  epara p.iniarq, p, p.depois
    dir.tipo(p.arqnome(p.texto)) != "A" && arqmudou.addfim(p.texto + "=1")
  efim
  nomeint = p.arqnome("")
  nomeint = txt(nomeint, 0, inttotal(nomeint) - 4)
  epara dir.abrir("."), dir.lin, dir.depois
    continuar txtfim(dir.texto, 4) != ".int"
    continuar txt(dir.texto, 0, inttotal(nomeint)) != nomeint
    t1 = dir.mtempo(dir.texto)
    dh.ano = txt1(t1)
    dh.mes = txtsub(t1, 1, 1)
    dh.dia = txtsub(t1, 2, 1)
    dh.hora = txtsub(t1, 3, 1)
    dh.min = txtsub(t1, 4, 1)
    dh.seg = txtsub(t1, 5, 1)
    continuar dh.numtotal < datamudou
    t1 = txt(dir.texto, inttotal(nomeint))
    se t1 == ".int"
      arqmudou.addfim("")
    senao txt(t1, 0, 1) == "-"
      arqmudou.addfim(txt(t1, 1, inttotal(t1) - 5))
    fimse
  efim
  ret 1

func passo2 # Adiciona classes dos arquivos que mudaram
# Acerta variável: textovar apagarcl
  textopos p1
  apagarcl.limpar
  epara p1 = arqmudou.ini, p1, p1.depois
    epara p.iniarq(p1.texto), p.lin, p.depois
      apagarcl.mudar(p.texto + "=1")
    efim
    d1.exec = 5000
  efim
  ret 1

func passo3 # Lê arquivos e cria classes novas, porém vazias
# Atualiza variáveis apagarcl, mudarcl e inicl
  textopos p1
  textopos p2
  textotxt t1
  inicl.limpar
  epara p1 = arqmudou.ini, p1, p1.depois
# Lê arquivo
    se !t1.ler(p.arqnome(p1.texto), 0)
      msg("Não foi possível abrir arquivo: " + p.arqnome(p1.texto))
      ret 0
    fimse
    t1.addini("") # Adiciona linha em branco no começo do arquivo
# Junta linhas
    epara p2 = t1.fim, p2.linha, p2.antes
      continuar txtfim(p2.texto, 1) != "\\"
      p2.mudar("", inttotal(p2.texto) - 1, 1)
      p2.depois, p2.juntar, d.exec = 10000
    efim
# Obtém as classes
    epara p2 = t1.fim, p2.linha, p2.antes
      continuar txt1(p2.texto) != "classe" || !txt2(p2.texto)
      d.exec = 10000
      txt100 nome
      nome = txt2(p2.texto) # Nome da classe
      apagarcl.mudar(nome + "=") # Retira classe da lista
      p2.remove # Para ficar só o conteúdo da classe
      mudarcl.mudar(nome + "=" + p1.texto + "\n" + p2.textolin(10000))
# msg("CLASSE: " + nome + "," + p1.texto)
# msg("MUDAR: " + mudarcl.valor(nome))
      p2.remove(10000)
      continuar p.existe(nome) # Checa se classe já existe
      p.criar(nome + "\n" + p1.texto + "\n") # Cria classe vazia
      inicl.mudar(nome + "=1") # Marca como "inicializar"
# msg("CRIAR: " + nome + "\n" + p1.texto)
    efim
  efim
  ret 1

func passo4 # Muda as classes
  txt100 nome
  textotxt erros
# Checa instruções das classes que serão mudadas
  nome = mudarcl.ini
  enquanto nome
    textotxt t1
    t1.addfim(mudarcl.valor(nome))
    t1.remove
    t1.addfim(p.classe(nome, t1.remove(10000)))
# msg("Ao mudar " + nome + ": " + t1.ini.texto)
    casovar t1.ini.texto
    casose "0" # Classe está diferente
      nome = mudarcl.depois(nome)
      sair
    casose "1" # Classe está igual
      txt100 t2
      t2 = mudarcl.depois(nome)
      mudarcl.mudar(nome + "=")
      nome = t2
      sair
    casose # Erro
      nome = mudarcl.depois(nome)
      erros.addfim("ERRO CLASSE " + nome + ":\n" + t1.remove(1000))
    casofim
  efim
# Termina se ocorreu algum erro
  se erros.linhas
    msg(erros.remove(1000))
    passoerro
    ret 0
  fimse
# Muda as classes
  epara nome = mudarcl.ini, nome, nome = mudarcl.depois(nome)
    se p.criar(nome + "\n" + mudarcl.valor(nome))
      erros.addfim("Erro ao alterar classe " + nome)
    fimse
  efim
# Termina se ocorreu algum erro
  se erros.linhas
    msg(erros.remove(1000))
    passoerro
    ret 0
  fimse
# Limpa as classes pendentes para apagar
  epara nome = apagarcl.ini, nome, nome = apagarcl.depois(nome)
    p.criar(nome + "\n" + p.arquivo(nome))
  efim
  ret 1

func passo5 # Apaga as classes pendentes e inicializa outras classes
  textotxt t1
  textotxt t2
  txt100 nome
  epara nome = apagarcl.ini, nome, nome = apagarcl.depois(nome)
    !p.apagar(nome) && t1.addfim("Erro ao apagar classe: " + nome + "\n")
  efim
# Acerta tempo da última alteração
  datahora dh
  dh.agora, datamudou = dh.numtotal + 1
# Classes criadas
  epara nome = inicl.ini, nome, nome = inicl.depois(nome)
    t2.addfim(nome)
  efim
  t2 && t1.addfim("Criado: " + txttroca(t2.remove(1000), "\n", ", "))
# Classes apagadas
  epara nome = apagarcl.ini, nome, nome = apagarcl.depois(nome)
    t2.addfim(nome)
  efim
  t2 && t1.addfim("Apagado: " + txttroca(t2.remove(1000), "\n", ", "))
# Classes alteradas
  epara nome = mudarcl.ini, nome, nome = mudarcl.depois(nome)
    t2.addfim(nome)
  efim
  t2 && t1.addfim("Mudado: " + txttroca(t2.remove(1000), "\n", ", "))
# Mensagem na tela
  mudarcl.limpar
  apagarcl.limpar
  se t1
    msg("MUDANÇAS:\n" + t1.remove(1000))
  senao
    msg("MUDANÇAS:\nNada mudou")
  fimse
  ret 1

func passo6 # Inicializa classes
  txt100 nome
  nome = inicl.ini
  se nome
    inicl.mudar(nome + "=")
    passofunc = 1
    [nome]:iniclasse(nome)

func passoerro # Ocorreu algum erro
# Apaga classes criadas
  txt100 nome
  epara nome = inicl.ini, nome, nome = inicl.depois(nome)
    p.apagar(nome)
  efim
  apagarcl.limpar
  inicl.limpar
  mudarcl.limpar
