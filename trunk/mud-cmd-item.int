classe cmd_acender
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Acender\b\n\
Sintaxe: ACENDER <objeto>\n\
Acende um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Acender o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dentro1, arg0.dono.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode acender
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue acender " + r.descnome + ".")
    senao !r.luztempo
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " não acende mais.")
    senao r.luztempo > 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está aces" + (r.msexo ? "o." : "a."))
    senao r.luzitem == 6 # Se requer fogo para acender
      l.limpar
      epara l.addfim(arg0.dentro1, arg0.dono.dentro1), l, l.ini.remove
        sair int(l.objini.luzitem) >= 3 && int(l.objini.luztempo) > 0
      efim
      ret !l.objini, arg0.msg("Você precisa de fogo para acender " + r.descnome + ".")
    senao r.luzitem == 7 # Se acende ao vestir
      ret arg0.msg("Você acenderá " + r.descnome + " quando usar.")
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acender(arg0, r), nulo
    efim
# Acende
    r.luztempo.pos, r.recalc = 1, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1(r.luzliga ? r.luzliga : "$P acende $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acendeu(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_apagar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Apagar\b\n\
Sintaxe: APAGAR <objeto>\n\
Apaga um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Apagar o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dentro1, arg0.dono.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode apagar
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue apagar " + r.descnome + ".")
    senao !r.luztempo || r.luztempo < 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está apagad" + (r.msexo ? "o." : "a."))
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagar(arg0, r), nulo
    efim
# Apaga
    r.luztipo == 5 ? (r.luztempo = 0) : r.luztempo.neg, r.recalc = 1, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1("$P apaga $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagou(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_pegar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Pegar\b\n\
Sintaxe: PEGAR <objeto>\n\
         PEGAR <quantidade> <objeto>\n\
         PEGAR <objeto> <container>\n\
         PEGAR <quantidade> <objeto> <container>\n\
Pega um objeto do chão ou de um container (uma bolsa, uma estante, etc).\n\
Para pegar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const posic = 5
#
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
ref r # Objeto sendo pego
txt20 mens # Parte da mensagem
int8 achou # Quantos itens achou
txt100 erro # Mensagem de erro

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_pegar(arg0, arg1), nulo
  efim
  arg0.p_espera < 3 && (arg0.p_espera = 3)
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2 && !arg0.jogconfig.14
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.msexo ? "o." : \
"a."))
    fimse
    mens = " $d $a."
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, misc:objmax, misc:tudo)
# Pega os itens
  achou = 0, erro = "Você não vê isso."
  epara l.addfim(sala.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    r = l.objini # Nota: r pode mudar após r.mudadono
    se r.i_pegar
      erro = r.i_pegar
      continuar
    senao r.persolugar
      casovar r.persolugar.objini.posicao
      casose "4"
        erro = "Você não consegue pegar porque tem alguém dormindo em cima."
        sair
      casose "5"
        erro = "Você não consegue pegar porque tem alguém descansando em cima."
        sair
      casose "6"
        erro = "Você não consegue pegar porque tem alguém sentado em cima."
        sair
      casose
        erro = "Você não consegue pegar porque tem alguém em cima."
      casofim
      continuar
    senao arg0.dentro1.total + (r.item == 2 ? 1 : total) > arg0.objmax
      erro = "Você não consegue carregar tanta coisa."
      continuar
    senao arg0.volden + r.voltot * total / r.objtot > arg0.volmax
      erro = "Você não consegue carregar tanta coisa."
      continuar
    senao arg0 == sala.dono
    senao arg0.pesoden - arg0.pesoveste + r.pesotot * total / r.objtot > arg0.pesomax
      se r.pesotot > r.objtot * arg0.pesomax * 2
        erro = "É pesado demais."
      senao
        erro = "Você não consegue carregar tanto peso."
      fimse
      continuar
    senao (arg0.objnum >> 1) + (r.objnum >> 1) > config:itens
      erro = "Você não consegue carregar tanta coisa."
      continuar
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_pegarobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P pega $o" + mens)
    senao
      $mens.mvis1("$P pega " + total + "x $o" + mens)
    fimse
    r = r.mudadono(arg0, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_pegouobj(arg0, sala, r, total)
    efim
    arg0.p_espera += 2
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Pega moedas
  se sala.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", sala.var.z_moedas_)
    total = int(misc:sep1) ? n : sala.var.z_moedas
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_pegarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ -= total
    sala.var.z_moedas_ < 0 && (sala.var.z_moedas = "")
    arg0.var.z_moedas_ += total
    sala.objmudou = 1
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P pega uma moeda" + mens)
    senao total == 2
      $mens.mvis1("$P pega duas moedas" + mens)
    senao
      $mens.mvis1("$P pega " + total + " moedas" + mens)
    fimse
    arg0.p_espera += 2
    ret
  fimse
# Não encontrou o item
  arg0.msg(erro)


classe cmd_soltar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta1 + ta2 + ta3 + ta4 : ta1 + ta3
const ta1 = "\b\c3Soltar\b\n\
Sintaxe: SOLTAR <objeto>\n\
         SOLTAR <quantidade> <objeto>\n\
         SOLTAR <objeto> <container>\n\
         SOLTAR <quantidade> <objeto> <container>\n"
const ta2 = "         SOLTAR <número do animal>\n"
const ta3 = "Solta um objeto no chão ou em um container (uma bolsa, uma estante, etc).\n\
Para soltar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const ta4 = "\nPermite também soltar algum animal (se desfazer) que você possuir."
const posic = 5
#
const cmdsg = 0 # 0=comando soltar, 1=comando guardar
ref sala # Aonde soltar os itens
uint32 total # Quantidade de itens do mesmo tipo
ref r # Objeto sendo pego
txt20 mens # Parte da mensagem
txt80 mens2 # Outra parte da mensagem
int8 achou # Quantos itens achou
txt100 erro # Mensagem de erro
int8 soltar # Se pode soltar itens

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
  arg0.p_espera < 3 && (arg0.p_espera = 3)
# Checa soltar animal
  se !cmdsg && arg1 == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar == 2, arg0.msg("Não é possível soltar esse animal.")
    listaobj e
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      ret e.objini.cmd_soltaranim(arg0, r, arg0.dono), nulo
    efim
    ret r.dono != arg0, nulo # Retorna se não possui mais o animal
    $mens.p(arg0, r)
    $mens.mvis1("$P se despede $d $a e $b vai embora.")
    apagar(r) # Apaga animal
    r.mdono(nulo) # Indica que não tem o animal
    arg0.recalc = 1 # Acerta personagem
    arg0.persobat == r && (arg0.persobat = arg0)
    arg0.persoesc == r && (arg0.persoesc = arg0)
    arg0.escolhebat # Escolhe um animal em condições de batalhar
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      e.objini.cmd_soltouanim(arg0, r, arg0.dono)
    efim
    ret
  fimse
# Obtém o objeto de onde soltar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    ret cmdsg, arg0.msg("Guardar aonde?")
    sala = arg0.dono
    soltar = sala.s_soltar
    mens = ""
    ret soltar == 1, arg0.msg("Você não consegue soltar itens aqui.")
  senao
    soltar = 0
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2 && !arg0.jogconfig.14
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.msexo ? "o." : \
"a."))
    fimse
    mens = " $e $a"
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, misc:objmax, misc:tudo)
# Solta os itens
  achou = 0, erro = "Você não vê isso."
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    r = l.objini # Nota: r pode mudar após r.mudadono
    se r == sala # Soltar o objeto dentro dele mesmo
      se sala.msexo
        erro = "Não é possível colocar " + sala.descnome + " dentro dele mesmo."
      senao
        erro = "Não é possível colocar " + sala.descnome + " dentro dela mesma."
      fimse
      continuar
    senao sala.dentro1.total + (r.item == 2 ? 1 : total) >= sala.objmax
      se sala.item
        erro = sala.descnome + "."
        casovar txtmin(txt1(erro))
        casose "o"
          erro = "Não consegue colocar mais nada no " + txt2(erro)
          sair
        casose "a"
          erro = "Não consegue colocar mais nada na " + txt2(erro)
          sair
        casose "os"
          erro = "Não consegue colocar mais nada nos " + txt2(erro)
          sair
        casose "as"
          erro = "Não consegue colocar mais nada nas " + txt2(erro)
          sair
        casose
          erro = "Não consegue colocar mais nada em " + erro
        casofim
      senao
        erro = "Não consegue soltar nada aqui."
      fimse
      continuar
    senao sala.volden + r.voltot * total / r.objtot > sala.volmax
      erro = "Não há espaço suficiente para soltar isso."
      continuar
    fimse
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_soltarobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    mens2 = mens ? "$P coloca " : "$P solta "
    mens2 += total <= 1 ? "$o" : txt(total) + "x $o"
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      r.apagar(total)
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      r.apagar(total)
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      r.apagar(total)
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      r = r.mudadono(sala, total)
    casofim
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_soltouobj(arg0, sala, r, total)
    efim
    arg0.p_espera += 2
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Solta moedas
  se arg0.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_soltarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && (arg0.var.z_moedas = "")
    $mens.p(arg0, sala)
    mens2 = mens ? "$P coloca " : "$P solta "
    se total == 1
      mens2 += "uma moeda"
    senao total == 2
      mens2 += "duas moedas"
    senao
      mens2 += txt(total) + " moedas"
    fimse
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      sala.var.z_moedas_ += total
      sala.objmudou = 1
    casofim
    arg0.p_espera += 2
    ret
  fimse
# Não encontrou o item
  arg0.msg(erro)


classe cmd_guardar
herda cmd_soltar
const cmdsg = 1
const txtajuda = "\b\c3Guardar\b\n\
Sintaxe: GUARDAR\n\
         GUARDAR <objeto> <container>\n\
         GUARDAR <quantidade> <objeto> <container>\n\
Coloca um objeto dentro de um container (uma bolsa, uma estante, etc).\n\
Para guardar tudo (até 10 objetos) tecle TUDO ao invés do objeto."


classe cmd_dar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta2 : ta1
const ta1 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
Dá um objeto para outro personagem."
const ta2 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
         DAR <número do animal> <personagem>\n\
Dá um objeto ou animal para outro personagem."
const posic = 5
#
ref sala # Para quem dar os itens
uint32 total # Quantidade de itens do mesmo tipo
ref r # Objeto sendo pego
txt20 mens # Parte da mensagem
int8 achou # Quantos itens achou
txt100 erro # Mensagem de erro

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_dar(arg0, arg1), nulo
  efim
# Dar animal a outro personagem
  se txt1(arg1) == intpos(arg1) && int(arg1) && intsub(arg1) <= 2 && config:animal1 >= arg1
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar, arg0.msg("Não é possível dar esse animal.")
    ret !txt2(arg1), arg0.msg("Dar " + arg1 + " para quem?")
    listaobj l
    nomeobj n
    n.ini(txt2(arg1), 1)
    epara l.addfim(arg0.dono.dentro2), l, l.ini.remove
      continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident)
      se i.obj == arg0
        ret arg0.msg("Dar para você mesm" + (arg0.msexo ? "o?" : "a?"))
      senao !l.objini.jog
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não é jogador.")
      senao !l.objini.animalmais
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não tem espaço para receber \
animal.")
      fimse
      listaobj e
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        ret e.objini.cmd_daranim(arg0, r, l.objini), nulo
      efim
      ret r.dono != arg0, nulo # Retorna se não possui mais o animal
      ret !l.objini.animalmais, nulo
      arg0.recalc = 1, l.objini.recalc = 1 # Acerta personagens
      r.mdono(l.objini) # Muda de dono
      arg0.persobat == r && (arg0.persobat = arg0)
      arg0.persoesc == r && (arg0.persoesc = arg0)
      arg0.escolhebat # Escolhe um animal em condições de batalhar
      $mens.p(arg0, l.objini)
      $mens.mvis1("$P dá " + r.descnome + " para $a.")
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        e.objini.cmd_deunim(arg0, r, l.objini)
      efim
      ret
    efim
    ret arg0.msg("Você não vê " + txt2(arg1) + ".")
  fimse
# Obtém para quem dar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  ret !misc:sep2, arg0.msg("Dar itens para quem?")
  sala = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
  se !sala
    ret arg0.msg("Você não vê " + misc:sep2 + ".")
  senao !sala.p_recebe
    ret arg0.msg("Não é possível dar nada para " + sala.descnome + ".")
  senao sala == arg0
    ret arg0.msg("Dar para você mesm" + (arg0.msexo ? "o?" : "a?"))
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, misc:objmax, misc:tudo)
# Dá os itens
  achou = 0, erro = "Você não vê isso."
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    r = l.objini # Nota: r pode mudar após r.mudadono
    se sala.dentro1.total + (r.item == 2 ? 1 : total) >= sala.objmax
      erro = txtcopiamai(sala.descnome, "A") + " não consegue carregar mais nada."
      continuar
    senao sala.volden + r.voltot * total / r.objtot > sala.volmax
      erro = txtcopiamai(sala.descnome, "A") + " não consegue carregar isso."
      continuar
    senao sala.pesoden - sala.pesoveste + r.pesotot * total / r.objtot > sala.pesomax
      erro = "É pesado demais para " + txtcopiamai(sala.descnome, "A") + "."
      continuar
    senao (sala.objnum >> 1) + (r.objnum >> 1) > config:itens
      erro = txtcopiamai(sala.descnome, "A") + " não consegue carregar isso."
      continuar
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_darobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P dá $o para $a.")
    senao
      $mens.mvis1("$P dá " + total + "x $o para $a.")
    fimse
    r = r.mudadono(sala, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_deuobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Dá moedas
  se arg0.var.z_moedas_ && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_darmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ += total
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && arg0.var.z_moedas = ""
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P dá uma moeda para $a.")
    senao total == 2
      $mens.mvis1("$P dá duas moedas para $a.")
    senao
      $mens.mvis1("$P dá " + total + " moedas para $a.")
    fimse
    ret
  fimse
# Não encontrou o item
  arg0.msg(erro)


classe cmd_usar
herda comando_comum
const objcmd = $cmd_vestir
const objajuda = $cmd_vestir


classe cmd_vestir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Vestir\b\n\
Sintaxe: VESTIR <objeto> [posição]\n\
         USAR <objeto> [posição]\n\
Seu personagem veste ou usa um objeto que está carregando.\n\
Para vestir tudo (até 10 objetos) tecle TUDO ao invés do objeto.\n\
Para saber em que posições pode vestir algo, tecle EQUIP TUDO"
const posic = 5
txt30 tipo1 # alvo.tipo1
txt30 tipo2 # alvo.tipo2
txt30 tipo3 # alvo.tipo3
ref alvo # Quem vai vestir

func escr
  ret !arg1, arg0.msg("Vestir o que?")
  alvo = arg0.persoesc
  tipo1 = alvo.tipo1 ? "\n" + alvo.tipo1 + "\n" : ""
  tipo2 = alvo.tipo2 ? "\n" + alvo.tipo2 + "\n" : ""
  tipo3 = alvo.tipo3 ? "\n" + alvo.tipo3 + "\n" : ""
# Variáveis
  int32 lugar # Aonde quer vestir
  int1 vest.32 # Aonde está vestindo
  int8 total # Quantidade de itens encontrados
  nomeobj n # Para reconhecer os itens
  listaitem item
# Preenche a variável vest com o que está vestindo
  epara item = alvo.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Descobre aonde quer vestir
  misc:separa(arg1) # Separa nome do objeto do nome da posição
  se !misc:sep2
    lugar = alvo.equippos # Todas as posições que possui
  senao
    n.ini(misc:sep2, 100)
    textotxt t
    textopos pos
    t.addfim(config:equip_txt)
    refvar lug2 = ~alvo.equippos
    epara pos = t.ini, pos, pos.depois
      continuar lug2 & intbit(pos.linha)
      n.nome(pos.texto) && (lugar = lugar | intbit(pos.linha))
    efim
    ret !lugar, arg0.msg("Você não sabe aonde fica " + misc:sep2 + ".")
  fimse
# Veste
  listaobj l
  ref r
  n.ini(misc:sep1, misc:objmax, misc:tudo)
  epara l.addfim(alvo.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    total += n
    $mens.p(alvo, nulo, r)
# Vestir - checa se o personagem pode vestir
    se r.vestirsim == (alvo == arg0 ? 2 : 1)
      $mens.mperso("$P não consegue vestir $o.")
      continuar
# Vestir - checa o nível
    senao int(r.pnivel) > alvo.pnivel
      $mens.mperso("$P precisa estar no nível " + r.pnivel + " para vestir $o.")
      continuar
    fimse
    uint8 x
    epara x = n, x, x -= 1
# Vestir - checa se o item pode ser vestido
      refvar lugar2 = lugar & r.vestir1
      se !lugar2
        se !r.vestir1
          $mens.mperso("Não se pode vestir $o.")
        senao
          $mens.mperso("$P não consegue vestir $o.")
        fimse
        sair
# Vestir - checa se a classe ou a raça tem permissão
      senao !r.vestirnao
      senao tipo1 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo1) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      senao tipo2 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo2) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      senao tipo3 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo3) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      fimse
# Vestir - checa se o item deixa
      txt100 txtvestir
      txtvestir = r.cmd_podevestir(alvo)
      ret txtvestir, $mens.mperso(txtvestir)
# Vestir - checa os itens que estão em cima
      int32 erro1 # Posição aonde já está vestindo o item
      int32 erro2 # Posições aonde tem itens em cima
      uint8 pos
      epara pos = 0, pos < 32, pos += 1
        continuar !(lugar2 >> pos & 1) # Checa se é o lugar
        se vest.[pos]
          erro1 = pos + 1
        senao (erro2 = vest.bits & config:vestir[pos]) == 0
          erro1 = 0
          sair
        fimse
      efim
# Vestir - mensagens de erro
      se erro2
        epara item = alvo.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair erro2 & intbit(item.obj.vestpos - 1)
        efim
        arg0.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
        sair
      senao erro1
        epara item = alvo.dentro2.ini, item, item.depois
          sair item.obj.vestpos == erro1
        efim
        arg0.msg("Já está usando " + item.obj.descnome + " nessa posição.")
        sair
# Veste o item
      senao
        listaobj e
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_vestir(alvo, r, pos + 1), nulo
        efim
        r.vestir(pos + 1)
        vest.[pos] = 1
        refvar mvestir = txtsublin(config:equip_vestir, pos, 1)
        $mens.mvis1(mvestir ? mvestir : "$P veste $o.")
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          e.objini.cmd_vestiu(alvo, r, pos + 1)
        efim
      fimse
    efim
  efim
# Avisa se não encontrou nenhum item
  !total && arg0.msg("Você não vê isso.")


classe cmd_empunhar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Empunhar\b\n\
Sintaxe: EMPUNHAR <objeto>\n\
Seu personagem empunha uma arma que está carregando."
const posic = 5
txt30 tipo1 # alvo.tipo1
txt30 tipo2 # alvo.tipo2
txt30 tipo3 # alvo.tipo3
ref alvo # Quem vai empunhar

func escr
  ret !arg1, arg0.msg("Empunhar o que?")
  alvo = arg0.persoesc
  ret alvo.iempu, $mens.p(alvo) + $mens.mperso("$P já está empunhando uma arma.")
  tipo1 = alvo.tipo1 ? "\n" + alvo.tipo1 + "\n" : ""
  tipo2 = alvo.tipo2 ? "\n" + alvo.tipo2 + "\n" : ""
  tipo3 = alvo.tipo3 ? "\n" + alvo.tipo3 + "\n" : ""
# Empunha
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, misc:objmax)
  epara l.addfim(alvo.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    $mens.p(alvo, nulo, r)
    se !r.armatipo
      ret $mens.mperso("$O não é arma.")
    senao r.vestirsim == (alvo == arg0 ? 2 : 1)
      ret $mens.mperso("$P não consegue vestir $o.")
    senao int(r.pnivel) > alvo.pnivel
      ret $mens.mperso("$P precisa estar no nível " + r.pnivel + " para empunhar $o.")
    senao !alvo.var.h_[txtsublin(config:arma_txt, r.armatipo, 1)]
      ret $mens.mperso("$P não conhece " + txtsublin(config:arma_txt, r.armatipo, 1) + ".")
    senao r.vestirnao
      se tipo1 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo1) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      senao tipo2 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo2) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      senao tipo3 && txtproc("\n" + txte(r.vestirnao) + "\n", tipo3) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      fimse
    fimse
    listaobj e
    epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
      ret e.objini.cmd_vestir(alvo, r, 50), nulo
    efim
    r.vestir(50)
    $mens.mvis1("$P empunha $o.")
    epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
      e.objini.cmd_vestiu(alvo, r, 50)
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_remover
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Remover\b\n\
Sintaxe: REMOVER <objeto>\n\
         REMOVER <quantidade> <objeto>\n\
Seu personagem deixa de usar um objeto que está vestindo ou usando.\n\
Para remover tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const posic = 5
ref alvo # Quem vai remover

func escr
  ret !arg1, arg0.msg("Remover o que?")
  alvo = arg0.persoesc
# Preenche a variável vest com o que está vestindo
  int1 vest.32 # Aonde está vestindo
  listaitem item
  epara item = alvo.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Remove
  uint8 total
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, misc:objmax, misc:tudo)
  epara l.addfim(alvo.dentro2), l, l.ini.remove
    r = l.objini
    continuar !r.vestpos || !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    uint8 x
    epara x = n, x, x -= 1
      total += 1
      refvar valor = vest.bits & config:vestir[r.vestpos - 1]
      se valor
        listaitem item
        epara item = alvo.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair valor & intbit(item.obj.vestpos - 1)
        efim
        alvo.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
      senao
        refvar posic = int(r.vestpos)
        listaobj e
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_remover(alvo, r, posic), nulo
        efim
        vest.[r.vestpos] = 0
        r.vestir(0)
        $mens.p(alvo, nulo, r)
        $mens.mvis1("$P remove $o.")
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          e.objini.cmd_removeu(alvo, r, posic)
        efim
      fimse
    efim
  efim
# Ajusta variáveis
  !total && $mens.p(alvo) + $mens.mperso("$P não está usando isso.")


classe comando_comebebe
herda comando_comum

func efeito
# arg0 = personagem que usou o objeto
# arg1 = o que o personagem digitou; usado ao lançar magias
# arg2 = objeto
# arg3 = quantidade
  arg0.p_fome = intmin($miscfome.cheio, arg0.p_fome + arg2.f_fome * arg3)
  arg0.p_sede = intmin($miscfome.cheio, arg0.p_sede + arg2.f_sede * arg3)
  arg0.p_bebida = intmin($miscfome.cheio, arg0.p_bebida + arg2.f_bebida * arg3)
  arg0.p_diges = intmin($miscfome.cheio, arg0.p_diges + arg2.f_diges * arg3)
  debug d
# Magias
  $magia_[arg2.f_magia1].escr(arg0, arg1, arg2, arg2.f_nivel1)
  d.ini
  $magia_[arg2.f_magia2].escr(arg0, arg1, arg2, arg2.f_nivel2)
  d.ini
  $magia_[arg2.f_magia3].escr(arg0, arg1, arg2, arg2.f_nivel3)


classe cmd_tomar
herda cmd_beber
const objcmd = $cmd_beber
const objajuda = $cmd_beber


classe cmd_beber
herda comando_comebebe, comando_ajuda
const txtajuda = "\b\c3Beber\b\n\
Sintaxe: BEBER [objeto]\n\
         TOMAR [objeto]\n\
Tenta beber alguma coisa. Sem argumentos, bebe a primeira fonte\n\
que encontrar."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
# Obtém o objeto
  n.ini(arg1, 1)
  se !arg1
    epara l.addfim(arg0.dono.dentro1), l, l.ini.remove
      sair l.objini.f_tipo == 1 && l.objini.visivel(arg0)
    efim
    ret !l.objini, arg0.msg("Beber o quê?")
  senao
    epara l.addfim(arg0.dentro1, arg0.dono.dentro1), l, l.ini.remove
      sair l.objini.visivel(arg0) && n.nome(l.objini.ident, l.objini.objtot)
    efim
    refvar r = l.objini
    se !r
      ret arg0.msg("Você não vê isso.")
    senao r.f_tipo == 1 # Fonte
    senao r.f_tipo != 2 # Não é bebida ou poção
      ret arg0.msg("Você não consegue beber " + r.descnome + ".")
    senao r.dono != arg0
      ret arg0.msg("Você precisa pegar " + r.descnome + " primeiro.")
    fimse
  fimse
  ref r
  r = l.objini
# Checa se consegue beber
  se arg0.p_sede >= $miscfome.cheio || arg0.p_fome >= $miscfome.cheio
    ret arg0.msg("Você não consegue beber mais nada.")
  senao arg0.p_bebida >= $miscfome.cheio - 5
    $mens.p(arg0, nulo, r)
    $mens.mvis1("$P não consegue levar $o à boca.")
    ret
  fimse
# Eventos
  l.limpar
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_beber(arg0, r), nulo
  efim
# Bebe o objeto
  $mens.p(arg0, nulo, r)
  se r.f_tipo == 1
    refvar msg1 = r.f_msgperso ? r.f_msgperso : "$P bebe $d $o."
    $mens.mvis2(msg1, r.f_msgoutros ? r.f_msgoutros : msg1)
  senao
    refvar msg1 = r.f_msgperso ? r.f_msgperso : "$P bebe $o."
    $mens.mvis2(msg1, r.f_msgoutros ? r.f_msgoutros : msg1)
    r.apagar(1)
  fimse
  efeito(arg0, "", r, 1)
# Eventos
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_bebeu(arg0, r)
  efim


classe cmd_comer
herda comando_comebebe, comando_ajuda
const txtajuda = "\b\c3Comer\b\n\
Sintaxe: COMER <objeto>\n\
Tenta comer alguma coisa, geralmente um alimento."
const posic = 5

func escr
  ret arg0.posicao == 7, arg0.msg(arg0.erropos(7)) # Não come durante a luta
  listaobj l
  nomeobj n # Para reconhecer os itens
# Obtém o objeto
  n.ini(arg1, 1)
  ret !arg1, arg0.msg("Comer o quê?")
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    sair l.objini.visivel(arg0) && n.nome(l.objini.ident, l.objini.objtot)
  efim
  ref r
  r = l.objini
# Checa se consegue comer
  se !r
    ret arg0.msg("Você não vê isso.")
  senao arg0.jogconfig.14 # Se é imortal, consegue comer
  senao r.f_tipo != 3 # Checa se é comida
    ret arg0.msg("Você não consegue comer " + r.descnome + ".")
  senao arg0.p_fome >= $miscfome.cheio - 5
    ret arg0.msg("Você não consegue comer mais nada.")
  senao arg0.p_bebida >= $miscfome.cheio - 5
    $mens.p(arg0, nulo, r)
    $mens.mvis1("$P não consegue levar $o à boca.")
    ret
  fimse
# Eventos
  l.limpar
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_comer(arg0, r), nulo
  efim
# Come o objeto
  $mens.p(arg0, nulo, r)
  refvar msg1 = r.f_msgperso ? r.f_msgperso : "$P come $o."
  $mens.mvis2(msg1, r.f_msgoutros ? r.f_msgoutros : msg1)
  r.apagar(1)
  efeito(arg0, "", r, 1)
# Eventos
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_comeu(arg0, r)
  efim


classe cmd_recitar
herda comando_comebebe, comando_ajuda
const txtajuda = "\b\c3Recitar\b\n\
Sintaxe: RECITAR <objeto>\n\
         RECITAR <objeto>  <alvo>\n\
Tenta recitar alguma coisa, geralmente um pergaminho.\n\
Conforme as magias contidas no pergaminho, é possível direcioná-las\n\
para um personagem ou mesmo um item."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
# Obtém o objeto
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  n.ini(misc:sep1, 1)
  txt100 nome
  nome = misc:sep2
  ret !arg1, arg0.msg("Recitar o quê?")
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    sair l.objini.visivel(arg0) && n.nome(l.objini.ident, l.objini.objtot)
  efim
  ref r
  r = l.objini
# Checa se consegue recitar
  se !r
    ret arg0.msg("Você não vê isso.")
  senao r.f_tipo != 4 # Checa se pode recitar
    ret arg0.msg("Não há nada para recitar em " + r.descnome + ".")
  senao arg0.p_bebida >= $miscfome.cheio / 2
    ret arg0.msg("Você não consegue ler o que está escrito em " + r.descnome + ".")
  senao int(r.pnivel) > arg0.pnivel
    refvar lin = txtcopiamai(r.descnome, "A")
    ret arg0.msg(lin + " é complicad" + (r.msexo ? "o" : "a") + " demais.")
  senao arg0.dono.s_falar
    ret arg0.msg(arg0.dono.s_falar)
  fimse
# Eventos
  l.limpar
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_recitar(arg0, r), nulo
  efim
# Recita o objeto
  $mens.p(arg0, nulo, r)
  refvar msg1 = r.f_msgperso ? r.f_msgperso : "$P recita $o."
  $mens.mvis2(msg1, r.f_msgoutros ? r.f_msgoutros : msg1)
  r.apagar(1)
  efeito(arg0, nome, r, 1)
# Eventos
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_recitou(arg0, r)
  efim


classe cmd_capturar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Capturar\b\n\
Sintaxe: CAPTURAR\n\
         CAPTURAR <objeto>\n\
Usa um objeto para tentar capturar o animal que está lutando com você.\n\
Se o nome do objeto for omitido, usa o último que você escolheu.\n\
Nota: a captura pode falhar se o animal achar que não vale a pena entrar\n\
para a sua equipe. Por isso, é sempre bom enfraquecê-lo antes."
const posic = 5

func escr
  ref r
  ref item # Item usado para capturar
# Checa se sabe o nome do item
  ret !arg1 && !arg0.var.z_captura, arg0.msg("Capturar com o quê?")
# Obtém o item
  nomeobj n # Para reconhecer os itens
  n.ini(arg1 ? arg1 : arg0.var.z_captura, misc:objmax)
  listaobj l
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    ret !r.i_captura, arg0.msg(txtcopiamai(r.descnome, "A") + " não serve para capturar animais."\
)
    item = r
    sair
  efim
# Checa se pode capturar
  ret !item, arg0.msg(arg1 ? "Você não vê isso." : "Capturar com o quê?")
  arg1 && (arg0.var.z_captura = arg1)
  r = arg0.atkenv.objlista # Alvo do personagem
  se !r
    se arg1
      arg0.msg("Você escolhe " + arg1 + " (" + item.descnome + ") para capturar animais.")
    senao
      arg0.msg("Não está lutando com nenhum animal.")
    fimse
    ret
  senao !r.p_captura || r.perso != 2 || arg0.perso != 3
    $mens.p(arg0, r)
    $mens.mvis2("Não é possível capturar $a.", "")
    ret
  senao arg0.animalmais # Se tem espaço suficiente
  senao !config:capturar || arg0.dentro3.total >= config:animal2
    arg0.msg("Sem espaço para guardar animal.")
    ret
  fimse
# Decide se consegue capturar
  real2 valor
  valor = r.pvida * 100 / r.pvidamax
  se valor < 10 # 0% a 10% de vida: valor=10
    valor = 10
  senao valor < 46 # 10% a 46% de vida: valor= 10 a 1
    valor = (50 - valor) / 4
  senao
    valor = 1
  fimse
  casovar r.p_captura
  casose "1" # Muito fácil
    valor *= 2
    sair
  casose "2" # Fácil
    valor *= 1.5
    sair
  casose "3" # Normal
    sair
  casose "4" # Difícil
    valor /= 1.5
    sair
  casose "5" # Muito difícil
    valor /= 2
    sair
  casofim
  $mens.p(arg0, r)
  se valor * item.i_captura(r) < r.pnivel * rand(5, 20)
    $mens.mvis1("$P joga " + item.descnome + " para $a, mas $a recusa.")
    item.apagar(1)
    ret
  fimse
  $mens.mvis1("$P joga " + item.descnome + " para $a.")
  item.apagar(1)
# Captura
  listaobj e
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    ret e.objini.cmd_pegaranim(arg0, r, arg0.dono), nulo
  efim
  refvar estacheio = !arg0.animalmais
  r.mudadono(arg0) # Muda de dono
  r.var.z_dono = arg0.nome
  r.var.z_pnivel = r.pnivel
  r.objsolto.remove(r) # Não conta mais na lista de personagens soltos
  arg0.recalc = 1
  r.ajustapeso # Para o peso do personagem ir para 0 (não conta no jogador)
  $mens.p(arg0, r)
  se estacheio
    r.idono.remove, r.idono = r.dono.dentro3.addfim(r)
    $mens.mvis2("$A entrou para a sua equipe como reserva.", "$A entrou para a equipe de \
$P.")
  senao
    $mens.mvis2("$A entrou para a sua equipe.", "$A entrou para a equipe de $P.")
  fimse
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    sair e.objini.cmd_pegouanim(arg0, r, arg0.dono)
  efim


classe cmd_trocar
herda comando_comum, comando_ajuda
const objcmd = config:animal1 ? este
const objajuda = config:animal1 ? este
const txtajuda = "\b\c3Trocar\b\n\
Sintaxe: TROCAR\n\
         TROCAR <item>\n\
         TROCAR <número> <número>\n\
Sem argumentos pega um item do animal escolhido.\n\
Com o nome de um item, dá um item para o animal escolhido.\n\
Com dois números, troca dois animais de lugar."

func escr
  ret arg0.atkenv, arg0.msg("Você não consegue trocar durante a batalha.")
  ret !arg1, escr_pegar(arg0)
  uint8 p1
  uint8 p2
  p1 = txt1(arg1), p2 = txt2(arg1)
  se txt1(arg1) != p1 || !p1 || p1 > config:animal1
    escr_dar(arg0, arg1)
  senao txt2(arg1) != p2 || !p2 || p2 > config:animal1
    escr_dar(arg0, arg1)
  senao
    escr_trocar(arg0, p1, p2)

func escr_pegar # Pegar item do animal
# arg0 = personagem
  ret arg0.persoesc == arg0, arg0.msg("Primeiro escolha um animal.")
  refvar rec = ref(arg0.persoesc.dentro1.ini.obj)
  se !rec
    $mens.p(arg0.persoesc) + $mens.mperso("$P não carrega nenhum item.")
  senao (arg0.objnum >> 1) + (rec.objnum >> 1) > config:itens
    arg0.msg("Você não consegue carregar tanta coisa.")
  senao
    rec.mudadono(arg0, 1)
    $mens.p(arg0, nulo, rec)
    $mens.mens = rec.descnome + " de " + arg0.persoesc.nome
    $mens.mvis1("$P pega $m.")

func escr_dar # Dar item para o animal
# arg0 = personagem
# arg1 = nome do item
  ret arg0.persoesc == arg0, arg0.msg("Primeiro escolha um animal.")
  listaobj l
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    refvar env = ref(l.objini)
    refvar rec = ref(arg0.persoesc.dentro1.ini.obj)
    se env.objnum >> 1 > 1 # Animal não carrega objetos com coisas dentro
      arg0.msg(txtcopiamai(arg0.persoesc.descnome, "A") + " não consegue carregar isso.")
    senao !rec # Se animal não está carregando nada
      env.mudadono(arg0.persoesc, 1)
      $mens.p(arg0)
      $mens.mens = env.descnome + " para " + arg0.persoesc.nome
      $mens.mvis1("$P dá $m.")
    senao (arg0.objnum >> 1) - (env.objnum >> 1) + (rec.objnum >> 1) > config:itens
      arg0.msg("Você não consegue carregar tanta coisa.")
    senao
      env.mudadono(arg0.persoesc, 1)
      rec.mudadono(arg0, 1)
      $mens.p(arg0)
      $mens.mens = rec.descnome + " de " + arg0.persoesc.nome + " e dá " + env.descnome
      $mens.mvis1("$P pega $m.")
    fimse
    ret
  efim
  arg0.msg("Você não vê isso.")

func escr_trocar # Trocar dois animais de lugar
# arg0 = personagem
# arg1 = número do primeiro animal
# arg2 = número do segundo animal
  refvar a1 = arg0.animalnum(arg1)
  refvar a2 = arg0.animalnum(arg2)
  ret a1 == a2, arg0.msg("Nada para ser trocado.")
# Obtém os itens da lista
  listaitem i1
  listaitem i2
  i1 = a1.idono
  i2 = a2.idono
# Adiciona novos itens na lista
  a1.idono = i2 ? i2.adddepois(a1) : arg0.dentro2.addfim(a1)
  a2.idono = i1 ? i1.adddepois(a2) : arg0.dentro2.addfim(a2)
# Remove os itens antigos da lista
  i1.remove, i2.remove
# Mensagens
  arg0.msg("Você troca de lugar " + arg1 + " e " + arg2 + ".")


classe cmd_animal
herda comando_comum, comando_ajuda
const objcmd = config:animal1 ? este
const objajuda = config:animal1 ? este
const txtajuda = txttroca(config:animal2 ? ta1 + ta2 : ta1, "$$", config:animal1)
const ta1 = "\b\c3Animais\b\n\
  \c2CAPTURAR\b  Pega o animal que está lutando com você.\n\
  \c2SOLTAR\b    Solta um animal (você se desfaz dele)\n\
  \c2DAR\b       Dá animal a outro personagem\n\
  \c2ANIMAL\b    Mostra animais que você possui\n\
  \c20\b         Não escolhe nenhum animal para batalha\n\
  \c21\b a \c2$$\b     Escolhe um animal seu, de 1 a $$\n\
  \c2TROCAR\b    Dá itens para um animal e troca animais de lugar"
const ta2 = "\n  \c2RESERVA\b   Manuseio de animais reserva"
const posic = 0

func escr
  textotxt t
  txt100 lin
  uint8 num
  listaitem i
  t.addfim((arg0.persobat == arg0 ? "0* Você  N" : "0  Você  N") + arg0.pnivel)
  epara i = arg0.dentro2.ini, i, i.depois
    continuar !i.obj.perso
    lin = txt(num += 1) + (arg0.persobat == i.obj ? "*" : " ")
    se i.obj.pvida
      lin += " " + txtcopiamai(i.obj.nome, "A") + "  N" + i.obj.pnivel
    senao
      lin += " (" + txtcopiamai(i.obj.nome, "A") + ")  N" + i.obj.pnivel
    fimse
    t.addfim(lin)
  efim
  se t.linhas == 1
    arg0.msg("Não possui nenhum animal.")
  senao
    arg0.msg2("\b\c6Animais:\b\n" + t.remove(1000))


classe comando_escolhe_animal
herda comando_comum
const posic = 5
int8 num # Número do animal; preenchido pela função "teclou" do personagem

func escr # Chamado pela função "teclou" do personagem ao escolher um animal
  refvar r = arg0.animalnum(num)
  se !r
    arg0.msg("Você não possui " + num + ".")
  senao arg0.persoesc == r
    arg0.msg("Você já escolheu " + num + ".")
  senao r == arg0
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = arg0
    $mens.p(arg0)
    $mens.mvis1("$P não escolhe ninguém.")
    arg0.escolhebat # Atualiza persobat
  senao
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = r
    arg0.escolhebat # Atualiza persobat
    $mens.p(arg0, r)
    $mens.mvis1("$P escolhe $b.")


classe cmd_reserva
herda comando_comum, comando_ajuda
const objcmd = config:animal1 && config:animal2 ? este
const objajuda = config:animal1 && config:animal2 ? este
const txtajuda = "\b\c3Reserva\b\n\
Sintaxe: RESERVA\n\
         RESERVA <número do animal>\n\
         RESERVA <nome do animal>\n\
Sem argumentos mostra os seus animais reserva.\n\
Com um número guarda seu animal para a lista de animais reserva.\n\
Com um nome pega um animal reserva."

func escr
  se arg0.dentro3.total != txt(int(arg0.dentro3.total))
    arg0.msg("Você não sabe como lidar com animais reserva.")
  senao !arg0.dono.s_reserva
    arg0.msg("Não pode lidar com animais reserva aqui.")
  senao arg0.atkenv
    arg0.msg("Você está lutando pela sua vida.")
  senao !arg1
    textotxt t
    txt100 lin
    listaitem i
    epara i = arg0.dentro3.ini, i, i.depois
      se i.obj.pvida
        lin = "1 " + txtcopiamai(i.obj.nome, "A") + "  N" + i.obj.pnivel
      senao
        lin = "1 (" + txtcopiamai(i.obj.nome, "A") + ")  N" + i.obj.pnivel
      fimse
      t.addfim(lin)
    efim
    se !t.linhas
      arg0.msg("Não possui nenhum animal reserva.")
    senao
      t.juntalin("(", "x)")
      arg0.msg2("\b\c6Animais reserva:\b\n" + t.remove(1000))
    fimse
  senao arg1 == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    se arg0.dentro3.total >= config:animal2
      ret arg0.msg("Atingido o limite de animais reserva.")
    fimse
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    listaobj e
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      ret e.objini.cmd_reservaguarda(arg0, r, arg0.dono), nulo
    efim
    ret r.dono != arg0, nulo # Retorna se não possui mais o animal
    r.idono.remove
    r.idono = r.dono.dentro3.addfim(r)
    arg0.recalc = 1
    arg0.msg("Você guardou " + r.descnome + " N" + r.pnivel)
  senao
    listaobj l
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara l.addfim(arg0.dentro3), l, l.ini.remove
      sair n.nome(l.objini.ident, l.objini.objtot)
    efim
    refvar r = ref(l.objini)
    ret !r, arg0.msg("Você não possui animal reserva " + arg1 + ".")
    ret !arg0.animalmais, arg0.msg("Sem espaço para pegar animal reserva.")
    r.idono.remove
    r.idono = r.dono.dentro2.addfim(r)
    arg0.recalc = 1
    arg0.msg("Você pegou " + r.descnome + " N" + r.pnivel)
  fimse
