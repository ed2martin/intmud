classe cmd_acender
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Acender\b\n\
Sintaxe: ACENDER <objeto>\n\
Acende um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Acender o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode acender
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue acender " + r.descnome + ".")
    senao !r.luztempo
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " não acende mais.")
    senao r.luztempo > 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está aces" + (r.msexo ? "o." : "a."))
    senao r.luzitem == 6 # Se requer fogo para acender
      l.limpar
      epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
        sair int(l.objini.luzitem) >= 3 && int(l.objini.luztempo) > 0
      efim
      ret !l.objini, arg0.msg("Você precisa de fogo para acender " + r.descnome + ".")
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acender(arg0, r), nulo
    efim
# Acende
    r.luztempo.pos, r.recalc = 1, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1(r.luzliga ? r.luzliga : "$P acende $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acendeu(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_apagar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Apagar\b\n\
Sintaxe: APAGAR <objeto>\n\
Apaga um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Acender o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode apagar
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue apagar " + r.descnome + ".")
    senao !r.luztempo || r.luztempo < 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está apagad" + (r.msexo ? "o." : "a."))
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagar(arg0, r), nulo
    efim
# Apaga
    r.luztipo == 5 ? (r.luztempo = 0) : r.luztempo.neg, r.recalc = 1, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1("$P apaga $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagou(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_pegar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Pegar\b\n\
Sintaxe: PEGAR <objeto>\n\
         PEGAR <quantidade> <objeto>\n\
         PEGAR <objeto> <container>\n\
         PEGAR <quantidade> <objeto> <container>\n\
Pega um objeto do chão ou de um container (uma bolsa, uma estante, etc).\n\
Para pegar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const posic = 5
#
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_pegar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2 && !arg0.jogconfig.14
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.msexo ? "o." : \
"a."))
    fimse
    mens = " de $a."
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000, misc:tudo)
# Pega os itens
  achou = 0
  epara l.addfim(sala.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    ref r # Nota: r pode mudar após r.mudadono
    r = l.objini
    se arg0.dentro1.total + total > arg0.objmax
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    senao arg0.volden + r.voltot * total / r.objtot > arg0.volmax
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    senao arg0.pesoden - arg0.pesoveste + r.pesotot * total / r.objtot > arg0.pesomax
      ret r.pesotot > r.objtot * arg0.pesomax * 2, arg0.msg("É pesado demais.")
      ret arg0.msg("Você não consegue carregar tanto peso.")
    senao (arg0.objnum >> 1) + (r.objnum >> 1) > config:itens
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_pegarobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P pega $o" + mens)
    senao
      $mens.mvis1("$P pega " + total + "x $o" + mens)
    fimse
    r = r.mudadono(arg0, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_pegouobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Pega moedas
  se sala.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", sala.var.z_moedas_)
    total = int(misc:sep1) ? n : sala.var.z_moedas
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_pegarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ -= total
    sala.var.z_moedas_ < 0 && sala.var.z_moedas = ""
    arg0.var.z_moedas_ += total
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P pega uma moeda" + mens)
    senao total == 2
      $mens.mvis1("$P pega duas moedas" + mens)
    senao
      $mens.mvis1("$P pega " + total + " moedas" + mens)
    fimse
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_soltar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta1 + ta2 + ta3 + ta4 : ta1 + ta3
const ta1 = "\b\c3Soltar\b\n\
Sintaxe: SOLTAR <objeto>\n\
         SOLTAR <quantidade> <objeto>\n\
         SOLTAR <objeto> <container>\n\
         SOLTAR <quantidade> <objeto> <container>\n"
const ta2 = "         SOLTAR <número do animal>\n"
const ta3 = "Solta um objeto no chão ou em um container (uma bolsa, uma estante, etc).\n\
Para soltar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const ta4 = "\nPermite também soltar algum animal (se desfazer) que você possuir."
const posic = 5
#
ref sala # Aonde soltar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
txt80 mens2 # Outra parte da mensagem
int1 achou # Se achou algum item
int8 soltar # Se pode soltar itens

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
# Checa soltar animal
  se arg1 == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar == 2, arg0.msg("Não é possível soltar esse animal.")
    listaobj e
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      ret e.objini.cmd_soltaranim(arg0, r, arg0.dono), nulo
    efim
    ret r.dono != arg0, nulo # Retorna se não possui mais o animal
    $mens.p(arg0, r)
    $mens.mvis1("$P se despede de $a e $b vai embora.")
    apagar(r) # Apaga animal
    r.mdono(nulo) # Indica que não tem o animal
    arg0.recalc = 1 # Acerta personagem
    arg0.persobat == r && (arg0.persobat = arg0)
    arg0.persoesc == r && (arg0.persoesc = arg0)
    arg0.escolhebat # Escolhe um animal em condições de batalhar
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      e.objini.cmd_soltouanim(arg0, r, arg0.dono)
    efim
    ret
  fimse
# Obtém o objeto de onde soltar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    soltar = sala.s_soltar
    mens = ""
    ret soltar == 1, arg0.msg("Você não consegue soltar itens aqui.")
  senao
    soltar = 0
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2 && !arg0.jogconfig.14
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.msexo ? "o." : \
"a."))
    fimse
    mens = " em $a"
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000, misc:tudo)
# Solta os itens
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r # Nota: r pode mudar após r.mudadono
    r = l.objini
    total = n # Quantidade de itens
    se r == sala # Soltar o objeto dentro dele mesmo
      refvar lin = r.msexo ? " dentro dele mesmo." : " dentro dela mesma."
      ret arg0.msg("Não é possível soltar " + r.descnome + lin)
    senao sala.dentro1.total + total >= sala.objmax
      ret sala.item, arg0.msg("Não consegue soltar nada em " + sala.descnome + ".")
      ret arg0.msg("Não consegue soltar nada aqui.")
    senao sala.volden + r.voltot * total / r.objtot > sala.volmax * r.objtot
      ret arg0.msg("Não há espaço suficiente para soltar isso.")
    fimse
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_soltarobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    mens2 = mens ? "$P coloca " : "$P solta "
    mens2 += total <= 1 ? "$o" : txt(total) + "x $o"
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      r.apagar(total)
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      r.apagar(total)
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      r.apagar(total)
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      r = r.mudadono(sala, total)
    casofim
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_soltouobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Solta moedas
  se arg0.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_soltarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && arg0.var.z_moedas = ""
    $mens.p(arg0, sala)
    mens2 = mens ? "$P coloca " : "$P solta "
    se total == 1
      mens2 += "uma moeda"
    senao total == 2
      mens2 += "duas moedas"
    senao
      mens2 += txt(total) + " moedas"
    fimse
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      sala.var.z_moedas_ += total
    casofim
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_dar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta2 : ta1
const ta1 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
Dá um objeto para outro personagem."
const ta2 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
         DAR <número do animal> <personagem>\n\
Dá um objeto ou animal para outro personagem."
const posic = 5
#
ref sala # Para quem dar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_dar(arg0, arg1), nulo
  efim
# Dar animal a outro personagem
  se txt1(arg1) == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar, arg0.msg("Não é possível dar esse animal.")
    ret !txt2(arg1), arg0.msg("Dar " + arg1 + " para quem?")
    listaobj l
    nomeobj n
    n.ini(txt2(arg1), 1)
    epara l.addfim(arg0.dono.dentro2), l, l.ini.remove
      continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident)
      se i.obj == arg0
        ret arg0.msg("Dar para você mesmo?")
      senao !l.objini.jog
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não é jogador.")
      senao !l.objini.animalmais
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não tem espaço para receber \
animal.")
      fimse
      listaobj e
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        ret e.objini.cmd_daranim(arg0, r, l.objini), nulo
      efim
      ret r.dono != arg0, nulo # Retorna se não possui mais o animal
      ret !l.objini.animalmais, nulo
      arg0.recalc = 1, l.objini.recalc = 1 # Acerta personagens
      r.mdono(l.objini) # Muda de dono
      arg0.persobat == r && (arg0.persobat = arg0)
      arg0.persoesc == r && (arg0.persoesc = arg0)
      arg0.escolhebat # Escolhe um animal em condições de batalhar
      $mens.p(arg0, l.objini)
      $mens.mvis1("$P dá " + r.descnome + " para $a.")
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        e.objini.cmd_deunim(arg0, r, l.objini)
      efim
      ret
    efim
    ret arg0.msg("Você não vê " + txt2(arg1) + ".")
  fimse
# Obtém para quem dar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  ret !misc:sep2, arg0.msg("Dar itens para quem?")
  sala = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
  se !sala
    ret arg0.msg("Você não vê " + misc:sep2 + ".")
  senao !sala.p_recebe
    ret arg0.msg("Não é possível dar nada para " + sala.descnome + ".")
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
# Dá os itens
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r # Nota: r pode mudar após r.mudadono
    r = l.objini
    total = n # Quantidade de itens
    se sala.dentro1.total + total >= sala.objmax
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar mais nada.")
    senao sala.volden + r.voltot * total / r.objtot > sala.volmax
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar isso.")
    senao sala.pesoden - sala.pesoveste + r.pesotot * total / r.objtot > sala.pesomax
      ret arg0.msg("É pesado demais para " + txtcopiamai(sala.descnome, "A") + ".")
    senao (sala.objnum >> 1) + (r.objnum >> 1) > config:itens
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar isso.")
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_darobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P dá $o para $a.")
    senao
      $mens.mvis1("$P dá " + total + "x $o para $a.")
    fimse
    r = r.mudadono(sala, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_deuobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Dá moedas
  se arg0.var.z_moedas_ && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_darmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ += total
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && arg0.var.z_moedas = ""
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P dá uma moeda para $a.")
    senao total == 2
      $mens.mvis1("$P dá duas moedas para $a.")
    senao
      $mens.mvis1("$P dá " + total + " moedas para $a.")
    fimse
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_usar
herda comando_comum
const objcmd = $cmd_vestir
const objajuda = $cmd_vestir


classe cmd_vestir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Vestir\b\n\
Sintaxe: VESTIR <objeto> [posição]\n\
         USAR <objeto> [posição]\n\
Seu personagem veste ou usa um objeto que está carregando.\n\
Para vestir tudo (até 10 objetos) tecle TUDO ao invés do objeto.\n\
Para saber em que posições pode vestir algo, tecle EQUIP TUDO"
const posic = 5
txt30 tipo1 # alvo.tipo1
txt30 tipo2 # alvo.tipo2
txt30 tipo3 # alvo.tipo3
ref alvo # Quem vai vestir

func escr
  ret !arg1, arg0.msg("Vestir o que?")
  alvo = arg0.persoesc
  tipo1 = alvo.tipo1 ? "\n" + alvo.tipo1 + "\n" : ""
  tipo2 = alvo.tipo2 ? "\n" + alvo.tipo2 + "\n" : ""
  tipo3 = alvo.tipo3 ? "\n" + alvo.tipo3 + "\n" : ""
# Variáveis
  int32 lugar # Aonde quer vestir
  int1 vest.32 # Aonde está vestindo
  int8 total # Quantidade de itens encontrados
  nomeobj n # Para reconhecer os itens
  listaitem item
# Preenche a variável vest com o que está vestindo
  epara item = alvo.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Descobre aonde quer vestir
  misc:separa(arg1) # Separa nome do objeto do nome da posição
  se !misc:sep2
    lugar = alvo.equippos # Todas as posições que possui
  senao
    n.ini(misc:sep2, 100)
    textotxt t
    textopos pos
    t.addfim(config:equip_txt)
    refvar lug2 = ~alvo.equippos
    epara pos = t.ini, pos, pos.depois
      continuar lug2 & intbit(pos.linha)
      n.nome(pos.texto) && (lugar = lugar | intbit(pos.linha))
    efim
    ret !lugar, arg0.msg("Você não sabe aonde fica " + misc:sep2 + ".")
  fimse
# Veste
  listaobj l
  ref r
  n.ini(misc:sep1, 1000000, misc:tudo)
  epara l.addfim(alvo.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    total += n
    $mens.p(alvo, nulo, r)
# Vestir - checa se o personagem pode vestir
    se r.vestirsim == (alvo == arg0 ? 2 : 1)
      $mens.mperso("$P não consegue vestir $o.")
      continuar
# Vestir - checa o nível
    senao int(r.pnivel) > alvo.pnivel
      $mens.mperso("$P precisa estar no nível " + r.pnivel + " para vestir $o.")
      continuar
    fimse
    uint8 x
    epara x = n, x, x -= 1
# Vestir - checa se o item pode ser vestido
      refvar lugar2 = lugar & r.vestir1
      se !lugar2
        se !r.vestir1
          $mens.mperso("Não se pode vestir $o.")
        senao
          $mens.mperso("$P não consegue vestir $o.")
        fimse
        sair
# Vestir - checa se a classe ou a raça tem permissão
      senao !r.vestirnao
      senao tipo1 && txtproc("\n" + r.vestirnao + "\n", tipo1) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      senao tipo2 && txtproc("\n" + r.vestirnao + "\n", tipo2) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      senao tipo3 && txtproc("\n" + r.vestirnao + "\n", tipo3) >= 0
        $mens.mperso("$P não consegue vestir $o.")
        sair
      fimse
# Vestir - checa se o item deixa
      txt100 txtvestir
      txtvestir = r.cmd_podevestir(alvo)
      ret txtvestir, $mens.mperso(txtvestir)
# Vestir - checa os itens que estão em cima
      int32 erro1 # Posição aonde já está vestindo o item
      int32 erro2 # Posições aonde tem itens em cima
      uint8 pos
      epara pos = 0, pos < 32, pos += 1
        continuar !(lugar2 >> pos & 1) # Checa se é o lugar
        se vest.[pos]
          erro1 = pos + 1
        senao (erro2 = vest.bits & config:vestir[pos]) == 0
          erro1 = 0
          sair
        fimse
      efim
# Vestir - mensagens de erro
      se erro2
        epara item = alvo.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair erro2 & intbit(item.obj.vestpos - 1)
        efim
        arg0.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
        sair
      senao erro1
        epara item = alvo.dentro2.ini, item, item.depois
          sair item.obj.vestpos == erro1
        efim
        arg0.msg("Já está usando " + item.obj.descnome + " nessa posição.")
        sair
# Veste o item
      senao
        listaobj e
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_vestir(alvo, r, pos + 1), nulo
        efim
        r.vestir(pos + 1)
        vest.[pos] = 1
        refvar mvestir = txtsublin(config:equip_vestir, pos, 1)
        $mens.mvis1(mvestir ? mvestir : "$P veste $o.")
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          e.objini.cmd_vestiu(alvo, r, pos + 1)
        efim
      fimse
    efim
  efim
# Avisa se não encontrou nenhum item
  !total && arg0.msg("Você não vê isso.")


classe cmd_empunhar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Empunhar\b\n\
Sintaxe: EMPUNHAR <objeto>\n\
Seu personagem empunha uma arma que está carregando."
const posic = 5
txt30 tipo1 # alvo.tipo1
txt30 tipo2 # alvo.tipo2
txt30 tipo3 # alvo.tipo3
ref alvo # Quem vai empunhar

func escr
  ret !arg1, arg0.msg("Empunhar o que?")
  alvo = arg0.persoesc
  ret alvo.iempu, $mens.p(alvo) + $mens.mperso("$P já está empunhando uma arma.")
  tipo1 = alvo.tipo1 ? "\n" + alvo.tipo1 + "\n" : ""
  tipo2 = alvo.tipo2 ? "\n" + alvo.tipo2 + "\n" : ""
  tipo3 = alvo.tipo3 ? "\n" + alvo.tipo3 + "\n" : ""
# Empunha
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  epara l.addfim(alvo.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    $mens.p(alvo, nulo, r)
    se !r.armatipo
      ret $mens.mperso("$O não é arma.")
    senao r.vestirsim == (alvo == arg0 ? 2 : 1)
      ret $mens.mperso("$P não consegue vestir $o.")
    senao int(r.pnivel) > alvo.pnivel
      ret $mens.mperso("$P precisa estar no nível " + r.pnivel + " para empunhar $o.")
    senao !alvo.var.h_[txtsublin(config:arma_txt, r.armatipo, 1)]
      ret $mens.mperso("$P não conhece " + txtsublin(config:arma_txt, r.armatipo, 1) + ".")
    senao r.vestirnao
      se tipo1 && txtproc("\n" + r.vestirnao + "\n", tipo1) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      senao tipo2 && txtproc("\n" + r.vestirnao + "\n", tipo2) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      senao tipo3 && txtproc("\n" + r.vestirnao + "\n", tipo3) >= 0
        ret $mens.mperso("$P não consegue empunhar $o.")
      fimse
    fimse
    listaobj e
    epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
      ret e.objini.cmd_vestir(alvo, r, 50), nulo
    efim
    r.vestir(50)
    $mens.mvis1("$P empunha $o.")
    epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
      e.objini.cmd_vestiu(alvo, r, 50)
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_remover
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Remover\b\n\
Sintaxe: REMOVER <objeto>\n\
         REMOVER <quantidade> <objeto>\n\
Seu personagem deixa de usar um objeto que está vestindo ou usando.\n\
Para remover tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const posic = 5
ref alvo # Quem vai remover

func escr
  ret !arg1, arg0.msg("Remover o que?")
  alvo = arg0.persoesc
# Preenche a variável vest com o que está vestindo
  int1 vest.32 # Aonde está vestindo
  listaitem item
  epara item = alvo.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Remove
  uint8 total
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000, misc:tudo)
  epara l.addfim(alvo.dentro2), l, l.ini.remove
    r = l.objini
    continuar !r.vestpos || !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    uint8 x
    epara x = n, x, x -= 1
      total += 1
      refvar valor = vest.bits & config:vestir[r.vestpos - 1]
      se valor
        listaitem item
        epara item = alvo.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair valor & intbit(item.obj.vestpos - 1)
        efim
        alvo.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
      senao
        refvar posic = int(r.vestpos)
        listaobj e
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_remover(alvo, r, posic), nulo
        efim
        vest.[r.vestpos] = 0
        r.vestir(0)
        $mens.p(alvo, nulo, r)
        $mens.mvis1("$P remove $o.")
        epara e.addfim(alvo.evento, r.evento), e, e.ini.remove
          e.objini.cmd_removeu(alvo, r, posic)
        efim
      fimse
    efim
  efim
# Ajusta variáveis
  !total && $mens.p(alvo) + $mens.mperso("$P não está usando isso.")


classe cmd_beber
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Beber\b\n\
Sintaxe: BEBER [objeto]\n\
Tenta beber alguma coisa. Sem argumentos, bebe a primeira fonte\n\
que encontrar."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
# Obtém o objeto
  n.ini(arg1, 1)
  se !arg1
    epara l.addfim(arg0.dono.dentro1), l, l.ini.remove
      sair l.objini.f_tipo == 1 && l.objini.visivel(arg0)
    efim
    ret !l.objini, arg0.msg("Beber o quê?")
  senao
    epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
      sair l.objini.visivel(arg0) && n.nome(l.objini.ident, l.objini.objtot)
    efim
    refvar r = l.objini
    se !r
      ret arg0.msg("Você não vê isso.")
    senao r.f_tipo == 1
    senao r.f_tipo != 2
      ret arg0.msg("Você não consegue beber " + r.nomedesc + ".")
    senao r.dono != arg0
      ret arg0.msg("Você precisa pegar " + r.nomedesc + " primeiro.")
    fimse
  fimse
  ref r
  r = l.objini
# Checa se consegue beber
  se arg0.p_sede >= 40 || arg0.p_fome >= 40
    ret arg0.msg("Você não consegue beber mais nada.")
  senao arg0.p_bebida >= 40
    ret arg0.msg("Você não consegue levar $o à boca.")
  fimse
# Avisa que bebeu e apaga objeto
  $mens.p(arg0, nulo, r)
  $mens.mvis1(r.f_tipo == 1 ? "$P bebe de $o." : "$P bebe $o.")
  r.apagar(1)
# Efeitos do objeto
  efeito(arg0, arg0, r, 1)

func efeito
# arg0 = personagem que usou o objeto
# arg1 = personagem alvo do efeito
# arg2 = objeto
# arg3 = quantidade
  arg1.p_fome = intmin(40, arg1.p_fome + arg2.f_fome * arg3)
  arg1.p_sede = intmin(40, arg1.p_sede + arg2.f_sede * arg3)
  arg1.p_bebida = intmin(40, arg1.p_bebida + arg2.f_bebida * arg3)
  ref r
  debug d
# Magia 1
  se !(r = $magia_[arg2.f_magia1])
  senao r.tipoalvo >= 4 || r.p_agressivo(arg0)
    d.ini
    r.exechab(arg0.persobat, arg1.persobat, 0.5, int(arg2.f_nivel3))
  fimse
# Magia 2
  se !(r = $magia_[arg2.f_magia2])
  senao r.tipoalvo >= 4 || r.p_agressivo(arg0)
    d.ini
    r.exechab(arg0.persobat, arg1.persobat, 0.5, int(arg2.f_nivel3))
  fimse
# Magia 3
  se !(r = $magia_[arg2.f_magia3])
  senao r.tipoalvo >= 4 || r.p_agressivo(arg0)
    d.ini
    r.exechab(arg0.persobat, arg1.persobat, 0.5, int(arg2.f_nivel3))
  fimse


classe cmd_capturar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Capturar\b\n\
Sintaxe: CAPTURAR\n\
         CAPTURAR <objeto>\n\
Usa um objeto para tentar capturar o animal que está lutando com você.\n\
Se o nome do objeto for omitido, usa o último que você escolheu.\n\
Nota: a captura pode falhar se o animal achar que não vale a pena entrar\n\
para a sua equipe. Por isso, é sempre bom enfraquecê-lo antes."
const posic = 5

func escr
  ref r
  ref item # Item usado para capturar
# Checa se sabe o nome do item
  ret !arg1 && !arg0.var.z_captura, arg0.msg("Capturar com o quê?")
# Obtém o item
  nomeobj n # Para reconhecer os itens
  n.ini(arg1 ? arg1 : arg0.var.z_captura, 1000000)
  listaobj l
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    ret !r.i_captura, arg0.msg(txtcopiamai(r.descnome, "A") + " não serve para capturar animais."\
)
    item = r
    sair
  efim
# Checa se pode capturar
  ret !item, arg0.msg(arg1 ? "Você não vê isso." : "Capturar com o quê?")
  arg1 && (arg0.var.z_captura = arg1)
  r = arg0.atkenv.objlista # Alvo do personagem
  se !r
    se arg1
      arg0.msg("Você escolhe " + arg1 + " (" + item.descnome + ") para capturar animais.")
    senao
      arg0.msg("Não está lutando com nenhum animal.")
    fimse
    ret
  senao !r.p_captura || r.perso != 2 || arg0.perso != 3
    $mens.p(arg0, r)
    $mens.mvis2("Não é possível capturar $a.", "")
    ret
  senao arg0.animalmais # Se tem espaço suficiente
  senao !config:capturar || arg0.dentro3.total >= config:animal2
    arg0.msg("Sem espaço para guardar animal.")
    ret
  fimse
# Decide se consegue capturar
  real2 valor
  valor = r.pvida * 100 / r.pvidamax
  se valor < 10 # 0% a 10% de vida: valor=10
    valor = 10
  senao valor < 46 # 10% a 46% de vida: valor= 10 a 1
    valor = (50 - valor) / 4
  senao
    valor = 1
  fimse
  casovar r.p_captura
  casose "1" # Muito fácil
    valor *= 2
    sair
  casose "2" # Fácil
    valor *= 1.5
    sair
  casose "3" # Normal
    sair
  casose "4" # Difícil
    valor /= 1.5
    sair
  casose "5" # Muito difícil
    valor /= 2
    sair
  casofim
  $mens.p(arg0, r)
  se valor * item.i_captura(r) < r.pnivel * rand(5, 20)
    $mens.mvis1("$P joga " + item.descnome + " para $a, mas $a recusa.")
    item.apagar(1)
    ret
  fimse
  $mens.mvis1("$P joga " + item.descnome + " para $a.")
  item.apagar(1)
# Captura
  listaobj e
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    ret e.objini.cmd_pegaranim(arg0, r, arg0.dono), nulo
  efim
  refvar estacheio = !arg0.animalmais
  r.mudadono(arg0) # Muda de dono
  r.var.z_dono = arg0.nome
  r.var.z_pnivel = r.pnivel
  r.objsolto.remove(r) # Não conta mais na lista de personagens soltos
  arg0.recalc = 1
  r.ajustapeso # Para o peso do personagem ir para 0 (não conta no jogador)
  $mens.p(arg0, r)
  se estacheio
    r.idono.remove, r.idono = r.dono.dentro3.addfim(r)
    $mens.mvis2("$A entrou para a sua equipe como reserva.", "$A entrou para a equipe de $P.")
  senao
    $mens.mvis2("$A entrou para a sua equipe.", "$A entrou para a equipe de $P.")
  fimse
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    sair e.objini.cmd_pegouanim(arg0, r, arg0.dono)
  efim


classe cmd_trocar
herda comando_comum, comando_ajuda
const objcmd = config:animal1 ? este
const objajuda = config:animal1 ? este
const txtajuda = "\b\c3Trocar\b\n\
Sintaxe: TROCAR\n\
         TROCAR <item>\n\
         TROCAR <número> <número>\n\
Sem argumentos pega um item do animal escolhido.\n\
Com o nome de um item, dá um item para o animal escolhido.\n\
Com dois números, troca dois animais de lugar."

func escr
  ret arg0.atkenv, arg0.msg("Você não consegue trocar durante a batalha.")
  ret !arg1, escr_pegar(arg0)
  uint8 p1
  uint8 p2
  p1 = txt1(arg1), p2 = txt2(arg1)
  se txt1(arg1) != p1 || !p1 || p1 > config:animal1
    escr_dar(arg0, arg1)
  senao txt2(arg1) != p2 || !p2 || p2 > config:animal1
    escr_dar(arg0, arg1)
  senao
    escr_trocar(arg0, p1, p2)

func escr_pegar # Pegar item do animal
# arg0 = personagem
  ret arg0.persoesc == arg0, arg0.msg("Primeiro escolha um animal.")
  refvar rec = ref(arg0.persoesc.dentro1.ini.obj)
  se !rec
    $mens.p(arg0.persoesc) + $mens.mperso("$P não carrega nenhum item.")
  senao (arg0.objnum >> 1) + (rec.objnum >> 1) > config:itens
    arg0.msg("Você não consegue carregar tanta coisa.")
  senao
    rec.mudadono(arg0, 1)
    $mens.p(arg0)
    refvar lin = "pega " + rec.descnome + " de " + arg0.persoesc.nome
    $mens.mvis1("$P " + txttroca(lin, "$", "$$") + ".")

func escr_dar # Dar item para o animal
# arg0 = personagem
# arg1 = nome do item
  ret arg0.persoesc == arg0, arg0.msg("Primeiro escolha um animal.")
  listaobj l
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    refvar env = ref(l.objini)
    refvar rec = ref(arg0.persoesc.dentro1.ini.obj)
    se env.objnum >> 1 > 1 # Animal não carrega objetos com coisas dentro
      arg0.msg(txtcopiamai(arg0.persoesc.descnome, "A") + " não consegue carregar isso.")
    senao !rec # Se animal não está carregando nada
      env.mudadono(arg0.persoesc, 1)
      $mens.p(arg0)
      refvar lin = "dá " + env.descnome + " para " + arg0.persoesc.nome
      $mens.mvis1("$P " + txttroca(lin, "$", "$$") + ".")
    senao (arg0.objnum >> 1) - (env.objnum >> 1) + (rec.objnum >> 1) > config:itens
      arg0.msg("Você não consegue carregar tanta coisa.")
    senao
      env.mudadono(arg0.persoesc, 1)
      rec.mudadono(arg0, 1)
      $mens.p(arg0)
      refvar lin = "pega " + rec.descnome + " de " + arg0.persoesc.nome + " e dá "
      $mens.mvis1("$P " + txttroca(lin + env.descnome, "$", "$$") + ".")
    fimse
    ret
  efim
  arg0.msg("Você não vê isso.")

func escr_trocar # Trocar dois animais de lugar
# arg0 = personagem
# arg1 = número do primeiro animal
# arg2 = número do segundo animal
  refvar a1 = arg0.animalnum(arg1)
  refvar a2 = arg0.animalnum(arg2)
  ret a1 == a2, arg0.msg("Nada para ser trocado.")
# Obtém os itens da lista
  listaitem i1
  listaitem i2
  i1 = a1.idono
  i2 = a2.idono
# Adiciona novos itens na lista
  a1.idono = i2 ? i2.adddepois(a1) : arg0.dentro2.addfim(a1)
  a2.idono = i1 ? i1.adddepois(a2) : arg0.dentro2.addfim(a2)
# Remove os itens antigos da lista
  i1.remove, i2.remove
# Mensagens
  arg0.msg("Você troca de lugar " + arg1 + " e " + arg2 + ".")


classe cmd_animal
herda comando_comum, comando_ajuda
const objcmd = config:animal1 ? este
const objajuda = config:animal1 ? este
const txtajuda = txttroca(config:animal2 ? ta1 + ta2 : ta1, "$$", config:animal1)
const ta1 = "\b\c3Animais\b\n\
  \c2CAPTURAR\b Pega o animal que está lutando com você.\n\
  \c2SOLTAR\b   Solta um animal (você se desfaz dele)\n\
  \c2DAR\b      Dá animal a outro personagem\n\
  \c2ANIMAL\b   Mostra animais que você possui\n\
  \c20\b        Não escolhe nenhum animal para batalha\n\
  \c21\b a \c2$$\b    Escolhe um animal seu, de 1 a $$\n\
  \c2TROCAR\b   Dá itens para um animal e troca animais de lugar"
const ta2 = "\n\  \c2RESERVA\b  Manuseio de animais reserva"
const posic = 0

func escr
  textotxt t
  txt100 lin
  uint8 num
  listaitem i
  t.addfim((arg0.persobat == arg0 ? "0* Você  N" : "0  Você  N") + arg0.pnivel)
  epara i = arg0.dentro2.ini, i, i.depois
    continuar !i.obj.perso
    lin = txt(num += 1) + (arg0.persobat == i.obj ? "*" : " ")
    se i.obj.pvida
      lin += " " + txtcopiamai(i.obj.nome, "A") + "  N" + i.obj.pnivel
    senao
      lin += " (" + txtcopiamai(i.obj.nome, "A") + ")  N" + i.obj.pnivel
    fimse
    t.addfim(lin)
  efim
  se t.linhas == 1
    arg0.msg("Não possui nenhum animal.")
  senao
    arg0.msg2("\b\c6Animais:\b\n" + t.remove(1000))


classe comando_escolhe_animal
herda comando_comum
const posic = 5
int8 num # Número do animal; preenchido pela função "teclou" do personagem

func escr # Chamado pela função "teclou" do personagem ao escolher um animal
  refvar r = arg0.animalnum(num)
  se !r
    arg0.msg("Você não possui " + num + ".")
  senao arg0.persoesc == r
    arg0.msg("Você já escolheu " + num + ".")
  senao r == arg0
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = arg0
    $mens.p(arg0)
    $mens.mvis1("$P não escolhe ninguém.")
    arg0.escolhebat # Atualiza persobat
  senao
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = r
    arg0.escolhebat # Atualiza persobat
    $mens.p(arg0, r)
    $mens.mvis1("$P escolhe $b.")


classe cmd_reserva
herda comando_comum, comando_ajuda
const objcmd = config:animal1 && config:animal2 ? este
const objajuda = config:animal1 && config:animal2 ? este
const txtajuda = "\b\c3Reserva\b\n\
Sintaxe: RESERVA\n\
         RESERVA <número do animal>\n\
         RESERVA <nome do animal>\n\
Sem argumentos mostra os seus animais reserva.\n\
Com um número guarda seu animal para a lista de animais reserva.\n\
Com um nome pega um animal reserva."

func escr
  se arg0.dentro3.total != txt(int(arg0.dentro3.total))
    arg0.msg("Você não sabe como lidar com animais reserva.")
  senao !arg0.dono.s_reserva
    arg0.msg("Não pode lidar com animais reserva aqui.")
  senao arg0.atkenv
    arg0.msg("Você está lutando pela sua vida.")
  senao !arg1
    textotxt t
    txt100 lin
    listaitem i
    epara i = arg0.dentro3.ini, i, i.depois
      se i.obj.pvida
        lin = "1 " + txtcopiamai(i.obj.nome, "A") + "  N" + i.obj.pnivel
      senao
        lin = "1 (" + txtcopiamai(i.obj.nome, "A") + ")  N" + i.obj.pnivel
      fimse
      t.addfim(lin)
    efim
    se !t.linhas
      arg0.msg("Não possui nenhum animal reserva.")
    senao
      t.juntalin("(", "x)")
      arg0.msg2("\b\c6Animais reserva:\b\n" + t.remove(1000))
    fimse
  senao arg1 == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    se arg0.dentro3.total >= config:animal2
      ret arg0.msg("Atingido o limite de animais reserva.")
    fimse
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    listaobj e
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      ret e.objini.cmd_reservaguarda(arg0, r, arg0.dono), nulo
    efim
    ret r.dono != arg0, nulo # Retorna se não possui mais o animal
    r.idono.remove
    r.idono = r.dono.dentro3.addfim(r)
    arg0.recalc = 1
    arg0.msg("Você guardou " + r.descnome + " N" + r.pnivel)
  senao
    listaobj l
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara l.addfim(arg0.dentro3), l, l.ini.remove
      sair n.nome(l.objini.ident, l.objini.objtot)
    efim
    refvar r = ref(l.objini)
    ret !r, arg0.msg("Você não possui animal reserva " + arg1 + ".")
    ret !arg0.animalmais, arg0.msg("Sem espaço para pegar animal reserva.")
    r.idono.remove
    r.idono = r.dono.dentro2.addfim(r)
    arg0.recalc = 1
    arg0.msg("Você pegou " + r.descnome + " N" + r.pnivel)
  fimse
