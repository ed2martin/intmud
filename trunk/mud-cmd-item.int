classe cmd_acender
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Acender\b\n\
Sintaxe: ACENDER <objeto>\n\
Acende um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Acender o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode acender
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue acender " + r.descnome + ".")
    senao !r.luztempo
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " não acende mais.")
    senao r.luztempo > 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está aces" + (r.sexo ? "o." : "a."))
    senao r.luzitem == 6 # Se requer fogo para acender
      l.limpar
      epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
        sair int(l.objini.luzitem) >= 3 && int(l.objini.luztempo) > 0
      efim
      ret !l.objini, arg0.msg("Você precisa de fogo para acender " + r.descnome + ".")
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acender(arg0, r), nulo
    efim
# Acende
    r.luztempo.pos, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1(r.luzliga ? r.luzliga : "$P acende $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_acendeu(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_apagar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Apagar\b\n\
Sintaxe: APAGAR <objeto>\n\
Apaga um objeto (um fósforo, uma lamparina, etc)."
const posic = 5

func escr
  listaobj l
  nomeobj n # Para reconhecer os itens
  textotxt nomes # Nomes dos itens pegos
  ret !arg1, arg0.msg("Acender o quê?")
  n.ini(arg1, 1)
  epara l.addfim(arg0.dono.dentro1, arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    ref r
    r = l.objini
# Checa se pode apagar
    se !r.luzitem || r.luzitem == 3
      ret arg0.msg("Você não consegue apagar " + r.descnome + ".")
    senao !r.luztempo || r.luztempo < 0
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está apagad" + (r.sexo ? "o." : "a."))
    fimse
# Eventos
    l.limpar
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagar(arg0, r), nulo
    efim
# Apaga
    r.luztipo == 5 ? (r.luztempo = 0) : r.luztempo.neg, r.ajustapeso
    $mens.p(arg0, nulo, r)
    $mens.mvis1("$P apaga $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_apagou(arg0, r), nulo
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_pegar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Pegar\b\n\
Sintaxe: PEGAR <objeto>\n\
         PEGAR <quantidade> <objeto>\n\
         PEGAR <objeto> <container>\n\
         PEGAR <quantidade> <objeto> <container>\n\
Pega um objeto do chão ou de um container (uma bolsa, uma estante, etc)."
const posic = 5
#
ref sala # De onde pegar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_pegar(arg0, arg1), nulo
  efim
# Obtém o objeto de onde pegar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    mens = "."
  senao
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.sexo ? "o." : \
"a."))
    fimse
    mens = " de $a."
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
# Pega os itens
  achou = 0
  epara l.addfim(sala.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    refvar r = ref(l.objini)
    se arg0.dentro1.total + total > arg0.objmax
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    senao arg0.volden + r.voltot * total / r.objtot > arg0.volmax
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    senao arg0.pesoden - arg0.pesoveste + r.pesotot * total / r.objtot > arg0.pesomax
      ret r.pesotot > r.objtot * arg0.pesomax * 2, arg0.msg("É pesado demais.")
      ret arg0.msg("Você não consegue carregar tanto peso.")
    senao (arg0.objnum >> 1) + (r.objnum >> 1) > config:itens
      ret arg0.msg("Você não consegue carregar tanta coisa.")
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_pegarobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P pega $o" + mens)
    senao
      $mens.mvis1("$P pega " + total + "x $o" + mens)
    fimse
    r.mudadono(arg0, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_pegouobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Pega moedas
  se sala.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", sala.var.z_moedas_)
    total = int(misc:sep1) ? n : sala.var.z_moedas
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_pegarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ -= total
    sala.var.z_moedas_ < 0 && sala.var.z_moedas = ""
    arg0.var.z_moedas_ += total
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P pega uma moeda" + mens)
    senao total == 2
      $mens.mvis1("$P pega duas moedas" + mens)
    senao
      $mens.mvis1("$P pega " + total + " moedas" + mens)
    fimse
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_soltar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta1 + ta2 + ta3 + ta4 : ta1 + ta3
const ta1 = "\b\c3Soltar\b\n\
Sintaxe: SOLTAR <objeto>\n\
         SOLTAR <quantidade> <objeto>\n\
         SOLTAR <objeto> <container>\n\
         SOLTAR <quantidade> <objeto> <container>\n"
const ta2 = "         SOLTAR <número do animal>\n"
const ta3 = "Solta um objeto no chão ou em um container (uma bolsa, uma estante, etc)."
const ta4 = "\nPermite também soltar algum animal (se desfazer) que você possuir."
const posic = 5
#
ref sala # Aonde soltar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
txt80 mens2 # Outra parte da mensagem
int1 achou # Se achou algum item
int8 soltar # Se pode soltar itens

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
# Checa soltar animal
  casovar arg1
  casose "1"
  casose "2"
  casose "3"
  casose "4"
  casose "5"
  casose "6"
  casose "7"
  casose "8"
    uint8 num
    num = int(arg1) - 1
    sair num >= config:animal1
    ref r
    r = arg0.animal.[num]
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar == 2, arg0.msg("Não é possível soltar esse animal.")
    listaobj e
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      ret e.objini.cmd_soltaranim(arg0, r, arg0.dono), nulo
    efim
    r = arg0.animal.[num]
    ret !r, nulo # Retorna se não possui mais o animal
    $mens.p(arg0, r)
    $mens.mvis1("$P se despede de $a e $a vai embora.")
    apagar(r) # Apaga animal
    arg0.recalc = 1 # Acerta personagem
    arg0.animal.[num] = 0 # Indica que não tem o animal
    arg0.escolhebat # Escolhe um animal em condições de batalhar
    arg0.persoesc == r && (arg0.persoesc = arg0.persobat)
    epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
      e.objini.cmd_soltouanim(arg0, r, arg0.dono)
    efim
    ret
  casofim
# Obtém o objeto de onde soltar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    sala = arg0.dono
    soltar = sala.s_soltar
    mens = ""
    ret soltar == 1, arg0.msg("Você não consegue soltar itens aqui.")
  senao
    soltar = 0
    sala = misc:sepitem(arg0) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.sexo ? "o." : \
"a."))
    fimse
    mens = " em $a"
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
# Solta os itens
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    se sala.dentro1.total + total >= sala.objmax
      ret sala.item, arg0.msg("Não consegue soltar nada em " + sala.descnome + ".")
      ret arg0.msg("Não consegue soltar nada aqui.")
    senao sala.volden + l.objini.voltot * total / l.objini.objtot > sala.volmax * l.objini.objtot
      ret arg0.msg("Não há espaço suficiente para soltar isso.")
    fimse
    listaobj e
    total = n # Quantidade de itens
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      sair e.objini.cmd_soltarobj(arg0, sala, l.objini, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, l.objini)
    mens2 = mens ? "$P coloca " : "$P solta "
    mens2 += total <= 1 ? "$o" : txt(total) + "x $o"
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      l.objini.apagar(total)
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      l.objini.apagar(total)
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      l.objini.apagar(total)
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      l.objini.mudadono(sala, total)
    casofim
    epara e.addfim(arg0.evento, sala.evento, l.objini.evento), e, e.ini.remove
      e.objini.cmd_soltouobj(arg0, sala, l.objini, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Solta moedas
  se arg0.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_soltarmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && arg0.var.z_moedas = ""
    $mens.p(arg0, sala)
    mens2 = mens ? "$P coloca " : "$P solta "
    se total == 1
      mens2 += "uma moeda"
    senao total == 2
      mens2 += "duas moedas"
    senao
      mens2 += txt(total) + " moedas"
    fimse
    casovar soltar
    casose "2"
      $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
      sair
    casose "3"
      $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
      sair
    casose "4"
      $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
      sair
    casose
      $mens.mvis1(mens2 + mens + ".")
      sala.var.z_moedas_ += total
    casofim
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_dar
herda comando_comum, comando_ajuda
const txtajuda = config:animal1 ? ta2 : ta1
const ta1 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
Dá um objeto para outro personagem."
const ta2 = "\b\c3Dar\b\n\
Sintaxe: DAR <objeto> <personagem>\n\
         DAR <número do animal> <personagem>\n\
Dá um objeto ou animal para outro personagem."
const posic = 5
#
ref sala # Para quem dar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
int1 achou # Se achou algum item

func escr
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_dar(arg0, arg1), nulo
  efim
# Dar animal a outro personagem
  casovar txt1(arg1)
  casose "1"
  casose "2"
  casose "3"
  casose "4"
  casose "5"
  casose "6"
  casose "7"
  casose "8"
    uint8 num
    num = int(arg1) - 1
    sair num >= config:animal1 || intsub(arg1) > 2
    ref r
    r = arg0.animal.[num]
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar, arg0.msg("Não é possível dar esse animal.")
    ret !txt2(arg1), arg0.msg("Dar " + arg1 + " para quem?")
    listaobj l
    nomeobj n
    n.ini(txt2(arg1), 1)
    epara l.addfim(arg0.dono.dentro2), l, l.ini.remove
      continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident)
      se i.obj == arg0
        ret arg0.msg("Dar para você mesmo?")
      senao !l.objini.jog
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não é jogador.")
      senao !l.objini.animalnum
        ret arg0.msg(txtcopiamai(l.objini.descnome, "A") + " não tem espaço para receber \
animal.")
      fimse
      listaobj e
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        ret e.objini.cmd_daranim(arg0, r, l.objini), nulo
      efim
      r = arg0.animal.[num]
      ret !r, nulo # Retorna se não possui mais o animal
      uint8 num2
      ret !(num2 = l.objini.animalnum), nulo
      arg0.animal.[num] = 0, arg0.recalc = 1
      l.objini.animal.[num2 - 1] = r, l.objini.recalc = 1
      r.dono = l.objini
      arg0.escolhebat
      $mens.p(arg0, l.objini)
      $mens.mvis1("$P dá " + r.descnome + " para $a.")
      epara e.addfim(arg0.evento, r.evento, l.objini.evento), e, e.ini.remove
        e.objini.cmd_deunim(arg0, r, l.objini)
      efim
      ret
    efim
    ret arg0.msg("Você não vê " + txt2(arg1) + ".")
  casofim
# Obtém para quem dar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  ret !misc:sep2, arg0.msg("Dar itens para quem?")
  sala = misc:sepperso(arg0) # Procura o alvo para o personagem arg0
  se !sala
    ret arg0.msg("Você não vê " + misc:sep2 + ".")
  senao !sala.p_recebe
    ret arg0.msg("Não é possível dar nada para " + sala.descnome + ".")
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, 1000000)
# Dá os itens
  achou = 0
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    refvar r = ref(l.objini)
    se sala.dentro1.total + total >= sala.objmax
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar mais nada.")
    senao sala.volden + r.voltot * total / r.objtot > sala.volmax
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar isso.")
    senao sala.pesoden - sala.pesoveste + r.pesotot * total / r.objtot > sala.pesomax
      ret arg0.msg("É pesado de mais para " + txtcopiamai(sala.descnome, "A") + ".")
    senao (sala.objnum >> 1) + (r.objnum >> 1) > config:itens
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não consegue carregar isso.")
    fimse
    listaobj e
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      sair e.objini.cmd_darobj(arg0, sala, r, total)
    efim
    se e
      sair (achou += 1) >= 10
      continuar
    fimse
    $mens.p(arg0, sala, r)
    se total <= 1
      $mens.mvis1("$P dá $o para $a.")
    senao
      $mens.mvis1("$P dá " + total + "x $o para $a.")
    fimse
    r.mudadono(sala, total)
    epara e.addfim(arg0.evento, sala.evento, r.evento), e, e.ini.remove
      e.objini.cmd_deuobj(arg0, sala, r, total)
    efim
    sair (achou += 1) >= 10
  efim
  ret achou, nulo
# Dá moedas
  se arg0.var.z_moedas_ && n.nome("moedas", arg0.var.z_moedas_)
    total = n
    listaobj e
    epara e.addfim(arg0.evento, sala.evento), e, e.ini.remove
      ret e.objini.cmd_darmoedas(arg0, sala, total), nulo
    efim
    ret !total, nulo
    sala.var.z_moedas_ += total
    arg0.var.z_moedas_ -= total
    arg0.var.z_moedas_ < 0 && arg0.var.z_moedas = ""
    $mens.p(arg0, sala)
    se total == 1
      $mens.mvis1("$P dá uma moeda para $a.")
    senao total == 2
      $mens.mvis1("$P dá duas moedas para $a.")
    senao
      $mens.mvis1("$P dá " + total + " moedas para $a.")
    fimse
    ret
  fimse
# Não encontrou o item
  arg0.msg("Você não vê isso.")


classe cmd_usar
herda comando_comum
const objcmd = $cmd_vestir
const objajuda = $cmd_vestir


classe cmd_vestir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Vestir\b\n\
Sintaxe: VESTIR <objeto> [posição]\n\
         USAR <objeto> [posição]\n\
Veste ou usa um objeto que você está carregando.\n\
Para saber em que posições pode vestir algo, tecle EQUIP TUDO"
const posic = 5
txt30 tipo1 # arg0.tipo1
txt30 tipo2 # arg0.tipo2
txt30 tipo3 # arg0.tipo3

func escr
  ret !arg1, arg0.msg("Vestir o que?")
  tipo1 = arg0.tipo1 ? "\n" + arg0.tipo1 + "\n" : ""
  tipo2 = arg0.tipo2 ? "\n" + arg0.tipo2 + "\n" : ""
  tipo3 = arg0.tipo3 ? "\n" + arg0.tipo3 + "\n" : ""
# Variáveis
  int32 lugar # Aonde quer vestir
  int1 vest.32 # Aonde está vestindo
  int8 total # Quantidade de itens encontrados
  nomeobj n # Para reconhecer os itens
  listaitem item
# Preenche a variável vest com o que está vestindo
  epara item = arg0.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Descobre aonde quer vestir
  misc:separa(arg1) # Separa nome do objeto do nome da posição
  se !misc:sep2
    lugar = -1 # Todos os bits em 1
  senao
    n.ini(misc:sep2, 100)
    textotxt t
    textopos pos
    t.addfim(config:equip_txt)
    epara pos = t.ini, pos, pos.depois
      n.nome(pos.texto) && (lugar = lugar | 1 << pos.linha)
    efim
    ret !lugar, arg0.msg("Você não sabe aonde fica " + misc:sep2 + ".")
  fimse
# Veste
  listaobj l
  ref r
  n.ini(misc:sep1, 1000000)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    total += n
# Vestir - checa o nível
    se int(r.pnivel) > arg0.pnivel
      arg0.msg("Você precisa estar no nível " + r.pnivel + " para vestir " + r.descnome + \
".")
      continuar
    fimse
    uint8 x
    epara x = n, x, x -= 1
# Vestir - checa se o item pode ser vestido
      refvar lugar2 = lugar & r.vestir1
      se !lugar2
        se !r.vestir1
          arg0.msg("Não se pode vestir " + r.descnome + ".")
        senao
          arg0.msg("Você não consegue vestir " + r.descnome + ".")
        fimse
        sair
# Vestir - checa se a classe ou a raça tem permissão
      senao !r.vestirnao
      senao tipo1 && txtproc("\n" + r.vestirnao + "\n", tipo1) >= 0
        arg0.msg("Você não consegue vestir " + r.descnome + ".")
        sair
      senao tipo2 && txtproc("\n" + r.vestirnao + "\n", tipo2) >= 0
        arg0.msg("Você não consegue vestir " + r.descnome + ".")
        sair
      senao tipo3 && txtproc("\n" + r.vestirnao + "\n", tipo3) >= 0
        arg0.msg("Você não consegue vestir " + r.descnome + ".")
        sair
      fimse
# Vestir - checa se o item deixa
      txt100 txtvestir
      txtvestir = r.cmd_podevestir(arg0)
      ret txtvestir, arg0.msg(txtvestir)
# Vestir - checa os itens que estão em cima
      int32 erro1 # Posição aonde já está vestindo o item
      int32 erro2 # Posições aonde tem itens em cima
      uint8 pos
      epara pos = 0, pos < 32, pos += 1
        continuar !(lugar2 >> pos & 1) # Checa se é o lugar
        se vest.[pos]
          erro1 = pos + 1
        senao (erro2 = vest.bits & config:vestir[pos]) == 0
          erro1 = 0
          sair
        fimse
      efim
# Vestir - mensagens de erro
      se erro2
        epara item = arg0.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair erro2 & 1 << item.obj.vestpos - 1
        efim
        arg0.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
        sair
      senao erro1
        epara item = arg0.dentro2.ini, item, item.depois
          sair item.obj.vestpos == erro1
        efim
        arg0.msg("Você está usando " + item.obj.descnome + " nessa posição.")
        sair
# Veste o item
      senao
        listaobj e
        epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_vestir(arg0, r, pos + 1), nulo
        efim
        r.vestir(pos + 1)
        vest.[pos] = 1
        refvar mvestir = txtsublin(config:equip_vestir, pos, 1)
        $mens.p(arg0, r)
        $mens.mvis1(mvestir ? mvestir : "$P veste $a.")
        epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
          e.objini.cmd_vestiu(arg0, r, pos + 1)
        efim
      fimse
    efim
  efim
# Avisa se não encontrou nenhum item
  !total && arg0.msg("Você não vê isso.")


classe cmd_empunhar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Empunhar\b\n\
Sintaxe: EMPUNHAR <objeto>\n\
Empunha uma arma que você está carregando."
const posic = 5
txt30 tipo1 # arg0.tipo1
txt30 tipo2 # arg0.tipo2
txt30 tipo3 # arg0.tipo3

func escr
  ret !arg1, arg0.msg("Empunhar o que?")
  ret arg0.iempu, arg0.msg("Você já está empunhando uma arma.")
  tipo1 = arg0.tipo1 ? "\n" + arg0.tipo1 + "\n" : ""
  tipo2 = arg0.tipo2 ? "\n" + arg0.tipo2 + "\n" : ""
  tipo3 = arg0.tipo3 ? "\n" + arg0.tipo3 + "\n" : ""
# Empunha
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    se !r.armatipo
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " não é arma.")
    senao int(r.pnivel) > arg0.pnivel
      ret arg0.msg("Você precisa estar no nível " + r.pnivel + " para empunhar " + r.descnome + \
".")
    senao config:atktipo && !arg0.var.h_[txtsublin(config:arma_txt, r.armatipo, 1)]
      ret arg0.msg("Você não conhece " + txtsublin(config:arma_txt, r.armatipo, 1) + ".")
    senao r.vestirnao
      se tipo1 && txtproc("\n" + r.vestirnao + "\n", tipo1) >= 0
        ret arg0.msg("Você não consegue empunhar " + r.descnome + ".")
      senao tipo2 && txtproc("\n" + r.vestirnao + "\n", tipo2) >= 0
        ret arg0.msg("Você não consegue empunhar " + r.descnome + ".")
      senao tipo3 && txtproc("\n" + r.vestirnao + "\n", tipo3) >= 0
        ret arg0.msg("Você não consegue empunhar " + r.descnome + ".")
      fimse
    fimse
    listaobj e
    epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
      ret e.objini.cmd_vestir(arg0, r, 50), nulo
    efim
    r.vestir(50)
    $mens.p(arg0, r) + $mens.mvis1("$P empunha $a.")
    epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
      e.objini.cmd_vestiu(arg0, r, 50)
    efim
    ret
  efim
  arg0.msg("Você não vê isso.")


classe cmd_remover
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Remover\b\n\
Sintaxe: REMOVER <objeto>\n\
         REMOVER <quantidade> <objeto>\n\
Deixa de usar um objeto que você está vestindo ou usando."
const posic = 5

func escr
  ret !arg1, arg0.msg("Remover o que?")
# Preenche a variável vest com o que está vestindo
  int1 vest.32 # Aonde está vestindo
  listaitem item
  epara item = arg0.dentro2.ini, item, item.depois
    vest.[item.obj.vestpos - 1] = 1
  efim
# Remove
  uint8 total
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  epara l.addfim(arg0.dentro2), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    uint8 x
    epara x = n, x, x -= 1
      total += 1
      refvar valor = vest.bits & config:vestir[r.vestpos - 1]
      se valor
        listaitem item
        epara item = arg0.dentro2.ini, item, item.depois
          continuar !item.obj.vestpos
          sair valor & 1 << item.obj.vestpos - 1
        efim
        arg0.msg("Antes precisa parar de usar " + item.obj.descnome + ".")
      senao
        refvar posic = int(r.vestpos)
        listaobj e
        epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
          ret e.objini.cmd_remover(arg0, r, posic), nulo
        efim
        vest.[r.vestpos] = 0
        r.vestir(0)
        $mens.p(arg0, r)
        $mens.mvis1("$P remove $a.")
        epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
          e.objini.cmd_removeu(arg0, r, posic)
        efim
      fimse
    efim
  efim
# Ajusta variáveis
  !total && arg0.msg("Você não está usando isso.")


classe cmd_capturar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Capturar\b\n\
Sintaxe: CAPTURAR\n\
         CAPTURAR <objeto>\n\
Usa um objeto para tentar capturar o animal que está lutando com você.\n\
Se o nome do objeto for omitido, usa o último que você escolheu.\n\
Nota: a captura pode falhar se o animal não gostar do item e/ou achar\n\
que você não é digno. Por isso, é sempre bom enfraquecê-lo antes."
const posic = 5

func escr
  ref r
  ref item # Item usado para capturar
# Checa se sabe o nome do item
  ret !arg1 && !arg0.var.z_captura, arg0.msg("Capturar com o quê?")
# Obtém o item
  nomeobj n # Para reconhecer os itens
  n.ini(arg1 ? arg1 : arg0.var.z_captura, 1000000)
  listaobj l
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    r = l.objini
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    ret !r.i_captura, arg0.msg(txtcopiamai(r.descnome, "A") + " não serve para capturar animais."\
)
    item = r
    sair
  efim
# Checa se pode capturar
  ret !item, arg0.msg(arg1 ? "Você não vê isso." : "Capturar com o quê?")
  arg1 && (arg0.var.z_captura = arg1)
  r = arg0.atkenv.objlista # Alvo do personagem
  se !r
    se arg1
      arg0.msg("Você escolhe " + arg1 + " (" + item.descnome + ") para capturar animais.")
    senao
      arg0.msg("Não está lutando com nenhum animal.")
    fimse
    ret
  senao !r.p_captura || r.perso != 2 || arg0.perso != 3
    $mens.p(arg0, r)
    $mens.mvis2("Não é possível capturar $a.", "")
    ret
  fimse
  uint8 lugar
  lugar = arg0.animalnum
  ret lugar == 0, arg0.msg("Sem espaço para guardar animal.")
# Decide se consegue capturar
  real valor
  valor = r.pvida * 100 / r.pvidamax
  se valor < 10 # 0% a 10% de vida: valor=10
    valor = 10
  senao valor < 46 # 10% a 46% de vida: valor= 10 a 1
    valor = (50 - valor) / 4
  senao
    valor = 1
  fimse
  casovar r.p_captura
  casose "1" # Muito fácil
    valor *= 2
    sair
  casose "2" # Fácil
    valor *= 1.5
    sair
  casose "3" # Normal
    sair
  casose "4" # Difícil
    valor /= 1.5
    sair
  casose "5" # Muito difícil
    valor /= 2
    sair
  casofim
  $mens.p(arg0, r)
  se valor * item.i_captura(r) < r.pnivel * rand(5, 20)
    $mens.mvis1("$P joga " + item.descnome + " para $a, mas $a recusa.")
    item.apagar(1)
    ret
  fimse
  $mens.mvis1("$P joga " + item.descnome + " para $a.")
  item.apagar(1)
# Captura
  listaobj e
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    ret e.objini.cmd_pegaranim(arg0, r, arg0.dono), nulo
  efim
  ret arg0.animal.[lugar - 1] || !item, nulo # Retorna se o espaço foi ocupado
  r.mudadono(arg0) # Muda de dono
  r.var.z_dono = arg0.nome
  r.var.z_pnivel = r.pnivel
  r.objsolto.remove(r) # Não conta mais na lista de personagens soltos
  arg0.animal.[lugar - 1] = r # Número do animal na lista do jogador
  arg0.recalc = 1
  r.ajustapeso # Para o peso do personagem ir para 0 (não conta no jogador)
  $mens.p(arg0, r)
  $mens.mvis2("$A entrou para a sua equipe.", "$A entrou para a equipe de $P.")
  epara e.addfim(arg0.evento, r.evento, arg0.dono.evento), e, e.ini.remove
    sair e.objini.cmd_pegouanim(arg0, r, arg0.dono)
  efim


classe cmd_animal
herda comando_comum, comando_ajuda
const objcmd = config:animal1 ? este
const objajuda = config:animal1 ? este
const txtajuda = txttroca(txtajuda1, "$$", config:animal1)
const txtajuda1 = "\b\c3Animais\b\n\
  \c2CAPTURAR\b Pega o animal que está lutando com você.\n\
  \c2SOLTAR\b   Solta um animal (você se desfaz dele).\n\
  \c2DAR\b      Dá animal a outro personagem.\n\
  \c2ANIMAL\b   Mostra animais que você possui.\n\
  \c20\b        Não escolhe nenhum animal para batalha.\n\
  \c21\b a \c2$$\b    Escolhe um animal seu, de 1 a $$."
const posic = 0

func escr
  textotxt t
  txt100 lin
  uint8 num
  ref animal
  t.addfim((arg0.persobat == arg0 ? "0* Você  N" : "0  Você  N") + arg0.pnivel)
  epara nulo, num < 8, num += 1
    animal = arg0.animal.[num]
    continuar !animal
    lin = num + 1
    lin += arg0.persobat == animal ? "*" : " "
    se animal.pvida
      lin += " " + animal.nome + "  N" + animal.pnivel
    senao
      lin += " (" + animal.nome + ")  N" + animal.pnivel
    fimse
    t.addfim(lin)
  efim
  se t.linhas == 1
    arg0.msg("Não possui nenhum animal.")
  senao
    arg0.msg2("Animais:\n" + t.remove(1000))


classe comando_escolhe
herda comando_comum
const objcmd = config:animal1 && int(nome) <= config:animal1 ? este
const posic = 5

func escr
  ref r
  r = perso(arg0) # Nota: perso está definido nas classes derivadas dessa
  se !r
    arg0.msg("Você não possui " + nome + ".")
  senao arg0.persoesc == r
    arg0.msg("Você já escolheu " + nome + ".")
  senao r == arg0
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = arg0
    $mens.p(arg0)
    $mens.mvis1("$P não escolhe ninguém.")
    arg0.escolhebat # Atualiza persobat
  senao
    se arg0.persoesc.pvida && arg0.atkenv # Animal está bom e está lutando
      arg0.p_espera = 40 # Espera 4 segundos
    fimse
    arg0.persoesc = r
    arg0.escolhebat # Atualiza persobat
    $mens.p(arg0, r)
    $mens.mvis1("$P escolhe $A.")


classe cmd_0
herda comando_escolhe
const nome = "0"
const perso = arg0


classe cmd_1
herda comando_escolhe
const nome = "1"
const perso = arg0.animal.0


classe cmd_2
herda comando_escolhe
const nome = "2"
const perso = arg0.animal.1


classe cmd_3
herda comando_escolhe
const nome = "3"
const perso = arg0.animal.2


classe cmd_4
herda comando_escolhe
const nome = "4"
const perso = arg0.animal.3


classe cmd_5
herda comando_escolhe
const nome = "5"
const perso = arg0.animal.4


classe cmd_6
herda comando_escolhe
const nome = "6"
const perso = arg0.animal.5


classe cmd_7
herda comando_escolhe
const nome = "7"
const perso = arg0.animal.6


classe cmd_8
herda comando_escolhe
const nome = "8"
const perso = arg0.animal.7
