classe adm_cod
# Edição do código e comandos gerais de administração
#
const adm_ = "\b\c3Páginas de administração\b\n\
Para ler tecle ADM seguido do nome de um tópico.\n\
Os tópicos são:\n\
  \c2AREA\b     Áreas\n\
  \c2SALA\b     Salas\n\
  \c2SAI\b      Saídas das salas\n\
  \c2ITEM\b     Itens\n\
  \c2TIPO\b     Tipos de personagens (raças e classes)\n\
  \c2PERSO\b    Personagens não jogador\n\
  \c2RESET\b    Reset de área ou sala\n\
  \c2HAB\b      Habilidades e magias\n\
  \c2EFEITO\b   Efeitos\n\
  \c2SOCIAL\b   Comandos sociais\n\
  \c2COD\b      Edição do código fonte\n\
  \c2JOG\b      Comandos para jogadores\n\
  \c2OUTROS\b   Outros comandos\n\
  \c2MENS\b     Caracteres especiais em mensagens\n\
  \c2CORES\b    Cores em mensagens"
# \c2INFO\b     Informações sobre o MUD"
#
const adm_jog = "\c3Comandos para jogadores\b\n\
\c2TELE\b <sala ou jogador>\n\
  Teletransporta para uma sala específica ou para aonde um jogador está.\n\
\c2TELE\b <jogador> <sala>\n\
  Transporta um jogador para uma sala.\n\
\c2TELEENTRA\b [mensagem]\n\
\c2TELESAI\b [mensagem]\n\
  Define as mensagens de quando você se teletransporta usando\n\
  o comando TELE. Sem argumentos, muda para a mensagem padrão, que é:\n\
  \"$P aparece de um redemoinho de fumaça.\" para Teleentra e\n\
  \"$P some em um redemoinho de fumaça.\" para Telesai.\n\
  Para saber as mensagens que você definiu, use o comando ESTAT.\n\
\c2AC\b <texto>\n\
  Envia mensagem para o canal de administração; vide comando CONFIG\n\
\c2ECHO\b <texto>\n\
  Envia texto para todos os jogadores.\n\
\c2MUDANOME\b <nome atual> <novo nome>\n\
  Muda o nome do personagem de um jogador.\n\
\c2LISTARSAV\b\n\
  Mostra os arquivos de jogos salvos. Estão no diretório sav.\n\
\c2APAGARSAV\b <nome do arquivo>\n\
  Apaga um arquivo de jogo salvo.\n\
\c2MONIT\b [jogador]\n\
  Monitora um jogador, permitindo ver o que ele lê e escreve.\n\
  Se [jogador] estiver ausente ou for o próprio, deixa de monitorar.\n\
  O principal objetivo é auxiliar outros usuários, por isso quando\n\
  esse comando é usado, todos os administradores são informados.\n\
  O comando QUEM também mostra aos administradores quem está monitorando.\n\
\c2ESCR\b <comando>\n\
  Digita um comando no teclado do usuário sendo monitorado."
#
const adm_outros = "\c3Outros comandos\b\n\
\c2ECONFIG\b\n\
  Edita as configurações do MUD.\n\
\c2SERV\b\n\
  Mostra informações sobre o estado atual do MUD.\n\
\c2INFO\b\n\
  Informações sobre a sala.\n\
\c2INFO\b <personagem ou item>\n\
  Informações sobre personagem ou item.\n\
\c2ESTAT\b <personagem>\n\
\c2ESTAT\b <personagem> <número do animal>\n\
  Mostra estatísticas de um personagem que está na sala.\n\
  Para administradores, mostra também fome, sede e embriaguês.\n\
  Essa sintaxe também funciona com os comandos INV, EQUIP e EFEITO.\n\
\c2HIST\b [personagem] [número do animal]\n\
  Mostra o histórico de um personagem na mesma sala ou animal desse\n\
  personagem, ou seja, os últimos 10 personagens que ele matou.\n\
\c2INFOHAB\b [personagem] [número do animal]\n\
\c2INFOMAG\b [personagem] [número do animal]\n\
\c2INFOE\b   [personagem] [número do animal]\n\
  Informa habilidades, magias e efeitos de um personagem na sala.\n\
\c2MATAR1\b <personagem/item>  [personagem/item] ... [personagem/item]\n\
  Com um argumento, apaga um personagem ou item.\n\
  Pode ser usado para apagar personagens ou itens dentro de outros.\n\
\c2MATAR2\b <personagem>\n\
  Mata instantaneamente um personagem.\n\
\c2LUGAR\b <sala ou personagem jogador> <comando>\n\
  Executa um comando como se estivesse em outra sala. Com personagem\n\
  jogador, executa como se estivesse na mesma sala do jogador.\n\
  Nota: O administrador é teletransportado momentaneamente para outra sala.\n\
\c2CMD\b <comando>\n\
\c2CMDP\b <personagem da sala> <comando>\n\
\c2CMDJ\b <personagem jogador> <comando>\n\
  Executa comando na linguagem do IntMUD e mostra o resultado.\n\
\c2MUDLER\b\n\
  Recarrega arquivos do MUD que foram alterados.\n\
  Nota: Outra forma de recarregar os arquivos é pressionar a tecla F10\n\
  na janela do IntMUD."
#
const adm_mens = "\b\c3Caracteres especiais em mensagens\b\n\n\
As seguintes sequências de caracteres têm um significado especial:\n\
 \c2$$\b  Símbolo $\n\
 \c2$P\b  Nome do personagem\n\
 \c2$Q\b  Nome do personagem sem citar o dono\n\
 \c2$R\b  Nome do personagem no comando QUEM\n\
 \c2$A\b  Nome do alvo\n\
 \c2$B\b  Nome do alvo sem citar o dono\n\
 \c2$C\b  Nome do alvo no comando QUEM\n\
 \c2$O\b  Nome do objeto\n\
 \c2$S\b  Depende do personagem: o, a, um ou uma\n\
 \c2$T\b  Depende do alvo: o, a, um ou uma\n\
 \c2$U\b  Depende do objeto: o, a, um ou uma\n\
 \c2$V\b  Depende do personagem: e ou a\n\
 \c2$W\b  Depende do alvo: e ou a\n\
 \c2$X\b  Depende do objeto: e ou a\n\
 \c2$M\b  Mensagem; somente comandos que usam uma mensagem digitada por alguém\n\n\
Quando o símbolo $ for seguido de uma letra minúscula, a primeira letra\n\
do texto não é transformada em maiúscula."
#
const adm_cores = "\b\c3Cores em mensagens\b\n\n\
É possível definir as cores dos caracteres e do fundo nas mensagens.\n\
Entretanto, não há suporte a cores no Papovox, nem para os usuários\n\
que jogarem através de um chat.\n\n\
As seguintes sequências de caracteres mudam a cor das letras:\n\
 \\c0  \c7Preto\b             \\c1  \c1Vermelho\b          \\c2  \c2Verde\b\n\
 \\c3  \c3Marrom\b            \\c4  \c4Azul\b              \\c5  \c5Magenta\b\n\
 \\c6  \c6Ciano\b             \\c7  \c7Branco\b            \\c8  \c8Cinza\b\n\
 \\c9  \c9Vermelho intenso\b  \\ca  \caVerde intenso\b     \\cb  \cbAmarelo\b\n\
 \\cc  \ccAzul intenso\b      \\cd  \cdMagenta intenso\b   \\ce  \ceCiano intenso\b\n\
 \\cf  \cfBranco intenso\b\n\n\
As seguintes sequências de caracteres mudam a cor de fundo:\n\
 \\d0  \d0Preto\b             \\d1  \d1Vermelho\b          \\d2  \d2Verde\b\n\
 \\d3  \d3Marrom\b            \\d4  \d4Azul\b              \\d5  \d5Magenta\b\n\
 \\d6  \d6Ciano\b             \\d7  \c0\d7Branco\b\n\n\
As seguintes sequências de caracteres mudam outros atributos:\n\
 \"    Aspas duplas\n\
 \\\\   Barra invertida: \\\n\
 \\b   Caracteres brancos sob fundo preto sem piscante, sublinhado e inverso\n\
 \\cg  Liga o sublinhado (um traço horizontal em baixo)\n\
 \\ch  Desliga o sublinhado\n\
 \\ci  Liga inversão de frente com fundo (troca cores de frente com fundo)\n\
 \\cj  Desliga inversão de frente com fundo\n\
 \\ck  Liga texto piscante\n\
 \\cl  Desliga texto piscante"
#
const adm_cod = "\b\c3Comandos de edição do código\b\n\
\c2lcl\b [nome]\n\
  Lista as classes existentes.\n\
\c2ccl\b <nome> [arquivo]\n\
  Cria classe. Aquivo é o sufixo do arquivo aonde criar a classe.\n\
  Se for omitido, cria no arquivo mud.int.\n\
\c2acl\b <nome>\n\
  Apaga classe.\n\
\c2ecl\b [nome]\n\
  Edita uma classe.\n\
\c2herda\b <nome>\n\
  Edita herança de uma classe (uma classe herdada por linha).\n\
\c2lfunc\b <nome>\n\
  Lista funções de uma classe.\n\
\c2lfunc2\b <nome>\n\
  Lista todas funções de uma classe, inclusive as herdadas."

func cmd_adm
  prog p
  se p.inifunctudo(este, "adm_" + arg0)
    msg2([p.texto])
  senao
    msg("\bTópico de administração desconhecido: " + arg0)
  fimse
  ret 1

func cmd_serv # Informações sobre o servidor
  txt100 lin
  int32 i.3
  debug d
  txtmais.limpar
  txtmais.addfim("\b\c3Estado atual do MUD:\b")
  i.2 = $miscserv.noar % 1440
  i.0 = ($miscserv.noar - i.2) / 1440 # Dias
  i.1 = intdiv(i.2 / 60) # Horas
  i.2 %= 60 # Minutos
  txtmais.addfim("No ar há " + i.0 + " dias " + i.1 + " horas " + i.2 + " min")
  txtmais.addfim("Memória usada:  " + txtnum(d.mem, ".") + " bytes")
  txtmais.addfim("Memória máxima: " + txtnum(d.memmax, ".") + " bytes")
# lin = "Memória usada:  " + txtnum(d.mem, ".") + " bytes"
# lin += "   (máximo foi " + txtnum(d.memmax, ".") + " bytes)"
# txtmais.addfim(lin)
  lin = "Processador (stempo): " + txtnum(d.stempo / 1000, ".3") + " seg."
  lin += "  (no último minuto " + txtnum($miscserv.stempo / 1000, ".3") + " seg.)"
  txtmais.addfim(lin)
  lin = "Processador (utempo): " + txtnum(d.utempo / 1000, ".3") + " seg."
  lin += "  (no último minuto " + txtnum($miscserv.utempo / 1000, ".3") + " seg.)"
  txtmais.addfim(lin)
  txtmais.addfim("IntMUD versão " + d.ver + " (" + d.data + "), MUD versão " + misc:versao)
  txtmostra
  ret 1

func cmd_teleentra
  se !arg0
    msg("Mensagem teleentra voltou ao padrão.")
  senao txtproc(arg0, "$P") >= 0
    msg("Mensagem teleentra mudou para: " + arg0)
  senao
    msg("Mensagem teleentra deve ter obrigatoriamente $P.")
    ret 1
  fimse
  perso.var.z_teleentra = arg0
  ret 1

func cmd_telesai
  se !arg0
    msg("Mensagem telesai voltou ao padrão.")
  senao txtproc(arg0, "$P") >= 0
    msg("Mensagem telesai mudou para: " + arg0)
  senao
    msg("Mensagem telesai deve ter obrigatoriamente $P.")
    ret 1
  fimse
  perso.var.z_telesai = arg0
  ret 1

func cmd_tele # Ir para uma sala específica
  ref p # Personagem
  ref s # Sala destino
  indiceitem item
# Transportar um jogador para uma sala
  se txt2(arg0)
    item.ini("pn " + txtnome(txt1(arg0)))
    p = item.obj, s = $s_[txt2(arg0)]
    se !p
      msg("Jogador inexistente ou ausente: " + txt1(arg0))
    senao !s
      msg("\bSala não existe: " + txt2(arg0))
    senao s == p.dono
      msg(p.nome + " já está em " + txt(s, 2) + ".")
      s = nulo
    fimse
# Transportar-se para uma sala
  senao arg0
    p = perso, s = $s_[arg0]
    se !p
      msg("Você deve estar controlando um personagem para isso")
    senao !s
      item.ini("pn " + txtnome(arg0))
      s = item.obj.dono
      !s && msg("\bSala ou jogador não existe: " + arg0)
    fimse
    se s && s == p.dono
      msg("Você já está em " + txt(s, 2) + ".")
      s = nulo
    fimse
  senao
    msg("Teletransportar quem? Para onde?")
  fimse
# Realiza o teletransporte
  se !(p && s)
  senao p == perso
    txt200 mens1
    $mens.p(p, perso)
    mens1 = perso.var.z_telesai
    $mens.mvis2("", mens1 ? mens1 : "$P some em um redemoinho de fumaça.")
    p.mudadono(s)
    mens1 = perso.var.z_teleentra
    $mens.mvis2("", mens1 ? mens1 : "$P aparece em um redemoinho de fumaça.")
  senao
    $mens.p(p, perso)
    p.msginv("$A teletransporta você.")
    $mens.mvis2("", "$P some em um redemoinho de fumaça.")
    p.mudadono(s)
    $mens.mvis2("", "$P aparece de um redemoinho de fumaça.")
  fimse
  ret 1

func cmd_lugar
  ref sala
# Checa um comando lugar dentro de outro
  se $jog_lugar
    msg("Não é permitido executar um comando LUGAR dentro de outro.")
    ret 1
# Obtém a sala
  senao !txt2(arg0)
    msg("Sintaxe: LUGAR <sala ou jogador> <comando>")
    ret 1
  senao !(sala = $s_[txt1(arg0)])
    indiceitem item
    item.ini("pn " + txtnome(txt1(arg0)))
    sala = item.obj.dono
  fimse
  se !sala
    msg("\bSala ou jogador não existe: " + txt1(arg0))
    ret 1
  fimse
# Muda de sala e garante que vai voltar à sala original
  criar("jog_lugar", perso, sala)
# Comando de administração
  refvar lin = txt2(arg0)
  ret cmd_[txt1(lin)](txt2(lin)), 1
# Comando para o jogo
  perso.teclou(lin) # Personagem processa comando
  perso.p_espera < 2 && (perso.p_espera = 2)
  ret 1

func cmd2_info # Usado por cmd_info
  txt512 lin
  lin = "Peso:   obj=" + arg0.pesoobj + "  dentro=" + arg0.pesoden
  lin += "  total=" + arg0.pesotot + "  voando=" + (arg0.pesoadd ? "N" : "S")
  lin += "\nVolume: obj=" + arg0.volobj + "  dentro=" + arg0.volden
  lin += "  total=" + arg0.voltot + "  expande=" + (arg0.volexp ? "S" : "N")
  lin += "\nQuantidade=" + arg0.objtot + "  Jogadores=" + arg0.socktot
  lin += "  Itens dentro=" + arg0.dentro1.total + "  Personagens dentro=" + arg0.dentro2.total
  lin += "  objnum=" + arg0.objnum
  lin += "\nevento="
  listaitem i
  epara i = arg0.evento.ini, i, i.depois
    lin += txt(i.obj) + " "
  efim
  lin += "\nevrec.0=" + arg0.evrec.0.objlista
  lin += "  evrec.1=" + arg0.evrec.1.objlista
  ret lin

func cmd_info
  se !arg0
# msg("\b\c2Você:\b\n" + cmd2_info(perso))
    msg("\c2Sala " + perso.dono + ":\b\n" + cmd2_info(perso.dono))
    ret 1
  fimse
  int1 achou
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("\b\c2" + r.nome + ": " + r + "\b\n" + cmd2_info(r))
    achou = 1
  efim
  !achou && msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_matar1
  se !arg0
    msg("Apagar o quê?")
    ret 1
  fimse
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(txt1(arg0), 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1, r.dentro2)
  txt200 nome
  nome = arg0
  enquanto 1
    n.ini(txt1(nome), 1000000)
    epara nulo, l, l.ini.remove
      r = l.objini
      sair r.visivel(perso) && n.nome(r.ident, r.objtot)
    efim
    se !l
      msg("Item ou personagem não encontrado: " + txt1(nome))
      ret 1
    senao txt2(nome)
      nome = txt2(nome)
      l.limpar
      l.addfim(r.dentro1, r.dentro2)
    senao r.perso && r.contr.jog
      msg("Não é possível apagar personagem de jogador: " + r.nome)
      ret 1
    senao
      msg("Apagando: " + r.nome), apagar(r)
      ret 1
    fimse
  efim

func cmd_matar2
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("Matando " + r.nome), r.morreu
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + arg0)
  ret 1

func cmd_cmd
  cmdlog("(cmd) " + nome + ": " + arg0, arg0)
  debug d
  msg(">" + d.cmd(perso, "ret " + arg0))
  ret 1

func cmd_cmdj
  se !txt2(arg0)
    msg("Digite CMDJ seguido do nome do personagem jogador e o comando")
    ret 1
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg0)))
  se !item.obj
    msg("Jogador inexistente ou ausente: " + txt1(arg0))
    ret 1
  fimse
  cmdlog("(cmdj) " + nome + ": " + arg0, txt2(arg0))
  debug d
  msg(txt(item.obj.nome) + ">" + d.cmd(item.obj, "ret " + txt2(arg0)))
  ret 1

func cmd_cmdp
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  se !txt2(arg0)
    msg("Digite CMDP seguido do nome do personagem e o comando")
    ret 1
  fimse
  n.ini(txt1(arg0), 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    cmdlog("(cmdp) " + nome + ": " + arg0, txt2(arg0))
    debug d
    msg(txt(r.nome) + ">" + d.cmd(r, "ret " + txt2(arg0)))
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + txt1(arg0))
  ret 1

func cmd_ac
  se !jogconfig.19
    msg("Canal AC está desabilitado.")
  senao !arg0
    msg("Tecle a mensagem após AC.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg("(ac) " + nome + ": " + arg0)
    efim
  fimse
  ret 1

func cmd_econfig
  m_menu("menu_econfig")
  ret 1

func cmd_echo
  se !arg0
    msg("\bTecle a mensagem após ECHO.")
  senao
    $mens.p(perso)
    $mens.mens = arg0
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.msg($mens.proc(config:echomsg, item.obj.perso))
    efim
  fimse
  ret 1

func cmd_mudler
  $mudaprog.exec
  ret 1

func cmd_mudanome
  se intsub(arg0) != 2
    msg("Tecle mudanome seguido do nome atual e o novo nome")
    ret 1
  fimse
  indiceitem ind
  txt20 nome.2 # Nome não codificado
  txt20 codif.2 # Nome codificado
  arqsav sav1
# Obtém os nomes
  nome.0 = txtmaimin(txt1(arg0))
  nome.1 = txtmaimin(txt2(arg0))
  codif.0 = txtnome(nome.0)
  codif.1 = txtnome(nome.1)
# Checa se o segundo personagem já existe
  se nome.0 == nome.1
    msg("Os dois nomes correspondem ao mesmo personagem.")
    ret 1
  senao inttotal(nome.1) < 3 || inttotal(nome.1) > 16
    msg("O novo nome deve ter de 3 a 16 caracteres.")
    ret 1
  senao intnome(nome.1)
    msg("O novo nome não é válido.")
    ret 1
  senao ind.obj("un " + codif.1)
    msg("Personagem " + nome.1 + " já está sendo usado.")
    ret 1
  senao codif.0 != codif.1 && sav1.existe("sav/" + codif.1 + ".sav")
    msg("Personagem " + nome.1 + " já existe.")
    ret 1
  fimse
# Jogador online
  uint8 mudou
  se ind.obj("un " + codif.0)
    ref r
    r = ind.obj("un " + codif.0)
    r.cnome = "un " + codif.1
    r.nome = nome.1
    r.perso.cnome = "pn " + codif.1
    r.perso.nome = nome.1
    mudou = 1
  fimse
# Jogo salvo
  se sav1.existe("sav/" + codif.0 + ".sav")
    textotxt t
    textopos p
    t.ler("sav/" + codif.0 + ".sav")
    p = t.ini
    p.txtproc("\nnome=") >= 0 && p.mudar(nome.1, 5, 100)
    t.salvar("sav/" + codif.1 + ".sav")
    codif.0 != codif.1 && sav1.apagar("sav/" + codif.0 + ".sav")
    mudou = 1
  fimse
# Informa se mudou
  se !mudou
    msg("Personagem " + nome.0 + " não existe.")
  senao
    msg("Personagem " + nome.0 + " mudou para " + nome.1 + ".")
    admlog("mudou personagem jogador " + nome.0 + " para " + nome.1)
  fimse
  ret 1

func cmd_listarsav
  arqdir dir
  txt100 lin
  lin = dir.abrir("sav")
  se lin
    msg("\bErro: " + lin)
  senao
    debug d
    d.exec = 50000
    txtmais.limpar
    epara nulo, dir.lin, dir.depois
      txtmais.addfim(txttroca(dir.texto + "\b", ".sav\b", ","))
    efim
    txtmais.ordena
    textopos pos
    pos = txtmais.fim, pos.antes
    pos.mudar("", inttotal(pos.texto) - 1, 1)
    refvar total = int(txtmais.linhas)
    txtmais.juntar
    txtmais.dividelin(50, 70)
    txtmais.addini("\bArquivos de jogos salvos (" + total + "):")
    txtmostra
  fimse
  ret 1

func cmd_apagarsav
  arqdir dir
  txt100 lin
  se !arg0
    msg("Tecle o nome do arquivo após APAGARSAV.")
  senao (lin = dir.apagar("sav/" + arg0 + ".sav")) != ""
    msg("Erro ao apagar jogo salvo " + arg0 + ": " + lin)
  senao
    msg("Jogo salvo apagado: " + arg0)
    admlog("apagou arquivo sav: " + arg0)
  fimse
  ret 1

func cmd_monit
  indiceitem item
  ref r
  r = item.obj("pn " + txtnome(arg0))
  se !arg0 || r == perso
    se imonit
      txt100 t1
      t1 = imonit.objlista.perso.nome
      imonit.remove
      msg("Deixando de monitorar " + t1)
      t1 = "*** " + perso.nome + " deixa de monitorar " + t1
      epara item.ini("un "), txt1(item.txt) == "un", item.depois
        item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
      efim
    senao
      msg("Não está monitorando ninguém")
    fimse
  senao !r
    msg("Jogador não encontrado: " + arg0)
  senao r == imonit.objlista.perso
    msg("Já está monitorando " + r.nome)
  senao
    imonit && msg("Deixando de monitorar " + imonit.objlista.perso.nome)
    imonit.remove
    txt100 t1
    t1 = "*** " + perso.nome + " monitora " + r.nome
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
    efim
    imonit = r.sock.lmonit.addini(este)
    msg("Monitorando " + r.nome)
  fimse
  ret 1

func cmd_escr
  se !imonit
    msg("Você não está monitorando ninguém")
  senao !arg0
    msg("Tecle a mensagem após ESCR")
  senao
    imonit.objlista.msg("*** " + perso.nome + " escreve no seu teclado: " + arg0)
    imonit.objlista.recebe(arg0)
  fimse
  ret 1

func cmd_hist
  refvar r = misc:objperso(perso, arg0)
  ret !r, 1
  se !r.p_hist.linhas
    msg(txtcopiamai(r.nome, "A") + " não matou ninguém.")
  senao
    txtmais.limpar
    txtmais.addfim("\b\c6Histórico de " + txtcopiamai(r.nome, "A") + ":\b")
    txtmais.addfim(r.p_hist.ini.textolin(100))
    txtmostra
  fimse
  ret 1

func cmd_infohab
  refvar r = misc:objperso(perso, arg0)
  ret !r, 1
  txt100 t1
  txt100 t2
  txtmais.limpar
  epara t1 = r.var.ini("h_"), txt(t1, 0, 2) == "h_", t1 = r.var.depois(t1)
    txtmais.addfim(txte(txt(t1, 2)) + " / " + txtsublin(misc:aulas, r.var.[t1], 1))
  efim
  se !txtmais.linhas
    txtmais.addfim(txtcopiamai(r.nome, "A") + " não conhece habilidades.")
  senao
    txtmais.addini("\b\c6Habilidades de " + r.nome + ":\b")
  fimse
  txtmostra
  ret 1

func cmd_infomag
  refvar r = misc:objperso(perso, arg0)
  ret !r, 1
  txt100 t1
  txt100 t2
  txtmais.limpar
  epara t1 = r.var.ini("m_"), txt(t1, 0, 2) == "m_", t1 = r.var.depois(t1)
    txtmais.addfim(txte(txt(t1, 2)) + " / " + txtsublin(misc:aulas, r.var.[t1], 1))
  efim
  se !txtmais.linhas
    txtmais.addfim(txtcopiamai(r.nome, "A") + " não conhece magias.")
  senao
    txtmais.addini("\b\c6Magias de " + r.nome + ":\b")
  fimse
  txtmostra
  ret 1

func cmd_infoe
  refvar r = misc:objperso(perso, arg0)
  ret !r, 1
  txtmais.limpar
  listaitem i
  epara i = r.dentro2.ini, i, i.depois
    continuar !i.obj.e_nome
    txtmais.addfim("1 " + i.obj.e_nome + (i.obj.t_duracao ? " (" + int(i.obj.t_duracao / 10) + \
")"))
  efim
  se !txtmais.linhas
    txtmais.addfim("Nenhum efeito afetando " + r.nome + ".")
  senao
    txtmais.ordenalin("", "x")
    txtmais.addini("\b\c6Efeitos afetando " + r.nome + ":\b")
  fimse
  txtmostra
  ret 1

func admlog # Mensagem para todos com a opção "config +admlog"
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.jogconfig.21 && item.obj.msg("\b\d1(adm) " + nome + " " + arg0 + "\b")
  efim

func cmdlog # Mensagem para todos com a opção "config +cmdlog"
# arg0 = texto que será enviado aos usuários
# arg1 = comando (se não tiver nenhuma letra, não envia o texto)
  se txtproc(txtsepara(txttroca(arg1, " ", ""), "L+DLEOV,DLEOV+L"), " ") >= 0
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.22 && item.obj.msg("\b\d4" + arg0 + "\b")
    efim

func cmd_lcl # Listar classes
  prog p
  txt80 lin
  se !p.iniclasse(arg0)
    msg("\bNenhuma classe encontrada.")
  senao
    debug d
    d.exec = 50000
    epara txtmais.limpar, p.lin, p.depois
      txtmais.addfim(p.texto + ",")
    efim
    textopos pos
    pos = txtmais.fim, pos.antes
    pos.mudar("", inttotal(pos.texto) - 1, 1)
    txtmais.juntar
    txtmais.dividelin(50, 70)
    txtmais.addini("\bClasses:")
    txtmostra
  fimse
  ret 1

func cmd_ccl # Cria classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após CCL")
  senao p.existe(txt1(arg0))
    msg("\bClasse já existe: " + txt1(arg0))
  senao
    tpasso = arg0
    p_ccl("")
  fimse
  ret 1

func p_ccl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    textotxt t
    prog p
    t.addfim(p.criar(txt1(tpasso) + "\n" + txt2(tpasso)))
    se t.bytes > 1
      msg2("Erro ao criar:\n" + t.remove(1000))
    senao
      msg("Classe criada: " + txt1(tpasso))
      config:salvar
      admlog("criou classe " + txt1(passo))
    fimse
  senao
    msg("Criar classe " + txt1(tpasso) + " ? Tecle S ou N")
    passo = "ccl"
  fimse
  ret 1

func cmd_acl # Apaga classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ACL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_acl("")
  fimse
  ret 1

func p_acl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    se !p.apagar(tpasso)
      msg("Erro ao apagar " + tpasso)
    senao
      msg("Classe apagada " + tpasso)
      config:salvar
      admlog("apagou classe " + tpasso)
    fimse
  senao
    msg("Apagar classe " + tpasso + " ? Tecle S ou N")
    passo = "acl"
  fimse
  ret 1

func cmd_ecl # Edita uma classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ECL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    var.opcnome = ""
    var.opcclasse = txts(arg0)
    p_classe("\b")
  fimse
  ret 1

func cmd_lfunc # Listar funções
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunc(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_lfunc2 # Listar funções inclusive as herdadas
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC2")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunctudo(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_herda
  prog p
  se !arg0
    msg("\bDigite o nome da classe após HERDA")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_herda("\b")
  fimse
  ret 1

func p_herda
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    prog p
    teditor.limpar
    epara p.iniherda(tpasso), p.lin, p.depois
      teditor.addfim(p.texto)
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "herda"
    msg("Editando herança de " + tpasso + ", O opções, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    p1 = teditor.ini
    se !p1.lin # Nenhum texto significa apagar herança
      p.inilinha(tpasso)
      txt1(p.texto) == "herda" && p.apagarlin(tpasso, 1)
      config:salvar, msg("Salvou: nenhuma herança")
      admlog("alterou herança da classe " + tpasso)
      ret 1
    fimse
    enquanto p1.lin
      t1.addfim(p1.texto), p1.depois
    efim
    t1.addfim(p.criar(tpasso, "herda " + txttroca(t1.remove(100), "\n", ",")))
    se t1.bytes > 1
      msg2("Erro ao salvar herança:\n" + t1.remove(1000))
    senao
      config:salvar, msg("Salvou herança")
      admlog("alterou herança da classe " + tpasso)
    fimse
    ret 1
  casofim
  ret p_editor(arg0, 200, "Herança")


classe jog_lugar
# Muda o personagem temporariamente de sala
# Chamado com: criar("jog_lugar", personagem, sala)
ref perso # Personagem do jogador
ref dono # Quem possui esse objeto; mesmo que: idono.objlista
ref donoantes # Dono anterior

func ini
  apagar(este)
  dono = arg0.dono
  donoantes = arg0.donoantes
  perso = arg0
  perso.mdono(arg1)

func fim
  perso.mdono(dono)
  perso.donoantes = donoantes
