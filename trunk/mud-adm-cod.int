classe jog_admcod
# Edição do código e comandos gerais de administração
#
const adm_ = "\b\c3Páginas de administração\b\n\
Para ler tecle ADM seguido do nome de um tópico.\n\
Os tópicos são:\n\
  \c2AREA\b     Áreas\n\
  \c2SALA\b     Salas\n\
  \c2SAI\b      Saídas das salas\n\
  \c2ITEM\b     Itens\n\
  \c2TIPO\b     Tipos de personagens\n\
  \c2PERSO\b    Personagens não jogador\n\
  \c2RESET\b    Reset de área ou sala\n\
  \c2ATK\b      Comandos de ataques\n\
  \c2SOCIAL\b   Comandos sociais\n\
  \c2COD\b      Edição do código fonte\n\
  \c2OUTROS\b   Outros comandos"
# \c2INFO\b     Informações sobre o MUD"
#
const adm_outros = "\c3Outros comandos\b\n\
\c2ECONFIG\b\n\
  Edita as configurações do MUD.\n\
\c2AC\b <texto>\n\
  Envia mensagem para o canal de administração; vide comando CONFIG\n\
\c2ECHO\b <texto>\n\
  Envia texto para todos os jogadores.\n\
\c2MUDANOME\b <nome atual> <novo nome>\n\
  Muda o nome do personagem de um jogador.\n\
\c2INFO\b\n\
  Informações sobre a sala.\n\
\c2INFO\b <personagem ou item>\n\
  Informações sobre personagem ou item.\n\
\c2MATAR1\b <personagem ou item>\n\
  Apaga personagem ou item.\n\
\c2MATAR2\b <personagem>\n\
  Mata instantaneamente personagem.\n\
\c2CMD\b <comando>\n\
\c2CMDP\b <personagem da sala> <comando>\n\
\c2CMDJ\b <personagem jogador> <comando>\n\
  Executa comando na linguagem do IntMUD e mostra o resultado.\n\
\c2MUDLER\b\n\
  Recarrega arquivos do MUD que foram alterados.\n\
\c2MONIT\b [jogador]\n\
  Monitora um jogador, permitindo ver o que ele lê e escreve.\n\
  Se [jogador] estiver ausente ou for o próprio, deixa de monitorar.\n\
  O principal objetivo é auxiliar outros usuários, por isso quando\n\
  esse comando é usado, todos os administradores são informados.\n\
  O comando QUEM também mostra aos administradores quem está monitorando.\n\
\c2ESCR\b <comando>\n\
  Digita um comando no teclado do usuário sendo monitorado."
#
const adm_cod = "\b\c3Comandos de edição do código\b\n\
\c2lcl\b [nome]\n\
  Lista as classes existentes.\n\
\c2ccl\b <nome> [arquivo]\n\
  Cria classe. Aquivo é o sufixo do arquivo aonde criar a classe.\n\
  Se for omitido, cria no arquivo mud.int.\n\
\c2acl\b <nome>\n\
  Apaga classe.\n\
\c2ecl\b [nome]\n\
  Edita uma classe.\n\
\c2herda\b <nome>\n\
  Edita herança de uma classe (uma classe herdada por linha).\n\
\c2lfunc\b <nome>\n\
  Lista funções de uma classe.\n\
\c2lfunc2\b <nome>\n\
  Lista todas funções de uma classe, inclusive as herdadas."

func cmd_adm
  prog p
  se p.inifunctudo(este, "adm_" + arg0)
    msg2([p.texto])
  senao
    msg("\bTópico de administração desconhecido: " + arg0)
  fimse
  ret 1

func cmd2_info # Usado por cmd_info
  txt512 lin
  lin = "Peso:   obj=" + arg0.pesoobj + "  dentro=" + arg0.pesoden
  lin += "  total=" + arg0.pesotot + "  voando=" + (arg0.pesoadd ? "N" : "S")
  lin += "\nVolume: obj=" + arg0.volobj + "  dentro=" + arg0.volden
  lin += "  total=" + arg0.voltot + "  expande=" + (arg0.volexp ? "S" : "N")
  lin += "\nQuantidade=" + arg0.objtot + "  Jogadores=" + arg0.socktot
  lin += "  Itens dentro=" + arg0.dentro1.total + "  Personagens dentro=" + arg0.dentro2.total
  lin += "\nevento="
  listaitem i
  epara i = arg0.evento.ini, i, i.depois
    lin += txt(i.obj) + " "
  efim
  lin += "\nevrec.0=" + arg0.evrec.0.objlista
  lin += "  evrec.1=" + arg0.evrec.1.objlista
  ret lin

func cmd_info
  se !arg0
# msg("\b\c2Você:\b\n" + cmd2_info(perso))
    msg("\c2Sala " + perso.dono + ":\b\n" + cmd2_info(perso.dono))
    ret 1
  fimse
  int1 achou
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("\b\c2" + r.nome + ": " + r + "\b\n" + cmd2_info(r))
    achou = 1
  efim
  !achou && msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_matar1
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("Apagando " + r.nome), apagar(r)
    ret 1
  efim
  msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_matar2
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("Matando " + r.nome), r.morreu
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + arg0)
  ret 1

func cmd_cmd
  admcmd("(cmd) " + nome + ": " + arg0, arg0)
  debug d
  msg(">" + d.cmd(perso, "ret " + arg0))
  ret 1

func cmd_cmdj
  se !txt2(arg0)
    msg("Digite CMDJ seguido do nome do personagem jogador e o comando")
    ret 1
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg0)))
  se !item.obj
    msg("Jogador inexistente ou ausente: " + txt1(arg0))
    ret 1
  fimse
  admcmd("(cmdj) " + nome + ": " + arg0, txt2(arg0))
  debug d
  msg(txt(item.obj.nome) + ">" + d.cmd(item.obj, "ret " + txt2(arg0)))
  ret 1

func cmd_cmdp
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  se !txt2(arg0)
    msg("Digite CMDP seguido do nome do personagem e o comando")
    ret 1
  fimse
  n.ini(txt1(arg0), 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    admcmd("(cmdp) " + nome + ": " + arg0, txt2(arg0))
    debug d
    msg(txt(r.nome) + ">" + d.cmd(r, "ret " + txt2(arg0)))
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + txt1(arg0))
  ret 1

func cmd_ac
  se !jogconfig.19
    msg("Canal AC está desabilitado.")
  senao !arg0
    msg("Tecle a mensagem após AC.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg("(ac) " + nome + ": " + arg0)
    efim
  fimse
  ret 1

func cmd_econfig
  m_menu("adm_econfig")
  ret 1

func cmd_echo
  se !arg0
    msg("\bTecle a mensagem após ECHO.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.msg("\b\cB(ADM) " + arg0 + "\b")
    efim
  fimse
  ret 1

func cmd_mudler
  $mudaprog.exec
  ret 1

func cmd_mudanome
  se intsub(arg0) != 2
    msg("Tecle mudanome seguido do nome atual e o novo nome")
    ret 1
  fimse
  indiceitem ind
  txt20 nome.2 # Nome não codificado
  txt20 codif.2 # Nome codificado
  arqsav sav1
# Obtém os nomes
  nome.0 = txtmaimin(txt1(arg0))
  nome.1 = txtmaimin(txt2(arg0))
  codif.0 = txtnome(nome.0)
  codif.1 = txtnome(nome.1)
# Checa se o segundo personagem já existe
  se nome.0 == nome.1
    msg("Os dois nomes correspondem ao mesmo personagem.")
    ret 1
  senao inttotal(nome.1) < 3 || inttotal(nome.1) > 16
    msg("O novo nome deve ter de 3 a 16 caracteres.")
    ret 1
  senao intnome(nome.1)
    msg("O novo nome não é válido.")
    ret 1
  senao ind.obj("un " + codif.1)
    msg("Personagem " + nome.1 + " já está sendo usado.")
    ret 1
  senao codif.0 != codif.1 && sav1.existe("sav/" + codif.1 + ".sav")
    msg("Personagem " + nome.1 + " já existe.")
    ret 1
  fimse
# Jogador online
  uint8 mudou
  se ind.obj("un " + codif.0)
    ref r
    r = ind.obj("un " + codif.0)
    r.cnome = "un " + codif.1
    r.nome = nome.1
    r.perso.cnome = "pn " + codif.1
    r.perso.nome = nome.1
    mudou = 1
  fimse
# Jogo salvo
  se sav1.existe("sav/" + codif.0 + ".sav")
    textotxt t
    textopos p
    t.ler("sav/" + codif.0 + ".sav")
    p = t.ini
    p.txtproc("\nnome=") >= 0 && p.mudar(nome.1, 5, 100)
    t.salvar("sav/" + codif.1 + ".sav")
    codif.0 != codif.1 && sav1.apagar("sav/" + codif.0 + ".sav")
    mudou = 1
  fimse
# Informa se mudou
  se !mudou
    msg("Personagem " + nome.0 + " não existe.")
  senao
    msg("Personagem " + nome.0 + " mudou para " + nome.1 + ".")
    admlog("mudou personagem jogador " + nome.0 + " para " + nome.1)
  fimse
  ret 1

func cmd_monit
  indiceitem item
  ref r
  r = item.obj("pn " + txtnome(arg0))
  se !arg0 || r == perso
    se imonit
      txt100 t1
      t1 = imonit.objlista.perso.nome
      imonit.remove
      msg("Deixando de monitorar " + t1)
      t1 = "*** " + perso.nome + " deixa de monitorar " + t1
      epara item.ini("un "), txt1(item.txt) == "un", item.depois
        item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
      efim
    senao
      msg("Não está monitorando ninguém")
    fimse
  senao !r
    msg("Jogador não encontrado: " + arg0)
  senao r == imonit.objlista.perso
    msg("Já está monitorando " + r.nome)
  senao
    imonit && msg("Deixando de monitorar " + imonit.objlista.perso.nome)
    imonit.remove
    txt100 t1
    t1 = "*** " + perso.nome + " monitora " + r.nome
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
    efim
    imonit = r.sock.lmonit.addini(este)
    msg("Monitorando " + r.nome)
  fimse
  ret 1

func cmd_escr
  se !imonit
    msg("Você não está monitorando ninguém")
  senao !arg0
    msg("Tecle a mensagem após ESCR")
  senao
    imonit.objlista.msg("*** " + perso.nome + " escreve no seu teclado: " + arg0)
    imonit.objlista.recebe(arg0)
  fimse
  ret 1

func admlog # Mensagem para todos com a opção "config +admlog"
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.jogconfig.21 && item.obj.msg("\b\d1(adm) " + nome + " " + arg0 + "\b")
  efim

func admcmd # Mensagem para todos com a opção "config +admcmd"
# arg0 = texto que será enviado aos usuários
# arg1 = comando (se não tiver nenhuma letra, não envia o texto)
  se txtproc(txtsepara(txttroca(arg1, " ", ""), "L+DLEOV,DLEOV+L"), " ") >= 0
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.22 && item.obj.msg("\b\d4" + arg0 + "\b")
    efim

func cmd_lcl # Listar classes
  prog p
  txt80 lin
  se !p.iniclasse(arg0)
    msg("\bNenhuma classe encontrada.")
  senao
    textotxt t
    t.addfim("\bClasses:")
    enquanto p.lin
      se inttotal(lin + p.texto) >= 70
        t.addfim(lin), lin = p.texto
      senao lin
        lin += ", " + p.texto
      senao
        lin = p.texto
      fimse
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_ccl # Cria classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após CCL")
  senao p.existe(txt1(arg0))
    msg("\bClasse já existe: " + txt1(arg0))
  senao
    tpasso = arg0
    p_ccl("")
  fimse
  ret 1

func p_ccl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    textotxt t
    prog p
    t.addfim(p.criar(txt1(tpasso) + "\n" + txt2(tpasso)))
    se t.bytes > 1
      msg2("Erro ao criar:\n" + t.remove(1000))
    senao
      msg("Classe criada: " + txt1(tpasso))
      config:salvar
      admlog("criou classe " + txt1(passo))
    fimse
  senao
    msg("Criar classe " + txt1(tpasso) + " ? Tecle S ou N")
    passo = "ccl"
  fimse
  ret 1

func cmd_acl # Apaga classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ACL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_acl("")
  fimse
  ret 1

func p_acl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    se !p.apagar(tpasso)
      msg("Erro ao apagar " + tpasso)
    senao
      msg("Classe apagada " + tpasso)
      config:salvar
      admlog("apagou classe " + tpasso)
    fimse
  senao
    msg("Apagar classe " + tpasso + " ? Tecle S ou N")
    passo = "acl"
  fimse
  ret 1

func cmd_ecl # Edita uma classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ECL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    var.opcnome = ""
    var.opcclasse = txts(arg0)
    p_classe("\b")
  fimse
  ret 1

func cmd_lfunc # Listar funções
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunc(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_lfunc2 # Listar funções inclusive as herdadas
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC2")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunctudo(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_herda
  prog p
  se !arg0
    msg("\bDigite o nome da classe após HERDA")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_herda("\b")
  fimse
  ret 1

func p_herda
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    prog p
    teditor.limpar
    epara p.iniherda(tpasso), p.lin, p.depois
      teditor.addfim(p.texto)
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "herda"
    msg("Editando herança de " + tpasso + ", O opções, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    p1 = teditor.ini
    se !p1.lin # Nenhum texto significa apagar herança
      p.inilinha(tpasso)
      txt1(p.texto) == "herda" && p.apagarlin(tpasso, 1)
      config:salvar, msg("Salvou: nenhuma herança")
      admlog("alterou herança da classe " + tpasso)
      ret 1
    fimse
    enquanto p1.lin
      t1.addfim(p1.texto), p1.depois
    efim
    t1.addfim(p.criar(tpasso, "herda " + txttroca(t1.remove(100), "\n", ",")))
    se t1.bytes > 1
      msg2("Erro ao salvar herança:\n" + t1.remove(1000))
    senao
      config:salvar, msg("Salvou herança")
      admlog("alterou herança da classe " + tpasso)
    fimse
    ret 1
  casofim
  ret p_editor(arg0, 200, "Herança")


classe adm_econfig
# Vide arquivo mud.txt, tópico "Criando menus de edição (administração)"
const titulo = "Configurações do MUD"
#
const nome1 = "Jogar localmente            "
const info1 = "Jogar na própria janela que o IntMUD abre\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo1 = "simnao--"
const classe1 = "config"
const var1 = "modolocal"
#
const nome2 = "Jogar em uma porta          "
const info2 = "Terá efeito na próxima vez que o MUD for ativado"
const tipo2 = "opcao--"
const classe2 = "config"
const var2 = "modoserv"
const extra2 = "Não\nTelnet\nTelnet e Papovox"
#
const nome3 = "Endereço do MUD             "
const info3 = "Para ativar em um endereço específico"
const tipo3 = "linha--"
const classe3 = "config"
const var3 = "servender"
#
const nome4 = "Porta do MUD                "
const info4 = "Nota: o programa Papovox só se conecta na porta 1963\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo4 = "numero--"
const classe4 = "config"
const var4 = "servporta"
#
const nome5 = "Limite de conexões por IP   "
const tipo5 = "numero--"
const classe5 = "config"
const var5 = "servusr"
#
const nome6 = "Tempo entre duas conexões   "
const info6 = "Quantos décimos de segundo para poder conectar-se novamente pelo mesmo IP"
const tipo6 = "numero--"
const classe6 = "config"
const var6 = "servtempo"
#
const nome7 = "Jogar em um chat            "
const info7 = "Somente em chats que suportam bots\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo7 = "simnao--"
const classe7 = "config"
const var7 = "modobot"
#
const nome8 = "Endereço do chat            "
const tipo8 = "linha--"
const classe8 = "config"
const var8 = "serv"
#
const nome9 = "Porta do chat               "
const tipo9 = "numero--"
const classe9 = "config"
const var9 = "porta"
#
const nome10 = "Sala do chat                "
const tipo10 = "linha--"
const classe10 = "config"
const var10 = "sala"
#
const nome11 = "Senha da sala do chat       "
const info11 = "Se for vazia, o programa pede a senha antes de conectar\n\
Se não for vazia, outros administradores poderão ver a senha"
const tipo11 = "linha--"
const classe11 = "config"
const var11 = "senha"
#
const nome12 = "Senha de administração      "
const info12 = "Se vazia, ninguém poderá ser administrador do MUD"
const tipo12 = "linha--"
const classe12 = "config"
const var12 = "senhaadm"
#
const nome13 = "Mensagem de apresentação    "
const info13 = "Primeira mensagem que o jogador recebe ao entrar no MUD"
const tipo13 = "texto--"
const classe13 = "config"
const var13 = "apres"
#
const nome14 = "Sala inicial                "
const info14 = "Sala onde os jogadores vão após criar o personagem"
const tipo14 = "sala--"
const classe14 = "config"
const var14 = "salaini"
#
const nome15 = "Sala quando morre           "
const tipo15 = "sala--"
const classe15 = "config"
const var15 = "salafim"
#
const nome16 = "Sala para continuar jogo salvo"
const info16 = "Se acontecer do jogador cair em uma sala inexistente"
const tipo16 = "sala--"
const classe16 = "config"
const var16 = "salasav"
#
const nome17 = "Animais para batalhar       "
const info17 = "Quantos animais pode usar em batalha"
const tipo17 = "numero--"
const classe17 = "config"
const var17 = "animal1"
const extra17 = "1 8"
#
const nome18 = "Salvar personagem ao criar  "
const tipo18 = "simnao--"
const classe18 = "config"
const var18 = "salvacria"
#
const nome19 = "Tipo de ataque              "
const tipo19 = "opcao--"
const classe19 = "config"
const var19 = "atktipo"
const extra19 = "Manual\nAutomático com a classe comando_atkauto"
#
const nome20 = "Quando alguém entra avisar  "
const info20 = "Quem deve ser informado quando um jogador entra ou sai"
const tipo20 = "opcao--"
const classe20 = "config"
const var20 = "entrainfo"
const extra20 = "Ninguém\nSomente administradores\nTodos"
#

func nome21
  se config:atktipo
    ret "Tempo para finalizar batalha"
  senao
    ret "Tempo de um turno           "

func info21
  se config:atktipo
    ret "Em décimos de segundo; tempo para chegar a primeira mensagem"
  senao
    ret "Em décimos de segundo"

const tipo21 = "numero--"
const classe21 = "config"
const var21 = "atktempo"
const extra21 = "10 200"
#
const nome22 = "Pode retornar até nível     "
const info22 = "Até que nível pode usar o comando retornar"
const tipo22 = "numero--"
const classe22 = "config"
const var22 = "retornar"
