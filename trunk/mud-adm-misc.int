classe adm_
const iniclasse = !$[arg0] && criar(arg0)
# Edição do código e comandos gerais de administração
const txtajuda = "\b\c3Páginas de administração\b\n\
Para ler tecle ADM seguido do nome de um tópico ou um comando.\n\
Os tópicos são:\n\
  \c2AREA\b      Áreas\n\
  \c2SALAS\b     Salas\n\
  \c2SAI\b       Saídas das salas\n\
  \c2ITEM\b      Itens\n\
  \c2TIPO\b      Tipos de personagens (raças e classes)\n\
  \c2PERSO\b     Personagens não jogador\n\
  \c2CASA\b      Casas de jogadores\n\
  \c2RESET\b     Reset de área ou sala\n\
  \c2HAB\b       Habilidades e magias\n\
  \c2EFEITO\b    Efeitos\n\
  \c2SOCIAL\b    Comandos sociais\n\
  \c2COD\b       Edição do código fonte\n\
  \c2JOG\b       Comandos para jogadores\n\
  \c2OUTROS\b    Outros comandos\n\
  \c2MENS\b      Caracteres especiais em mensagens\n\
  \c2CORES\b     Cores em mensagens"
# \c2INFO\b     Informações sobre o MUD"


classe adm_jog
const iniclasse = !$[arg0] && criar(arg0)
const txtajuda = "\c3Comandos para jogadores\b\n\
  \c2TELE\b      Teletransporta jogador\n\
  \c2TELEENTRA\b Define mensagem de chegada do Tele\n\
  \c2TELESAI\b   Define mensagem de saída do Tele\n\
  \c2AC\b        Envia mensagem para o canal de administração\n\
  \c2ECHO\b      Envia mensagem para todos\n\
  \c2SECHO\b     Envia mensagem para uma sala\n\
  \c2JECHO\b     Envia mensagem para um jogador\n\
  \c2REZOU\b     Envia mensagem para jogador com cópia para admin\n\
  \c2BAN\b       Banir jogadores por IP\n\
  \c2MUDANOME\b  Muda o nome do personagem de um jogador\n\
  \c2SAVTUDO\b   Salva em arquivo os jogos e as casas pendentes\n\
  \c2LISTARSAV\b Mostra os arquivos de jogos salvos\n\
  \c2APAGARSAV\b Apaga um arquivo de jogo salvo.\n\
  \c2MONIT\b     Monitora um jogador\n\
  \c2ESCR\b      Digita um comando no teclado do jogador\n\
  \c2INFOJOG\b   Mostra algumas informações do jogador"


classe adm_outros
const iniclasse = !$[arg0] && criar(arg0)
const txtajuda = "\c3Outros comandos\b\n\
  \c2ECONFIG\b   Edita as configurações do MUD\n\
  \c2SERV\b      Informações sobre o MUD\n\
  \c2INFO\b      Informações sobre a sala, personagem ou intem\n\
  \c2ESTAT\b     Mostra estatísticas de um personagem da sala\n\
  \c2HIST\b      Mostra o histórico de um personagem da sala\n\
  \c2INFOHAB\b   Informa habilidades de um personagem da sala\n\
  \c2INFOMAG\b   Informa magias de um personagem da sala\n\
  \c2INFOE\b     Informa efeitos de um personagem da sala\n\
  \c2MATAR1\b    Apaga um personagem ou item\n\
  \c2MATAR2\b    Mata instantaneamente um personagem\n\
  \c2LUGAR\b     Executa um comando como se estivesse em outra sala\n\
  \c2CMD\b       Executa um comando do IntMUD no seu personagem\n\
  \c2CMDP\b      Executa um comando do IntMUD em um personagem da sala\n\
  \c2CMDJ\b      Executa um comando do IntMUD em um personagem de jogador\n\
  \c2MUDLER\b    Recarrega arquivos do MUD que foram alterados"


classe adm_mens
const iniclasse = !$[arg0] && criar(arg0)
const txtajuda = "\b\c3Caracteres especiais em mensagens\b\n\n\
As seguintes sequências de caracteres têm um significado especial:\n\
 \c2$$\b  Símbolo $\n\
 \c2$P\b  Nome do personagem\n\
 \c2$Q\b  Nome do personagem sem citar o dono\n\
 \c2$R\b  Nome do personagem no comando QUEM\n\
 \c2$A\b  Nome do alvo\n\
 \c2$B\b  Nome do alvo sem citar o dono\n\
 \c2$C\b  Nome do alvo no comando QUEM\n\
 \c2$O\b  Nome do objeto\n\
 \c2$H\b  Depende do personagem: um ou uma\n\
 \c2$I\b  Depende do alvo: um ou uma\n\
 \c2$J\b  Depende do objeto: um ou uma\n\
 \c2$S\b  Depende do personagem: o ou a\n\
 \c2$T\b  Depende do alvo: o ou a\n\
 \c2$U\b  Depende do objeto: o ou a\n\
 \c2$V\b  Depende do personagem: e ou a\n\
 \c2$W\b  Depende do alvo: e ou a\n\
 \c2$X\b  Depende do objeto: e ou a\n\
 \c2$M\b  Mensagem; somente comandos que usam uma mensagem digitada por alguém\n\
 \c2$D\b  É substituído por \"de\"\n\
     No entando, seguido de o/a/os/as, forma as palavras do/da/dos/das\n\
     Costuma ser usado nas mensagens como $d $p, $d $a e $d $o\n\
 \c2$E\b  É substituído por \"em\"\n\
     No entando, seguido de o/a/os/as, forma as palavras no/na/nos/nas\n\
     Costuma ser usado nas mensagens como $e $p, $e $a e $e $o\n\
 \c2$F\b  Semelhante a $D, exceto que seguido de um/uma/uns/umas também\n\
     forma as palavras do/da/dos/das.\n\
 \c2$G\b  Semelhante a $E, exceto que seguido de um/uma/uns/umas também\n\
     forma as palavras no/na/nos/nas.\n\n\
Quando o símbolo $ for seguido de uma letra minúscula, a primeira letra\n\
do texto não é transformada em maiúscula."


classe adm_cores
const iniclasse = !$[arg0] && criar(arg0)
const txtajuda = "\b\c3Cores em mensagens\b\n\n\
É possível definir as cores dos caracteres e do fundo nas mensagens.\n\
Entretanto, não há suporte a cores no Papovox, nem para os usuários\n\
que jogarem através de um chat.\n\n\
As seguintes sequências de caracteres mudam a cor das letras:\n\
 \\c0  \c7Preto\b             \\c1  \c1Vermelho\b          \\c2  \c2Verde\b\n\
 \\c3  \c3Marrom\b            \\c4  \c4Azul\b              \\c5  \c5Magenta\b\n\
 \\c6  \c6Ciano\b             \\c7  \c7Branco\b            \\c8  \c8Cinza\b\n\
 \\c9  \c9Vermelho intenso\b  \\ca  \caVerde intenso\b     \\cb  \cbAmarelo\b\n\
 \\cc  \ccAzul intenso\b      \\cd  \cdMagenta intenso\b   \\ce  \ceCiano intenso\b\n\
 \\cf  \cfBranco intenso\b\n\n\
As seguintes sequências de caracteres mudam a cor de fundo:\n\
 \\d0  \d0Preto\b             \\d1  \d1Vermelho\b          \\d2  \d2Verde\b\n\
 \\d3  \d3Marrom\b            \\d4  \d4Azul\b              \\d5  \d5Magenta\b\n\
 \\d6  \d6Ciano\b             \\d7  \c0\d7Branco\b\n\n\
As seguintes sequências de caracteres mudam outros atributos:\n\
 \"    Aspas duplas\n\
 \\\\   Barra invertida: \\\n\
 \\b   Caracteres brancos sob fundo preto sem piscante, sublinhado e inverso\n\
 \\cg  Liga o sublinhado (um traço horizontal em baixo)\n\
 \\ch  Desliga o sublinhado\n\
 \\ci  Liga inversão de frente com fundo (troca cores de frente com fundo)\n\
 \\cj  Desliga inversão de frente com fundo\n\
 \\ck  Liga texto piscante\n\
 \\cl  Desliga texto piscante"


classe adm_cod
const iniclasse = !$[arg0] && criar(arg0)
const txtajuda = "\b\c3Comandos de edição do código\b\n\
  \c2LCL\b       Lista as classes existentes\n\
  \c2CCL\b       Cria classe\n\
  \c2ACL\b       Apaga classe\n\
  \c2ECL\b       Edita uma classe\n\
  \c2ICL\b       Inicializa uma classe (chama a função iniclasse)\n\
  \c2RCL\b       Renomeia uma classe\n\
  \c2HERDA\b     Edita herança de uma classe\n\
  \c2LFUNC\b     Lista funções de uma classe\n\
  \c2LFUNC2\b    Lista todas funções de uma classe, inclusive as herdadas"


classe adm_adm
herda comando_adm, comando_comum
# Ajuda dos comandos de administração

func escr
  prog p
  epara p.iniclasse("adm_" + txt1(arg1)), p.lin, p.depois
    refvar t1 = $[p.texto].txtajuda(arg0)
    ret t1, arg0.msg2(t1)
  efim
  arg0.msg("\bComando ou tópico de administração desconhecido: " + arg1)


classe adm_serv
herda comando_adm, comando_comum
const txtajuda = "\b\c3Serv\b\n\
Sintaxe: SERV\n\
Mostra informações sobre o estado atual do MUD."

func escr
  refvar txtmais = arg0.sock.txtmais
  txt100 lin
  int32 i.3
  debug d
  txtmais.limpar
  txtmais.addfim("\b\c3Estado atual do MUD:\b")
  i.2 = $miscserv.noar % 1440
  i.0 = ($miscserv.noar - i.2) / 1440 # Dias
  i.1 = intdiv(i.2 / 60) # Horas
  i.2 %= 60 # Minutos
  txtmais.addfim("No ar há " + i.0 + " dias " + i.1 + " horas " + i.2 + " min")
  txtmais.addfim("Memória usada:  " + txtnum(d.mem, ".") + " bytes")
  txtmais.addfim("Memória máxima: " + txtnum(d.memmax, ".") + " bytes")
# lin = "Memória usada:  " + txtnum(d.mem, ".") + " bytes"
# lin += "   (máximo foi " + txtnum(d.memmax, ".") + " bytes)"
# txtmais.addfim(lin)
  lin = "Processador (stempo): " + txtnum(d.stempo / 1000, ".3") + " seg."
  lin += "  (no último minuto " + txtnum($miscserv.stempo / 1000, ".3") + " seg.)"
  txtmais.addfim(lin)
  lin = "Processador (utempo): " + txtnum(d.utempo / 1000, ".3") + " seg."
  lin += "  (no último minuto " + txtnum($miscserv.utempo / 1000, ".3") + " seg.)"
  txtmais.addfim(lin)
  txtmais.addfim("IntMUD versão " + d.ver + " (" + d.data + "), MUD versão " + misc:versao)
  arg0.sock.txtmostra


classe adm_savtudo
herda comando_adm, comando_comum
const txtajuda = "\b\c3SavTudo\b\n\
Sintaxe: SAVTUDO\n\
Salva todos os jogos de jogadores e casas pendentes em arquivo."

func escr
  $miscsav.salvartudo
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.jogconfig.23 && item.obj.msg("\b(savtudo) " + arg0.nome + " salvou os jogos.\b")
  efim


classe adm_tele
herda comando_adm, comando_comum
const txtajuda = "\b\c3Tele\b\n\
Sintaxe: TELE <sala ou jogador>\n\
         TELE <jogador> <sala>\n\
Com um argumento, você se transporta para uma sala ou para aonde o\n\
jogador está. Com dois argumentos, transporta um jogador para uma sala."

func escr # Ir para uma sala específica
  ref p # Personagem
  ref s # Sala destino
  indiceitem item
# Transportar um jogador para uma sala
  se txt2(arg1)
    item.ini("pn " + txtnome(txt1(arg1)))
    p = item.obj, s = $s_[txt2(arg1)]
    se !p
      arg0.msg("Jogador inexistente ou ausente: " + txt1(arg1))
    senao !s
      arg0.msg("\bSala não existe: " + txt2(arg1))
    senao s == p.dono
      arg0.msg(p.nome + " já está em " + txt(s, 2) + ".")
      s = nulo
    fimse
# Transportar-se para uma sala
  senao arg1
    p = arg0, s = $s_[arg1]
    se !p
      arg0.msg("Você deve estar controlando um personagem para isso")
    senao !s
      item.ini("pn " + txtnome(arg1))
      s = item.obj.dono
      !s && arg0.msg("\bSala ou jogador não existe: " + arg1)
    fimse
    se s && s == p.dono
      arg0.msg("Você já está em " + txt(s, 2) + ".")
      s = nulo
    fimse
  senao
    arg0.msg("Teletransportar quem? Para onde?")
  fimse
# Realiza o teletransporte
  se !(p && s)
  senao p == arg0
    txt200 mens1
    $mens.p(p, arg0)
    mens1 = arg0.var.z_telesai
    $mens.mvis2("", mens1 ? mens1 : "$P some em um redemoinho de fumaça.")
    p.mudadono(s)
    mens1 = arg0.var.z_teleentra
    $mens.mvis2("", mens1 ? mens1 : "$P aparece em um redemoinho de fumaça.")
  senao
    $mens.p(p, arg0)
    p.msginv("$A teletransporta você.")
    $mens.mvis2("", "$P some em um redemoinho de fumaça.")
    p.mudadono(s)
    $mens.mvis2("", "$P aparece de um redemoinho de fumaça.")
    se !p.jogconfig.23
      $misclog.cmdlog("tele " + arg0.nome + ": " + p.nome + " para " + txt(s, 2))
    fimse
  fimse


classe adm_teleentra
herda comando_adm, comando_comum
const txtajuda = "\b\c3TeleEntra\b\n\
Sintaxe: TELEENTRA [texto]\n\
Define a mensagem quando você se transporta usando o comando Tele.\n\
Sem argumentos, muda para a mensagem padrão, que é:\n\
$P aparece de um redemoinho de fumaça.\n\
Para saber as mensagens que você definiu, use o comando Estat.\n\
Veja também: TELESAI"

func escr
  se !arg1
    arg0.msg("Mensagem teleentra voltou ao padrão.")
  senao txtproc(arg1, "$P") >= 0
    arg0.msg("Mensagem teleentra mudou para: " + arg1)
  senao
    ret arg0.msg("Mensagem teleentra deve ter obrigatoriamente $P.")
  fimse
  arg0.var.z_teleentra = arg1


classe adm_telesai
herda comando_adm, comando_comum
const txtajuda = "\b\c3TeleSai\b\n\
Sintaxe: TELESAI [texto]\n\
Define a mensagem quando você se transporta usando o comando Tele.\n\
Sem argumentos, muda para a mensagem padrão, que é:\n\
$P some em um redemoinho de fumaça.\n\
Para saber as mensagens que você definiu, use o comando Estat.\n\
Veja também: TELEENTRA"

func escr
  se !arg1
    arg0.msg("Mensagem telesai voltou ao padrão.")
  senao txtproc(arg1, "$P") >= 0
    arg0.msg("Mensagem telesai mudou para: " + arg1)
  senao
    ret arg0.msg("Mensagem telesai deve ter obrigatoriamente $P.")
  fimse
  arg0.var.z_telesai = arg1


classe adm_lugar
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lugar\b\n\
Sintaxe: LUGAR <sala ou personagem jogador> <comando>\n\
Executa um comando como se estivesse em outra sala. Com personagem\n\
jogador, executa como se estivesse na mesma sala do jogador.\n\
Nota: O administrador é teletransportado momentaneamente para outra sala."

func escr
  ref sala
# Checa um comando lugar dentro de outro
  se $jog_lugar
    ret arg0.msg("Não é permitido executar um comando LUGAR dentro de outro.")
# Obtém a sala
  senao !txt2(arg1)
    ret arg0.msg("Sintaxe: LUGAR <sala ou jogador> <comando>")
  senao !(sala = $s_[txt1(arg1)])
    indiceitem item
    item.ini("pn " + txtnome(txt1(arg1)))
    sala = item.obj.dono
  fimse
  ret !sala, arg0.msg("\bSala ou jogador não existe: " + txt1(arg1))
# Muda de sala e garante que vai voltar à sala original
  criar("jog_lugar", arg0, sala)
# Comando de administração
  refvar lin = txt2(arg1)
  refvar r = $adm_[txt1(lin)].objcmd(arg0)
  ret r, r.escr(arg0, txt2(lin))
# Comando para o jogo
  arg0.teclou(lin) # Personagem processa comando
  arg0.p_espera < 2 && (arg0.p_espera = 2)


classe adm_matar1
herda comando_adm, comando_comum
const txtajuda = "\b\c3Matar1\b\n\
Sintaxe: MATAR1 <personagem ou item>\n\
Apaga um personagem ou item da mesma sala.\n\
Para apagar personagens ou itens dentro de outros, deve-se especificar\n\
aonde o item está. Exemplo, para apagar uma faca que está dentro de uma\n\
bolsa que o personagem João carrega, deve-se digitar:\n\
MATAR1 João bolsa faca"

func escr
  ret !arg1, arg0.msg("Apagar o quê?")
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(txt1(arg1), 1000000)
  r = arg0
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1, r.dentro2)
  txt200 nome
  nome = arg1
  enquanto 1
    n.ini(txt1(nome), 1000000)
    epara nulo, l, l.ini.remove
      r = l.objini
      sair r.visivel(arg0) && n.nome(r.ident, r.objtot)
    efim
    se !l
      ret arg0.msg("Item ou personagem não encontrado: " + txt1(nome))
    senao txt2(nome)
      nome = txt2(nome)
      l.limpar
      l.addfim(r.dentro1, r.dentro2)
    senao r.perso && r.contr.jog
      ret arg0.msg("Não é possível apagar personagem de jogador: " + r.nome)
    senao
      arg0.msg("Apagando: " + r.nome), apagar(r)
      ret
    fimse
  efim


classe adm_matar2
herda comando_adm, comando_comum
const txtajuda = "\b\c3Matar2\b\n\
Sintaxe: MATAR2 <personagem>\n\
Mata instantaneamente um personagem."

func escr
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  l.addfim(arg0.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    arg0.msg("Matando " + r.nome), r.morreu(arg0)
    ret
  efim
  arg0.msg("Não há nenhum personagem chamado " + arg1)


classe adm_cmd
herda comando_adm, comando_comum
const txtajuda = "\b\c3Cmd\b\n\
Sintaxe: CMD <comando>\n\
Executa comando na linguagem do IntMUD e mostra o resultado.\n\
O objeto \"este\" é sempre o seu personagem."

func escr
  se txtsepara(arg1, "L+DLEOV,DLEOV+L", "\b") != arg1
    cmdlog(arg0, "cmd", arg1)
  fimse
  debug d
  arg0.msg(">" + d.cmd(arg0, "ret " + arg1))


classe adm_cmdj
herda comando_adm, comando_comum
const txtajuda = "\b\c3Cmdj\b\n\
Sintaxe: CMDJ <personagem jogador> <comando>\n\
Executa comando na linguagem do IntMUD e mostra o resultado."

func escr
  se !txt2(arg1)
    ret arg0.msg("Digite CMDJ seguido do nome do personagem jogador e o comando")
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg1)))
  se !item.obj
    ret arg0.msg("Jogador inexistente ou ausente: " + txt1(arg1))
  senao txtsepara(txt2(arg1), "L+DLEOV,DLEOV+L", "\b") != txt2(arg1)
    cmdlog(arg0, "cmdj", arg1)
  fimse
  debug d
  arg0.msg(txt(item.obj.nome) + ">" + d.cmd(item.obj, "ret " + txt2(arg1)))


classe adm_cmdp
herda comando_adm, comando_comum
const txtajuda = "\b\c3Cmdp\b\n\
Sintaxe: CMDP <personagem da sala> <comando>\n\
Executa comando na linguagem do IntMUD e mostra o resultado."

func escr
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  se !txt2(arg1)
    ret arg0.msg("Digite CMDP seguido do nome do personagem e o comando")
  fimse
  n.ini(txt1(arg1), 1000000)
  l.addfim(arg0.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    se txtsepara(txt2(arg1), "L+DLEOV,DLEOV+L", "\b") != txt2(arg1)
      cmdlog(arg0, "cmdp", arg1)
    fimse
    debug d
    ret arg0.msg(txt(r.nome) + ">" + d.cmd(r, "ret " + txt2(arg1)))
  efim
  arg0.msg("Não há nenhum personagem chamado " + txt1(arg1))


classe adm_ac
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ac\b\n\
Sintaxe: AC <texto>\n\
Envia mensagem para o canal de administração.\n\
Você pode bloquear ou não o canal AC com o comando CONFIG, conforme abaixo:\n\
CONFIG -AC\n\
CONFIG +AC"

func escr
  se !arg0.jogconfig.19
    arg0.msg("Canal AC está desabilitado.")
  senao !arg1
    arg0.msg("Tecle a mensagem após AC.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg("(ac) " + arg0.nome + ": " + arg1)
    efim
  fimse


classe adm_econfig
herda comando_adm, comando_comum
const txtajuda = "\b\c3Econfig\b\nSintaxe: ECONFIG\nEdita as configurações do MUD."

func escr
  arg0.sock.m_menu("menu_econfig")


classe adm_echo
herda comando_adm, comando_comum
const txtajuda = "\b\c3Echo\b\n\
Sintaxe: ECHO <mensagem>\n\
Envia uma mensagem para todos os jogadores."

func escr
  se !arg1
    arg0.msg("\bTecle a mensagem após ECHO.")
  senao
    $misclog.rezou("echo " + arg0.nome + ": " + arg1)
    $mens.p(arg0)
    $mens.mens = arg1
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.msg($mens.proc(config:echomsg, item.obj.perso))
    efim
  fimse


classe adm_secho
herda comando_adm, comando_comum
const txtajuda = "\b\c3Secho\b\n\
Sintaxe: SECHO <mensagem>\n\
Envia uma mensagem para todos da sala em que você está."

func escr
  se !arg1
    arg0.msg("\bTecle a mensagem após SECHO.")
  senao
    $mens.p(arg0)
    $mens.mens = arg1
    $mens.mtodos1(config:sechomsg)
  fimse


classe adm_jecho
herda comando_adm, comando_comum
const txtajuda = "\b\c3Jecho\b\n\
Sintaxe: JECHO <jogador> <mensagem>\n\
Envia uma mensagem para um jogador."

func escr
  se !txt2(arg1)
    ret arg0.msg("Digite JECHO seguido do nome do personagem jogador e a mensagem")
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg1)))
  ret !item.obj, arg0.msg("Jogador inexistente ou ausente: " + txt1(arg1))
  $misclog.rezou("jecho " + arg0.nome + ": " + arg1)
  $mens.p(arg0, item.obj)
  $mens.mens = txt2(arg1)
  item.obj.msginv(config:jecho1msg)
  arg0.msginv(config:jecho2msg)


classe adm_rezou
herda comando_adm, comando_comum
const txtajuda = "\b\c3Rezou\b\n\
Sintaxe: REZOU <jogador> <texto>\n\
Envia mensagem para o jogador com cópia para todos os administradores."

func escr
  se !txt2(arg1)
    ret arg0.msg("Digite REZOU seguido do nome do personagem jogador e a mensagem")
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg1)))
  ret !item.obj, arg0.msg("Jogador inexistente ou ausente: " + txt1(arg1))
  $misclog.rezou("rezou " + arg0.nome + ": " + arg1)
  $mens.p(arg0, item.obj)
  $mens.mens = txt2(arg1)
  item.obj.msginv(config:rezou2msg)
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    continuar !item.obj.jogconfig.23 || item.obj.perso.var.u_[nome]
    item.obj.msg($mens.proc(config:rezou1msg, item.obj.perso))
  efim


classe adm_mudler
herda comando_adm, comando_comum
const txtajuda = "\b\c3Mudler\b\n\
Sintaxe: MUDLER\n\
Recarrega arquivos do MUD que foram alterados.\n\
Nota: Outra forma de recarregar os arquivos é pressionar a tecla F10\n\
na janela do IntMUD."

func escr
  $mudaprog.exec
  ret 1


classe adm_mudanome
herda comando_adm, comando_comum
const txtajuda = "\b\c3Mudanome\b\n\
Sintaxe: MUDANOME <nome atual> <novo nome>\n\
Muda o nome do personagem de um jogador.\n\
Nota: O jogador não precisa estar necessariamente online no MUD."

func escr
  se intsub(arg1) != 2
    ret arg0.msg("Tecle mudanome seguido do nome atual e o novo nome")
  fimse
  indiceitem ind
  txt20 nome.2 # Nome não codificado
  txt20 codif.2 # Nome codificado
  arqsav sav1
# Obtém os nomes
  nome.0 = txtmaimin(txt1(arg1))
  nome.1 = txtmaimin(txt2(arg1))
  codif.0 = txtnome(nome.0)
  codif.1 = txtnome(nome.1)
# Checa se o segundo personagem já existe
  se nome.0 == nome.1
    ret arg0.msg("Os dois nomes correspondem ao mesmo personagem.")
  senao inttotal(nome.1) < 3 || inttotal(nome.1) > 16
    ret arg0.msg("O novo nome deve ter de 3 a 16 caracteres.")
  senao intnome(nome.1)
    ret arg0.msg("O novo nome não é válido.")
  senao ind.obj("un " + codif.1)
    ret arg0.msg("Personagem " + nome.1 + " já está sendo usado.")
  senao codif.0 != codif.1 && sav1.existe("sav/" + codif.1 + ".sav")
    ret arg0.msg("Personagem " + nome.1 + " já existe.")
  fimse
# Jogador online
  uint8 mudou
  se ind.obj("un " + codif.0)
    ref r
    r = ind.obj("un " + codif.0)
    r.cnome = "un " + codif.1
    r.nome = nome.1
    r.perso.cnome = "pn " + codif.1
    r.perso.nome = nome.1
    mudou = 1
  fimse
# Jogo salvo
  se sav1.existe("sav/" + codif.0 + ".sav")
    textotxt t
    textopos p
    t.ler("sav/" + codif.0 + ".sav")
    p = t.ini
    p.txtproc("\nnome=") >= 0 && p.mudar(nome.1, 5, 100)
    t.salvar("sav/" + codif.1 + ".sav")
    codif.0 != codif.1 && sav1.apagar("sav/" + codif.0 + ".sav")
    mudou = 1
  fimse
# Informa se mudou
  se !mudou
    arg0.msg("Personagem " + nome.0 + " não existe.")
  senao
    arg0.msg("Personagem " + nome.0 + " mudou para " + nome.1 + ".")
    cmdlog(arg0, "mudanome", "Mudou personagem jogador " + nome.0 + " para " + nome.1)
  fimse


classe adm_listarsav
herda comando_adm, comando_comum
const txtajuda = "\b\c3Listarsav\b\n\
Sintaxe: LISTARSAV\n\
Mostra os arquivos de jogos salvos. Estão no diretório sav."

func escr
  arqdir dir
  txt100 lin
  lin = dir.abrir("sav")
  ret lin, arg0.msg("\bErro: " + lin)
  debug d
  d.exec = 50000
  refvar txtmais = arg0.sock.txtmais
  txtmais.limpar
  epara nulo, dir.lin, dir.depois
    txtmais.addfim(txttroca(dir.texto + "\b", ".sav\b", ","))
  efim
  txtmais.ordena
  textopos pos
  pos = txtmais.fim, pos.antes
  pos.mudar("", inttotal(pos.texto) - 1, 1)
  refvar total = int(txtmais.linhas)
  txtmais.juntar
  txtmais.dividelin(50, 70)
  txtmais.addini("\bArquivos de jogos salvos (" + total + "):")
  arg0.sock.txtmostra


classe adm_apagarsav
herda comando_adm, comando_comum
const txtajuda = "\b\c3Apagarsav\b\n\
Sintaxe: APAGARSAV <nome do arquivo>\n\
Apaga um arquivo de jogo salvo."

func escr
  arqdir dir
  txt100 lin
  se !arg1
    arg0.msg("Tecle o nome do arquivo após APAGARSAV.")
  senao (lin = dir.apagar("sav/" + arg1 + ".sav")) != ""
    arg0.msg("Erro ao apagar jogo salvo " + arg1 + ": " + lin)
  senao
    $miscsav.apagousav(arg1)
    arg0.msg("Jogo salvo apagado: " + arg1)
    cmdlog(arg0, "apagarsav", "Apagou jogo salvo " + arg1)
  fimse


classe adm_monit
herda comando_adm, comando_comum
const txtajuda = "\b\c3Monit\b\n\
Sintaxe: MONIT [jogador]\n\
Monitora um jogador, permitindo ver o que ele lê e escreve.\n\
Se [jogador] estiver ausente ou for o próprio, deixa de monitorar.\n\
O principal objetivo é auxiliar outros usuários, por isso quando\n\
esse comando é usado, todos os administradores são informados.\n\
O comando QUEM também mostra aos administradores quem está monitorando."

func escr
  indiceitem item
  ref r
  r = item.obj("pn " + txtnome(arg1))
  refvar imonit = arg0.sock.imonit
  se !arg1 || r == arg0
    se imonit
      txt100 t1
      t1 = imonit.objlista.perso.nome
      imonit.remove
      arg0.msg("Deixando de monitorar " + t1)
      t1 = "*** " + arg0.nome + " deixa de monitorar " + t1
      epara item.ini("un "), txt1(item.txt) == "un", item.depois
        item.obj.jogconfig.23 && item.obj != arg0.sock && item.obj.msg(t1)
      efim
      $misclog.cmdlog("monit " + arg0.nome + ":")
    senao
      arg0.msg("Não está monitorando ninguém")
    fimse
  senao !r
    arg0.msg("Jogador não encontrado: " + arg1)
  senao r == imonit.objlista.perso
    arg0.msg("Já está monitorando " + r.nome)
  senao
    imonit && arg0.msg("Deixando de monitorar " + imonit.objlista.perso.nome)
    imonit.remove
    txt100 t1
    t1 = "*** " + arg0.nome + " monitora " + r.nome
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != arg0.sock && item.obj.msg(t1)
    efim
    imonit = r.sock.lmonit.addini(arg0.sock)
    arg0.msg("Monitorando " + r.nome)
    $misclog.cmdlog("monit " + arg0.nome + ": " + r.nome)
  fimse


classe adm_escr
herda comando_adm, comando_comum
const txtajuda = "\b\c3Escr\b\n\
Sintaxe: ESCR <comando>\n\
Digita um comando no teclado do usuário sendo monitorado."

func escr
  se !arg0.sock.imonit
    arg0.msg("Você não está monitorando ninguém")
  senao !arg1
    arg0.msg("Tecle a mensagem após ESCR")
  senao
    arg0.sock.imonit.objlista.msg("*** " + arg0.nome + " escreve no seu teclado: " + arg1)
    arg0.sock.imonit.objlista.recebe(arg1)
    $misclog.cmdlog("escr " + arg0.nome + ": " + arg1)
  fimse


classe adm_info
herda comando_adm, comando_comum
const txtajuda = "\b\c3Info\b\n\
Sintaxe: INFO [personagem ou item]\n\
Mostra informações sobre a sala aonde você está, um personagem na sala\n\
ou item na sala ou que você carrega."

func escr
  se !arg1
# arg0.msg("\b\c2Você:\b\n" + info(arg0))
    ret arg0.msg("\c2Sala " + arg0.dono + ":\b\n" + info(arg0.dono))
  fimse
  int1 achou
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg1, 1000000)
  r = arg0
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(arg0) || !n.nome(r.ident, r.objtot)
    arg0.msg("\b\c2" + r.nome + ": " + r + "\b\n" + info(r))
    achou = 1
  efim
  !achou && arg0.msg("Não há nenhum personagem ou item chamado " + arg1)

func info # Usado por escr
  txt512 lin
  lin = "Peso:   obj=" + arg0.pesoobj + "  dentro=" + arg0.pesoden
  lin += "  total=" + arg0.pesotot + "  voando=" + (arg0.pesoadd ? "N" : "S")
  lin += "\nVolume: obj=" + arg0.volobj + "  dentro=" + arg0.volden
  lin += "  total=" + arg0.voltot + "  expande=" + (arg0.volexp ? "S" : "N")
  lin += "\nQuantidade=" + arg0.objtot + "  Jogadores=" + arg0.socktot
  lin += "  Itens dentro=" + arg0.dentro1.total + "  Personagens dentro=" + arg0.dentro2.total
  lin += "  objnum=" + arg0.objnum
  lin += "\nevento="
  listaitem i
  epara i = arg0.evento.ini, i, i.depois
    lin += txt(i.obj) + " "
  efim
  lin += "\nevrec.0=" + arg0.evrec.0.objlista
  lin += "  evrec.1=" + arg0.evrec.1.objlista
  lin += "  evrec.2=" + arg0.evrec.2.objlista
  ret lin


classe adm_estat
herda comando_adm
const txtajuda = "\b\c3Estat\b\n\
Sintaxe: ESTAT [personagem] [número do animal]\n\
Mostra estatísticas e diversas informações sobre um personagem da sala."


classe adm_hist
herda comando_adm, comando_comum
const txtajuda = "\b\c3Hist\b\n\
Sintaxe: HIST [personagem] [número do animal]\n\
Mostra o histórico de um personagem na mesma sala ou animal desse\n\
personagem, ou seja, os últimos 10 personagens que ele matou."

func escr
  refvar r = misc:objperso(arg0, arg1)
  ret !r, 1
  ret !r.p_hist.linhas, arg0.msg(txtcopiamai(r.nome, "A") + " não matou ninguém.")
  arg0.sock.txtmais.limpar
  arg0.sock.txtmais.addfim("\b\c6Histórico de " + txtcopiamai(r.nome, "A") + ":\b")
  arg0.sock.txtmais.addfim(r.p_hist.ini.textolin(100))
  arg0.sock.txtmostra


classe adm_infohab
herda comando_adm, comando_comum
const txtajuda = "\b\c3InfoHab\b\n\
Sintaxe: INFOHAB [personagem] [número do animal]\n\
Informa as habilidades de um personagem na sala."

func escr
  refvar r = misc:objperso(arg0, arg1)
  ret !r, 1
  txt100 t1
  txt100 t2
  refvar txtmais = arg0.sock.txtmais
  txtmais.limpar
  epara t1 = r.var.ini("h_"), txt(t1, 0, 2) == "h_", t1 = r.var.depois(t1)
    txtmais.addfim(txte(txt(t1, 2)) + " / " + txtsublin(misc:aulas, r.var.[t1], 1))
  efim
  se !txtmais.linhas
    txtmais.addfim(txtcopiamai(r.nome, "A") + " não conhece habilidades.")
  senao
    txtmais.addini("\b\c6Habilidades de " + r.nome + ":\b")
  fimse
  arg0.sock.txtmostra


classe adm_infomag
herda comando_adm, comando_comum
const txtajuda = "\b\c3InfoMag\b\n\
Sintaxe: INFOMAG [personagem] [número do animal]\n\
Informa as magias de um personagem na sala."

func escr
  refvar r = misc:objperso(arg0, arg1)
  ret !r, 1
  txt100 t1
  txt100 t2
  refvar txtmais = arg0.sock.txtmais
  txtmais.limpar
  epara t1 = r.var.ini("m_"), txt(t1, 0, 2) == "m_", t1 = r.var.depois(t1)
    txtmais.addfim(txte(txt(t1, 2)) + " / " + txtsublin(misc:aulas, r.var.[t1], 1))
  efim
  se !txtmais.linhas
    txtmais.addfim(txtcopiamai(r.nome, "A") + " não conhece magias.")
  senao
    txtmais.addini("\b\c6Magias de " + r.nome + ":\b")
  fimse
  arg0.sock.txtmostra


classe adm_infoe
herda comando_adm, comando_comum
const txtajuda = "\b\c3InfoE\b\n\
Sintaxe: INFOE [personagem] [número do animal]\n\
Informa os efeitos afetando um personagem na sala."

func escr
  refvar r = misc:objperso(arg0, arg1)
  ret !r, 1
  refvar txtmais = arg0.sock.txtmais
  txtmais.limpar
  listaitem i
  epara i = r.dentro2.ini, i, i.depois
    continuar !i.obj.e_nome
    txtmais.addfim("1 " + i.obj.e_nome + (i.obj.t_duracao ? " (" + int(i.obj.t_duracao / 10) + \
")"))
  efim
  se !txtmais.linhas
    txtmais.addfim("Nenhum efeito afetando " + r.nome + ".")
  senao
    txtmais.ordenalin("", "x")
    txtmais.addini("\b\c6Efeitos afetando " + r.nome + ":\b")
  fimse
  arg0.sock.txtmostra


classe adm_infojog
herda comando_adm, comando_comum
const txtajuda = "\b\c3InfoJog\b\n\
Sintaxe: INFOJOG <jogador>\n\
Mostra algumas informações do jogador: como está conectado, nível, moedas,\n\
e-mail, sala e jogo salvo. Se não estiver online, procura no jogo salvo."

func escr
  ret !arg1, arg0.msg("Digite o nome do jogador após INFOJOG")
# Obtém: p = objeto do personagem
  ref p # Objeto do personagem
  enquanto 1
    indiceitem item
    item.ini("pn " + txtnome(arg1))
    p = item.obj
    sair p
    se intnome(arg1)
      arg0.msg("Nome inválido para jogador: " + arg1)
      ret 1
    fimse
    arqsav sav1
    listaobj l1
    p = $jog_info, l1.addfim(p)
    p.cnome = "x " + txtnome(arg1)
    sair sav1.ler("sav/" + txt2(p.cnome) + ".sav", l1, 1)
    ret arg0.msg("Jogador inexistente: " + arg1)
  efim
# Mostra os dados do personagem
  txt100 lin
  lin = p.nome + ", nível " + p.pnivel
  p.var.z_moedas_ == 1 && (lin += ", uma moeda")
  p.var.z_moedas_ == 2 && (lin += ", duas moedas")
  p.var.z_moedas_ > 2 && (lin += ", " + p.var.z_moedas_ + " moedas")
  arg0.msg("\b\c6" + lin + "\b")
  p.sock && arg0.msg("Conexão:      " + p.sock.info)
  p.cnome && arg0.msg("Jogo salvo:   " + txt2(p.cnome))
  se p.dono
    arg0.msg("Está em:      " + p.dono)
  senao p.salanome
    arg0.msg("Entrará em:   " + p.salanome)
  fimse
  p.var.z_email && arg0.msg("E-mail:       " + p.var.z_email)


classe adm_ban
herda comando_adm, comando_comum
const txtajuda = "\c3Banir jogadores por IP\b\n\
\c2BAN\b\n\
  Mostra a lista de endereços banidos.\n\
\c2BAN\b <endereço IP> <tempo>\n\
  Impede que os jogadores de um endereço IP criem personagens no jogo.\n\
  Tempo é um número, em minutos. Se for 0, bane por tempo indeterminado.\n\
  Para banir uma faixa de endereços, terminar o endereço com um ponto.\n\
  Para banir todos os usuários novos, colocar um ponto no lugar do endereço.\n\
\c2BAN\b <endereço IP>\n\
  Desbane os jogadores do endereço especificado.\n\
\c2Exemplos:\b\n\
  ban 10.20.30.40    Bane 10.20.30.40 por tempo indeterminado\n\
  ban 1.2.3.4 10     Bane 1.2.3.4 por 10 minutos\n\
  ban 1.2. 0         Bane todos os endereços que começam com 1.2.\n\
  ban 1.2.3.4        Desbane 1.2.3.4\n\
  ban . 0            Bane todos; quem não tem personagem salvo não entra\n\
\c2Notas:\b\n\
1. Não é possível banir jogadores conectados via bot\n\
2. Para apenas derrubar jogadores, usar o comando cmdj da seguinte forma:\n\
   cmdj <personagem> apagar(este)"

func escr
  textopos pos
# Nenhum argumento: lista de endereços banidos
  se !arg1
    refvar txtmais = arg0.sock.txtmais
    txtmais.limpar
    datahora dh
    dh.agora
    refvar tini = dh.numtotal
    epara pos = $miscban.texto.ini, pos, pos.depois
      refvar tempo = intpos(txt2(pos.texto)) - tini
      se tempo < 0
        txtmais.addfim(txt1(pos.texto))
      senao tempo < 60
        txtmais.addfim(txt1(pos.texto) + " " + tempo + " seg.")
      senao
        txtmais.addfim(txt1(pos.texto) + " " + tempo / 60 + " min.")
      fimse
    efim
    se !txtmais.linhas
      txtmais.addfim("Nenhum endereço banido.")
    senao
      txtmais.addini("\b\c6Endereços banidos:\b")
    fimse
    ret arg0.sock.txtmostra
# Pelo menos um argumento: checa se endereço IP válido
  senao
    socket s
    refvar ender = txt1(arg1)
    se !s.ipvalido(ender) && !s.ipvalido(ender + "0")
      ret arg0.msg("Endereço IP inválido: " + arg1)
    fimse
  fimse
# Um argumento: desbane
  se !txt2(arg1)
    pos = $miscban.texto.ini
    se pos.txtproc("\n" + arg1 + " ") < 0
      arg0.msg("Endereço não está banido: " + arg1)
    senao
      pos.remove
      $miscban.salvar
      arg0.msg("Endereço foi desbanido: " + arg1)
      cmdlog(arg0, "ban", "desbaniu IP " + arg1)
    fimse
    ret
# Mais de um argumento: bane
  senao
    refvar tempo = intpos(txt2(arg1))
    pos = $miscban.texto.ini
    pos.txtproc("\n" + txt1(arg1) + " ") >= 0 && pos.remove
    se tempo > 0
      datahora hora
      hora.agora
      $miscban.texto.addini(txt1(arg1) + " " + (tempo * 60 + hora.numtotal))
      arg0.msg("Endereço foi banido: " + txt1(arg1) + " por " + tempo + " min")
      cmdlog(arg0, "ban", "baniu IP " + txt1(arg1) + " por " + tempo + " min")
    senao
      $miscban.texto.addini(txt1(arg1) + " 0")
      arg0.msg("Endereço foi banido: " + txt1(arg1))
      cmdlog(arg0, "ban", "baniu IP " + txt1(arg1))
    fimse
    $miscban.salvar
  fimse


classe adm_lcl
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lcl\b\nSintaxe: LCL [nome]\nLista as classes existentes."

func escr # Listar classes
  prog p
  txt80 lin
  refvar txtmais = arg0.sock.txtmais
  ret !p.iniclasse(arg1), arg0.msg("\bNenhuma classe encontrada.")
  debug d
  d.exec = 50000
  epara txtmais.limpar, p.lin, p.depois
    txtmais.addfim(p.texto + ",")
  efim
  textopos pos
  pos = txtmais.fim, pos.antes
  pos.mudar("", inttotal(pos.texto) - 1, 1)
  txtmais.juntar
  txtmais.dividelin(50, 70)
  txtmais.addini("\bClasses:")
  arg0.sock.txtmostra


classe adm_ccl
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ccl\b\n\
Sintaxe: CCL <nome> [arquivo]\n\
Cria uma classe. Aquivo é o sufixo do arquivo aonde criar a classe.\n\
Se for omitido, cria no arquivo mud.int.\n\
Nota: após criar a classe, costuma-se editar com Ecl e inicializar com Icl."

func escr # Cria classe
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após CCL")
  senao p.existe(txt1(arg1))
    arg0.msg("\bClasse já existe: " + txt1(arg1))
  senao
    arg0.sock.tpasso = arg1
    passo(arg0.sock, "")
  fimse

func passo
  arg0.passo = ""
  se arg1 == "n"
    arg0.msg("Cancelado")
  senao arg1 == "s"
    textotxt t
    prog p
    t.addfim(p.criar(txt1(arg0.tpasso) + "\n" + txt2(arg0.tpasso)))
    se t.bytes > 1
      arg0.msg2("Erro ao criar:\n" + t.remove(1000))
    senao
      arg0.msg("Classe criada: " + txt1(arg0.tpasso))
      config:salvar
      admlog(arg0, "criou classe " + txt1(passo))
    fimse
  senao
    arg0.msg("Criar classe " + txt1(arg0.tpasso) + " ? Tecle S ou N")
    arg0.passo = este
  fimse
  ret 1


classe adm_acl
herda comando_adm, comando_comum
const txtajuda = "\b\c3Acl\b\nSintaxe: ACL <nome>\nApaga uma classe."

func escr # Apaga classe
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após ACL")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao
    arg0.sock.tpasso = arg1
    passo(arg0.sock, "")
  fimse

func passo
  arg0.passo = ""
  se arg1 == "n"
    arg0.msg("Cancelado")
  senao arg1 == "s"
    prog p
    se !p.apagar(arg0.tpasso)
      arg0.msg("Erro ao apagar " + arg0.tpasso)
    senao
      arg0.msg("Classe apagada " + arg0.tpasso)
      config:salvar
      admlog(arg0, "apagou classe " + arg0.tpasso)
    fimse
  senao
    arg0.msg("Apagar classe " + arg0.tpasso + " ? Tecle S ou N")
    arg0.passo = este
  fimse
  ret 1


classe adm_ecl
herda comando_editor, comando_comum
const txtajuda = "\b\c3Ecl\b\nSintaxe: ECL [nome da classe]\nEdita uma classe."

func escr # Edita uma classe
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após ECL")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao
    arg0.sock.var.opcnome = ""
    arg0.sock.var.opcclasse = txts(arg1)
    passo(arg0.sock, "\b")
  fimse

func passo # Editar função
  se arg1 == "z" # Sair do editor
    arg0.msg("Fechando editor")
    arg0.passo = ""
  senao
    arg0.var.opcnome = "classe " + arg0.var.opcclasse
    passocod(arg0, arg1)
  fimse
  ret 1


classe adm_icl
herda comando_adm, comando_comum
const txtajuda = "\b\c3Icl\b\n\
Sintaxe: ICL <nome da classe>\n\
Inicializa uma classe (chama a função iniclasse da classe).\n\
Isso é necessário após criar e editar com os comandos ccl e ecl."

func escr # Inicializa uma classe
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após ICL")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao
    [arg1]:iniclasse(arg1)
    arg0.msg("\bClasse inicializada: " + arg1)
  fimse


classe adm_rcl
herda comando_adm, comando_comum
const txtajuda = "\b\c3Rcl\b\nSintaxe: RCL <nome> <novo nome>\nRenomeia uma classe."

func escr # Renomeia uma classe
  prog p
  se !txt2(arg1)
    arg0.msg("Digite RCL seguido do nome da classe e o novo nome da classe")
  senao !p.existe(txt1(arg1))
    arg0.msg("Classe não existe: " + txt1(arg1))
  senao p.existe(txt2(arg1))
    arg0.msg("Classe já existe: " + txt2(arg1))
  senao
    arg0.msg("Renomeando classe " + txt1(arg1) + " para " + txt2(arg1))
    p.renomear(txt1(arg1), txt2(arg1))
    config:salvar
  fimse


classe adm_lfunc
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lfunc\b\n\
Sintaxe: LFUNC <nome da classe>\n\
Lista as funções de uma classe."

func escr # Listar funções
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após LFUNC")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao !p.inifunc(arg1)
    arg0.msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg1 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg1, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    arg0.msg2(t.remove(1000))
  fimse


classe adm_lfunc2
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lfunc2\b\n\
Sintaxe: LFUNC2 <nome da classe>\n\
Lista todas as funções de uma classe, inclusive as herdadas."

func escr # Listar funções inclusive as herdadas
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após LFUNC2")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao !p.inifunctudo(arg1)
    arg0.msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg1 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg1, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    arg0.msg2(t.remove(1000))
  fimse


classe adm_herda
herda comando_editor, comando_comum
const txtajuda = "\b\c3Herda\b\n\
Sintaxe: herda <nome da classe>\n\
Edita herança de uma classe (uma classe herdada por linha)."

func escr
  prog p
  se !arg1
    arg0.msg("\bDigite o nome da classe após HERDA")
  senao !p.existe(arg1)
    arg0.msg("\bClasse não existe: " + arg1)
  senao
    arg0.sock.tpasso = arg1
    passo(arg0.sock, "\b")
  fimse

func passo
  casovar txtmin(txt(arg1, 0, 1))
  casose "\b"
    prog p
    arg0.teditor.limpar
    epara p.iniherda(arg0.tpasso), p.lin, p.depois
      arg0.teditor.addfim(p.texto)
    efim
    arg0.teditor.bytes == 1 && teditor.limpar
    arg0.leditor = arg0.teditor.ini
    arg0.leditor1 = arg0.teditor.ini
    arg0.leditor2 = arg0.teditor.fim
    arg0.leditor2.antes
    arg0.passo = este
    arg0.msg("Editando herança de " + arg0.tpasso + ", O opções, Z sair")
    ret 1
  casose "z" # Sair do editor
    arg0.msg("Fechando editor")
    arg0.passo = ""
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    p1 = arg0.teditor.ini
    se !p1.lin # Nenhum texto significa apagar herança
      p.inilinha(arg0.tpasso)
      txt1(p.texto) == "herda" && p.apagarlin(arg0.tpasso, 1)
      config:salvar, arg0.msg("Salvou: nenhuma herança")
      admlog(arg0, "alterou herança da classe " + arg0.tpasso)
      ret 1
    fimse
    enquanto p1.lin
      t1.addfim(p1.texto), p1.depois
    efim
    t1.addfim(p.criar(arg0.tpasso, "herda " + txttroca(t1.remove(100), "\n", ",")))
    se t1.bytes > 1
      arg0.msg2("Erro ao salvar herança:\n" + t1.remove(1000))
    senao
      config:salvar, arg0.msg("Salvou herança")
      admlog(arg0, "alterou herança da classe " + arg0.tpasso)
    fimse
    ret 1
  casofim
  ret passoeditor(arg0, arg1, 1000, "Herança")


classe jog_lugar
# Muda o personagem temporariamente de sala
# Chamado com: criar("jog_lugar", personagem, sala)
ref perso # Personagem do jogador
ref dono # Quem possui esse objeto; mesmo que: idono.objlista
ref donoantes # Dono anterior

func ini
  apagar(este)
  dono = arg0.dono
  donoantes = arg0.donoantes
  perso = arg0
  perso.mdono(arg1)

func fim
  perso.mdono(dono)
  perso.donoantes = donoantes


classe jog_info
# Usado no comando infojog
const iniclasse = !$[arg0] && criar(arg0)
sav textovar var # Variáveis criadas sob demanda
sav txt20 nome # Nome do personagem
txt100 cnome # Para obter o nome codificado
sav txt40 salanome # Nome da sala
sav uint16 pnivel # Nível atual
