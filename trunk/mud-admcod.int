classe jog_admcod
# Edição do código (classes e funções
const adm_cod = "\b\c3Comandos de edição do código\b\n\
\c2lcl\b [nome]\n\
  Lista as classes existentes.\n\
\c2ccl\b <nome> [arquivo]\n\
  Cria classe. Aquivo é o sufixo do arquivo aonde criar a classe.\n\
  Se for omitido, cria no arquivo mud.int.\n\
\c2acl\b <nome>\n\
  Apaga classe.\n\
\c2ecl\b [nome]\n\
  Edita uma classe.\n\
\c2herda\b <nome>\n\
  Edita herança de uma classe (uma classe herdada por linha).\n\
\c2lfunc\b <nome>\n\
  Lista funções de uma classe.\n\
\c2lfunc2\b <nome>\n\
  Lista todas funções de uma classe, inclusive as herdadas."

func cmd_lcl # Listar classes
  prog p
  txt80 lin
  se !p.iniclasse(arg0)
    msg("\bNenhuma classe encontrada.")
  senao
    textotxt t
    t.addfim("\bClasses:")
    enquanto p.lin
      se inttotal(lin + p.texto) >= 70
        t.addfim(lin), lin = p.texto
      senao lin
        lin += ", " + p.texto
      senao
        lin = p.texto
      fimse
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_ccl # Cria classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após CCL")
  senao p.existe(txt1(arg0))
    msg("\bClasse já existe: " + txt1(arg0))
  senao
    tpasso = arg0
    p_ccl("")
  fimse
  ret 1

func p_ccl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    textotxt t
    prog p
    t.addfim(p.criar(txt1(tpasso) + "\n" + txt2(tpasso)))
    se t.bytes > 1
      msg2("Erro ao criar:\n" + t.remove(1000))
    senao
      msg("Classe criada: " + txt1(tpasso))
      config:salvar
      admlog("criou classe " + txt1(passo))
    fimse
  senao
    msg("Criar classe " + txt1(tpasso) + " ? Tecle S ou N")
    passo = "ccl"
  fimse
  ret 1

func cmd_acl # Apaga classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ACL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_acl("")
  fimse
  ret 1

func p_acl
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    se !p.apagar(tpasso)
      msg("Erro ao apagar " + tpasso)
    senao
      msg("Classe apagada " + tpasso)
      config:salvar
      admlog("apagou classe " + tpasso)
    fimse
  senao
    msg("Apagar classe " + tpasso + " ? Tecle S ou N")
    passo = "acl"
  fimse
  ret 1

func cmd_ecl # Edita uma classe
  prog p
  se !arg0
    msg("\bDigite o nome da classe após ECL")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    var.opcnome = ""
    var.opcclasse = txts(arg0)
    p_classe("\b")
  fimse
  ret 1

func cmd_lfunc # Listar funções
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunc(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_lfunc2 # Listar funções inclusive as herdadas
  prog p
  se !arg0
    msg("\bDigite o nome da classe após LFUNC2")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao !p.inifunctudo(arg0)
    msg("\bNenhuma função encontrada.")
  senao
    textotxt t
    t.addfim("\bFunções de " + arg0 + ":")
    enquanto p.lin
      t.addfim(p.vartipo(arg0, p.texto) + " " + p.texto)
      p.depois
    efim
    lin && t.addfim(lin)
    msg2(t.remove(1000))
  fimse
  ret 1

func cmd_herda
  prog p
  se !arg0
    msg("\bDigite o nome da classe após HERDA")
  senao !p.existe(arg0)
    msg("\bClasse não existe: " + arg0)
  senao
    tpasso = arg0
    p_herda("\b")
  fimse
  ret 1

func p_herda
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    prog p
    teditor.limpar
    epara p.iniherda(tpasso), p.lin, p.depois
      teditor.addfim(p.texto)
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "herda"
    msg("Editando herança de " + tpasso + ", O opções, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    p1 = teditor.ini
    se !p1.lin # Nenhum texto significa apagar herança
      p.inilinha(tpasso)
      txt1(p.texto) == "herda" && p.apagarlin(tpasso, 1)
      config:salvar, msg("Salvou: nenhuma herança")
      admlog("alterou herança da classe " + tpasso)
      ret 1
    fimse
    enquanto p1.lin
      t1.addfim(p1.texto), p1.depois
    efim
    t1.addfim(p.criar(tpasso, "herda " + txttroca(t1.remove(100), "\n", ",")))
    se t1.bytes > 1
      msg2("Erro ao salvar herança:\n" + t1.remove(1000))
    senao
      config:salvar, msg("Salvou herança")
      admlog("alterou herança da classe " + tpasso)
    fimse
    ret 1
  casofim
  ret p_editor(arg0, 200, "Herança")
