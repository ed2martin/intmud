classe comum_dentro
# Todos os objetos que podem ter outro dentro
#
sav listaobj dentro # Lista de objetos que possui
sav listaobj evento # Objetos que recebem eventos desse
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
uint32 pesoden # Peso do que tem dentro
const pesotot = pesoobj + pesoden # Peso total do objeto
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto quando estiver vazio
const volmax = 1000000 # Volume máximo do que pode ter dentro
uint32 volden # Volume do que tem dentro
const volexp = 0 # 0=não expande, 1=expande com os itens que tem dentro
const voltot = volobj + volexp * volden # Volume total

func mudapeso # Deve ser chamado para mudar pesoden; arg0=o quanto mudou
  ref r
  pesoden += arg0, r = este
  enquanto r && !r.ipesovoa
    r = r.idono.objlista, r.pesoden += arg0
  efim

func mudavol # Muda volden; arg0=o quanto mudou
  ref r
  volden += arg0, r = este
  enquanto r.volexp
    r = r.idono.objlista, r.volden += arg0
  efim

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, r = dono
  enquanto r
    r.jogtot += arg0, r = r.dono
  efim

func ajustapeso # Ajuda peso e volume
  listaitem item
  uint32 soma1
  uint32 soma2
  item = dentro.ini
  soma = peso
  enquanto item
    soma1 += item.obj.pesotot, soma2 += item.obj.voltot, item.depois
  efim
  mudapeso(soma1 - pesotot)
  mudavol(soma2 - volden)


classe comum_fora
# Todos os objetos que podem pertencer a outro
# IMPORTANTE: Se herdar também comum_dentro,
# colocar comum_dentro antes de comum_fora na instrução herda
#
sav listaobj evento # Objetos que recebem eventos desse
sav listaitem idono # Uso interno: aonde o personagem ou item está
sav listaitem ibitev # Uso interno: para receber eventos
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
const pesotot = pesoobj # Peso total
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto
const voltot = volobj # Volume total
#
const sletra0 = "a" # sletra[sexo] = "o" ou "a"
const sletra1 = "o"
const sum0 = "uma" # sum[sexo] = "um" ou "uma"
const sum1 = "um"

varfunc dono # O dono do personagem/item
  se !args # Nenhum argumento: leitura
    ret idono.objlista # Retorna objeto que contém o personagem ou item
  fimse
  !ipesovoa && idono.objlista.mudapeso(-pesotot) # Retira peso do objeto
  idono.objlista.mudavol(-voltot) # Retira o volume
  jogtot && idono.objlista.mudajog(-jogtot) # Retira os jogadores
  idono.remove
  se ibitev # Se bitev=1, remove do antigo objeto e adiciona no novo
    ibitev.remove, ibitev = arg0.evento.addfim(este)
  fimse
  idono = arg0.dentro.addfim(este) # Adiciona na sala
  !ipesovoa && idono.objlista.mudapeso(pesotot) # Coloca peso do objeto
  idono.objlista.mudavol(voltot) # Coloca o volume
  jogtot && idono.objlista.mudajog(jogtot) # Coloca os jogadores

varfunc bitev
  se !args # Nenhum argumento: leitura
    ret int(ibitev)
  senao # Um argumento: altera valor
    ibitev.remove
    arg0 && (ibitev = dono.evento.addfim(este))

varfunc pesovoa
  se !args # Nenhum argumento: leitura
    ret ipesovoa != 0
  senao # Um argumento: altera valor
    int32 total
    !ipesovoa && (total -= pesotot)
    ipesovoa = arg0
    !ipesovoa && (total += pesotot)
    total && dono.mudapeso(total)

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, r = dono
  enquanto r
    r.jogtot += arg0, r = r.dono
  efim

func visivel # Checa se um objeto está visível (arg0=objeto)
  ret !(~bitver & arg0.inv)

func itemnome # Procura um item pelo nome
# arg0 = listaobj com os possíveis candidatos
# arg1 = texto digitado, exemplos: "banana", "2.banana", "10 banana"
# Deixa na lista (em arg0) somente os itens correspondentes
  nomeobj n # Texto procurado
  uint16 total # Quantidade de itens
  total = txt1(arg1)
  se total == 0 || txt(total) != txt1(arg1)
    n.ini(arg1, 1)
  senao total <= 10
    n.ini(txt2(arg1), total)
  senao
    n.ini(txt2(arg1), 10)
  fimse
  listaitem i # Para procurar os itens
  i = arg0.ini
  enquanto i
    se !(~bitver & i.obj.bitinv) && n.nome(i.obj.ident)
      i.depois
    senao
      i.removedepois
    fimse
  efim


classe perso
herda comum_dentro, comum_fora
# Personagens

sav uint8 bitver # O que o personagem/item pode ver
const bitinv = 3 # Grau de invisibilidade do personagem/item

const perso = 1 # Para identificar que é personagem
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const sexo = 0 # Sexo: 0=feminino, 1=masculino
#sav int1 sexo # Sexo: 0=feminino, 1=masculino
sav uint32 moedas # Quantas moedas está carregando
sav uint8 posicao # Posição do personagem
const pospadr = 8 # Posição padrão do personagem
const descpos = txtmaimin(nome) + " está aqui."
sav listaobj veste # Lista de objetos que está vestindo ou de magias afetando

func ini # Objeto foi criado
  bitver = 3
  posic = pospadrao

func fim # Objeto foi apagado
  ref r
  r = sock, r.mudaperso(nulo)
  dono = nulo
  casovar txt1(r.info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    apagar(r)
    sair
  casose "l" # Jogando localmente
    terminar
  casose "b" # Como bot
    r.reinicia
  casofim

func descpos
  casovar posic
  casose "0"
    ret txtmaimin(nome) + " jás aqui."
  casose "1"
    ret txtmaimin(nome) + " está aqui mortalmente ferid" + sletra[sexo] + "."
  casose "2"
    ret txtmaimin(nome) + " está aqui incapacitad" + sletra[sexo] + "."
  casose "3"
    ret txtmaimin(nome) + " está aqui, muito frac" + sletra[sexo] + "."
  casose "4"
    ret txtmaimin(nome) + " dorme aqui."
  casose "5"
    ret txtmaimin(nome) + " descansa aqui."
  casose "6"
    ret txtmaimin(nome) + " está sentad" + sletra[sexo] + "."
  casose "7"
    ret txtmaimin(nome) + " está lutando."
  casose "8"
    ret txtmaimin(nome) + " está em pé."
  casofim
  ret txtmaimin(nome) + " está aqui."

func teclou # Personagem teclou algum comando
# Executa eventos
  listaobj l0
  l0.addfim(este, dono, este.eventos, dono.eventos)
  enquanto l0 && !l0.ini.obj.evescr(este, arg0)
    l0.ini.remove
  efim
  se l0
    ret
  fimse
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  prog p # Para procurar o objeto
  p.inifunc("com_exec", "c_" + txt1(arg0))
  enquanto p.lin
    obj = com_exec:[p.texto]
    se obj.pode(este, arg0) && nivel >= obj.nivel
      sair
    fimse
    p.depois
  efim
# Executa comando
  se !p.lin
    msg("O quê?")
  senão posic >= obj.posic
    obj.exec(este, txt1(arg0), txt2(arg0))
  senão
    casovar posic
    casose "0" Morto
      msg("\c9Você está morto!!!\b")
      sair
    casose "1" # Mortalmente ferido
    casose "2" # Incapacitado
      msg("\c9Você está muito mal, incapaz de fazer qualquer coisa.\b")
      sair
    casose "3" # Fraco
      msg("\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b")
      sair
    casose "4" # Dormindo
      msg("\c9Nos seus sonhos...\b")
      sair
    casose "5" # Descansando
      msg("\c9Você se sente relaxado demais para fazer isso.\b")
      sair
    casose "6" # Sentado
      msg("\c9Talvez você deva ficar em pé primeiro.\b")
      sair
    casose "7" # Lutando
      msg("\c9Sem chance! Você está lutando pela sua vida.\b")
      sair
    casose
      msg("\c9Você tenta, mas não consegue.\b")
    casofim

classe i_borracha
herda comum_fora
const nome = "borracha"
const ident = "borracha"
const sexo = 0
const descpos = "Uma borracha está jogada aqui."
const descver = "Você não vê nada de especial."
