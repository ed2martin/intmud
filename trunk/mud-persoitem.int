classe comum_dentro
# Todos os objetos que podem ter outro dentro
#
sav listaobj dentro1 # Lista de objetos que possui
sav listaobj dentro2 # Lista de personagens ou de objetos que está vestindo
listaobj evento # Objetos que recebem eventos desse
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
uint32 pesoden # Peso do que tem dentro
const pesotot = pesoobj + pesoden # Peso total do objeto
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto quando estiver vazio
const volmax = 1000000 # Volume máximo do que pode ter dentro
uint32 volden # Volume do que tem dentro
const volexp = 0 # 0=não expande, 1=expande com os itens que tem dentro
const voltot = volobj + volexp * volden # Volume total

func mudapeso # Deve ser chamado para mudar pesoden; arg0=o quanto mudou
  ref r
  pesoden += arg0, r = este
  enquanto r && !r.ipesovoa
    r = r.idono.objlista, r.pesoden += arg0
  efim

func mudavol # Muda volden; arg0=o quanto mudou
  ref r
  volden += arg0, r = este
  enquanto r.volexp
    r = r.idono.objlista, r.volden += arg0
  efim

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, t_item = s_item * 600, r = dono
  enquanto r
    r.jogtot += arg0, r.t_item = r.s_item * 600, r = r.dono
  efim

func ajustapeso # Ajuda peso e volume
  listaitem item
  uint32 soma1
  uint32 soma2
  soma = peso
  item = dentro1.ini
  enquanto item
    soma1 += item.obj.pesotot, soma2 += item.obj.voltot, item.depois
  efim
  item = dentro2.ini
  enquanto item
    soma1 += item.obj.pesotot, soma2 += item.obj.voltot, item.depois
  efim
  mudapeso(soma1 - pesotot)
  mudavol(soma2 - volden)


classe comum_fora
# Todos os objetos que podem pertencer a outro
# IMPORTANTE: Se herdar também comum_dentro,
# colocar comum_dentro antes de comum_fora na instrução herda
#
sav listaitem idono # Uso interno: aonde o personagem ou item está
listaobj evento # Objetos que recebem eventos desse
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
const bitinv = 3 # Grau de invisibilidade do personagem/item
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
const pesotot = pesoobj # Peso total
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto
const voltot = volobj # Volume total

varfunc dono # O dono do personagem/item
  se !args # Nenhum argumento: leitura
    ret idono.objlista # Retorna objeto que contém o personagem ou item
  senao idono.objlista != ref(arg0)
    !ipesovoa && idono.objlista.mudapeso(-pesotot) # Retira peso do objeto
    idono.objlista.mudavol(-voltot) # Retira o volume
    jogtot && idono.objlista.mudajog(-jogtot) # Retira os jogadores
    idono.remove
    se perso
      idono = ref(arg0).dentro2.addini(este) # Adiciona personagem
    senao
      idono = ref(arg0).dentro1.addini(este) # Adiciona item
    fimse
    !ipesovoa && idono.objlista.mudapeso(pesotot) # Coloca peso do objeto
    idono.objlista.mudavol(voltot) # Coloca o volume
    jogtot && idono.objlista.mudajog(jogtot) # Coloca os jogadores

varfunc pesovoa
  se !args # Nenhum argumento: leitura
    ret ipesovoa != 0
  senao # Um argumento: altera valor
    int32 total
    !ipesovoa && (total -= pesotot)
    ipesovoa = arg0
    !ipesovoa && (total += pesotot)
    total && dono.mudapeso(total)

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, t_item = s_item * 600, r = dono
  enquanto r
    r.jogtot += arg0, r.t_item = r.s_item * 600, r = r.dono
  efim

func visivel # Checa se um objeto está visível (arg0=objeto)
  ret !(~bitver & arg0.inv)

func itemnome # Procura um item pelo nome
# arg0 = listaobj com os possíveis candidatos
# arg1 = texto digitado, exemplos: "banana", "2.banana", "10 banana"
# Deixa na lista (em arg0) somente os itens correspondentes
  nomeobj n # Texto procurado
  n.ini(arg1, 10)
  listaitem i # Para procurar os itens
  i = arg0.ini
  enquanto i
    se visivel(i.obj) && n.nome(i.obj.ident)
      i.depois
    senao
      i.removedepois
    fimse
  efim


classe comum_perso
herda comum_dentro, comum_fora
# Personagens

uint8 bitver # O que o personagem/item pode ver
uint8 bitinv # Grau de invisibilidade do personagem/item
#
const perso = 1 # Para identificar que é personagem
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const sexo = 0 # Sexo: 0=feminino, 1=masculino
#sav int1 sexo # Sexo: 0=feminino, 1=masculino
sav uint32 moedas # Quantas moedas está carregando
#
const expmax = nivel*nivel*nivel+20 # Experiência para subir de nível
sav uint16 nivel # Nível atual
sav uint32 exp # Experiência atual
sav uint16 ivida  # Pontos de vida; usado internamente (usar vida)
sav uint16 mana # Pontos de mana
sav uint16 move # Pontos de movimento
uint16 vidamax # Quantidade máxima de vida
uint16 manamax # Quantidade máxima de mana
uint16 movemax # Quantidade máxima de movimento
uint16 veloc # Velocidade do personagem
uint16 atknorm # Quantidade de ataque normal
uint16 defnorm # Quantidade de defesa normal
uint16 atkmag # Quantidade de ataque mágico/especial
uint16 defmag # Quantidade de defesa mágica/especial
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
const tipo1 = 0 # Tipo de personagem, vide função misc:atktipo
const tipo2 = 18 # Segundo tipo do personagem, ou 18 se nenhum
int8 deftipo.18
# Defesa contra os diversos tipos de danos
# Vide função misc:atktipo
# somar 2 = dobra defesa
# subtrair 2 = reduz defesa pela metade
# 9 ou mais = imune ao tipo de golpe
#
inttempo b_tempo # Tempo para terminar a batalha
ref b_alvo # Personagem alvo da batalha
sav uint8 posicao # Posição do personagem
const pospadr = 8 # Posição padrão do personagem
const descpos = txtmaimin(nome) + " está aqui."
sav listaobj veste # Lista de objetos que está vestindo ou de magias afetando
textotxt p_comandos # Comandos em espera para serem processados
inttempo p_espera # Tempo de espera para o próximo comando
sav inttempo p_restaura # Para restaurar status de tempos em tempos

func ini # Objeto foi criado
  dono = arg0
  posicao = pospadr
  ajustavar
  vida = vidamax
  mana = manamax
  move = movemax
  p_restaura = 100

func fim # Objeto foi apagado
  ref r
  r = sock, r.mudaperso(nulo)
  dono = nulo
  casovar txt1(r.info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    apagar(r)
    sair
  casose "l" # Jogando localmente
    terminar
  casose "b" # Como bot
    r.reinicia
  casofim
# Executa eventos
  listaobj l0
  l0.addfim(evento), evento.limpar
  enquanto l0
    l0.ini.obj.e_fim(este, arg0), l0.ini.remove
  efim

varfunc vida
  se !args # Lê vida
    ret ivida
  senao # Altera vida
    casovar (ivida = arg0) * 100 / vidamax
    casose "0"
    casose "1"
      posicao = (vida != 0) # 0=morto, 1=mortalmente ferido
      ret
    casose "2"
      posicao = 2 # incapacitado
      ret
    casose "3"
      posicao = 3 # fraco
      ret
    casose
      posicao < 4 && (posicao = pospadr)
    casofim

func descpos
  casovar posicao
  casose "0"
    ret txtmaimin(nome) + " jás aqui."
  casose "1"
    ret txtmaimin(nome) + " está aqui mortalmente ferid" + misc:sletra[sexo] + "."
  casose "2"
    ret txtmaimin(nome) + " está aqui incapacitad" + misc:sletra[sexo] + "."
  casose "3"
    ret txtmaimin(nome) + " está aqui, muito frac" + misc:sletra[sexo] + "."
  casose "4"
    ret txtmaimin(nome) + " dorme aqui."
  casose "5"
    ret txtmaimin(nome) + " descansa aqui."
  casose "6"
    ret txtmaimin(nome) + " está sentad" + misc:sletra[sexo] + "."
  casose "7"
    ret txtmaimin(nome) + " está lutando."
  casose "8"
    ret txtmaimin(nome) + " está em pé."
  casofim
  ret txtmaimin(nome) + " está aqui."

func teclou # Personagem teclou algum comando (arg0=comando)
  se !p_espera # Nenhum comando pendente
    p_espera = 2
    teclouproc(arg0)
  senao b_tempo # Está batalhando
    # p_comandos && msg("Feito, aguarde")
    p_comandos.limpar
    p_comandos.addfim(arg0)
  senao p_comandos.bytes < 1024 # Não chegou ao limite de comandos
    p_comandos.addfim(arg0)
  senao # Chegou ao limite de comandos
    msg("Aguarde")

func p_espera_exec # Pega o próximo comando
  se p_comandos.linhas
    p_espera = 2
    teclouproc(p_comandos.remove)
  senao !sock
    mob_exec

func teclouproc # Processa comando (arg0=comando)
# Encerra batalha se for o caso
  b_tempo && b_alvo.dono != dono && batalhafim
# Executa eventos
  listaobj l0
  l0.addfim(este.evento)
  enquanto l0 && !l0.ini.obj.e_escr(este, arg0)
    l0.ini.remove
  efim
  se l0
    ret
  fimse
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  prog p # Para procurar o objeto
  txt512 comando
  comando = txtremove(arg0, "SA")
  casovar txtmin(txt1(comando))
  casose ""
    msg("O quê?")
    ret
  casose "m"
  casose "ma"
  casose "mag"
  casose "magi"
  casose "magia"
    se dono.s_semmagia
      msg("Você não consegue lançar magias aqui.")
      ret
    fimse
    p.iniclasse("com_magia_" + txtsub(comando, 1, 1))
    comando = txtsub(comando, 2)
    sair
  casose
    p.iniclasse("com_" + txt1(comando))
    comando = txt2(comando)
  casofim
  enquanto p.lin
    obj = $[p.texto]
    se obj.pode(este, arg0) && nivel >= obj.nivel
      sair
    fimse
    p.depois
  efim
# Executa comando
  se !p.lin
    msg("O quê?")
  senão posicao >= obj.posic
    obj.exec(este, arg0, comando)
  senão
    casovar posicao
    casose "0" Morto
      msg("\c9Você está mort" + misc:sletra[sexo] + "!!!\b")
      sair
    casose "1" # Mortalmente ferido
    casose "2" # Incapacitado
      msg("\c9Você está muito mal, incapaz de fazer qualquer coisa.\b")
      sair
    casose "3" # Fraco
      msg("\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b")
      sair
    casose "4" # Dormindo
      msg("\c9Nos seus sonhos...\b")
      sair
    casose "5" # Descansando
      msg("\c9Você se sente relaxad" + misc:sletra[sexo] + " demais para fazer isso.\b")
      sair
    casose "6" # Sentado
      msg("\c9Talvez você deva ficar em pé primeiro.\b")
      sair
    casose "7" # Lutando
      msg("\c9Sem chance! Você está lutando pela sua vida.\b")
      sair
    casose
      msg("\c9Você tenta, mas não consegue.\b")
    casofim

func mudasala # Coloca personagem em outra sala (arg0 = sala)
# Executa e limpa eventos
  listaobj l0
  l0.addfim(evento), evento.limpar
  enquanto l0
    l0.ini.obj.e_saiu(este, arg0), l0.ini.remove
  efim
# Muda de sala
  dono = arg0
# Executa eventos
  l0.addfim(evento, dono.evento)
  este.e_sala1(este, arg0)
  dono.e_sala(este, arg0)
  enquanto l0
    l0.ini.obj.e_sala(este, arg0), l0.ini.remove
  efim
# Mostra descrição
  sock && msg2(dono.descsala(este, 7))
# Executa eventos
  l0.addfim(evento)
  enquanto l0
    l0.ini.obj.e_entrou(este, arg0), l0.ini.remove
  efim

func ajustavar # Ajusta variáveis, principalmente batalha
# Acerta atributos básicos
  bitver = 3
  bitinv = 3
  vidamax = nivel * 2 + 25
  veloc = nivel + 50
  manamax = nivel + 30
  movemax = nivel * 2 + 30
  atknorm = nivel * 4 + 40
  defnorm = nivel * 5 + 40
  atkmag = nivel * 4 + 50
  defmag = nivel * 5 + 50
  evasao = nivel * 2 + 30
  precisao = nivel * 2 + 30
# Acerta diversos tipos de defesa
  deftipo.limpar # Todas as defesas em 100%
  misc:def[tipo1] # Acerta defesa conforme o primeiro tipo
  misc:def[tipo2] # Acerta defesa conforme o segundo tipo
# Atributos do que está vestindo e do que está afetando o personagem
  listaitem item
  item = dentro2.ini
  enquanto item
    item.obj.ajustaperso(este)
    item.depois
  efim

func batalhaini # Inicia batalha com outro personagem
# arg0 = nome do alvo, ou "" se nenhum
# retorna: verdadeiro se pode prosseguir com o golpe
# Checa se é sala pacífica
  se dono.s_pacifico
    msg("Aqui é um lugar pacífico.")
    b_alvo = nulo
    b_tempo = 0
    ret
# Obtém o alvo
  senao arg0 # Escolheu o alvo
    listaobj l
    ref r
    l.addfim(dono.dentro2)
    itemnome(l, arg0)
    r = l.ini.obj
    se !r
      msg("Você não vê isso.")
      ret
    senao r == este
      msg("Atacar a si mesmo?")
      ret
    senao r.p_pacifico
      msg(r.nome + " é pacífic" + $mens.sexoA[r.sexo] + ".")
      ret
    fimse
    b_alvo = r
  senao !b_alvo # Atacar um alvo já definido
    msg("Atacar quem?")
    ret
  senao b_alvo.dono != dono # Alvo está em outra sala
    msg("Batalha encerrada.")
    batalhafim
    ret
  fimse
# Indica que estão batalhando
  posicao >= 4 && (posicao = 7)
  b_alvo.posicao >= 4 && (b_alvo.posicao = 7)
  b_tempo = 150 # Tempo da luta
  b_alvo.b_tempo = 150 # Tempo da luta do outro personagem
  !b_alvo.b_alvo && (b_alvo.b_alvo = este) # Alvo do outro personagem
  b_alvo.p_espera == 0 && (b_alvo.p_espera = 1) # Para gerar evento de MOBs
  ret 1

func batalhadepois # Deve ser chamado depois que executou um golpe
  b_alvo.vida == 0 && b_alvo.morreu + batalhafim
  vida == 0 && b_alvo.batalhafim + morreu

func batalhafim # Encerra a batalha
  b_tempo && posicao == 7 && (posicao = pospadr)
  b_alvo = nulo, b_tempo = 0

func b_tempo_exec # Encerra a batalha depois de um tempo
  b_alvo && msg("Batalha encerrada.")
  posicao == 7 && (posicao = pospadr)
  b_alvo = nulo, b_tempo = 0

func morreu # Procedimentos quando morre
  $mens.p(este)
  $mens.mvis1("$P morreu.")
  se jog
    batalhafim
    vida = pos(vidamax/2 - 20) + 2
    mana = manamax / 2
    move = movemax / 2
    p_restaura = rand(100, 130)
    mudasala(config:salafim)
    salvar # Salva o jogo
  senao
    ref r
    apagar(este)
    r = sock, r.mudaperso(nulo)
    r.reinicia

func p_restaura_exec # Restaura algumas variáveis
  p_restaura = rand(100, 130)
  se vida < vidamax
    casovar posicao
    casose "1" # Mortalmente ferido
    casose "2" # Incapacitado
      vida += 1
      sair
    casose "3" # Fraco
      vida += 2
      sair
    casose "4" # Dormindo
      vida += vidamax / 5 + 5
      sair
    casose "5" # Descansando
      vida += vidamax / 10 + 3
      sair
    casose "6" # Sentado
      vida += vidamax / 15 + 2
      sair
    casose "7" # Lutando
    casose "8" # Em pé
      vida += vidamax / 30 + 1
    casofim
    vida > vidamax && (vida = vidamax)
  fimse
  se mana < manamax
    casovar posicao
    casose "4" # Dormindo
      mana += manamax / 5 + 5
      sair
    casose "5" # Descansando
      mana += manamax / 10 + 3
      sair
    casose "6" # Sentado
      mana += manamax / 15 + 2
      sair
    casose "7" # Lutando
    casose "8" # Em pé
      mana += manamax / 30 + 1
    casofim
    mana > manamax && (mana = manamax)
  fimse
  se move < movemax
    casovar posicao
    casose "4" # Dormindo
      move += manamax / 5 + 5
      sair
    casose "5" # Descansando
      move += manamax / 10 + 3
      sair
    casose "6" # Sentado
      move += manamax / 15 + 2
      sair
    casose "7" # Lutando
    casose "8" # Em pé
      move += manamax / 30 + 1
    casofim
    move > movemax && (move = movemax)
  fimse

func mob_exec # Somente MOBs, inteligência artificial do MOB
  se b_alvo
    teclou("atk")

func msgvis # Mensagem se o jogador estiver vendo o alvo
  se sock && posicao > 4 && visivel($mens.perso) # Se tem jogador e está acordado
      $mens.proc(arg0, este)

func msginv # Mensagem mesmo se o alvo estiver invisível
  se sock && posicao > 4 && visivel($mens.perso) # Se tem jogador e está acordado
    $mens.proc(arg0, este)

classe comum_item
herda comum_fora
# Itens
const bitinv = 3 # Grau de invisibilidade do personagem/item
const item = 1 # Para identificar que é item
const sexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "item"
const ident = nome
const descpos = txtmaimin(nome) + " está aqui."
const descver = "Você não vê nada de especial."
uint32 vestpos # Em que posição está vestindo, 0=nenhuma
func ini # Objeto foi criado
  dono = arg0
func fim
  evento.limpar


classe i_borracha
herda comum_item
const nome = "borracha"
const sexo = 0
const descpos = "Uma borracha está jogada aqui."
const vestir = 8


classe p_anao
herda comum_perso
const nome = "anão"
const ident = "anão"
const sexo = 1
const descpos = "Um anão está aqui."
const descver = "Você não vê nada de especial."
