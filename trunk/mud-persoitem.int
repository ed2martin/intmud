classe comum_dentro
# Todos os objetos que podem ter outro dentro
#
sav listaobj dentro1 # Lista de objetos que possui
sav listaobj dentro2 # Lista de personagens ou de objetos que está vestindo
sav listaobj evento # Objetos que recebem eventos desse
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
uint32 pesoden # Peso do que tem dentro
const pesotot = pesoobj + pesoden # Peso total do objeto
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto quando estiver vazio
const volmax = 1000000 # Volume máximo do que pode ter dentro
uint32 volden # Volume do que tem dentro
const volexp = 0 # 0=não expande, 1=expande com os itens que tem dentro
const voltot = volobj + volexp * volden # Volume total

func mudapeso # Deve ser chamado para mudar pesoden; arg0=o quanto mudou
  ref r
  pesoden += arg0, r = este
  enquanto r && !r.ipesovoa
    r = r.idono.objlista, r.pesoden += arg0
  efim

func mudavol # Muda volden; arg0=o quanto mudou
  ref r
  volden += arg0, r = este
  enquanto r.volexp
    r = r.idono.objlista, r.volden += arg0
  efim

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, t_item = s_item * 600, r = dono
  enquanto r
    r.jogtot += arg0, r.t_item = r.s_item * 600, r = r.dono
  efim

func ajustapeso # Ajuda peso e volume
  listaitem item
  uint32 soma1
  uint32 soma2
  soma = peso
  item = dentro1.ini
  enquanto item
    soma1 += item.obj.pesotot, soma2 += item.obj.voltot, item.depois
  efim
  item = dentro2.ini
  enquanto item
    soma1 += item.obj.pesotot, soma2 += item.obj.voltot, item.depois
  efim
  mudapeso(soma1 - pesotot)
  mudavol(soma2 - volden)


classe comum_fora
# Todos os objetos que podem pertencer a outro
# IMPORTANTE: Se herdar também comum_dentro,
# colocar comum_dentro antes de comum_fora na instrução herda
#
sav listaobj evento # Objetos que recebem eventos desse
sav listaitem idono # Uso interno: aonde o personagem ou item está
sav listaitem ibitev # Uso interno: para receber eventos
uint8 jogtot # Quantidade de objetos controlados por jogadores (com sock!=nulo)
const bitinv = 3 # Grau de invisibilidade do personagem/item
#
const pesoobj = 1 # Peso do objeto, 1000 = 1Kg
const pesotot = pesoobj # Peso total
sav int1 ipesovoa # Uso interno: se está voando (peso total é zero)
#
const volobj = 1 # Volume do objeto
const voltot = volobj # Volume total
#
const sletra0 = "a" # sletra[sexo] = "o" ou "a"
const sletra1 = "o"
const sum0 = "uma" # sum[sexo] = "um" ou "uma"
const sum1 = "um"

varfunc dono # O dono do personagem/item
  se !args # Nenhum argumento: leitura
    ret idono.objlista # Retorna objeto que contém o personagem ou item
  fimse
  !ipesovoa && idono.objlista.mudapeso(-pesotot) # Retira peso do objeto
  idono.objlista.mudavol(-voltot) # Retira o volume
  jogtot && idono.objlista.mudajog(-jogtot) # Retira os jogadores
  idono.remove
  se ibitev # Se bitev=1, remove do antigo objeto e adiciona no novo
    ibitev.remove, ibitev = arg0.evento.addfim(este)
  fimse
  se perso
    idono = arg0.dentro2.addini(este) # Adiciona personagem
  senao
    idono = arg0.dentro1.addini(este) # Adiciona item
  fimse
  !ipesovoa && idono.objlista.mudapeso(pesotot) # Coloca peso do objeto
  idono.objlista.mudavol(voltot) # Coloca o volume
  jogtot && idono.objlista.mudajog(jogtot) # Coloca os jogadores

varfunc bitev
  se !args # Nenhum argumento: leitura
    ret int(ibitev)
  senao # Um argumento: altera valor
    ibitev.remove
    arg0 && (ibitev = dono.evento.addfim(este))

varfunc pesovoa
  se !args # Nenhum argumento: leitura
    ret ipesovoa != 0
  senao # Um argumento: altera valor
    int32 total
    !ipesovoa && (total -= pesotot)
    ipesovoa = arg0
    !ipesovoa && (total += pesotot)
    total && dono.mudapeso(total)

func mudajog # Muda jogtot; arg0=o quanto mudou
  ref r
  jogtot += arg0, t_item = s_item * 600, r = dono
  enquanto r
    r.jogtot += arg0, r.t_item = r.s_item * 600, r = r.dono
  efim

func visivel # Checa se um objeto está visível (arg0=objeto)
  ret !(~bitver & arg0.inv)

func itemnome # Procura um item pelo nome
# arg0 = listaobj com os possíveis candidatos
# arg1 = texto digitado, exemplos: "banana", "2.banana", "10 banana"
# Deixa na lista (em arg0) somente os itens correspondentes
  nomeobj n # Texto procurado
  uint16 total # Quantidade de itens
  total = txt1(arg1)
  se total == 0 || txt(total) != txt1(arg1)
    n.ini(arg1, 1)
  senao total <= 10
    n.ini(txt2(arg1), total)
  senao
    n.ini(txt2(arg1), 10)
  fimse
  listaitem i # Para procurar os itens
  i = arg0.ini
  enquanto i
    se visivel(i.obj) && n.nome(i.obj.ident)
      i.depois
    senao
      i.removedepois
    fimse
  efim


classe comum_perso
herda comum_dentro, comum_fora
# Personagens

uint8 bitver # O que o personagem/item pode ver
uint8 bitinv # Grau de invisibilidade do personagem/item
#
const perso = 1 # Para identificar que é personagem
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const sexo = 0 # Sexo: 0=feminino, 1=masculino
#sav int1 sexo # Sexo: 0=feminino, 1=masculino
sav uint32 moedas # Quantas moedas está carregando
#
const expmax = nivel*nivel*nivel+20 # Experiência para subir de nível
sav uint16 nivel # Nível atual
sav uint32 exp # Experiência atual
sav uint16 vida  # Pontos de vida
sav uint16 mana # Pontos de mana
sav uint16 move # Pontos de movimento
uint16 vidamax # Quantidade máxima de vida
uint16 manamax # Quantidade máxima de mana
uint16 movemax # Quantidade máxima de movimento
uint16 veloc # Velocidade do personagem
uint16 atknorm # Quantidade de ataque normal
uint16 defnorm # Quantidade de defesa normal
uint16 atkmag # Quantidade de ataque mágico/especial
uint16 defmag # Quantidade de defesa mágica/especial
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
const tipo1 = 0 # Tipo de personagem, vide função m_tab:atktipo
const tipo2 = 18 # Segundo tipo do personagem, ou 18 se nenhum
int8 deftipo.18
# Defesa contra os diversos tipos de danos
# Vide função m_tab:atktipo
# somar 2 = dobra defesa
# subtrair 2 = reduz defesa pela metade
# 9 ou mais = imune ao tipo de golpe
#
inttempo b_tempo # Tempo para terminar a batalha
ref b_alvo # Personagem alvo da batalha
sav uint8 iposicao # Posição do personagem; usado internamente
const pospadr = 8 # Posição padrão do personagem
const descpos = txtmaimin(nome) + " está aqui."
sav listaobj veste # Lista de objetos que está vestindo ou de magias afetando
textotxt p_comandos # Comandos em espera para serem processados
inttempo p_espera # Tempo de espera para o próximo comando

func ini # Objeto foi criado
  arg0 && (dono = arg0)
  posicao = pospadr
  ajustavar
  vida = vidamax
  mana = manamax
  move = movemax

func fim # Objeto foi apagado
  ref r
  r = sock, r.mudaperso(nulo)
  dono = nulo
  casovar txt1(r.info)
  casose "t" # Conectado via Papovox
  casose "p" # Conectado via Telnet
    apagar(r)
    sair
  casose "l" # Jogando localmente
    terminar
  casose "b" # Como bot
    r.reinicia
  casofim

varfunc posicao # Posição do personagem
  se args # Altera posição
    iposicao = arg0
  senao # Lê posição
    casovar vida * 100 / vidamax
    casose "0"
    casose "1"
      ret vida != 0 # 0=morto, 1=mortalmente ferido
    casose "2"
      ret 2 # incapacitado
    casose "3"
      ret 3 # fraco
    casose
      se b_alvo
        ret 7
      senao
        ret iposicao
      fimse
    casofim

func descpos
  casovar posicao
  casose "0"
    ret txtmaimin(nome) + " jás aqui."
  casose "1"
    ret txtmaimin(nome) + " está aqui mortalmente ferid" + sletra[sexo] + "."
  casose "2"
    ret txtmaimin(nome) + " está aqui incapacitad" + sletra[sexo] + "."
  casose "3"
    ret txtmaimin(nome) + " está aqui, muito frac" + sletra[sexo] + "."
  casose "4"
    ret txtmaimin(nome) + " dorme aqui."
  casose "5"
    ret txtmaimin(nome) + " descansa aqui."
  casose "6"
    ret txtmaimin(nome) + " está sentad" + sletra[sexo] + "."
  casose "7"
    ret txtmaimin(nome) + " está lutando."
  casose "8"
    ret txtmaimin(nome) + " está em pé."
  casofim
  ret txtmaimin(nome) + " está aqui."

func teclou # Personagem teclou algum comando (arg0=comando)
  se !p_espera
    p_espera = 2
    teclouproc(arg0)
  senao p_comandos.bytes < 1024
    p_comandos.addfim(arg0)
  senao
    msg("Aguarde")

func p_espera_exec # Pega o próximo comando
  se p_comandos.linhas
    p_espera = 2
    teclouproc(p_comandos.remove)
  senao !sock
    mob_exec

func teclouproc # Processa comando (arg0=comando)
# Executa eventos
  listaobj l0
  l0.addfim(este, dono, este.eventos, dono.eventos)
  enquanto l0 && !l0.ini.obj.evescr(este, arg0)
    l0.ini.remove
  efim
  se l0
    ret
  fimse
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  prog p # Para procurar o objeto
  txt512 comando
  comando = txtremove(arg0, "SA")
  casovar txtmin(txt1(comando))
  casose ""
    msg("O quê?")
    ret
  casose "m"
  casose "ma"
  casose "mag"
  casose "magi"
  casose "magia"
    se dono.s_semmagia
      msg("Você não consegue lançar magias aqui.")
      ret
    fimse
    p.iniclasse("com_magia_" + txtsub(comando, 1, 1))
    comando = txtsub(comando, 2)
    sair
  casose
    p.iniclasse("com_" + txt1(comando))
    comando = txt2(comando)
  casofim
  enquanto p.lin
    obj = $[p.texto]
    se obj.pode(este, arg0) && nivel >= obj.nivel
      sair
    fimse
    p.depois
  efim
# Executa comando
  se !p.lin
    msg("O quê?")
  senão posicao >= obj.posic
    obj.exec(este, arg0, comando)
  senão
    casovar posicao
    casose "0" Morto
      msg("\c9Você está morto!!!\b")
      sair
    casose "1" # Mortalmente ferido
    casose "2" # Incapacitado
      msg("\c9Você está muito mal, incapaz de fazer qualquer coisa.\b")
      sair
    casose "3" # Fraco
      msg("\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b")
      sair
    casose "4" # Dormindo
      msg("\c9Nos seus sonhos...\b")
      sair
    casose "5" # Descansando
      msg("\c9Você se sente relaxado demais para fazer isso.\b")
      sair
    casose "6" # Sentado
      msg("\c9Talvez você deva ficar em pé primeiro.\b")
      sair
    casose "7" # Lutando
      msg("\c9Sem chance! Você está lutando pela sua vida.\b")
      sair
    casose
      msg("\c9Você tenta, mas não consegue.\b")
    casofim

func mudasala # Coloca personagem em outra sala (arg0 = sala)
  dono = arg0
  sock && msg2(dono.descsala(este, 7))
  dono.entrou(este)

func ajustavar # Ajusta variáveis, principalmente batalha
# Acerta atributos básicos
  bitver = 3
  bitinv = 3
  vidamax = nivel * 2 + 25
  veloc = nivel + 50
  manamax = nivel + 30
  movemax = nivel * 2 + 30
  atknorm = nivel * 4 + 40
  defnorm = nivel * 5 + 40
  atkmag = nivel * 4 + 50
  defmag = nivel * 5 + 50
  evasao = nivel * 2 + 30
  precisao = nivel * 2 + 30
# Acerta diversos tipos de defesa
  deftipo.limpar # Todas as defesas em 100%
  m_tab:def[tipo1] # Acerta defesa conforme o primeiro tipo
  m_tab:def[tipo2] # Acerta defesa conforme o segundo tipo
# Atributos do que está vestindo e do que está afetando o personagem
  listaitem item
  item = dentro2.ini
  enquanto item
    item.obj.ajustaperso(este)
    item.depois
  efim

func batalhaini # Inicia batalha com outro personagem
# arg0 = nome do alvo, ou "" se nenhum
# retorna: verdadeiro se pode prosseguir com o golpe
# Checa se é sala pacífica
  se dono.s_pacifico
    msg("Aqui é um lugar pacífico.")
    b_alvo = nulo
    b_tempo = 0
    ret
# Obtém o alvo
  senao arg0 # Escolheu o alvo
    listaobj l
    ref r
    l.addfim(dono.dentro2)
    itemnome(l, arg0)
    r = l.ini.obj
    se !r
      msg("Você não vê isso.")
      ret
    senao r == este
      msg("Atacar a si mesmo?")
      ret
    senao r.p_pacifico
      msg(r.nome + " é pacífic" + $mens.sexoA[r.sexo] + ".")
      ret
    fimse
    b_alvo = r
  senao !b_alvo # Atacar um alvo já definido
    msg("Atacar quem?")
    ret
  senao b_alvo.dono != dono # Alvo está em outra sala
    msg("Batalha encerrada.")
    b_alvo = nulo
    b_tempo = 0
    ret
  fimse
# Indica que estão batalhando
  b_tempo = 150 # Tempo da luta
  b_alvo.b_tempo = 150 # Tempo da luta do outro personagem
  !b_alvo.b_alvo && (b_alvo.b_alvo = este) # Alvo do outro personagem
  b_alvo.p_espera == 0 && (b_alvo.p_espera = 1) # Para gerar evento de MOBs
  ret 1

func batalhadepois # Deve ser chamado depois que executou um golpe
  se b_alvo
    se b_alvo.vida == 0
      b_alvo.morreu, b_alvo = nulo, b_tempo = 0
    fimse
    vida == 0 && morreu

func b_tempo_exec # Encerra a batalha
  se b_alvo
    msg("Batalha encerrada.")
    b_alvo = nulo, b_tempo = 0

func morreu # Procedimentos quando morre
  $mens.p(este)
  $mens.mvis1("$P morreu.")
  se jog
    b_alvo = nulo
    b_tempo = 0
    vida = pos(vidamax/2 - 20) + 2
    mana = manamax / 2
    move = movemax / 2
    mudasala(config:salafim)
  senao
    ref r
    apagar(este)
    r = sock, r.mudaperso(nulo)
    r.reinicia

func mob_exec # Somente MOBs, inteligência artificial do MOB
  se b_alvo
    teclou("atk")

func msgvis # Mensagem se o jogador estiver vendo o alvo
  se sock && posicao > 4 && visivel($mens.perso) # Se tem jogador e está acordado
      $mens.proc(arg0, este)

func msginv # Mensagem mesmo se o alvo estiver invisível
  se sock && posicao > 4 && visivel($mens.perso) # Se tem jogador e está acordado
    $mens.proc(arg0, este)

classe comum_item
herda comum_fora
# Itens
const bitinv = 3 # Grau de invisibilidade do personagem/item
const item = 1 # Para identificar que é item
const sexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "item"
const descpos = txtmaimin(nome) + " está aqui."
const descver = "Você não vê nada de especial."
uint32 vestpos # Em que posição está vestindo, 0=nenhuma
func ini # Objeto foi criado
  arg0 && (dono = arg0)


classe i_borracha
herda comum_item
const nome = "borracha"
const ident = "borracha"
const sexo = 0
const descpos = "Uma borracha está jogada aqui."
const descver = "Você não vê nada de especial."
const vestir = 8


classe p_anao
herda comum_perso
const nome = "anão"
const ident = "anão"
const sexo = 1
const descpos = "Um anão está aqui."
const descver = "Você não vê nada de especial."
