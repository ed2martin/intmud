classe adm_casa
herda comando_adm
const txtajuda = "\b\c3Comandos de casas\b\n\
  \c2LCASA\b     Lista casas existentes\n\
  \c2CCASA\b     Cria uma \n\
  \c2ECASA\b     Edita uma casa\n\
  \c2ACASA\b     Apaga uma ou mais casas"


classe adm_lcasa
herda comando_adm, comando_comum
const txtajuda = "\b\c3Lcasa\b\n\
Sintaxe: LCASA [nome]\n\
Lista as casas que começam com o nome especificado.\n\
Se o nome for omitido, lista todas as casas."

func escr # Listar casas
  prog p
  se !p.iniclasse("c_" + txtremove(arg1, "EMDCT7"))
    ret arg0.msg("\bNenhuma casa encontrada.")
  fimse
  datahora hora
  hora.agora
  textotxt t
  txt200 lin
  t.addfim("\b\c6Casa  ArquivoJogador  DiasTaxa  Situação\b")
  enquanto p.lin && t.linhas < 500
    lin = txtsub($[p.texto].nomejog, 1, 1)
    se lin
      lin = "  " + lin + "  " + (hora.numdias - $[p.texto].diataxa)
      casovar $[p.texto].infotaxa
      casose "1"
        lin += "  Atrasado"
        sair
      casose "2"
        lin += "  Bloqueado"
        sair
      casose
        lin += "  Ok"
      casofim
    fimse
    t.addfim(txt(p.texto, 2) + lin)
    p.depois
  efim
  arg0.msg2(t.remove(500))


classe adm_ccasa
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ccasa\b\n\
Sintaxe: CCASA <nome>\n\
Cria uma casa. Nome deve ser o nome de uma área ou da casa.\n\
Nomes de casas são sempre nomes de área seguido de um número de 001 a 999.\n\
Passos para criar uma casa:\n\
1. Usar o comando CCASA\n\
2. Definir as salas que correspondem à casa com o comando ECASA\n\
3. Editar as salas (comando ESALA) colocando 0 na opção \"Apagar itens\"\n\
4. Acertar também a opção \"Objetos máximo\"\n\
5. Para segurança dos jogadores, editar as saídas da casa (comando ESAI)\n\
   para fechar ao passar e trancar ao fechar\n\
6. Colocar o nome da casa no código da fechadura (comando ESAI)\n\
Nota: para casa casa é criado um arquivo no diretório sav2."

func escr # Criar casa
  prog p
  txt40 nome
  uint16 num
# Checa se digitou nome da casa
  se arg1 == ""
    ret arg0.msg("Tecle o nome da casa ou área após CCASA")
  fimse
# Checa nome completo
  nome = txtmin(txtremove(arg1, "EMDCT7"))
  num = int(txtfim(nome, 3)) + 1000
  se num > 1000 && txtfim(num, 3) == txtfim(arg1, 3)
    se !p.existe("a_" + txt(nome, 0, inttotal(nome) - 3))
      ret arg0.msg("Área não existe: " + txt(nome, 0, inttotal(nome) - 3))
    senao p.existe("c_" + nome)
      ret arg0.msg("Casa já existe: " + nome)
    fimse
# Checa nome de área
  senao !p.existe("a_" + nome)
    ret arg0.msg("Área não existe: " + nome)
  senao
    epara num = 1001, p.existe("c_" + nome + txtfim(num, 3)), num += 1
      continuar num < 2000
      ret arg0.msg("Atingido limite de casas na área " + nome)
    efim
    nome += txtfim(num, 3)
  fimse
# Cria casa
  txt200 area
  area = txt(nome, 0, inttotal(nome) - 3)
  criar("admordena", "a-" + area)
  p.criar("c_" + nome + "\na-" + area + "\nherda casa\nconst area = \"" + area + "\"")
# config:salvar
  arg0.msg("\bCasa criada: " + nome)
  admlog(arg0, "criou casa " + nome)


classe adm_acasa
herda comando_adm, comando_comum
const txtajuda = "\b\c3Acasa\b\n\
Sintaxe: ACASA <nomes das casas>\n\
Apaga uma ou mais casas, com os nomes especificados."

func escr # Apagar casa
  prog p
  refvar nome = txtmin(txtremove(arg1, "EMDCT7"))
  se nome == ""
    ret arg0.msg("Tecle um ou mais nomes da casa após ACASA")
  fimse
  uint16 x
  enquanto txtsub(nome, x, 1)
    se !p.existe("c_" + txtsub(nome, x, 1))
      ret arg0.msg("Casa não existe: " + txtsub(nome, x, 1))
    fimse
    x += 1
  efim
  arg0.sock.tpasso = nome
  passo(arg0.sock, "")

func passo # Confirmar que quer apagar casa
  arg0.passo = ""
  se arg1 == "n"
    arg0.msg("Cancelado")
  senao arg1 == "s"
    prog p
    uint16 x
    enquanto txtsub(arg0.tpasso, x, 1)
      p.apagar("c_" + txtsub(arg0.tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      arg0.msg("Casa apagada: " + arg0.tpasso)
      admlog(arg0, "apagou casa " + arg0.tpasso)
    senao
      arg0.msg("Casas apagadas: " + arg0.tpasso)
      admlog(arg0, "apagou casas " + arg0.tpasso)
    fimse
  senao
    txt10 m1
    arg0.passo = este
    txt2(arg0.tpasso) && (m1 = "s")
    arg0.msg("Apagar casa" + m1 + " " + arg0.tpasso + "? Tecle S ou N")
  fimse
  ret 1


classe adm_ecasa
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ecasa\b\n\
Sintaxe: ECASA <nome>\n\
Edita a casa com o nome especificado."

func escr # Editar casa
  txt100 nome
  prog p
  nome = txtmin(txtremove(arg1, "EMDCT7"))
  se nome == ""
    arg0.msg("Tecle o nome da casa após ECASA")
  senao !$c_[nome]
    arg0.msg("\bCasa não existe: " + nome)
  senao
    arg0.sock.var.classe1 = "c_" + nome
    arg0.sock.m_menu("menu_casa")
  fimse


classe menu_casa
herda comando_menu
const titulo = "Casa " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Nome"
const info1 = "Nome para os comandos LISTA e COMPRAR"
const tipo1 = "opc_linha"
const clas1 = var.classe1
const vari1 = "nome"
#
const nome2 = "Descrição"
const info2 = "É mostrado ao teclar LISTAR e o nome da casa"
const tipo2 = "opc_texto"
const clas2 = var.classe1
const vari2 = "desc"
#
const nome3 = "Palavras chave"
const info3 = "Palavras que os jogadores digitam para os comandos COMPRAR e LISTAR"
const tipo3 = "opc_linha"
const clas3 = var.classe1
const vari3 = "ident"
#
const nome4 = "Valor da casa"
const tipo4 = "opc_numero"
const clas4 = var.classe1
const vari4 = "valor"
#
const nome5 = "Sala 1"
const tipo5 = "opc_sala"
const clas5 = var.classe1
const vari5 = "s1"
const exec5 = "acerta_mudou"
#
const nome6 = "Sala 2"
const tipo6 = "opc_sala"
const clas6 = var.classe1
const vari6 = "s2"
const exec6 = "acerta_mudou"
#
const nome7 = "Sala 3"
const tipo7 = "opc_sala"
const clas7 = var.classe1
const vari7 = "s3"
const exec7 = "acerta_mudou"
#
const nome8 = "Sala 4"
const tipo8 = "opc_sala"
const clas8 = var.classe1
const vari8 = "s4"
const exec8 = "acerta_mudou"
#
const nome9 = "Sala 5"
const tipo9 = "opc_sala"
const clas9 = var.classe1
const vari9 = "s5"
const exec9 = "acerta_mudou"
#
const nome10 = "Sala 6"
const tipo10 = "opc_sala"
const clas10 = var.classe1
const vari10 = "s6"
const exec10 = "acerta_mudou"
#
const nome11 = "Sala 7"
const tipo11 = "opc_sala"
const clas11 = var.classe1
const vari11 = "s7"
const exec11 = "acerta_mudou"
#
const nome12 = "Sala 8"
const tipo12 = "opc_sala"
const clas12 = var.classe1
const vari12 = "s8"
const exec12 = "acerta_mudou"
#
const nome13 = "Sala 9"
const tipo13 = "opc_sala"
const clas13 = var.classe1
const vari13 = "s9"
const exec13 = "acerta_mudou"


classe admatucasa
# Atualiza a variável infotaxa de todas as casas
const iniclasse = arg0 != "casa" && !$[arg0] && criar(arg0)
prog p
debug d
ref r

func atualiza # Atualiza as casas
  d.exec = 50000
  epara p.iniherdainv("casa"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.tempotaxa = 1
    efim
  efim


classe casa
listaobj salas
intexec inicasa
const iniclasse = arg0 != "casa" && !$[arg0] && criar(arg0)
const ini = inicasa = 1
sav indiceobj nomejog # "cj " + nome codificado + " " + prefixo da área
sav txt50 chave # Código da chave que abre a porta da casa
sav int32 diataxa # A partir de quando deve pagar a taxa de manutenção da casa
int8 infotaxa # 0=taxa em dia, 1=avisar, 2=bloquear casa
inttempo tempotaxa # Para atualizar infotaxa
int1 objmudou # Se as informações da casa foram mudadas (precisa salvar a casa)
const ident = nome
#
# Ordem que deve organizar as constantes:
const admordem = "area\nnome\ndesc\nident\nvalor\ns1\ns2\ns3\ns4\ns5"

func fim # Apaga arquivo da casa
  ret inttotal(este) != 1, nulo # Por segurança: só apaga arquivo se tiver 1 objeto
  arqsav sav1
  sav1.apagar("sav2/c-" + txt(este, 2) + ".sav")

func inicasa_exec # Carrega objetos da casa
  listaobj l1
  l1.addfim(este)
  arqsav sav1
  sav1.ler("sav2/c-" + txt(este, 2) + ".sav", l1)
  l1.ini.remove # Remove da lista, porque é o objeto de controle da casa
# Acerta variáveis
  listaitem item
  debug d
  epara item = l1.ini, item, item.depois
    d.ini, item.obj.ajustaobj
  efim
  epara item = l1.fim, item, item.antes
    d.ini
    se txt(item.obj, 0, 2) == "s_" # Se for sala
      apagar($[item.obj]), item.obj.ini # Apaga a sala que já existia e inicializa essa
    senao !item.obj.dono # Se for item sem dono
      apagar(item.obj) # Apaga o item
    fimse
    item.obj.var.limpar("d_", "j_")
    item.obj.ajustapeso, item.obj.acertapos, item.obj.recalc = 1
  efim
# Indica que nenhuma sala mudou
  objmudou = 0
  s1.objmudou = 0, s2.objmudou = 0, s3.objmudou = 0
  s4.objmudou = 0, s5.objmudou = 0, s6.objmudou = 0
  s7.objmudou = 0, s8.objmudou = 0, s9.objmudou = 0
# Checa a fechadura
  !chave && mudachave
# Checa se ainda pertence a um jogador
  se nomejog
    arqsav sav
    se sav.existe("sav/" + txtsub(nomejog, 1, 1) + ".sav")
      nomejog = "cj " + txtsub(nomejog, 1, 1) + " " + area
    senao
      nomejog = "", objmudou = 1
    fimse
  fimse
  nomejog && tempotaxa_exec

func tempotaxa_exec # Atualiza variável infotaxa
  datahora hora
  hora.agora
  refvar atraso = hora.numdias - diataxa
  se intpos(config:casatempotaxa) == 0 # Sem taxa de manutenção das casas
    infotaxa = 0
    tempotaxa = 0
  senao !nomejog # Se não pertence a nenhum jogador
    infotaxa = 0
    tempotaxa = 0
  senao !diataxa # Se o tempo quando pagou a taxa está vazio
    infotaxa = 0
    tempotaxa = (86402 - hora.numseg) * 10 # Dois segundos após o dia mudar
    refvar tempo = intpos(config:casatempotaxa)
    diataxa = hora.numdias + tempo
    tempo && (diataxa = intdiv(diataxa / tempo) * tempo)
    objmudou = 1
  senao atraso >= config:casatempoperder
    infotaxa = 0
    tempotaxa = 0
    nomejog = ""
    mudachave
  senao atraso >= config:casatempobloq
    infotaxa = 2
    tempotaxa = (86402 - hora.numseg) * 10 # Dois segundos após o dia mudar
  senao atraso >= config:casatempoaviso
    infotaxa = 1
    tempotaxa = (86402 - hora.numseg) * 10 # Dois segundos após o dia mudar
  senao
    infotaxa = 0
    tempotaxa = (86402 - hora.numseg) * 10 # Dois segundos após o dia mudar
  fimse

func acerta_mudou # Chamado quando a lista das salas da casa mudou
  txt512 lin
  lin = "func mudou # Se houve alguma mudança\n"
  lin += "# Não alterar; função criada automaticamente\nret objmudou"
  prog p
  int8 x
  epara x = 1, x < 10, x += 1
    p.existe(este, "s" + x) && (lin += "||s" + x + ".objmudou")
  efim
  p.criar(este, lin)
  config:salvar
  objmudou = 1

func mudachave # Muda o código da fechadura da casa
  datahora hora
  hora.agora
  chave = txt(este) + " " + rand(10) + rand(10) + hora.numtotal
  objmudou = 1

func mudou # Se houve alguma mudança (há necessidade de salvar)
  ret objmudou

func salvar # Salva objetos da casa
  objmudou = 0
  s1.objmudou = 0, s2.objmudou = 0, s3.objmudou = 0
  s4.objmudou = 0, s5.objmudou = 0, s6.objmudou = 0
  s7.objmudou = 0, s8.objmudou = 0, s9.objmudou = 0
  listaitem item
  listaobj lista
  debug dbg
  dbg.exec = 50000
  lista.addfim1(este, s1, s2, s3, s4, s5, s6, s7, s8, s9)
  item = lista.ini, item.depois
  enquanto item
    se item.obj.objsav & 1 != 1 # Se item.obj.objsav!=1 e item.obj.objsav!=3
      item.removedepois
    senao lista.total < 2000
      lista.addfim(item.obj.dentro1, item.obj.dentro2, item.obj.dentro3), item.depois
    senao
      item.depois
    fimse
  efim
  arqsav sav1
  sav1.salvar("sav2/c-" + txt(este, 2) + ".sav", lista, 365000, "x")

func descloja # Retorna informações da casa para a venda
  uint16 itens
  uint8 salas
  itens = s1.objmax + s2.objmax + s3.objmax + s4.objmax + s5.objmax
  itens += s6.objmax + s7.objmax + s8.objmax + s9.objmax
  salas = 9 - !s1 - !s2 - !s3 - !s4 - !s5 - !s6 - !s7 - !s8 - !s9
  txt300 lin
  lin = txtcopiamai(nome, "A")
  lin += salas == 1 ? ", possui uma sala" : ", possui " + salas + " salas"
  ret lin + ", até " + itens + " itens"


classe cmd_pagar
herda comando_comum
const txtajuda = "\b\c3Pagar\b\n\
Sintaxe: PAGAR [item]\n\
Sem argumentos mostra a lista de casas cujas taxas de manutenção podem\n\
ser pagas. Seguido de um nome ou número paga a taxa."
const posic = 5
txt200 lin
int32 valor # Usado internamente: valor da taxa
int8 abre # Usado internamente: horário de abertura
int8 fecha # Usado internamente: horário de fechamento
real2 lucro # Para calcular o lucro do vendedor
int32 linha
ref p # Vendedor que está verificando
txt30 tipo1 # arg0.tipo1
txt30 tipo2 # arg0.tipo2
txt30 tipo3 # arg0.tipo3

func escr
  tipo1 = arg0.tipo1 ? "\n" + arg0.tipo1 + "\n" : ""
  tipo2 = arg0.tipo2 ? "\n" + arg0.tipo2 + "\n" : ""
  tipo3 = arg0.tipo3 ? "\n" + arg0.tipo3 + "\n" : ""
  arg1 ? escr2(arg0, arg1) : escr1(arg0)

func escr1 # Consultar a lista de taxas
  se intpos(config:casatempotaxa) == 0
    ret arg0.msg("Não há taxa de manutenção das casas.")
  fimse
  textotxt t
  listaobj l
  linha = 1, l.addfim(arg0.dono.dentro2)
  epara l.remove(arg0), l, l.ini.remove
    p = l.objini # Personagem que está sendo verificado
    continuar p.atkenv || !p.taxacasa
# Checa se pode cobrar alguma taxa
    se tipo1 && txtproc("\n" + txte(p.lojanao) + "\n", tipo1) >= 0
      t.addfim(txtcopiamai(p.descnome, "A") + ": Não negocio com " + arg0.tipo1)
      continuar
    senao tipo2 && txtproc("\n" + txte(p.lojanao) + "\n", tipo2) >= 0
      t.addfim(txtcopiamai(p.descnome, "A") + ": Não negocio com " + arg0.tipo2)
      continuar
    senao tipo3 && txtproc("\n" + txte(p.lojanao) + "\n", tipo3) >= 0
      t.addfim(txtcopiamai(p.descnome, "A") + ": Não negocio com " + arg0.tipo3)
      continuar
    fimse
    abre = p.lojaini - misc:hora, fecha = p.lojafim - misc:hora
    se abre < fecha ? abre > 0 || fecha <= 0 : abre > 0 && fecha <= 0
      t.addfim(txtcopiamai(p.descnome, "A") + ": Volte outra hora")
      continuar
    senao
      listaobj e
      lin = ""
      epara e.addfim(arg0.evento, p.evento), e, e.ini.remove
        lin = e.objini.cmd_negociar(arg0, p, "pagar")
        sair lin
      efim
      se lin
        t.addfim(txtcopiamai(p.descnome, "A") + ": " + lin)
        continuar
      fimse
    fimse
    t.addfim("\b\c6" + txtcopiamai(p.descnome, "A") + " informa:\b")
    lucro = (100 + p.taxavenda) / 100
# Informa casas
    se 1
      textotxt t2
      indiceitem item
      datahora hora
      hora.agora
      int1 mudou
      epara t2.addfim(p.taxacasa), t2.linhas, t2.remove
        refvar casa = item.obj("cj " + txt2(arg0.sock.cnome) + " " + t2.ini.texto)
        continuar !casa
        lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += txtcopiamai(casa.nome, "A")
        lin += txtesp(40 - inttotal(lin))
        valor = hora.numdias - casa.diataxa
        se valor == -1
          t.addfim(lin + "Em 12 dias MUD (1 dia)")
        senao valor < 0
          valor = -valor
          t.addfim(lin + "Em " + valor * 12 + " dias MUD (" + valor + " dias)")
        senao
          se config:casatempotaxa
            valor = intdiv(valor / config:casatempotaxa) + 1
          senao
            valor = 0
          fimse
          valor *= lucro * casa.valor * config:casataxa / 100
          t.addfim(lin + "$ " + valor)
        fimse
        mudou = 1
      efim
      !mudou && t.addfim("Você não deve nada.")
    fimse
  efim
# Envia mensagens
  se t.linhas
    arg0.msg2(t.remove(1000))
  senao
    arg0.msg("Ninguém cobra taxas aqui.")

func escr2 # Consultar um item
  listaobj l
  nomeobj n
  linha = 0, l.addfim(arg0.dono.dentro2), n.ini(arg1, 1)
  epara l.remove(arg0), l, l.ini.remove
    p = l.objini # Personagem que está sendo verificado
    continuar p.atkenv || !p.taxacasa
# Checa se pode vender alguma coisa
    continuar tipo1 && txtproc("\n" + txte(p.lojanao) + "\n", tipo1) >= 0
    continuar tipo2 && txtproc("\n" + txte(p.lojanao) + "\n", tipo2) >= 0
    continuar tipo3 && txtproc("\n" + txte(p.lojanao) + "\n", tipo3) >= 0
    abre = p.lojaini - misc:hora, fecha = p.lojafim - misc:hora
    continuar abre < fecha ? abre > 0 || fecha <= 0 : abre > 0 && fecha <= 0
    listaobj e
    epara e.addfim(arg0.evento, p.evento), e, e.ini.remove
      sair e.objini.cmd_negociar(arg0, p, "pagar")
    efim
    continuar e
    lucro = (100 + p.taxavenda) / 100
# Pagar casas
    se 1
      textotxt t2
      indiceitem item
      datahora hora
      hora.agora
      epara t2.addfim(p.taxacasa), t2.linhas, t2.remove
        refvar casa = item.obj("cj " + txt2(arg0.sock.cnome) + " " + t2.ini.texto)
        continuar !casa
        continuar txt(linha += 1) != arg1 && !n.nome(casa.ident, 1)
        valor = hora.numdias - casa.diataxa
        se valor < 0
          ret arg0.msg(txtcopiamai(p.descnome, "A") + " informa que a taxa já está paga.")
        senao config:casatempotaxa
          refvar total = intdiv(valor / config:casatempotaxa) + 1
          valor = total * lucro * casa.valor * config:casataxa / 100
          se arg0.var.z_moedas_ < valor
            ret arg0.msg("Você não tem " + valor + (valor == 1 ? " moeda." : " moedas."))
          fimse
          casa.diataxa += total * config:casatempotaxa
          casa.tempotaxa = 1
          casa.objmudou = 1
          arg0.var.z_moedas_ -= valor
        senao
          casa.diataxa = hora.numdias
          casa.tempotaxa = 1
          casa.objmudou = 1
        fimse
        ret arg0.msg(txtcopiamai(p.descnome, "A") + " informa que a taxa foi paga.")
      efim
      !mudou && t.addfim("Você não deve nada.")
    fimse
  efim
  arg0.msg("Não tem como você pagar isso aqui.")


classe cmd_pdesc
herda comando_comum, comando_editor
const txtajuda = "\b\c3PDesc\b\n\
Sintaxe: PDESC\n\
Muda a descrição do seu personagem. Essa descrição aparece quando alguém\n\
olha para você com o comando OLHAR."
const posic = 5

func escr
  se arg0.pnivel < config:pdescnivel
    arg0.msg("Você precisa chegar no nível " + config:pdescnivel + " para usar esse comando")
  senao
    passo(arg0.sock, "\b")
  fimse

func passo # Alterando descrição do personagem
  casovar txtmin(txt(arg1, 0, 1))
  casose "\b"
    textopos p1
    arg0.teditor.limpar
    arg0.teditor.addfim(arg0.perso.var.z_desc)
    arg0.teditor.bytes == 1 && arg0.teditor.limpar
    arg0.leditor = arg0.teditor.ini
    arg0.leditor1 = arg0.teditor.ini
    arg0.leditor2 = arg0.teditor.fim
    arg0.leditor2.antes
    arg0.passo = este
    arg0.msg("Editando descrição do personagem, O opções, X salvar, Z sair")
    ret 1
  casose "z" # Sair do editor
    arg0.msg("Fechando editor")
    arg0.passo = ""
    ret 1
  casose "x" # Salvar o texto
    se arg0.teditor.linhas > 8
      arg0.msg("Máximo permitido 8 linhas.")
    senao !arg0.teditor.linhas
      arg0.perso.var.z_desc = ""
      arg0.msg("Descrição do personagem apagada.")
    senao
      arg0.perso.var.z_desc = arg0.teditor.ini.textolin(100)
      arg0.msg("Descrição do personagem alterada.")
    fimse
    ret 1
  casofim
  ret passoeditor(arg0, arg1, 1000, "descrição do personagem")


classe cmd_sdesc
herda comando_comum, comando_editor
const txtajuda = "\b\c3SDesc\b\n\
Sintaxe: SDESC\n\
Muda a descrição da sala em que você está, desde que esteja na sua casa.\n\
Se a descrição estiver vazia, voltará ao texto original da sala.\n\
Nota: Somente o dono da casa pode mudar as descrições das salas."
const posic = 5

func escr
  se !arg0.dentrocasa
    arg0.msg("Você não está dentro da sua casa.")
  senao
    passo(arg0.sock, "\b")
  fimse

func passo # Alterando descrição da sala
  casovar txtmin(txt(arg1, 0, 1))
  casose "\b"
    textopos p1
    arg0.teditor.limpar
    arg0.teditor.addfim(arg0.perso.dono.var.z_desc)
    arg0.teditor.bytes == 1 && arg0.teditor.limpar
    arg0.leditor = arg0.teditor.ini
    arg0.leditor1 = arg0.teditor.ini
    arg0.leditor2 = arg0.teditor.fim
    arg0.leditor2.antes
    arg0.passo = este
    arg0.msg("Editando descrição da sala, O opções, X salvar, Z sair")
    ret 1
  casose "z" # Sair do editor
    arg0.msg("Fechando editor")
    arg0.passo = ""
    ret 1
  casose "x" # Salvar o texto
    se !arg0.perso.dentrocasa
      arg0.msg("Você não está dentro da sua casa.")
    senao arg0.teditor.linhas > 8
      arg0.msg("Máximo permitido 8 linhas.")
    senao !arg0.teditor.linhas
      arg0.perso.dono.var.z_desc = ""
      arg0.perso.dono.objmudou = 1
      arg0.msg("Descrição da sala apagada.")
    senao
      arg0.perso.dono.var.z_desc = arg0.teditor.ini.textolin(100)
      arg0.perso.dono.objmudou = 1
      arg0.msg("Descrição da sala alterada.")
    fimse
    ret 1
  casofim
  ret passoeditor(arg0, arg1, 1000, "descrição da sala")


classe cmd_ptitulo
herda comando_comum
const txtajuda = "\b\c3PTitulo\b\n\
Sintaxe: PTITULO  [novo título]\n\
Muda o título do seu personagem. O título aparece no comando QUEM."
const posic = 5

func escr
  se arg0.pnivel < config:ptitulonivel
    arg0.msg("Você precisa chegar no nível " + config:ptitulonivel + " para usar esse comando")
  senao inttotal(arg1) > 30
    arg0.msg("O título do personagem não pode passar de 30 caracteres.")
  senao vartroca(txtcod(arg1), "", "t_") != txtcod(arg1)
    arg0.msg("O título contém caracteres não permitidos.")
  senao
    arg0.var.z_titulo = arg1
    arg0.msg(arg1 ? "Título do personagem alterado." : "Título do personagem apagado.")
  fimse

const t_@v = "" # menor que
const t_@x = "" # maior que
const t_@z = "" # abre colchetes
const t_@1 = "" # fecha colchetes
const t_@4 = "" # abre chaves
const t_@6 = "" # fecha chaves


classe cmd_stitulo
herda comando_comum
const txtajuda = "\b\c3STitulo\b\n\
Sintaxe: STITULO  [novo título]\n\
Muda o título da sala em que você está, desde que esteja na sua casa.\n\
Se não for especificado nenhum título, voltará ao texto original da sala.\n\
Nota: Somente o dono da casa pode mudar os títulos das salas."
const posic = 5

func escr
  se !arg0.dentrocasa
    arg0.msg("Você não está dentro da sua casa.")
  senao inttotal(arg1) > 60
    arg0.msg("O título da sala não pode passar de 60 caracteres.")
  senao
    arg0.dono.var.z_titulo = arg1
    arg0.dono.objmudou = 1
    arg0.msg(arg1 ? "Título da sala alterado." : "Título da sala apagado.")
  fimse
