classe adm_casa
# Comandos de casas
#
const adm_casa = "\b\c3Comandos de casas\b\n\
\c2LCASA\b [casa]\n\
  Lista casas que começam com o nome especificado.\n\
\c2CCASA\b <nome>\n\
  Cria casa. Nome deve ser o nome de uma área ou da casa\n\
  (nome da área seguido de um número de três dígitos de 001 a 999).\n\
  Nota: para casa casa é criado um arquivo no diretório sav2.\n\
\c2ECASA\b <casa>\n\
  Edita casa.\n\
\c2ACASA\b <um ou mais nomes de casa>\n\
  Apaga uma ou mais casas e os arquivos salvos das casas.\n\
\c2Para criar uma casa:\b\n\
  1. Usar o comando CCASA\n\
  2. Definir as salas que correspondem à casa com o comando ECASA\n\
  3. Editar as salas (comando ESALA) colocando 0 na opção \"Apagar itens\"\n\
  4. Acertar também a opção \"Objetos máximo\"\n\
  5. Editar as saídas da casa"

func cmd_lcasa # Listar casas
  prog p
  se !p.iniclasse("c_" + txtremove(arg0, "EMDCT7"))
    msg("\bNenhuma casa encontrada.")
  senao
    textotxt t
    t.addfim("\b\c6Casas:\b")
    enquanto p.lin && t.linhas < 500
      t.addfim(txt(p.texto, 2) + "  " + $[p.texto].s_titulo)
      p.depois
    efim
    msg2(t.remove(500))
  fimse
  ret 1

func cmd_ccasa # Criar casa
  prog p
  txt40 nome
  uint16 num
# Checa se digitou nome da casa
  se arg0 == ""
    msg("Tecle o nome da casa ou área após CCASA")
    ret 1
  fimse
# Checa nome completo
  nome = txtmin(txtremove(arg0, "EMDCT7"))
  num = int(txtfim(nome, 3)) + 1000
  se num > 1000 && txtfim(num, 3) == txtfim(arg0, 3)
    se !p.existe("a_" + txt(nome, 0, inttotal(nome) - 3))
      msg("Área não existe: " + txt(nome, 0, inttotal(nome) - 3))
      ret 1
    senao p.existe("c_" + nome)
      msg("Casa já existe: " + nome)
      ret 1
    fimse
# Checa nome de área
  senao !p.existe("a_" + nome)
    msg("Área não existe: " + nome)
    ret 1
  senao
    epara num = 1001, p.existe("c_" + nome + txtfim(num, 3)), num += 1
      continuar num < 2000
      msg("Atingido limite de casas na área " + nome)
      ret 1
    efim
    nome += txtfim(num, 3)
  fimse
# Cria casa
  txt200 area
  area = txt(nome, 0, inttotal(nome) - 3)
  criar("admordena", "a-" + area)
  p.criar("c_" + nome + "\na-" + area + "\nherda casa\nconst area = \"" + area + "\"")
# config:salvar
  msg("\bCasa criada: " + nome)
  admlog("criou casa " + nome)
  ret 1

func cmd_acasa # Apagar casa
  prog p
  refvar nome = txtmin(txtremove(arg0, "EMDCT7"))
  se nome == ""
    msg("Tecle um ou mais nomes da casa após ACASA")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(nome, x, 1)
    se !p.existe("c_" + txtsub(nome, x, 1))
      msg("Casa não existe: " + txtsub(nome, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = nome, p_acasa
  ret 1

func p_acasa # Confirmar que quer apagar casa
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("c_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Casa apagada: " + tpasso)
      admlog("apagou casa " + tpasso)
    senao
      msg("Casas apagadas: " + tpasso)
      admlog("apagou casas " + tpasso)
    fimse
  senao
    txt10 m1
    passo = "acasa"
    txt2(tpasso) && (m1 = "s")
    msg("Apagar casa" + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_ecasa # Editar casa
  txt100 nome
  prog p
  nome = txtmin(txtremove(arg0, "EMDCT7"))
  se nome == ""
    msg("Tecle o nome da casa após ECASA")
  senao !$c_[nome]
    msg("\bCasa não existe: " + nome)
  senao
    var.classe1 = "c_" + nome
    m_menu("menu_casa")
  fimse
  ret 1


classe menu_casa
const titulo = "Casa " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Valor da casa"
const tipo1 = "numero"
const clas1 = var.classe1
const vari1 = "valor"
#
const nome2 = "Sala fora da casa"
const info2 = "Quem sai do jogo dentro da casa entra no jogo nessa sala"
const tipo2 = "sala--"
const clas2 = var.classe1
const vari2 = "sfora"
#
const nome3 = "Sala 1"
const tipo3 = "sala--"
const clas3 = var.classe1
const vari3 = "s1"
#
const nome4 = "Sala 2"
const tipo4 = "sala--"
const clas4 = var.classe1
const vari4 = "s2"
#
const nome5 = "Sala 3"
const tipo5 = "sala--"
const clas5 = var.classe1
const vari5 = "s3"
#
const nome6 = "Sala 4"
const tipo6 = "sala--"
const clas6 = var.classe1
const vari6 = "s4"
#
const nome7 = "Sala 5"
const tipo7 = "sala--"
const clas7 = var.classe1
const vari7 = "s5"


classe casa
listaobj salas
intexec inicasa
const iniclasse = criar(arg0)
const ini = inicasa = 1
sav indiceobj nomejog # "cj " + nome codificado + " " + prefixo da área
int1 objmudou

func fim # Apaga arquivo da casa
  ret inttotal(este) != 1, nulo # Por segurança: só apaga arquivo se tiver 1 objeto
  arqsav sav1
  sav1.apagar("sav2/c-" + txt(este, 2) + ".sav")

func inicasa_exec # Carrega objetos da casa
  listaobj l1
  lista.addfim(este)
  arqsav sav1
  sav1.ler("sav2/c-" + txt(este, 2) + ".sav", l1)
  l1.ini.remove # Remove da lista, porque é o objeto de controle da casa
# Acerta variáveis
  listaitem item
  debug d
  epara item = l1.ini, item, item.depois
    d.ini, item.obj.ajustaobj
  efim
  epara item = l1.fim, item, item.antes
    d.ini
    !item.obj.dono && apagar(txt(item.obj, 0, 2) == "s_" ? $[item.obj] : este)
    item.obj.var.limpar("d_", "j_")
    item.obj.ajustapeso, item.obj.acertapos, item.obj.recalc = 1
  efim
# Indica que nenhuma sala mudou
  objmudou
  s1.objmudou = 0
  s2.objmudou = 0
  s3.objmudou = 0
  s4.objmudou = 0
  s5.objmudou = 0
# Checa se ainda pertence a um jogador
  se nomejog
    arqsav sav
    se sav.existe("sav/" + txtsub(nomejog, 1, 1) + ".sav")
      nomejog = "cj " + txtsub(nomejog, 1, 1) + " " + area
    senao
      nomejog = "", objmudou = 1
    fimse
  fimse

func mudou # Se houve alguma mudança (há necessidade de salvar)
  ret objmudou || s1.objmudou || s2.objmudou || s3.objmudou || s4.objmudou || s5.objmudou

func salvar # Salva objetos da casa
  objmudou = 0
  s1.objmudou = 0
  s2.objmudou = 0
  s3.objmudou = 0
  s4.objmudou = 0
  s5.objmudou = 0
  listaitem item
  listaobj lista
  debug dbg
  dbg.exec = 50000
  lista.addfim1(este, s1, s2, s3, s4, s5)
  item = lista.ini, item.depois
  enquanto item
    se (item.obj.objsav & 1) != 1 # Se item.obj.objsav!=1 e item.obj.objsav!=3
      item.removedepois
    senao lista.total < 2000
      lista.addfim(item.obj.dentro1, item.obj.dentro2, item.obj.dentro3), item.depois
    senao
      item.depois
    fimse
  efim
  arqsav sav1
  sav1.salvar("sav2/c-" + txt(este, 2) + ".sav", lista, 365000, "x")
