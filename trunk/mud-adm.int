classe jog_adm
# Funções necessárias para os comandos de administração

func cmd2_info # Usado por cmd_info
  txt200 lin
  lin = "Peso:   obj=" + arg0.pesoobj + "  dentro=" + arg0.pesoden
  lin += "  total=" + arg0.pesotot + "  voando=" + (arg0.pesoadd ? "N" : "S")
  lin += "\nVolume: obj=" + arg0.volobj + "  dentro=" + arg0.volden
  lin += "  total=" + arg0.voltot + "  expande=" + (arg0.volexp ? "S" : "N")
  lin += "\nQuantidade=" + arg0.objtot + "  Jogadores=" + arg0.socktot
  lin += "  Itens dentro=" + arg0.dentro1.total + "  Personagens dentro=" + arg0.dentro2.total
  ret lin

func cmd_info
  se !arg0
# msg("\b\c2Você:\b\n" + cmd2_info(perso))
    msg("\c2Sala:\b\n" + cmd2_info(perso.dono))
    ret 1
  fimse
  int1 achou
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !perso.visivel(r) || !n.nome(r.ident, r.objtot)
    msg("\b\c2" + r.nome + ": " + r + "\b\n" + cmd2_info(r))
    achou = 1
  efim
  !achou && msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_cmd
  debug d
  msg(">" + d.cmd(este, "ret " + arg0))
  ret 1

func cmd_adm
  prog p
  se p.inifunctudo(este, "adm_" + arg0)
    msg2([p.texto])
  senao
    msg("\bTópico de administração desconhecido: " + arg0)
  fimse
  ret 1

const adm_ = "\b\c3Páginas de administração\b\n\
Para ler tecle ADM seguido do nome de um tópico.\n\
Os tópicos são:\n\
  \c2AREA\b     Áreas\n\
  \c2SALA\b     Salas\n\
  \c2SAI\b      Saídas das salas\n\
  \c2ITEM\b     Itens\n\
  \c2PNJ\b      PNJs (personagens não jogadores)\n\
  \c2COD\b      Edição do código fonte\n\
  \c2OUTROS\b   Outros comandos"
# \c2INFO\b     Informações sobre o MUD\n
# \c2CONFIG\b   Configuração do MUD"
const adm_item = "\b\c3Comandos de itens\b\n\
\c2LITEM\b <nome>\n\
  Lista itens que começam com o nome especificado.\n\
\c2CITEM\b <nome>\n\
  Cria item. Nome pode conter letras e números.\n\
\c2EITEM\b <nome>\n\
  Edita item.\n\
\c2AITEM\b <nome>\n\
  Apaga item."
const adm_pnj = "\b\c3Comandos de PNJs\b\n\
\c2LPNJ\b <nome>\n\
  Lista PNJs que começam com o nome especificado.\n\
\c2CPNJ\b <nome>\n\
  Cria PNJ. Nome pode conter letras e números.\n\
\c2EPNJ\b <nome>\n\
  Edita PNJ.\n\
\c2APNJ\b <nome>\n\
  Apaga PNJ."
const adm_outros = "\c3Outros comandos\b\n\
\c2AC\b <texto>\n\
  Envia mensagem para o canal de administração; vide comando CONFIG\n\
\c2ECHO\b <texto>\n\
  Envia texto para todos os jogadores.\n\
\c2INFO\b\n\
  Informações sobre a sala.\n\
\c2INFO\b <personagem ou item>\n\
  Informações sobre personagem ou item.\n\
\c2CMD\b <comando>\n\
  Executa comando na linguagem do IntMUD e mostra o resultado."

func cmd_ac
  se !jogconfig.19
    msg("Canal AC está desabilitado.")
  senao !arg0
    msg("Tecle a mensagem após AC.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg("(ac) " + nome + ": " + arg0)
    efim
  fimse
  ret 1

func cmd_echo
  se !arg0
    msg("\bTecle a mensagem após ECHO.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.msg("\b\cB*ADM: " + arg0 + "\b")
    efim
  fimse
  ret 1

const txt_legenda = "Legenda:\n\
<nulo> Significa que a opção não foi definida.\n\
<herda> É herdado de outra classe.\n\
Exemplo, as salas herdam as propriedades das nas áreas.\n\
Outro texto entre os sinais de menor e maior indicam o modo\n\
como a opção foi definida. Exemplo, <func> significa função."

func m_linha # Mostra texto de uma linha, do tipo "const x = \"abc\""
# arg0=nome da variável, tpasso=nome da classe
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    se p.vartexto(tpasso, arg0)
      ret txtvis([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<" + txt1(p.texto) + ">"
    fimse
  casose "2" # Em uma classe herdada
    se p.vartexto(tpasso, arg0)
      ret "<herda> " + txtvis([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<herda " + txt1(p.texto) + ">"
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func m_texto # Mostra quantidade de linhas de texto de várias linhas
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    se p.vartexto(tpasso, arg0)
      ret m_texto2([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<" + txt1(p.texto) + ">"
    fimse
  casose "2" # Em uma classe herdada
    se p.vartexto(tpasso, arg0)
      ret "<herda> " + m_texto2([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<herda " + txt1(p.texto) + ">"
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func m_texto2 # Usado por m_texto
  uint16 x
  x = inttotal(arg0) - inttotal(txttroca(arg0, "\n", ""))
  se x
    ret txt(x + 1) + " linhas"
  fimse
  ret "Uma linha"

func m_numero # Mostra número, do tipo "const x = 10"
# arg0=nome da variável, tpasso=nome da classe
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    se p.varnum(tpasso, arg0)
      ret txt([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<" + txt1(p.texto) + ">"
    fimse
  casose "2" # Em uma classe herdada
    se p.varnum(tpasso, arg0)
      ret "<herda> " + txt([tpasso]:[arg0])
    senao
      p.inilinha(tpasso, arg0)
      ret "<herda " + txt1(p.texto) + ">"
    fimse
  casose # Não foi definido
    ret "<nulo> 0"
  casofim

func m_opcao # Mostra uma opção baseado numa lista de opções
# arg0=nome da variável, arg1=nomes das opções, tpasso=nome da classe
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    se p.varnum(tpasso, arg0)
      ret m_opcaomostra([tpasso]:[arg0], arg1)
    senao
      p.inilinha(tpasso, arg0)
      ret "<" + txt1(p.texto) + ">"
    fimse
  casose "2" # Em uma classe herdada
    se p.varnum(tpasso, arg0)
      ret "<herda> " + m_opcaomostra([tpasso]:[arg0], arg1)
    senao
      p.inilinha(tpasso, arg0)
      ret "<herda " + txt1(p.texto) + ">"
    fimse
  casose # Não foi definido
    ret "<nulo> " + m_opcaomostra(0, arg1)
  casofim

func m_opcaomostra # Retorna o texto correspondente a uma opção
# arg0 = número da opção atual
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo a opção atual
  uint16 valor
  textotxt t
  valor = arg0
  t.addfim(arg1)
  t.remove(valor)
  se t.linhas
    ret txt(valor) + " " + t.remove(1)
  senao
    ret txt(valor) + " <inválido>"

func m_simnao # Mostra opção que pode ser 0 (não) ou 1 (sim)
# arg0=nome da variável, tpasso=nome da classe
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    se !p.varnum(tpasso, arg0)
      p.inilinha(tpasso, arg0)
      ret "<" + txt1(p.texto) + ">"
    senao [tpasso]:[arg0]
      ret txt([tpasso]:[arg0]) + " Sim"
    senao
      ret txt([tpasso]:[arg0]) + " Não"
    fimse
  casose "2" # Em uma classe herdada
    se !p.varnum(tpasso, arg0)
      p.inilinha(tpasso, arg0)
      ret "<herda " + txt1(p.texto) + ">"
    senao [tpasso]:[arg0]
      ret "<herda> " + txt([tpasso]:[arg0]) + " Sim"
    senao
      ret "<herda> " + txt([tpasso]:[arg0]) + " Não"
    fimse
  casose # Não foi definido
    ret "<nulo> 0 Não"
  casofim

func m_sala # Informa valor de variável do tipo "const x = $s_abc"
# arg0=nome da variável, tpasso=nome da classe
  prog p
  casovar p.existe(tpasso, arg0)
  casose "1" # Na própria classe
    p.inilinha(tpasso, arg0)
    se txt1(p.texto) != "const"
      ret "<" + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg0) + 6) != arg0 + " = $s_"
      ret "<const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<const>"
    senao
      ret txt(p.texto, inttotal(arg0) + 12)
    fimse
  casose "2" # Em uma classe herdada
    p.inilinha(tpasso, arg0)
    se txt1(p.texto) != "const"
      ret "<herda " + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg0) + 6) != arg0 + " = $s_"
      ret "<herda const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<herda const>"
    senao
      ret "<herda> " + txt(p.texto, inttotal(arg0) + 12)
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_linha # Altera um texto de uma linha
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
  prog p
  se arg0 == ""
    passo = "linha"
    msg("Entre com um texto, N nenhum, Z cancela")
    ret 1
  senao arg0 == "n"
    p.apagar(txt1(tpasso), txtsub(tpasso, 1, 1))
    p.salvar(config:progsalvar)
    msg("Apagado: " + txtsub(tpasso, 3))
  senao arg0 != "z"
    txt200 t
    t = "const " + txtsub(tpasso, 1, 1) + "=\"" + txtvis(arg0) + "\""
    p.criar(txt1(tpasso), t)
    p.salvar(config:progsalvar)
    msg(txtsub(tpasso, 3) + " mudou para: " + arg0)
  fimse
  passo = txtsub(tpasso, 2, 1)
  p_[passo]("")
  ret 1

func p_texto # Altera um texto de várias linhas
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    textopos p1
    teditor.limpar
    teditor.addfim([txt1(tpasso)]:[txtsub(tpasso, 1, 1)])
    epara p1 = teditor.ini, p1.lin, p1.depois
      p1.mudar(txtvis(p1.texto))
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "texto"
    msg("Editando " + txtsub(tpasso, 3) + ", O opções, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = txtsub(tpasso, 2, 1)
    p_[passo]("")
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    epara p1 = teditor.ini, p1.lin, p1.depois
      t1.addfim(txtinvis(p1.texto))
    efim
    txt200 t
    t = "const " + txtsub(tpasso, 1, 1) + "=\""
    p.criar(txt1(tpasso), t + txtvis(t1.remove(1000)) + "\"")
    p.salvar(config:progsalvar)
    msg("Salvou " + txtsub(tpasso, 3))
    ret 1
  casofim
  ret p_editor(arg0, 2000, txtsub(tpasso, 3))

func p_numero # Altera um texto de uma linha
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
# A primeira linha da variável teditor, se não for nula, contém
# os valores mínimo e máximo da variável
  prog p
  se arg0 == ""
    passo = "numero"
    msg("Entre com um número, N nenhum, Z cancela")
    ret 1
  senao arg0 == "n"
    p.apagar(txt1(tpasso), txtsub(tpasso, 1, 1))
    p.salvar(config:progsalvar)
    msg("Apagado: " + txtsub(tpasso, 3))
  senao arg0 != "z"
    txt100 lin
    real valor
    valor = arg0
    lin = teditor.ini.texto
    se arg0 != valor # Checa se é número
      msg("Entre com um número.")
      ret 1
    senao lin # Checa limites mínimo e máximo
      se valor < txt1(lin) || valor > txt2(lin)
        msg("Entre com um número de " + txt1(lin) + " a " + txt2(lin) + ".")
        ret 1
      fimse
    fimse
    lin = "const " + txtsub(tpasso, 1, 1) + "=" + valor
    p.criar(txt1(tpasso), lin)
    p.salvar(config:progsalvar)
    msg(txtsub(tpasso, 3) + " mudou para: " + arg0)
  fimse
  passo = txtsub(tpasso, 2, 1)
  p_[passo]("")
  ret 1

func p_opcao # Altera uma opção de uma lista de opções
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
# teditor contém as opções
  prog p
  se arg0 == ""
    passo = "opcao"
    msg("Entre com uma opção, O mostra as opções, Z cancela")
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:")
    textopos pos
    epara pos = teditor.ini, pos.lin, pos.depois
      txtmais.addfim(txt(pos.linha) + ". " + pos.texto)
    efim
    txtmais.addfim("N. Nenhuma, Z. Cancela")
    txtmostra
    ret 1
  senao arg0 == "n"
    p.apagar(txt1(tpasso), txtsub(tpasso, 1, 1))
    p.salvar(config:progsalvar)
    msg("Apagado: " + txtsub(tpasso, 3))
  senao arg0 != "z"
    textopos pos
    txt100 lin
    pos = teditor.ini
    pos.linha = int(arg0)
    se arg0 != pos.linha || pos.texto == ""
      msg("Entre com uma opção de 0 a " + (teditor.linhas - 1))
      ret 1
    fimse
    lin = "const " + txtsub(tpasso, 1, 1) + "=" + pos.linha
    p.criar(txt1(tpasso), lin)
    p.salvar(config:progsalvar)
    msg(txtsub(tpasso, 3) + " mudou para: " + arg0 + " " + pos.texto)
  fimse
  passo = txtsub(tpasso, 2, 1)
  p_[passo]("")
  ret 1

func p_simnao # Altera uma opção que pode ser "SIM" ou "NÃO"
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
  prog p
  se arg0 == "0" || arg0 == "1"
    txt100 lin
    lin = "const " + txtsub(tpasso, 1, 1) + "=" + arg0
    p.criar(txt1(tpasso), lin)
    p.salvar(config:progsalvar)
    lin = "0 não"
    arg0 == 1 && (lin = "1 sim")
    msg(txtsub(tpasso, 3) + " mudou para: " + lin)
  senao arg0 == "n"
    p.apagar(txt1(tpasso), txtsub(tpasso, 1, 1))
    p.salvar(config:progsalvar)
    msg("Apagado: " + txtsub(tpasso, 3))
  senao arg0 != "z"
    passo = "simnao"
    msg("Escolha: 0 não, 1 sim, N nenhum, Z cancela")
    ret 1
  fimse
  passo = txtsub(tpasso, 2, 1)
  p_[passo]("")
  ret 1

func p_func
# Variável tpasso contém: "classe variável passo nome"
# classe e variável são os nomes da classe e da variável
# passo é o valor da variável passo para a opção sair
# nome é o nome da opção
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    teditor.limpar
    prog p
    txt100 lin
    txt20 lin2
    textotxt t1
    passo = "func"
    lin = txt1(tpasso) + ":" + txtsub(tpasso, 1, 1) + ", O opções, Z sair"
    lin2 = txtsub(tpasso, 3)
    lin2 && (lin2 += "; ")
    se !p.inilinha(txt1(tpasso), txtsub(tpasso, 1, 1))
      msg(lin2 + "Criando " + lin)
      teditor.addfim("const " + txtsub(tpasso, 1, 1) + " = nulo")
    senao txt1(p.texto) == "const" && inttotal(p.texto) > 75
      msg(lin2 + "Editando " + lin)
      teditor.addfim(txttroca(p.texto, "\\n", "\\n\\\n"))
    senao
      msg(lin2 + "Editando " + lin)
      enquanto p.lin
        t1.limpar
        t1.addfim(p.texto)
        t1.dividelin(35, 75)
        enquanto t1.linhas > 1
          teditor.addfim(t1.remove + "\\")
        efim
        teditor.addfim(t1.remove)
        p.depois
      efim
    fimse
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = txtsub(tpasso, 2, 1)
    p_[passo]("")
    ret 1
  casose "x" # Salvar o texto
    p_funcsalvar
    ret 1
  casofim
  ret p_editor(arg0, 16384, txtsub(tpasso, 3))

func p_funcsalvar # Opçao salvar de p_func
  textotxt t1
  textopos p1
  txt512 lin
# Junta linhas e coloca em t1
  t1.ini.add(teditor.ini, teditor.linhas)
  p1 = t1.ini
  enquanto p1.txtproc("\\\n") >= 0
    p1.mudar("", inttotal(p1.texto) - 1, 1) # Tira a "\" no final
    p1.depois, p1.juntar # Junta as duas linhas
  efim
# Obtém o nome da constante / função
  lin = t1.ini.texto
  enquanto txt1(lin) == "sav" || txt1(lin) == "comum"
    lin = txt2(lin)
  efim
  se t1.linhas > 1 && txt1(lin) != "func" && txt1(lin) != "varfunc"
    msg("Erro: somente FUNC e VARFUNC podem ter várias linhas")
    ret 1
  fimse
  lin = txt1(txttroca(txt2(lin), "#", " "))
# Checa se o nome mudou
  se lin != txtsub(tpasso, 1, 1)
    lin += " para " + txtsub(tpasso, 1, 1)
    msg("Erro: mude o nome da variável de " + lin)
    ret
  fimse
# Checa existência de outra função ou constante dentro
  p1 = t1.ini.texto
  p1.depois
  enquanto p1.lin
    casovar txtmin(txt1(p1.texto))
    casose "func"
    casose "varfunc"
      msg("Erro: definido uma função dentro de outra")
      ret
    casose "const"
      msg("Erro: definido uma constante dentro de uma função")
      ret
    casofim
    p1.depois
  efim
# Tenta salvar
  prog p
  t1.addfim(p.criar(txt1(tpasso), t1.remove(10000)))
  se t1.ini.texto == ""
    p.salvar(config:progsalvar)
    msg("Salvo com sucesso")
    ret
  fimse
# Informa erros, corrigindo os números das linhas
  msg("Erro ao salvar:")
  p1 = t1.ini
  p1.depois(5), p1.remove(1000)
  uint16 x
  enquanto t1.linhas
    x = lin = t1.remove
    se txt(x) == txt(lin, 0, inttotal(txt(x)))
      p1 = teditor.ini
      enquanto p1.txtproc("\\\n") >= 0 && p1.linha < x
        p1.depois, x += 1
      efim
      lin = txt(x) + txt(lin, inttotal(txt(x)))
    fimse
    msg(lin)
  efim

func p_editor
# Processamento de qualquer editor de texto
# arg0 = texto digitado
# arg1 = quantidade máxima de bytes
# arg2 = nome da opção
# teditor contém o texto, leditor é a linha atual
# Retorna sempre 1
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
  casose "" # Entrou na opção ou apenas pressionou ENTER
    msg("Editando " + arg2 + ", O opções, Z sair")
    ret 1
  casose "." # Insere linha removendo espaços
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txtremove(txt(arg0, 1), "ED"))
    leditor.depois
    msg("Texto inserido")
    ret 1
  casose "," # Insere linha
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txt(arg0, 1))
    leditor.depois
    msg("Texto inserido")
    ret 1
  casose "a" # Apaga a linha atual
    se !leditor.lin
      msg("Está no fim do texto")
      ret 1
    fimse
    leditor.remove
    msg(leditor.lin ? "Linha apagada" : "Linha apagada; fim do texto")
    ret 1
  casose "i" # Informações sobre a linha atual
    txt100 t
    t = "Linha " + (leditor.linha + 1) + "/" + teditor.linhas
    t += ", " + inttotal(leditor.texto)
    t += " caracteres, " + teditor.bytes + "/" + arg1 + " bytes"
    msg(t)
    ret 1
  casose "l" # Mostra a linha atual
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  casose "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  casose "o" # Mostra opções do editor
    txtmais.limpar
    txtmais.addfim(m_editor)
    txtmostra
    ret 1
  casose "s" # Sobe uma ou mais linhas
    leditor.linha == 0 && msg("Início do texto")
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.antes, x -= 1
      msg(leditor.texto)
      ret !editor.linha, 1
    efim
    ret 1
  casose "d"
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.depois, x -= 1
      se !leditor.lin
        msg("Fim do texto")
        ret 1
      fimse
      msg(leditor.texto)
    efim
    ret 1
  casose "t" # Informações sobre a área de transferência
    se transf.linhas == 0
      msg("Área de transferência vazia")
    senao transf.linhas == 1
      msg("Área de transferência: 1 linha " + transf.bytes + " bytes")
    senao
      msg("Área de transferência: " + transf.linhas + " linhas " + transf.bytes + " bytes")
    fimse
    msg("Bloco linhas " + (leditor1.linha + 1) + " a " + (leditor2.linha + 1))
    ret 1
  casose "p" # Procurar
    txt512 t # Texto após o comando P
    int16 col # Coluna aonde encontrou
    textopos pos # Posição aonde encontrou
    t = txtremove(txt(arg0, 1), "ED")
    se t # Procura texto
      peditor = t, pos = leditor
      col = pos.txtproc(t, 0)
    senao peditor # Procura novamente
      pos = leditor, pos.depois
      col = pos.txtproc(peditor, 0)
    senao # Nada para procurar
      col = -1
    fimse
    se col >= 0
      leditor = pos
      msg("Encontrado linha " + (leditor.linha + 1) + " coluna " + (col + 1))
      msg(leditor.texto)
    senao
      msg("Nada encontrado")
    fimse
    ret 1
  casose "e" # Embelezar o texto
    teditor.addini(txttroca(teditor.remove(10000), "\n", " "))
    teditor.dividelin(57, 77)
    msg("Texto embelezado; voltando à linha 1")
    ret 1
  casose "c" # Mostrar texto com as definições de cores
    textopos pos
    txtmais.limpar
    txtmais.addfim("\bTexto com cores:")
    epara pos = teditor.ini, pos.lin, pos.depois
      txtmais.addfim(txtinvis(pos.texto))
    efim
    txtmostra
    ret 1
  casofim
# Comandos de dois caracteres
  casovar txtmin(arg0)
  casose "bi"
    leditor1 = leditor
    msg("Início de bloco linha " + (leditor1.linha + 1))
    ret 1
  casose "bf"
    leditor2 = leditor
    msg("Fim de bloco linha " + (leditor2.linha + 1))
    ret 1
  casose "ba"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser apagado")
    senao
      leditor1.remove(total)
      se total == 1
        msg("Uma linha apagada")
      senao
        msg(txt(total) + " linhas apagadas")
      fimse
    fimse
    ret 1
  casose "bc"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    se transf.linhas == 1
      msg("1 linha guardada")
    senao
      msg(txt(transf.linhas) + " linhas guardadas")
    fimse
    ret 1
  casose "bx"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    leditor1.remove(total)
    se transf.linhas == 1
      msg("1 linha movida")
    senao
      msg(txt(transf.linhas) + " linhas movidas")
    fimse
    ret 1
  casose "bv"
    se teditor.bytes + transf.bytes > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor1.add(transf.ini, transf.linhas)
    se transf.linhas == 1
      msg("1 linha colada")
    senao
      msg(txt(transf.linhas) + " linhas coladas")
    fimse
    ret 1
  casose "be" # Embelezar o bloco
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser embelezado")
    senao
      textotxt t
      t.addfim(txttroca(leditor1.textolin(total), "\n", " "))
      t.dividelin(57, 77)
      leditor1.remove(total)
      leditor1.add(t.ini, t.linhas)
      leditor2.linha = leditor1.linha + t.linhas - 1
      se total == 1
        msg("Uma linha embelezada")
      senao
        msg(txt(total) + " linhas embelezadas")
      fimse
    fimse
    ret 1
  casose "bl" # Limpar o texto
    teditor.limpar
    msg("Texto apagado")
    ret 1
  casofim
# Checa número de linha
  uint16 lin
  lin = arg0
  se arg0 == lin
    leditor.linha = lin - 1
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  fimse
# Opção desconhecida
  msg("Opção desconhecida: " + txt(arg0, 0, 1))
  msg("Editando " + arg2 + ", O opções, Z sair")
  ret 1

const m_editor = "\b\c3Comandos do editor\b\n\
\c2I\b  Informações sobre a linha atual, quantidade de linhas, etc.\n\
\c2T\b  Informações sobre a área de transferência e o bloco marcado\n\
\c2L\b  Mostra a linha atual\n\
\c2S\b  seguido ou não de um número: Sobe uma ou mais linhas no texto\n\
\c2D\b  seguido ou não de um número: Desce uma ou mais linhas no texto\n\
\c2Um número qualquer:\b  Vai para a linha correspondente\n\
As linhas começam em 1; um número bem grande, vai para o fim do texto\n\
\c2Um ponto seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior\n\
A linha atual avança automaticamente\n\
\c2Uma vírgula seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior, sem remover espaços\n\
Exemplo: vírgula seguido de dois espaços e a letra A insere uma linha\n\
que contém dois espaços e a letra A\n\
\c2A\b  Apaga a linha atual\n\
\c2P\b  seguido de um texto: Procura um texto a partir da linha atual\n\
\c2P\b  Procura a próxima linha que contém o texto\n\
\c2E\b  Embeleza o texto, formatando em até 77 caracteres por linha\n\
\c2C\b  Mostra o texto com as definições de cores\n\
\c2M\b  seguido de um texto: Executa um comando do MUD sem sair da edição\n\
\c2X\b  Salva o texto\n\
\c2Z\b  Encerra a edição\n\
\c2BI\b  Marca início do bloco na linha atual\n\
\c2BF\b  Marca fim de bloco na linha atual\n\
\c2BA\b  Apaga bloco marcado\n\
\c2BC\b  Copia bloco para a área de transferência\n\
\c2BX\b  Move bloco para a área de transferência\n\
\c2BV\b  Insere texto da área de transferência entre a linha atual e a anterior\n\
\c2BE\b  Embeleza o bloco marcado\n\
\c2BL\b  Apaga todo o texto sendo editado"

func infosala # Retorna 1 se pode ser editado como variável tipo "const x = $s_abc"
# arg0=nome da variável, tpasso=nome da classe
  se p.existe(tpasso, arg0) != 1 || !p.inilinha(tpasso, arg0)
    ret 1
  senao txt1(p.texto) != "const"
    ret 0
  senao txt(p.texto, 6, inttotal(arg0) + 6) != arg0 + " = $s_"
    ret 0
  senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
    ret 0
  senao
    ret 1
