classe adm_comum
# Funções necessárias para os comandos de administração
#
const txt_legenda = "Legenda:\n\
<nulo> Significa que a opção não foi definida.\n\
<herda> É herdado de outra classe.\n\
Exemplo, as salas herdam as propriedades das nas áreas.\n\
Outro texto entre os sinais de menor e maior indicam o modo\n\
como a opção foi definida. Exemplo, <func> significa função."

func m_menu
  tpasso = arg0, p_menu("")
  ret

const t_menu = "<menu>"
const admcod = txttroca(txttroca(arg0, "\"", "\\\""), "\n", "\\n")
const admdec = txttroca(txtvis(arg0), "\\\"", "\"")

func p_menu
  casovar txtmin(arg0)
  casose ""
  casose "\b"
    var.opcnome = "", var.opcclasse = "", var.opcvar = ""
    var.opcpasso = "", var.opcextra = "", var.opcexec = ""
    passo = "menu"
    msg([tpasso]:titulo + ", tecle O para saber as opções")
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim("\b" + [tpasso]:titulo)
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      refvar t1 = [tpasso]:titu[txt(p.texto, 4)]
      t1 && txtmais.addfim(t1)
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      refvar t1 = [tpasso]:titu[txt(p.texto, 4)]
      t1 && txtmais.addfim(t1)
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("V mostra as variáveis alteradas em cada opção (classe:variável)")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "v"
    txtmais.limpar
    txt100 lin
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    txtmostra
    ret 1
  casose "z"
    tpasso = [tpasso]:menufim
    ret tpasso, p_menu("\b")
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casofim
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao [tpasso]:nome[arg0] # Editar opção do menu
    var.opcnome = txtremove([tpasso]:nome[arg0], "ED")
    var.opcclasse = [tpasso]:clas[arg0]
    var.opcvar = [tpasso]:vari[arg0]
    var.opcextra = [tpasso]:extr[arg0]
    var.opcpasso = passo
    var.opcvalido_ = txtproc([tpasso]:tipo[arg0], "--") >= 0
    var.opcexec = [tpasso]:exec[arg0]
    refvar tipo = txttroca([tpasso]:tipo[arg0], "-", "")
    se tipo == "menu"
      tpasso = var.opcclasse
      p_menu("\b")
    senao !var.opcvar
      msg2(var.opcextra)
    senao
      msg(m_menu2(tpasso, arg0))
      [tpasso]:info[arg0] && msg([tpasso]:info[arg0])
      p_[tipo]("\b")
    fimse
  senao txt(arg0, 0, 1) == "f" && [tpasso]:nome[txt(arg0, 1)] # Editar função
    se txtproc([tpasso]:tipo[txt(arg0, 1)], "-") >= 0
      msg("Essa opção não pode ser editada como função; escolha outra")
      ret 1
    fimse
    txt20 opc
    opc = txt(arg0, 1)
    var.opcnome = txtremove([tpasso]:nome[opc], "ED")
    var.opcclasse = [tpasso]:clas[opc]
    var.opcvar = [tpasso]:vari[opc]
    var.opcextra = [tpasso]:extr[opc]
    var.opcpasso = passo
    var.opcexec = [tpasso]:exec[arg0]
    se !var.opcvar
      msg2(var.opcextra)
      ret 1
    fimse
    p_func("\b")
  senao # Nenhuma das anteriores
    msg("Opção inválida: " + arg0)
  fimse
  ret 1

func m_menu2 # Usado em m_menu para obter o texto de uma opção do menu
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  txt80 func1 # Função que mostra o conteúdo da variável
  lin = "\b\c2" + arg1 + (txt(arg1, 1) ? "\b." : "\b. ") + [arg0]:nome[arg1]
  refvar maximo = int([arg0]:colunas)
  inttotal(lin) < maximo && (lin = txt(lin + txtesp(maximo), 0, maximo))
  func1 = "t_" + txttroca([arg0]:tipo[arg1], "-", "") # Nome da função
  ret lin + ": " + [func1]([arg0]:clas[arg1], [arg0]:vari[arg1], [arg0]:extr[arg1])

func m_menu3 # Usado em m_menu para obter o nome da variável
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  lin = arg1 + (txt(arg1, 1) ? "." : ". ") + [arg0]:nome[arg1]
  inttotal(lin) < 20 && (lin = txt(lin + txtesp(18), 0, 20))
  ret lin + ": " + [arg0]:clas[arg1] + ":" + [arg0]:vari[arg1]

func t_linha # Retorna texto de uma linha, do tipo "const x = \"abc\""
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + admdec([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + admdec([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_linha # Alterando um texto de uma linha
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "linha"
    msg("Entre com um texto, N nenhum, V Texto vazio, Z cancela")
    ret 1
  senao arg0 == "v"
    p.criar(var.opcclasse, "const " + var.opcvar + "=\"\"")
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para um texto vazio")
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 == "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    senao
      p.criar(var.opcclasse, "const " + var.opcvar + "=\"\"")
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      msg(var.opcnome + " mudou para um texto vazio")
      admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    fimse
  senao arg0 != "z"
    p.criar(var.opcclasse, "const " + var.opcvar + "=\"" + admcod(arg0) + "\"")
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para: " + arg0)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_txtlinha # Retorna uma linha de uma variável do tipo "const x = \"abc\""
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + admdec(txtsublin([arg0]:[arg1], arg2, 1)) + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + admdec(txtsublin([arg0]:[arg1], arg2, 1)) + \
"\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_txtlinha # Alterando um texto de uma linha
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "txtlinha"
    msg("Entre com um texto, N nenhum, Z cancela")
    ret 1
  senao arg0 != "z"
    refvar linha = int(var.opcextra)
    textotxt t1
    textopos pos
    t1.addfim([var.opcclasse]:[var.opcvar])
    t1.linhas < linha && t1.addfim(txtrepete("\n", linha - t1.linhas))
    pos = t1.ini, pos.linha = linha
    pos.mudar(arg0 == "n" ? "" : arg0)
    pos = t1.fim, pos.antes
    enquanto t1.bytes && pos.texto == ""
      pos.remove, pos.antes
    efim
    se t1.bytes == 0 && !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    senao
      prog p
      refvar t = "const " + var.opcvar + "=\""
      p.criar(var.opcclasse, t + txtvis(t1.remove(1000)) + "\"")
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      se arg0 == "n"
        msg(var.opcnome + " mudou para um texto vazio")
      senao
        msg(var.opcnome + " mudou para: " + arg0)
      fimse
      admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    fimse
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_texto # Retorna quantidade de linhas de texto de várias linhas
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> " + t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_texto2([arg0]:[arg1])
  casofim

func t_texto2 # Usado por t_texto
  txt10 x
  x = intsublin(arg0)
  ret x != "1" ? "\c6" + x + " linhas\b" : "\c6Uma linha\b"

func p_texto # Alterando um texto de várias linhas
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    textopos p1
    teditor.limpar
    teditor.addfim([var.opcclasse]:[var.opcvar])
    epara p1 = teditor.ini, p1.lin, p1.depois
      p1.mudar(admdec(p1.texto))
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "texto"
    msg("Editando " + var.opcnome + ", O opções, X salvar, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
    ret 1
  casose "x" # Salvar o texto
    prog p
    se !var.opcvalido && !teditor.linhas
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
      ret 1
    fimse
    textopos p1
    textotxt t1
    epara p1 = teditor.ini, p1.lin, p1.depois
      t1.addfim(txtinvis(p1.texto))
    efim
    txt200 t
    t = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, t + admcod(t1.remove(1000)) + "\"")
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Salvou " + var.opcnome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret 1
  casofim
  ret p_editor(arg0, 2000, var.opcvar)

func t_numero # Retorna número, do tipo "const x = 10"
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), "\c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> \c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> \c60\b"
  casofim

func p_numero # Alterando um número
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "numero"
    se var.opcvalido
      msg("Entre com um número, Z cancela")
    senao
      msg("Entre com um número, N nenhum, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 valor
    valor = arg0
    se arg0 != valor # Checa se é número
      ret p_numero("\b")
    senao var.opcextra # Checa limites mínimo e máximo
      se valor < int(txt1(var.opcextra)) || valor > int(txt2(var.opcextra))
        msg("Entre com um número de " + txt1(var.opcextra) + " a " + txt2(var.opcextra) + \
".")
        ret 1
      fimse
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + valor)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para: " + valor)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_numreal = t_numero(arg0, arg1) # Retorna número, do tipo "const x = 10"

func p_numreal # Alterando um número
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "numreal"
    se var.opcvalido
      msg("Entre com um número, Z cancela")
    senao
      msg("Entre com um número, N nenhum, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    real2 valor
    valor = arg0
    se arg0 != valor # Checa se é número
      ret p_numero("\b")
    senao var.opcextra # Checa limites mínimo e máximo
      se valor < int(txt1(var.opcextra)) || valor > int(txt2(var.opcextra))
        msg("Entre com um número de " + txt1(var.opcextra) + " a " + txt2(var.opcextra) + \
".")
        ret 1
      fimse
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + valor)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para: " + valor)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_opcao # Retorna uma opção baseado numa lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_opcaomostra(0, arg2)
  casofim

func t_opcaomostra # Retorna o texto correspondente a uma opção
# arg0 = número da opção atual
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo a opção atual
  uint16 valor
  textotxt t
  valor = arg0
  t.addfim(arg1)
  t.remove(valor)
  ret "\c6" + valor + (t.linhas ? " " + t.remove(1) + "\b" : " <inválido>\b")

func p_opcao # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "opcao"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    textotxt t
    int16 x
    x = arg0, t.addfim(var.opcextra)
    se arg0 != x || x < 0 || x >= t.linhas
      msg("Opção inválida")
      ret p_opcao("\b")
    fimse
    t.remove(x)
    txt100 lin
    lin = " # " + var.opcnome + ": " + x + " " + t.ini.texto
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + lin)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para: " + x + " " + t.remove)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_txtopcao = t_texto(arg0, arg1)

func p_txtopcao
  uint16 linha
  linha = arg0, passo = "txtopcao"
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
  senao arg0 == "o"
    textotxt t
    t.addfim([var.opcclasse]:[var.opcvar])
    txtmais.limpar
    textopos pos
    epara pos = t.ini, pos, pos.depois
      txtmais.addfim("\c2" + txtmais.linhas + ".\b" + (pos.linha <= 9 ? " ") + pos.texto)
    efim
    txtmais.addini("\bOpções:")
    pos.antes
    se pos.texto != "" && t.linhas < int(txt2(var.opcextra))
      txtmais.addfim("\c2" + txt(txtmais.linhas - 1) + ".\b")
    fimse
    linha = txtsub(var.opcextra, 2)
    pos = txtmais.ini, pos.depois, pos.remove(linha)
    txt100 lin
    lin = "Para alterar, tecle um número de " + linha
    lin += " a " + (txt2(var.opcextra) - 1)
    txtmais.addfim(lin + ", seguido ou não de um texto")
    txtmais.addfim("Z Sair, M seguido de um texto executa comando do MUD")
    txtmostra
  senao arg0 == "z"
    passo = var.opcpasso, p_[passo]("\b")
  senao arg0 == "n" && !var.opcvalido
    prog p
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao txt(linha) != txt1(arg0)
    msg("Opção inexistente: " + txt1(arg0))
  senao linha < int(txtsub(var.opcextra, 2)) || linha >= int(txt2(var.opcextra))
    txt100 lin
    lin = "O número da linha vai de " + int(txtsub(var.opcextra, 2))
    msg(lin + " até " + (txt2(var.opcextra) - 1))
  senao
    textotxt t1
    textopos pos
    t1.addfim([var.opcclasse]:[var.opcvar])
    t1.linhas < linha && t1.addfim(txtrepete("\n", linha - t1.linhas))
    pos = t1.ini, pos.linha = linha, pos.mudar(txt2(arg0))
    pos = t1.fim, pos.antes
    uint16 linhasmin
    linhasmin = txt1(var.opcextra)
    enquanto pos.linha > linhasmin && pos.texto == ""
      pos.remove, pos.antes
    efim
    pos.linha == linhasmin && pos.texto == "" && pos.remove
    prog p
    refvar t = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, t + txtvis(t1.remove(1000)) + "\"")
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Linha " + linha + " foi alterada")
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  ret 1

func t_vetor # Retorna as opções selecionadas de lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_vetormostra(0, arg2)
  casofim

func t_vetormostra # Retorna o texto correspondente a uma opção
# arg0 = valor numérico
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo as opções escolhidas
  int32 valor
  textotxt t
  txt512 lin
  int8 x
  valor = arg0
  epara t.addfim(arg1), t.linhas, valor = valor >> 1
    valor & 1 ? (lin += ", " + x + "-" + t.remove) : t.remove, x += 1
  efim
  ret lin ? "\c6" + txt(lin, 2) + "\b" : ""

func p_vetor # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "vetor"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 x
    x = arg0
    se arg0 != x || x < 0 || x >= intsublin(var.opcextra)
      msg("Opção inválida")
      ret p_vetor("\b")
    fimse
    x = intbit(x) ^ [var.opcclasse]:[var.opcvar]
    txt100 lin
    lin = txtcor(t_vetormostra(x, var.opcextra))
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + " # " + var.opcnome + ": " + \
lin)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Escolheu: " + lin)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetor("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_tipos = t_vetorfunc(arg0, arg1)

func p_tipos
  prog p
  passo = "tipos"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("tipo_"), p.lin, p.depois
      txtmais.addfim(txt(p.texto, 5))
    efim
  fimse
  ret p_vetorfunc(arg0, p.existe("tipo_" + txts(arg0)))

const t_tipodep = t_vetorfunc(arg0, arg1)

func p_tipodep
  prog p
  passo = "tipodep"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("cmd_"), p.lin, p.depois
      $[p.texto].cmdmenu && txtmais.addfim("h_" + txt(p.texto, 4))
    efim
    epara p.iniclasse("magia_"), p.lin, p.depois
      txtmais.addfim("m_" + txt(p.texto, 6))
    efim
    epara p.iniclasse("idioma_"), p.lin, p.depois
      txtmais.addfim("i_" + txt(p.texto, 7))
    efim
  fimse
  casovar txtmin(txt(arg0, 0, 2))
  casose "h_"
    ret p_vetorfunc(arg0, $cmd_[txt(arg0, 2)].cmdmenu != nulo)
  casose "m_"
    ret p_vetorfunc(arg0, $magia_[txt(arg0, 2)] != nulo)
  casose "i_"
    ret p_vetorfunc(arg0, $idioma_[txt(arg0, 2)] != nulo)
  casofim
  ret p_vetorfunc(arg0, 0)

func t_vetorfunc # Usado intermanente: retorna uma lista de textos
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_vetorfunc # Usado intermanente: alterando um vetor de textos
# arg0 = texto digitado pelo usuário
# arg1 = verdadeiro se o texto for a texto válido para o vetor
# Se arg0=="o", a variável txtmais deve ter a lista de opções válidas, uma por linha
  prog p
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    se txtmais.bytes <= 1
      txtmais.limpar, txtmais.add("\bNão há nenhuma opção definida")
    senao
      txtmais.addfim(txttroca(txtmais.remove(5000), "\n", ", "))
      txtmais.juntar, txtmais.dividelin(40, 75)
      txtmais.addini("\bOpções:")
    fimse
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 lin
    lin = txts(arg0)
    textotxt t
    t.addfim([var.opcclasse]:[var.opcvar])
    t.bytes <= 1 && t.limpar
    textopos pos
    pos = t.ini
    se pos.txtproc("\n" + lin + "\n") >= 0
      pos.remove
    senao !arg1
      msg("Opção inválida: " + lin)
      ret p_vetorfunc("\b")
    senao
      t.addfim(lin), t.ordena
    fimse
    lin = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, lin + txtvis(t.ini.textolin(1000)) + "\"")
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Escolheu: " + txttroca(t.ini.textolin(1000), "\n", " "))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetorfunc("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_simnao # Retorna opção que pode ser 0 (não) ou 1 (sim)
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<" + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "\c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "\c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose "2" # Em uma classe herdada
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<herda " + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "<herda> \c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "<herda> \c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose # Não foi definido
    ret "<nulo> \c60 Não\b"
  casofim

func p_simnao # Alterando uma opção que pode ser "SIM" ou "NÃO"
  prog p
  casovar arg0
  casose "0"
  casose "1"
    txt100 lin
    lin = " # " + var.opcnome + ": " + (arg0 == 1 ? "Sim" : "Não")
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + arg0 + lin)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para: " + (arg0 == 1 ? "1 sim" : "0 não"))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  casose "z"
    sair
  casose "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
      sair
    fimse
  casose
    passo = "simnao"
    se var.opcvalido
      msg("Escolha: 0 não, 1 sim, Z cancela")
    senao
      msg("Escolha: 0 não, 1 sim, N nenhum, Z cancela")
    fimse
    ret 1
  casofim
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_sala # Retorna sala (constante do tipo "const x = $s_abc")
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções (não usado)
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<" + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<const>"
    senao
      ret txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose "2" # Em uma classe herdada
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<herda " + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<herda const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<herda const>"
    senao
      ret "<herda> " + txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_sala # Alterando a sala
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "sala"
    se var.opcvalido
      msg("Entre com o nome da sala, Z cancela")
    senao
      msg("Entre com o nome da sala, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 nome
    nome = txtmin(txts(arg0))
    se !p.existe("s_" + nome)
      msg("\bSala \"" + nome + "\" não existe, escolha outra.")
      ret 1
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=$s_" + nome)
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg(var.opcnome + " mudou para " + nome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func p_func # Editar função
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
  senao
    p_codcomum(arg0, 0)
    passo == "codcomum" && (passo = "func")
  fimse
  ret 1

func p_classe # Editar classe
  var.opcnome = "classe " + var.opcclasse
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
  senao
    p_codcomum(arg0, 1)
    passo == "codcomum" && (passo = "classe")
  fimse
  ret 1

func p_codcomum
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    teditor.limpar
    prog p
    txt100 lin
    passo = "codcomum"
    lin = var.opcclasse + ":" + var.opcvar + ", O opções, Z sair"
# Classe
    se arg1
      msg("Editando classe " + var.opcclasse + ", O opções, Z sair")
      p.inilinha(var.opcclasse)
      teditor.addfim("ARQ:" + p.arquivo(var.opcclasse))
# Variável que não existe
    senao !p.inilinha(var.opcclasse, var.opcvar)
      msg(var.opcnome + ", criando " + lin)
      teditor.addfim("const " + var.opcvar + " = nulo")
# Constante
    senao txt1(p.texto) == "const" && inttotal(p.texto) > 75
      msg(var.opcnome + ", editando " + lin)
      teditor.addfim(txttroca(p.texto, "\\n", "\\n\\\n"))
      p.depois
# Qualquer outra coisa
    senao
      msg(var.opcnome + ", editando " + lin)
    fimse
# Copia o texto para o editor
    enquanto p.lin
      teditor.addfim(txtesp(p.nivel) + p.texto), p.depois
    efim
# Divide linhas grandes acrescentando barra invertida no final
    textopos pos
    int16 n
    int16 x
    epara pos = teditor.ini, pos, pos.depois
      enquanto pos.texto(100, 1)
        n = pos.txtproc("\\n", 60, 1) + 2
        se n < 60 || n > 98
          x = 60
          enquanto x && x < 100
            n = x, x = pos.txtproc(" ", x, 1) + 1
          efim
          n == 60 && (n = 100)
        fimse
        pos.mudar("\\\n", n, 0)
        pos.depois
      efim
    efim
# Acerta variáveis
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    ret 1
  casose "x" # Salvar o texto
    p_funcsalvar(arg1)
    ret 1
  casofim
  ret p_editor(arg0, 16384, var.opcnome)

func p_funcsalvar # Opçao salvar de p_func
  textotxt t1
  textopos p1
  txt512 lin
# Junta linhas e coloca em t1
  t1.ini.add(teditor.ini, teditor.linhas)
  p1 = t1.ini
  enquanto p1.txtproc("\\\n") >= 0
    p1.mudar("", inttotal(p1.texto) - 1, 1) # Tira a "\" no final
    p1.depois, p1.juntar # Junta as duas linhas
  efim
# SOMENTE FUNÇÕES
  se !arg0
# Obtém o nome da constante / função
    lin = t1.ini.texto
    enquanto txt1(lin) == "sav" || txt1(lin) == "comum"
      lin = txt2(lin)
    efim
    se t1.linhas > 1 && txt1(lin) != "func" && txt1(lin) != "varfunc"
      msg("Erro: somente FUNC e VARFUNC podem ter várias linhas")
      ret 1
    fimse
    lin = txt1(txttroca(txt2(lin), "#", " "))
# Checa se o nome mudou
    se lin != var.opcvar
      msg("Erro: mude o nome da variável de " + lin + " para " + var.opcvar)
      ret
    fimse
# Checa existência de outra função ou constante dentro
    p1 = t1.ini.texto
    epara p1.depois, p1.lin, p1.depois
      casovar txtmin(txt1(p1.texto))
      casose "func"
      casose "varfunc"
        msg("Erro: definido uma função dentro de outra")
        ret
      casose "const"
      casose "varconst"
        msg("Erro: definido uma constante dentro de uma função")
        ret
      casofim
    efim
# Tenta salvar
    prog p
    t1.addfim(p.criar(var.opcclasse, t1.remove(10000)))
  senao
# SOMENTE CLASSES
# Tenta salvar
    prog p
    se t1.ini.texto(0, 4) != "ARQ:"
      msg("Primeira linha deve conter o texto \"ARQ:\" seguido do nome do arquivo")
      ret 1
    fimse
    t1.addfim(p.criar(var.opcclasse + "\n" + txt(t1.remove(10000), 4)))
  fimse
# Informa se conseguiu salvar
  se t1.ini.texto == ""
    config:salvar
    var.opcexec && criar("admmudou", var.opcclasse, var.opcexec)
    msg("Salvo com sucesso")
    admlog("editou classe " + var.opcclasse)
    ret
  fimse
# Informa erros, corrigindo os números das linhas
  msg("Erro ao salvar:")
  p1 = t1.ini
  p1.depois(8), p1.remove(1000) # Mantém somente as primeiras mensagens
  uint16 x
  enquanto t1.linhas
    x = lin = t1.remove
    se txt(x) == txt(lin, 0, inttotal(txt(x)))
      p1 = teditor.ini
      enquanto p1.txtproc("\\\n") >= 0 && p1.linha < x
        p1.depois, x += 1
      efim
      lin = txt(x) + txt(lin, inttotal(txt(x)))
    fimse
    msg(lin)
  efim

func p_editor
# Processamento de qualquer editor de texto
# arg0 = texto digitado
# arg1 = quantidade máxima de bytes
# arg2 = nome da opção
# teditor contém o texto, leditor é a linha atual
# Retorna sempre 1
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
  casose "" # Entrou na opção ou apenas pressionou ENTER
    msg("Editando " + arg2 + ", O opções, Z sair")
    ret 1
  casose "." # Insere linha removendo espaços
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txtremove(txt(arg0, 1), "ED"))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "," # Insere linha
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txt(arg0, 1))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "a" # Apaga a linha atual
    se !leditor.lin
      msg("Está no fim do texto")
      ret 1
    fimse
    leditor.remove
    msg(leditor.lin ? "Linha apagada" : "Linha apagada; fim do texto")
    ret 1
  casose "i" # Informações sobre a linha atual
    txt100 t
    t = "Linha " + (leditor.linha + 1) + "/" + teditor.linhas
    t += ", " + inttotal(leditor.texto)
    t += " caracteres, " + teditor.bytes + "/" + arg1 + " bytes"
    msg(t)
    ret 1
  casose "l" # Mostra a linha atual
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  casose "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  casose "o" # Mostra opções do editor
    txtmais.limpar
    txtmais.addfim(m_editor)
    txtmostra
    ret 1
  casose "s" # Sobe uma ou mais linhas
    leditor.linha == 0 && msg("Início do texto")
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.antes, x -= 1
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
      ret !leditor.linha, 1
    efim
    ret 1
  casose "d"
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.depois, x -= 1
      se !leditor.lin
        msg("Fim do texto")
        ret 1
      fimse
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
    efim
    ret 1
  casose "t" # Informações sobre a área de transferência
    se transf.linhas == 0
      msg("Área de transferência vazia")
    senao transf.linhas == 1
      msg("Área de transferência: 1 linha " + transf.bytes + " bytes")
    senao
      msg("Área de transferência: " + transf.linhas + " linhas " + transf.bytes + " bytes")
    fimse
    msg("Bloco linhas " + (leditor1.linha + 1) + " a " + (leditor2.linha + 1))
    ret 1
  casose "p" # Procurar
    txt512 t # Texto após o comando P
    int16 col # Coluna aonde encontrou
    textopos pos # Posição aonde encontrou
    t = txtremove(txt(arg0, 1), "ED")
    se t # Procura texto
      peditor = t, pos = leditor
      col = pos.txtproc(t, 0)
    senao peditor # Procura novamente
      pos = leditor, pos.depois
      col = pos.txtproc(peditor, 0)
    senao # Nada para procurar
      col = -1
    fimse
    se col >= 0
      leditor = pos
      msg("Encontrado linha " + (leditor.linha + 1) + " coluna " + (col + 1))
      msg(leditor.texto)
    senao
      msg("Nada encontrado")
    fimse
    ret 1
  casose "e" # Embelezar o texto
    teditor.addini(txttroca(teditor.remove(10000), "\n", " "))
    teditor.dividelin(57, 77)
    msg("Texto embelezado; voltando à linha 1")
    ret 1
  casose "c" # Mostrar texto com as definições de cores
    textopos pos
    txtmais.limpar
    txtmais.addfim("\bTexto com cores:")
    epara pos = teditor.ini, pos.lin, pos.depois
      txtmais.addfim(txtinvis(pos.texto))
    efim
    txtmostra
    ret 1
  casofim
# Comandos de dois caracteres
  casovar txtmin(arg0)
  casose "bi"
    leditor1 = leditor
    msg("Início de bloco linha " + (leditor1.linha + 1))
    ret 1
  casose "bf"
    leditor2 = leditor
    msg("Fim de bloco linha " + (leditor2.linha + 1))
    ret 1
  casose "ba"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser apagado")
    senao
      leditor1.remove(total)
      se total == 1
        msg("Uma linha apagada")
      senao
        msg(txt(total) + " linhas apagadas")
      fimse
    fimse
    ret 1
  casose "bc"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    se transf.linhas == 1
      msg("1 linha guardada")
    senao
      msg(txt(transf.linhas) + " linhas guardadas")
    fimse
    ret 1
  casose "bx"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    leditor1.remove(total)
    se transf.linhas == 1
      msg("1 linha movida")
    senao
      msg(txt(transf.linhas) + " linhas movidas")
    fimse
    ret 1
  casose "bv"
    se teditor.bytes + transf.bytes > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor1.add(transf.ini, transf.linhas)
    se transf.linhas == 1
      msg("1 linha colada")
    senao
      msg(txt(transf.linhas) + " linhas coladas")
    fimse
    ret 1
  casose "be" # Embelezar o bloco
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser embelezado")
    senao
      textotxt t
      t.addfim(txttroca(leditor1.textolin(total), "\n", " "))
      t.dividelin(57, 77)
      leditor1.remove(total)
      leditor1.add(t.ini, t.linhas)
      leditor2.linha = leditor1.linha + t.linhas - 1
      se total == 1
        msg("Uma linha embelezada")
      senao
        msg(txt(total) + " linhas embelezadas")
      fimse
    fimse
    ret 1
  casose "bl" # Limpar o texto
    teditor.limpar
    msg("Texto apagado")
    ret 1
  casofim
# Checa número de linha
  uint16 lin
  lin = arg0
  se arg0 == lin
    leditor.linha = lin - 1
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  fimse
# Opção desconhecida
  msg("Opção desconhecida: " + txt(arg0, 0, 1))
  msg("Editando " + arg2 + ", O opções, Z sair")
  ret 1

const m_editor = "\b\c3Comandos do editor\b\n\
\c2I\b  Informações sobre a linha atual, quantidade de linhas, etc.\n\
\c2T\b  Informações sobre a área de transferência e o bloco marcado\n\
\c2L\b  Mostra a linha atual\n\
\c2S\b  seguido ou não de um número: Sobe uma ou mais linhas no texto\n\
\c2D\b  seguido ou não de um número: Desce uma ou mais linhas no texto\n\
\c2Um número qualquer:\b  Vai para a linha correspondente\n\
As linhas começam em 1; um número bem grande, vai para o fim do texto\n\
\c2Um ponto seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior\n\
A linha atual avança automaticamente\n\
\c2Uma vírgula seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior, sem remover espaços\n\
Exemplo: vírgula seguido de dois espaços e a letra A insere uma linha\n\
que contém dois espaços e a letra A\n\
\c2A\b  Apaga a linha atual\n\
\c2P\b  seguido de um texto: Procura um texto a partir da linha atual\n\
\c2P\b  Procura a próxima linha que contém o texto\n\
\c2E\b  Embeleza o texto, formatando em até 77 caracteres por linha\n\
\c2C\b  Mostra o texto com as definições de cores\n\
\c2M\b  seguido de um texto: Executa um comando do MUD sem sair da edição\n\
\c2X\b  Salva o texto\n\
\c2Z\b  Encerra a edição\n\
\c2BI\b  Marca início do bloco na linha atual\n\
\c2BF\b  Marca fim de bloco na linha atual\n\
\c2BA\b  Apaga bloco marcado\n\
\c2BC\b  Copia bloco para a área de transferência\n\
\c2BX\b  Move bloco para a área de transferência\n\
\c2BV\b  Insere texto da área de transferência entre a linha atual e a anterior\n\
\c2BE\b  Embeleza o bloco marcado\n\
\c2BL\b  Apaga todo o texto sendo editado"

func infosala # Retorna 1 se pode ser editado como variável tipo "const x = $s_abc"
# arg0=nome da classe, arg1=nome da variável
  prog p
  se p.existe(arg0, arg1) != 1 || !p.inilinha(arg0, arg1)
    ret 1
  senao txt1(p.texto) != "const"
    ret 0
  senao txt(p.texto, 6, inttotal(arg1) + 6) != arg0 + " = $s_"
    ret 0
  senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
    ret 0
  senao
    ret 1


classe admmudou
# Chama uma função de todos os objetos de uma determinada classe
# Modo de usar:
# criar("admmudou", <nome da classe>, <nome da função>)
intexec repete
txt100 nomefunc
listaobj l
ref r

func ini
  repete = 1, nomefunc = arg1
  epara r = $[arg0], r, r = objdepois(r)
    l.addfim(r)
  efim

func repete_exec
  ret !l, apagar(este)
  repete = 1, r = l.objini, l.ini.remove, r.[nomefunc]


classe admordena
# Organiza as classes de um arquivo em ordem alfabética
# Modo de usar:
# criar("admordena", <sufixo do nome do arquivo>)
intexec repete
txt100 nomeclasse

func ini
  nomeclasse = arg0, repete = 1

func repete_exec
  apagar(este)
  prog p
  textotxt t
  epara p.iniarq(nomeclasse), p.lin, p.depois
    t.addfim(p.texto)
  efim
  t.ordena
  p.clini(nomeclasse, t.ini.texto)
  enquanto t.linhas > 1
    p.cldepois(t.remove, t.ini.texto)
  efim
  config:salvar
