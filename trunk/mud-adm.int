classe jog_adm
# Funções necessárias para os comandos de administração

func cmd2_info # Usado por cmd_info
  txt512 lin
  lin = "Peso:   obj=" + arg0.pesoobj + "  dentro=" + arg0.pesoden
  lin += "  total=" + arg0.pesotot + "  voando=" + (arg0.pesoadd ? "N" : "S")
  lin += "\nVolume: obj=" + arg0.volobj + "  dentro=" + arg0.volden
  lin += "  total=" + arg0.voltot + "  expande=" + (arg0.volexp ? "S" : "N")
  lin += "\nQuantidade=" + arg0.objtot + "  Jogadores=" + arg0.socktot
  lin += "  Itens dentro=" + arg0.dentro1.total + "  Personagens dentro=" + arg0.dentro2.total
  lin += "\nevento="
  listaitem i
  epara i = arg0.evento.ini, i, i.depois
    lin += txt(i.obj) + " "
  efim
  lin += "\nevrec.0=" + arg0.evrec.0.objlista
  lin += "  evrec.1=" + arg0.evrec.1.objlista
  ret lin

func cmd_info
  se !arg0
# msg("\b\c2Você:\b\n" + cmd2_info(perso))
    msg("\c2Sala " + perso.dono + ":\b\n" + cmd2_info(perso.dono))
    ret 1
  fimse
  int1 achou
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("\b\c2" + r.nome + ": " + r + "\b\n" + cmd2_info(r))
    achou = 1
  efim
  !achou && msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_matar1
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  r = perso
  l.addfim(r.dono.dentro1, r.dono.dentro2, r.dentro1)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("Apagando " + r.nome), apagar(r)
    ret 1
  efim
  msg("Não há nenhum personagem ou item chamado " + arg0)
  ret 1

func cmd_matar2
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  n.ini(arg0, 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    msg("Matando " + r.nome), r.morreu
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + arg0)
  ret 1

func cmd_cmd
  debug d
  msg(">" + d.cmd(perso, "ret " + arg0))
  ret 1

func cmd_cmdj
  se !txt2(arg0)
    msg("Digite CMDJ seguido do nome do personagem jogador e o comando")
    ret 1
  fimse
  indiceitem item
  item.ini("pn " + txtnome(txt1(arg0)))
  se !item.obj
    msg("Jogador inexistente ou ausente: " + txt1(arg0))
    ret 1
  fimse
  debug d
  msg(txt(item.obj.nome) + ">" + d.cmd(item.obj, "ret " + txt2(arg0)))
  ret 1

func cmd_cmdp
  listaobj l
  ref r
  nomeobj n # Para reconhecer os itens
  se !txt2(arg0)
    msg("Digite CMDP seguido do nome do personagem e o comando")
    ret 1
  fimse
  n.ini(txt1(arg0), 1000000)
  l.addfim(perso.dono.dentro2)
  enquanto l
    r = l.objini, l.ini.remove
    continuar !r.visivel(perso) || !n.nome(r.ident, r.objtot)
    debug d
    msg(txt(r.nome) + ">" + d.cmd(r, "ret " + txt2(arg0)))
    ret 1
  efim
  msg("Não há nenhum personagem chamado " + txt1(arg0))
  ret 1

func cmd_adm
  prog p
  se p.inifunctudo(este, "adm_" + arg0)
    msg2([p.texto])
  senao
    msg("\bTópico de administração desconhecido: " + arg0)
  fimse
  ret 1

const adm_ = "\b\c3Páginas de administração\b\n\
Para ler tecle ADM seguido do nome de um tópico.\n\
Os tópicos são:\n\
  \c2AREA\b     Áreas\n\
  \c2SALA\b     Salas\n\
  \c2SAI\b      Saídas das salas\n\
  \c2ITEM\b     Itens\n\
  \c2TIPO\b     Tipos de personagens\n\
  \c2PERSO\b    Personagens não jogador\n\
  \c2RESET\b    Reset de área ou sala\n\
  \c2ATK\b      Comandos de ataques\n\
  \c2SOCIAL\b   Comandos sociais\n\
  \c2COD\b      Edição do código fonte\n\
  \c2OUTROS\b   Outros comandos"
# \c2INFO\b     Informações sobre o MUD"
const adm_outros = "\c3Outros comandos\b\n\
\c2ECONFIG\b\n\
  Edita as configurações do MUD.\n\
\c2AC\b <texto>\n\
  Envia mensagem para o canal de administração; vide comando CONFIG\n\
\c2ECHO\b <texto>\n\
  Envia texto para todos os jogadores.\n\
\c2MUDANOME\b <nome atual> <novo nome>\n\
  Muda o nome do personagem de um jogador.\n\
\c2INFO\b\n\
  Informações sobre a sala.\n\
\c2INFO\b <personagem ou item>\n\
  Informações sobre personagem ou item.\n\
\c2MATAR1\b <personagem ou item>\n\
  Apaga personagem ou item.\n\
\c2MATAR2\b <personagem>\n\
  Mata instantaneamente personagem.\n\
\c2CMD\b <comando>\n\
\c2CMDP\b <personagem da sala> <comando>\n\
\c2CMDJ\b <personagem jogador> <comando>\n\
  Executa comando na linguagem do IntMUD e mostra o resultado.\n\
\c2MUDLER\b\n\
  Recarrega arquivos do MUD que foram alterados.\n\
\c2MONIT\b [jogador]\n\
  Monitora um jogador, permitindo ver o que ele lê e escreve.\n\
  Se [jogador] estiver ausente ou for o próprio, deixa de monitorar.\n\
  O principal objetivo é auxiliar outros usuários, por isso quando\n\
  esse comando é usado, todos os administradores são informados.\n\
  O comando QUEM também mostra aos administradores quem está monitorando.\n\
\c2ESCR\b <comando>\n\
  Digita um comando no teclado do usuário sendo monitorado."

func cmd_ac
  se !jogconfig.19
    msg("Canal AC está desabilitado.")
  senao !arg0
    msg("Tecle a mensagem após AC.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.19 && item.obj.msg("(ac) " + nome + ": " + arg0)
    efim
  fimse
  ret 1

func cmd_econfig
  m_menu("adm_econfig")
  ret 1

func cmd_echo
  se !arg0
    msg("\bTecle a mensagem após ECHO.")
  senao
    indiceitem item
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.msg("\b\cB(ADM) " + arg0 + "\b")
    efim
  fimse
  ret 1

func cmd_mudler
  $mudaprog.exec
  ret 1

func cmd_mudanome
  se intsub(arg0) != 2
    msg("Tecle mudanome seguido do nome atual e o novo nome")
    ret 1
  fimse
  indiceitem ind
  txt20 nome.2 # Nome não codificado
  txt20 codif.2 # Nome codificado
  arqsav sav1
# Obtém os nomes
  nome.0 = txtmaimin(txt1(arg0))
  nome.1 = txtmaimin(txt2(arg0))
  codif.0 = txtnome(nome.0)
  codif.1 = txtnome(nome.1)
# Checa se o segundo personagem já existe
  se nome.0 == nome.1
    msg("Os dois nomes correspondem ao mesmo personagem.")
    ret 1
  senao inttotal(nome.1) < 3 || inttotal(nome.1) > 16
    msg("O novo nome deve ter de 3 a 16 caracteres.")
    ret 1
  senao intnome(nome.1)
    msg("O novo nome não é válido.")
    ret 1
  senao ind.obj("un " + codif.1)
    msg("Personagem " + nome.1 + " já está sendo usado.")
    ret 1
  senao codif.0 != codif.1 && sav1.existe("sav/" + codif.1 + ".sav")
    msg("Personagem " + nome.1 + " já existe.")
    ret 1
  fimse
# Jogador online
  uint8 mudou
  se ind.obj("un " + codif.0)
    ref r
    r = ind.obj("un " + codif.0)
    r.cnome = "un " + codif.1
    r.nome = nome.1
    r.perso.cnome = "pn " + codif.1
    r.perso.nome = nome.1
    mudou = 1
  fimse
# Jogo salvo
  se sav1.existe("sav/" + codif.0 + ".sav")
    textotxt t
    textopos p
    t.ler("sav/" + codif.0 + ".sav")
    p = t.ini
    p.txtproc("\nnome=") >= 0 && p.mudar(nome.1, 5, 100)
    t.salvar("sav/" + codif.1 + ".sav")
    codif.0 != codif.1 && sav1.apagar("sav/" + codif.0 + ".sav")
    mudou = 1
  fimse
# Informa se mudou
  se !mudou
    msg("Personagem " + nome.0 + " não existe.")
  senao
    msg("Personagem " + nome.0 + " mudou para " + nome.1 + ".")
    admlog("mudou personagem jogador " + nome.0 + " para " + nome.1)
  fimse
  ret 1

func cmd_monit
  indiceitem item
  ref r
  r = item.obj("pn " + txtnome(arg0))
  se !arg0 || r == perso
    se imonit
      txt100 t1
      t1 = imonit.objlista.perso.nome
      imonit.remove
      msg("Deixando de monitorar " + t1)
      t1 = "*** " + perso.nome + " deixa de monitorar " + t1
      epara item.ini("un "), txt1(item.txt) == "un", item.depois
        item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
      efim
    senao
      msg("Não está monitorando ninguém")
    fimse
  senao !r
    msg("Jogador não encontrado: " + arg0)
  senao r == imonit.objlista.perso
    msg("Já está monitorando " + r.nome)
  senao
    imonit && msg("Deixando de monitorar " + imonit.objlista.perso.nome)
    imonit.remove
    txt100 t1
    t1 = "*** " + perso.nome + " monitora " + r.nome
    epara item.ini("un "), txt1(item.txt) == "un", item.depois
      item.obj.jogconfig.23 && item.obj != este && item.obj.msg(t1)
    efim
    imonit = r.sock.lmonit.addini(este)
    msg("Monitorando " + r.nome)
  fimse
  ret 1

func cmd_escr
  se !imonit
    msg("Você não está monitorando ninguém")
  senao !arg0
    msg("Tecle a mensagem após ESCR")
  senao
    imonit.objlista.msg("*** " + perso.nome + " escreve no seu teclado: " + arg0)
    imonit.objlista.recebe(arg0)
  fimse
  ret 1

func admlog # Mensagem para todos com a opção "config +admlog"
  indiceitem item
  epara item.ini("un "), txt1(item.txt) == "un", item.depois
    item.obj.jogconfig.21 && item.obj.msg("\b\d1(adm) " + nome + " " + arg0 + "\b")
  efim

const txt_legenda = "Legenda:\n\
<nulo> Significa que a opção não foi definida.\n\
<herda> É herdado de outra classe.\n\
Exemplo, as salas herdam as propriedades das nas áreas.\n\
Outro texto entre os sinais de menor e maior indicam o modo\n\
como a opção foi definida. Exemplo, <func> significa função."

func m_menu
  tpasso = arg0, p_menu("")
  ret

func p_menu
  casovar txtmin(arg0)
  casose ""
  casose "\b"
    var.opcnome = "", var.opcclasse = "", var.opcvar = ""
    var.opcpasso = "", var.opcextra = "", var.opcmudou = ""
    passo = "menu"
    msg([tpasso]:titulo + ", tecle O para saber as opções")
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim("\b" + [tpasso]:titulo)
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      txtmais.addfim(m_menu2(tpasso, txt(p.texto, 4)))
    efim
    txtmais.addfim("Tecle F seguido de um número se quiser editar como função")
    txtmais.addfim("V mostra as variáveis alteradas em cada opção (classe:variável)")
    txtmais.addfim("Z Sair, L Legenda, M seguido de um texto executa comando do MUD")
    txtmostra
    ret 1
  casose "v"
    txtmais.limpar
    txt100 lin
    prog p
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Opções de um dígito
      continuar inttotal(p.texto) > 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    epara p.inifunctudo(tpasso, "nome"), p.lin, p.depois # Outras opções
      continuar inttotal(p.texto) == 5
      txtmais.addfim(m_menu3(tpasso, txt(p.texto, 4)))
    efim
    txtmostra
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = ""
    ret 1
  casose "l"
    msg(txt_legenda)
    ret 1
  casofim
  se txt(arg0, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
  senao [tpasso]:nome[arg0] # Editar opção do menu
    var.opcnome = txtremove([tpasso]:nome[arg0], "ED")
    var.opcclasse = [tpasso]:classe[arg0]
    var.opcvar = [tpasso]:var[arg0]
    var.opcextra = [tpasso]:extra[arg0]
    var.opcpasso = passo
    var.opcvalido_ = txtproc([tpasso]:tipo[arg0], "--") >= 0
    var.opcmudou = [tpasso]:mudou[arg0]
    se !var.opcvar
      msg2(var.opcextra)
      ret 1
    fimse
    msg(m_menu2(tpasso, arg0))
    [tpasso]:info[arg0] && msg([tpasso]:info[arg0])
    p_[txttroca([tpasso]:tipo[arg0], "-", "")]("\b")
  senao txt(arg0, 0, 1) == "f" && [tpasso]:nome[txt(arg0, 1)] # Editar função
    se txtproc([tpasso]:tipo[txt(arg0, 1)], "-") >= 0
      msg("Essa opção não pode ser editada como função; escolha outra")
      ret 1
    fimse
    txt20 opc
    opc = txt(arg0, 1)
    var.opcnome = txtremove([tpasso]:nome[opc], "ED")
    var.opcclasse = [tpasso]:classe[opc]
    var.opcvar = [tpasso]:var[opc]
    var.opcextra = [tpasso]:extra[opc]
    var.opcpasso = passo
    var.opcmudou = [tpasso]:mudou[arg0]
    se !var.opcvar
      msg2(var.opcextra)
      ret 1
    fimse
    p_func("\b")
  senao # Nenhuma das anteriores
    msg("Opção inválida: " + arg0)
  fimse
  ret 1

func m_menu2 # Usado em m_menu para obter o texto de uma opção do menu
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  txt80 func1 # Função que mostra o conteúdo da variável
  lin = "\b\c2" + arg1 + (txt(arg1, 1) ? "\b." : "\b. ") + [arg0]:nome[arg1]
  inttotal(lin) < 23 && (lin = txt(lin + txtesp(20), 0, 23))
  func1 = "t_" + txttroca([arg0]:tipo[arg1], "-", "") # Nome da função
  ret lin + ": " + [func1]([arg0]:classe[arg1], [arg0]:var[arg1], [arg0]:extra[arg1])

func m_menu3 # Usado em m_menu para obter o nome da variável
# arg0 = nome da classe que contém o menu
# arg1 = número da opção
  txt100 lin
  lin = arg1 + (txt(arg1, 1) ? "." : ". ") + [arg0]:nome[arg1]
  inttotal(lin) < 20 && (lin = txt(lin + txtesp(18), 0, 20))
  ret lin + ": " + [arg0]:classe[arg1] + ":" + [arg0]:var[arg1]

func t_linha # Retorna texto de uma linha, do tipo "const x = \"abc\""
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + txtvis([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + txtvis([arg0]:[arg1]) + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_linha # Alterando um texto de uma linha
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "linha"
    msg("Entre com um texto, N nenhum, Z cancela")
    ret 1
  senao arg0 == "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    senao
      p.criar(var.opcclasse, "const " + var.opcvar + "=\"\"")
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg(var.opcnome + " mudou para um texto vazio")
      admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    fimse
  senao arg0 != "z"
    p.criar(var.opcclasse, "const " + var.opcvar + "=\"" + txtvis(arg0) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + arg0)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_texto # Retorna quantidade de linhas de texto de várias linhas
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> " + t_texto2([arg0]:[arg1])
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_texto2([arg0]:[arg1])
  casofim

func t_texto2 # Usado por t_texto
  txt10 x
  x = intsublin(arg0)
  ret x != "1" ? "\c6" + x + " linhas\b" : "\c6Uma linha\b"

func p_texto # Alterando um texto de várias linhas
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    textopos p1
    teditor.limpar
    teditor.addfim([var.opcclasse]:[var.opcvar])
    epara p1 = teditor.ini, p1.lin, p1.depois
      p1.mudar(txtvis(p1.texto))
    efim
    teditor.bytes == 1 && teditor.limpar
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    passo = "texto"
    msg("Editando " + var.opcnome + ", O opções, X salvar, Z sair")
    ret 1
  casose "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
    ret 1
  casose "x" # Salvar o texto
    prog p
    textopos p1
    textotxt t1
    epara p1 = teditor.ini, p1.lin, p1.depois
      t1.addfim(txtinvis(p1.texto))
    efim
    txt200 t
    t = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, t + txtvis(t1.remove(1000)) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Salvou " + var.opcnome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret 1
  casofim
  ret p_editor(arg0, 2000, var.opcvar)

func t_numero # Retorna número, do tipo "const x = 10"
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), "\c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> \c6" + [arg0]:[arg1] + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> \c60\b"
  casofim

func p_numero # Alterando um número
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "numero"
    se var.opcvalido
      msg("Entre com um número, Z cancela")
    senao
      msg("Entre com um número, N nenhum, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 valor
    valor = arg0
    se arg0 != valor # Checa se é número
      ret p_numero("\b")
    senao var.opcextra # Checa limites mínimo e máximo
      se valor < int(txt1(var.opcextra)) || valor > int(txt2(var.opcextra))
        msg("Entre com um número de " + txt1(var.opcextra) + " a " + txt2(var.opcextra) + ".")
        ret 1
      fimse
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + valor)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + valor)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_opcao # Retorna uma opção baseado numa lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_opcaomostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_opcaomostra(0, arg2)
  casofim

func t_opcaomostra # Retorna o texto correspondente a uma opção
# arg0 = número da opção atual
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo a opção atual
  uint16 valor
  textotxt t
  valor = arg0
  t.addfim(arg1)
  t.remove(valor)
  ret "\c6" + valor + (t.linhas ? " " + t.remove(1) + "\b" : " <inválido>\b")

func p_opcao # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "opcao"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    textotxt t
    int16 x
    x = arg0, t.addfim(var.opcextra)
    se arg0 != x || x < 0 || x >= t.linhas
      msg("Opção inválida")
      ret p_opcao("\b")
    fimse
    t.remove(x)
    txt100 lin
    lin = " # " + var.opcnome + ": " + x + " " + t.ini.texto
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + x + " " + t.remove)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_vetor # Retorna as opções selecionadas de lista de opções
# arg0=nome da classe, arg1=nome da variável, arg2=nomes das opções
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.varnum(arg0, arg1), t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.varnum(arg0, arg1), "<herda> " + t_vetormostra([arg0]:[arg1], arg2)
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo> " + t_vetormostra(0, arg2)
  casofim

func t_vetormostra # Retorna o texto correspondente a uma opção
# arg0 = valor numérico
# arg1 = texto com lista de opções separadas por "\n"
# Retorna: Um texto contendo as opções escolhidas
  int32 valor
  textotxt t
  txt512 lin
  valor = arg0
  epara t.addfim(arg1), t.linhas, valor = valor >> 1
    valor & 1 ? (lin += ", " + t.remove) : t.remove
  efim
  ret lin ? "\c6" + txt(lin, 2) + "\b" : ""

func p_vetor # Alterando uma opção de uma lista de opções
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "vetor"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    txtmais.limpar
    txtmais.addfim("\bOpções:\n" + var.opcextra)
    textopos pos
    pos = txtmais.ini
    epara pos.depois, pos, pos.depois
      pos.mudar(txt(pos.linha - 1) + " ", 0, 0)
    efim
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    int32 x
    x = arg0
    se arg0 != x || x < 0 || x >= intsublin(var.opcextra)
      msg("Opção inválida")
      ret p_vetor("\b")
    fimse
    x = 1 << x ^ [var.opcclasse]:[var.opcvar]
    txt100 lin
    lin = txtcor(t_vetormostra(x, var.opcextra))
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + x + " # " + var.opcnome + ": " + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Escolheu: " + lin)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetor("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

const t_tipos = t_vetorfunc(arg0, arg1)

func p_tipos
  prog p
  passo = "tipos"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("tipo_"), p.lin, p.depois
      txtmais.addfim(txt(p.texto, 5))
    efim
  fimse
  ret p_vetorfunc(arg0, p.existe("tipo_" + txts(arg0)))

const t_tipodep = t_vetorfunc(arg0, arg1)

func p_tipodep
  prog p
  passo = "tipodep"
  se arg0 == "o"
    txtmais.limpar
    epara p.iniclasse("cmd_"), p.lin, p.depois
      $[p.texto].atkcom && txtmais.addfim("h_" + txt(p.texto, 4))
    efim
    epara p.iniclasse("magia_"), p.lin, p.depois
      txtmais.addfim("m_" + txt(p.texto, 6))
    efim
    epara p.iniclasse("idioma_"), p.lin, p.depois
      txtmais.addfim("i_" + txt(p.texto, 7))
    efim
  fimse
  casovar txtmin(txt(arg0, 0, 2))
  casose "h_"
    ret p_vetorfunc(arg0, $cmd_[txt(arg0, 2)].atkcom != nulo)
  casose "m_"
    ret p_vetorfunc(arg0, $magia_[txt(arg0, 2)] != nulo)
  casose "i_"
    ret p_vetorfunc(arg0, $idioma_[txt(arg0, 2)] != nulo)
  casofim
  ret p_vetorfunc(arg0, 0)

func t_vetorfunc # Usado intermanente: retorna uma lista de textos
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret p.vartexto(arg0, arg1), "\c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<" + txt1(p.texto) + ">"
  casose "2" # Em uma classe herdada
    ret p.vartexto(arg0, arg1), "<herda> \c3" + txttroca([arg0]:[arg1], "\n", " ") + "\b"
    p.inilinha(arg0, arg1)
    ret "<herda " + txt1(p.texto) + ">"
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_vetorfunc # Usado intermanente: alterando um vetor de textos
# arg0 = texto digitado pelo usuário
# arg1 = verdadeiro se o texto for a texto válido para o vetor
# Se arg0=="o", a variável txtmais deve ter a lista de opções válidas, uma por linha
  prog p
  se arg0 == "" || arg0 == "\b"
    se var.opcvalido
      msg("Entre com uma opção, O mostra as opções, Z sair")
    senao
      msg("Entre com uma opção, O mostra as opções, N nenhuma, Z sair")
    fimse
    ret 1
  senao arg0 == "o"
    se txtmais.bytes <= 1
      txtmais.limpar, txtmais.add("\bNão há nenhuma opção definida")
    senao
      txtmais.addfim(txttroca(txtmais.remove(5000), "\n", ", "))
      txtmais.juntar, txtmais.dividelin(40, 75)
      txtmais.addini("\bOpções:")
    fimse
    txtmostra
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 lin
    lin = txts(arg0)
    textotxt t
    t.addfim([var.opcclasse]:[var.opcvar])
    t.bytes <= 1 && t.limpar
    textopos pos
    pos = t.ini
    se pos.txtproc("\n" + lin + "\n") >= 0
      pos.remove
    senao !arg1
      msg("Opção inválida: " + lin)
      ret p_vetorfunc("\b")
    senao
      t.addfim(lin), t.ordena
    fimse
    lin = "const " + var.opcvar + "=\""
    p.criar(var.opcclasse, lin + txtvis(t.ini.textolin(1000)) + "\"")
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Escolheu: " + txttroca(t.ini.textolin(1000), "\n", " "))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
    ret p_vetorfunc("\b")
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_simnao # Retorna opção que pode ser 0 (não) ou 1 (sim)
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<" + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "\c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "\c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose "2" # Em uma classe herdada
    se !p.varnum(arg0, arg1)
      p.inilinha(arg0, arg1)
      ret "<herda " + txt1(p.texto) + ">"
    senao [arg0]:[arg1]
      ret "<herda> \c6" + [arg0]:[arg1] + " Sim\b"
    senao
      ret "<herda> \c6" + [arg0]:[arg1] + " Não\b"
    fimse
  casose # Não foi definido
    ret "<nulo> \c60 Não\b"
  casofim

func p_simnao # Alterando uma opção que pode ser "SIM" ou "NÃO"
  prog p
  casovar arg0
  casose "0"
  casose "1"
    txt100 lin
    lin = " # " + var.opcnome + ": " + (arg0 == 1 ? "Sim" : "Não")
    p.criar(var.opcclasse, "const " + var.opcvar + "=" + arg0 + lin)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para: " + (arg0 == 1 ? "1 sim" : "0 não"))
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  casose "z"
    sair
  casose "n"
    se !var.opcvalido
      p.apagar(var.opcclasse, var.opcvar)
      config:salvar
      var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
      msg("Apagado: " + var.opcnome)
      admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
      sair
    fimse
  casose
    passo = "simnao"
    se var.opcvalido
      msg("Escolha: 0 não, 1 sim, Z cancela")
    senao
      msg("Escolha: 0 não, 1 sim, N nenhum, Z cancela")
    fimse
    ret 1
  casofim
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func t_sala # Retorna sala (constante do tipo "const x = $s_abc")
# arg0=nome da classe, arg1=nome da variável
  prog p
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<" + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<const>"
    senao
      ret txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose "2" # Em uma classe herdada
    p.inilinha(arg0, arg1)
    se txt1(p.texto) != "const"
      ret "<herda " + txt1(p.texto) + ">"
    senao txt(p.texto, 6, inttotal(arg1) + 6) != arg1 + " = $s_"
      ret "<herda const>"
    senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
      ret "<herda const>"
    senao
      ret "<herda> " + txt(p.texto, inttotal(arg1) + 12)
    fimse
  casose # Não foi definido
    ret "<nulo>"
  casofim

func p_sala # Alterando a sala
  prog p
  se arg0 == "" || arg0 == "\b"
    passo = "sala"
    se var.opcvalido
      msg("Entre com o nome da sala, Z cancela")
    senao
      msg("Entre com o nome da sala, N nenhuma, Z cancela")
    fimse
    ret 1
  senao arg0 == "n" && !var.opcvalido
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Apagado: " + var.opcnome)
    admlog("apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao arg0 != "z"
    txt100 nome
    nome = txtmin(txts(arg0))
    se !p.existe("s_" + nome)
      msg("\bSala \"" + nome + "\" não existe, escolha outra.")
      ret 1
    fimse
    p.criar(var.opcclasse, "const " + var.opcvar + "=$s_" + nome)
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg(var.opcnome + " mudou para " + nome)
    admlog("mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse
  passo = var.opcpasso, p_[passo]("\b")
  ret 1

func p_func # Editar função
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = var.opcpasso, p_[passo]("\b")
  senao
    p_codcomum(arg0, 0)
    passo == "codcomum" && (passo = "func")
  fimse
  ret 1

func p_classe # Editar classe
  var.opcnome = "classe " + var.opcclasse
  se arg0 == "z" # Sair do editor
    msg("Fechando editor")
    passo = ""
  senao
    p_codcomum(arg0, 1)
    passo == "codcomum" && (passo = "classe")
  fimse
  ret 1

func p_codcomum
  casovar txtmin(txt(arg0, 0, 1))
  casose "\b"
    teditor.limpar
    prog p
    txt100 lin
    passo = "codcomum"
    lin = var.opcclasse + ":" + var.opcvar + ", O opções, Z sair"
# Classe
    se arg1
      msg("Editando classe " + var.opcclasse + ", O opções, Z sair")
      p.inilinha(var.opcclasse)
      teditor.addfim("ARQ:" + p.arquivo(var.opcclasse))
# Variável que não existe
    senao !p.inilinha(var.opcclasse, var.opcvar)
      msg(var.opcnome + ", criando " + lin)
      teditor.addfim("const " + var.opcvar + " = nulo")
# Constante
    senao txt1(p.texto) == "const" && inttotal(p.texto) > 75
      msg(var.opcnome + ", editando " + lin)
      teditor.addfim(txttroca(p.texto, "\\n", "\\n\\\n"))
      p.depois
# Qualquer outra coisa
    senao
      msg(var.opcnome + ", editando " + lin)
    fimse
# Copia o texto para o editor
    enquanto p.lin
      teditor.addfim(txtesp(p.nivel) + p.texto), p.depois
    efim
# Divide linhas grandes acrescentando barra invertida no final
    textopos pos
    int16 n
    int16 x
    epara pos = teditor.ini, pos, pos.depois
      enquanto pos.texto(100, 1)
        n = pos.txtproc("\\n", 60, 1) + 2
        se n < 60 || n > 98
          x = 60
          enquanto x && x < 100
            n = x, x = pos.txtproc(" ", x, 1) + 1
          efim
          n == 60 && (n = 100)
        fimse
        pos.mudar("\\\n", n, 0)
        pos.depois
      efim
    efim
# Acerta variáveis
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
    leditor2.antes
    ret 1
  casose "x" # Salvar o texto
    p_funcsalvar(arg1)
    ret 1
  casofim
  ret p_editor(arg0, 16384, var.opcnome)

func p_funcsalvar # Opçao salvar de p_func
  textotxt t1
  textopos p1
  txt512 lin
# Junta linhas e coloca em t1
  t1.ini.add(teditor.ini, teditor.linhas)
  p1 = t1.ini
  enquanto p1.txtproc("\\\n") >= 0
    p1.mudar("", inttotal(p1.texto) - 1, 1) # Tira a "\" no final
    p1.depois, p1.juntar # Junta as duas linhas
  efim
# SOMENTE FUNÇÕES
  se !arg0
# Obtém o nome da constante / função
    lin = t1.ini.texto
    enquanto txt1(lin) == "sav" || txt1(lin) == "comum"
      lin = txt2(lin)
    efim
    se t1.linhas > 1 && txt1(lin) != "func" && txt1(lin) != "varfunc"
      msg("Erro: somente FUNC e VARFUNC podem ter várias linhas")
      ret 1
    fimse
    lin = txt1(txttroca(txt2(lin), "#", " "))
# Checa se o nome mudou
    se lin != var.opcvar
      msg("Erro: mude o nome da variável de " + lin + " para " + var.opcvar)
      ret
    fimse
# Checa existência de outra função ou constante dentro
    p1 = t1.ini.texto
    epara p1.depois, p1.lin, p1.depois
      casovar txtmin(txt1(p1.texto))
      casose "func"
      casose "varfunc"
        msg("Erro: definido uma função dentro de outra")
        ret
      casose "const"
      casose "varconst"
        msg("Erro: definido uma constante dentro de uma função")
        ret
      casofim
    efim
# Tenta salvar
    prog p
    t1.addfim(p.criar(var.opcclasse, t1.remove(10000)))
  senao
# SOMENTE CLASSES
# Tenta salvar
    prog p
    se t1.ini.texto(0, 4) != "ARQ:"
      msg("Primeira linha deve conter o texto \"ARQ:\" seguido do nome do arquivo")
      ret 1
    fimse
    t1.addfim(p.criar(var.opcclasse + "\n" + txt(t1.remove(10000), 4)))
  fimse
# Informa se conseguiu salvar
  se t1.ini.texto == ""
    config:salvar
    var.opcmudou && criar("admmudou", var.opcclasse, var.opcmudou)
    msg("Salvo com sucesso")
    admlog("editou classe " + var.opcclasse)
    ret
  fimse
# Informa erros, corrigindo os números das linhas
  msg("Erro ao salvar:")
  p1 = t1.ini
  p1.depois(8), p1.remove(1000) # Mantém somente as primeiras mensagens
  uint16 x
  enquanto t1.linhas
    x = lin = t1.remove
    se txt(x) == txt(lin, 0, inttotal(txt(x)))
      p1 = teditor.ini
      enquanto p1.txtproc("\\\n") >= 0 && p1.linha < x
        p1.depois, x += 1
      efim
      lin = txt(x) + txt(lin, inttotal(txt(x)))
    fimse
    msg(lin)
  efim

func p_editor
# Processamento de qualquer editor de texto
# arg0 = texto digitado
# arg1 = quantidade máxima de bytes
# arg2 = nome da opção
# teditor contém o texto, leditor é a linha atual
# Retorna sempre 1
  casovar txtmin(txt(arg0, 0, 1))
  casose "\n"
    leditor = teditor.ini
    leditor1 = teditor.ini
    leditor2 = teditor.fim
  casose "" # Entrou na opção ou apenas pressionou ENTER
    msg("Editando " + arg2 + ", O opções, Z sair")
    ret 1
  casose "." # Insere linha removendo espaços
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txtremove(txt(arg0, 1), "ED"))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "," # Insere linha
    se teditor.bytes + inttotal(arg0) > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor.add(txt(arg0, 1))
    leditor.depois
    msg("Adicionada linha " + leditor.linha)
    ret 1
  casose "a" # Apaga a linha atual
    se !leditor.lin
      msg("Está no fim do texto")
      ret 1
    fimse
    leditor.remove
    msg(leditor.lin ? "Linha apagada" : "Linha apagada; fim do texto")
    ret 1
  casose "i" # Informações sobre a linha atual
    txt100 t
    t = "Linha " + (leditor.linha + 1) + "/" + teditor.linhas
    t += ", " + inttotal(leditor.texto)
    t += " caracteres, " + teditor.bytes + "/" + arg1 + " bytes"
    msg(t)
    ret 1
  casose "l" # Mostra a linha atual
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  casose "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg0, 1), "E"))
    ret 1
  casose "o" # Mostra opções do editor
    txtmais.limpar
    txtmais.addfim(m_editor)
    txtmostra
    ret 1
  casose "s" # Sobe uma ou mais linhas
    leditor.linha == 0 && msg("Início do texto")
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.antes, x -= 1
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
      ret !leditor.linha, 1
    efim
    ret 1
  casose "d"
    uint8 x
    x = txtremove(txt(arg0, 1), "E")
    x > 8 && (x = 8)
    x < 1 && (x = 1)
    enquanto x > 0
      leditor.depois, x -= 1
      se !leditor.lin
        msg("Fim do texto")
        ret 1
      fimse
      msg(txt(leditor.linha + 1) + " " + leditor.texto)
    efim
    ret 1
  casose "t" # Informações sobre a área de transferência
    se transf.linhas == 0
      msg("Área de transferência vazia")
    senao transf.linhas == 1
      msg("Área de transferência: 1 linha " + transf.bytes + " bytes")
    senao
      msg("Área de transferência: " + transf.linhas + " linhas " + transf.bytes + " bytes")
    fimse
    msg("Bloco linhas " + (leditor1.linha + 1) + " a " + (leditor2.linha + 1))
    ret 1
  casose "p" # Procurar
    txt512 t # Texto após o comando P
    int16 col # Coluna aonde encontrou
    textopos pos # Posição aonde encontrou
    t = txtremove(txt(arg0, 1), "ED")
    se t # Procura texto
      peditor = t, pos = leditor
      col = pos.txtproc(t, 0)
    senao peditor # Procura novamente
      pos = leditor, pos.depois
      col = pos.txtproc(peditor, 0)
    senao # Nada para procurar
      col = -1
    fimse
    se col >= 0
      leditor = pos
      msg("Encontrado linha " + (leditor.linha + 1) + " coluna " + (col + 1))
      msg(leditor.texto)
    senao
      msg("Nada encontrado")
    fimse
    ret 1
  casose "e" # Embelezar o texto
    teditor.addini(txttroca(teditor.remove(10000), "\n", " "))
    teditor.dividelin(57, 77)
    msg("Texto embelezado; voltando à linha 1")
    ret 1
  casose "c" # Mostrar texto com as definições de cores
    textopos pos
    txtmais.limpar
    txtmais.addfim("\bTexto com cores:")
    epara pos = teditor.ini, pos.lin, pos.depois
      txtmais.addfim(txtinvis(pos.texto))
    efim
    txtmostra
    ret 1
  casofim
# Comandos de dois caracteres
  casovar txtmin(arg0)
  casose "bi"
    leditor1 = leditor
    msg("Início de bloco linha " + (leditor1.linha + 1))
    ret 1
  casose "bf"
    leditor2 = leditor
    msg("Fim de bloco linha " + (leditor2.linha + 1))
    ret 1
  casose "ba"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser apagado")
    senao
      leditor1.remove(total)
      se total == 1
        msg("Uma linha apagada")
      senao
        msg(txt(total) + " linhas apagadas")
      fimse
    fimse
    ret 1
  casose "bc"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    se transf.linhas == 1
      msg("1 linha guardada")
    senao
      msg(txt(transf.linhas) + " linhas guardadas")
    fimse
    ret 1
  casose "bx"
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    transf.limpar
    transf.ini.add(leditor1, total)
    leditor1.remove(total)
    se transf.linhas == 1
      msg("1 linha movida")
    senao
      msg(txt(transf.linhas) + " linhas movidas")
    fimse
    ret 1
  casose "bv"
    se teditor.bytes + transf.bytes > arg1
      msg("Editor não suporta tantos caracteres")
      ret 1
    fimse
    leditor1.add(transf.ini, transf.linhas)
    se transf.linhas == 1
      msg("1 linha colada")
    senao
      msg(txt(transf.linhas) + " linhas coladas")
    fimse
    ret 1
  casose "be" # Embelezar o bloco
    int32 total
    total = leditor2.linha - leditor1.linha + 1
    se total <= 0
      msg("Nada para ser embelezado")
    senao
      textotxt t
      t.addfim(txttroca(leditor1.textolin(total), "\n", " "))
      t.dividelin(57, 77)
      leditor1.remove(total)
      leditor1.add(t.ini, t.linhas)
      leditor2.linha = leditor1.linha + t.linhas - 1
      se total == 1
        msg("Uma linha embelezada")
      senao
        msg(txt(total) + " linhas embelezadas")
      fimse
    fimse
    ret 1
  casose "bl" # Limpar o texto
    teditor.limpar
    msg("Texto apagado")
    ret 1
  casofim
# Checa número de linha
  uint16 lin
  lin = arg0
  se arg0 == lin
    leditor.linha = lin - 1
    msg(txt(leditor.linha + 1) + " " + leditor.texto)
    ret 1
  fimse
# Opção desconhecida
  msg("Opção desconhecida: " + txt(arg0, 0, 1))
  msg("Editando " + arg2 + ", O opções, Z sair")
  ret 1

const m_editor = "\b\c3Comandos do editor\b\n\
\c2I\b  Informações sobre a linha atual, quantidade de linhas, etc.\n\
\c2T\b  Informações sobre a área de transferência e o bloco marcado\n\
\c2L\b  Mostra a linha atual\n\
\c2S\b  seguido ou não de um número: Sobe uma ou mais linhas no texto\n\
\c2D\b  seguido ou não de um número: Desce uma ou mais linhas no texto\n\
\c2Um número qualquer:\b  Vai para a linha correspondente\n\
As linhas começam em 1; um número bem grande, vai para o fim do texto\n\
\c2Um ponto seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior\n\
A linha atual avança automaticamente\n\
\c2Uma vírgula seguido de um texto:\b\n\
Insere um texto entre a linha atual e a anterior, sem remover espaços\n\
Exemplo: vírgula seguido de dois espaços e a letra A insere uma linha\n\
que contém dois espaços e a letra A\n\
\c2A\b  Apaga a linha atual\n\
\c2P\b  seguido de um texto: Procura um texto a partir da linha atual\n\
\c2P\b  Procura a próxima linha que contém o texto\n\
\c2E\b  Embeleza o texto, formatando em até 77 caracteres por linha\n\
\c2C\b  Mostra o texto com as definições de cores\n\
\c2M\b  seguido de um texto: Executa um comando do MUD sem sair da edição\n\
\c2X\b  Salva o texto\n\
\c2Z\b  Encerra a edição\n\
\c2BI\b  Marca início do bloco na linha atual\n\
\c2BF\b  Marca fim de bloco na linha atual\n\
\c2BA\b  Apaga bloco marcado\n\
\c2BC\b  Copia bloco para a área de transferência\n\
\c2BX\b  Move bloco para a área de transferência\n\
\c2BV\b  Insere texto da área de transferência entre a linha atual e a anterior\n\
\c2BE\b  Embeleza o bloco marcado\n\
\c2BL\b  Apaga todo o texto sendo editado"

func infosala # Retorna 1 se pode ser editado como variável tipo "const x = $s_abc"
# arg0=nome da classe, arg1=nome da variável
  prog p
  se p.existe(arg0, arg1) != 1 || !p.inilinha(arg0, arg1)
    ret 1
  senao txt1(p.texto) != "const"
    ret 0
  senao txt(p.texto, 6, inttotal(arg1) + 6) != arg0 + " = $s_"
    ret 0
  senao txtproc(txtsepara("x" + txt(txtsub(p.texto, 3), 3), "LD+EO")) >= 0
    ret 0
  senao
    ret 1


classe admmudou
# Chama uma função de todos os objetos de uma determinada classe
# Modo de usar:
# criar("admmudou", <nome da classe>, <nome da função>)
intexec repete
txt100 nomefunc
listaobj l
ref r

func ini
  repete = 1, nomefunc = arg1
  epara r = $[arg0], r, r = objdepois(r)
    l.addfim(r)
  efim

func repete_exec
  ret !l, apagar(este)
  repete = 1, r = l.objini, l.ini.remove, r.[nomefunc]


classe adm_econfig
# Vide arquivo mud.txt, tópico "Criando menus de edição (administração)"
const titulo = "Configurações do MUD"
#
const nome1 = "Jogar localmente            "
const info1 = "Jogar na própria janela que o IntMUD abre\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo1 = "simnao--"
const classe1 = "config"
const var1 = "modolocal"
#
const nome2 = "Jogar em uma porta          "
const info2 = "Terá efeito na próxima vez que o MUD for ativado"
const tipo2 = "opcao--"
const classe2 = "config"
const var2 = "modoserv"
const extra2 = "Não\nTelnet\nTelnet e Papovox"
#
const nome3 = "Endereço do MUD             "
const info3 = "Para ativar em um endereço específico"
const tipo3 = "texto--"
const classe3 = "config"
const var3 = "servender"
#
const nome4 = "Porta do MUD                "
const info4 = "Nota: o programa Papovox só se conecta na porta 1963\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo4 = "numero--"
const classe4 = "config"
const var4 = "servporta"
#
const nome5 = "Limite de conexões por IP   "
const tipo5 = "numero--"
const classe5 = "config"
const var5 = "servusr"
#
const nome6 = "Tempo entre duas conexões   "
const info6 = "Quantos décimos de segundo para poder conectar-se novamente pelo mesmo IP"
const tipo6 = "numero--"
const classe6 = "config"
const var6 = "servtempo"
#
const nome7 = "Jogar em um chat            "
const info7 = "Somente em chats que suportam bots\n\
Terá efeito na próxima vez que o MUD for ativado"
const tipo7 = "simnao--"
const classe7 = "config"
const var7 = "modobot"
#
const nome8 = "Endereço do chat            "
const tipo8 = "linha--"
const classe8 = "config"
const var8 = "serv"
#
const nome9 = "Porta do chat               "
const tipo9 = "numero--"
const classe9 = "config"
const var9 = "porta"
#
const nome10 = "Sala do chat                "
const tipo10 = "linha--"
const classe10 = "config"
const var10 = "sala"
#
const nome11 = "Senha da sala do chat       "
const info11 = "Se for vazia, o programa pede a senha antes de conectar\n\
Se não for vazia, outros administradores poderão ver a senha"
const tipo11 = "linha--"
const classe11 = "config"
const var11 = "senha"
#
const nome12 = "Senha de administração      "
const info12 = "Se vazia, ninguém poderá ser administrador do MUD"
const tipo12 = "linha--"
const classe12 = "config"
const var12 = "senhaadm"
#
const nome13 = "Mensagem de apresentação    "
const info13 = "Primeira mensagem que o jogador recebe ao entrar no MUD"
const tipo13 = "texto--"
const classe13 = "config"
const var13 = "apres"
#
const nome14 = "Sala inicial                "
const info14 = "Sala onde os jogadores vão após criar o personagem"
const tipo14 = "sala--"
const classe14 = "config"
const var14 = "salaini"
#
const nome15 = "Sala quando morre           "
const tipo15 = "sala--"
const classe15 = "config"
const var15 = "salafim"
#
const nome16 = "Sala para continuar jogo salvo"
const info16 = "Se acontecer do jogador cair em uma sala inexistente"
const tipo16 = "sala--"
const classe16 = "config"
const var16 = "salasav"
#
const nome17 = "Animais para batalhar       "
const info17 = "Quantos animais pode usar em batalha"
const tipo17 = "numero--"
const classe17 = "config"
const var17 = "animal1"
const extra17 = "1 8"
#
const nome18 = "Salvar personagem ao criar  "
const tipo18 = "simnao--"
const classe18 = "config"
const var18 = "salvacria"
#
const nome19 = "Tipo de ataque              "
const tipo19 = "opcao--"
const classe19 = "config"
const var19 = "atktipo"
const extra19 = "Manual\nAutomático com a classe comando_atkauto"
#
const nome20 = "Quando alguém entra avisar  "
const info20 = "Quem deve ser informado quando um jogador entra ou sai"
const tipo20 = "opcao--"
const classe20 = "config"
const var20 = "entrainfo"
const extra20 = "Ninguém\nSomente administradores\nTodos"
#

func nome21
  se config:atktipo
    ret "Tempo para finalizar batalha"
  senao
    ret "Tempo de um turno           "

func info21
  se config:atktipo
    ret "Em décimos de segundo; tempo para chegar a primeira mensagem"
  senao
    ret "Em décimos de segundo"

const tipo21 = "numero--"
const classe21 = "config"
const var21 = "atktempo"
const extra21 = "10 200"
#
const nome22 = "Escolher nível na área 'casa'"
const info22 = "É uma opção que fica na sala casa003, \"Passagem\""
const tipo22 = "simnao--"
const classe22 = "config"
const var22 = "escolhenivel"
