classe comum_item
herda comum_persoitem
# Itens
const item = 1 # Para identificar que é item
const msexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "sem nome"
const ident = nome
const descnome = nome
const descpos = txtcopiamai(descnome, "A") + " está aqui."
const objsav = 1 # Se deve salvar o item ao salvar personagem do jogador
sav uint16 pnivel # Nível atual (personagens de nível mais baixo não vestem)
sav uint8 vestpos # Em que posição está vestindo, 0=nenhuma
#
# Ordem que deve organizar as constantes:
const admordem = "nome\n\
ident\n\
descnome\n\
descpos\n\
descver\n\
descident\n\
msexo\n\
nivel\n\
armamanual\n\
armamax\n\
armamin\n\
armaprecisao\n\
armatipo\n\
f_tipo\n\
f_bebida\n\
f_fome\n\
f_sede\n\
f_diges\n\
f_magia1 f_magia2 f_magia2\n\
f_msgperso f_msgoutros\n\
f_nivel1 f_nivel2 f_nivel3\n\
f_remove\n\
i_captura\n\
i_chave\n\
i_movel\n\
i_lugar\n\
i_abertoini\n\
i_tranc\n\
i_fechadura\n\
luzfim\n\
luzitem\n\
luzini\n\
luzliga\n\
luztxt\n\
mantersala\n\
objmax\n\
pesoobj\n\
tipoitem\n\
valor\n\
vestir1\n\
vestirnao\n\
vestirsim\n\
volexp\n\
volmax\n\
volobj\n\
inivar\n\
eveste\n\
evperso\n\
evitem\nevsala"

func ini # Objeto foi criado (arg0=dono, arg1=nível)
  se arg2 || inivar
    textotxt t
    epara t.addfim(txttroca(txt(arg2) + "\n" + inivar, ",", "\n")), t.linhas, var.mudar(t.remove)
    efim
  fimse
  i_aberto = i_abertoini, luztempo = luzini
  pnivel = arg1 ? arg1 : nivel, comum_obj:ini
  cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)
  epara nulo, var.ini("e_"), var.mudar(var.ini("e_"))
    criar(var.ini("e_"), este, var.valor(var.ini("e_")))
  efim
  recalc_exec

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  mdono(arg0), cmd_mudadono
  ret este

func recalc_exec # Ajusta variáveis
  bitver = 17, bitinv = 3, atribs.limpar, cmd_recalc1(este), atribs_exec

func recalc_ajusta # Ajusta variáveis quando algum atributo foi mudado
  dono.perso && (dono.recalc = 1)

func vestir # Veste o item, arg0=posição
  dono.recalc = 1 # Para recalcular atributos
  idono.remove, vestpos = arg0
  se vestpos
    idono = dono.dentro2.addfim(este)
    vestpos == 50 && (dono.iempu = idono)
  senao
    idono = dono.dentro1.addfim(este)

const apagar = apagar(este), mdono(nulo) # Apaga o item (arg0 = quantidade)


classe comum_itemgrupo
herda comum_item
# Itens mais simples:
# Quando houver mais de um em um mesmo lugar, eles são agrupados em um
# único objeto. A única exceção é quando forem vestidos (não são agrupados).
const item = 2 # Para identificar que é item
const pnivel = nivel
sav uint16 objtot # Quantidade de itens

func objproc # Procura um objeto do mesmo tipo em uma listaobj
# Objetivo: saber se pode agrupar objetos
# arg0 = variável listaobj
# Retorna: o objeto correspondente ou nulo se não houver
  ret arg0.objini(este)

func ini # Objeto foi criado (arg0=dono, arg1=quantidade)
  objtot = arg1
  !objtot && (objtot = 1) # Garante pelo menos um item
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0, objtot)
  recalc_exec

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  ret !ref(arg0) || 0 >= arg1, nulo
  ref r
  r = objproc(arg0.dentro1) # r = objeto no novo dono
  se objtot > arg1 # Se não vai mover tudo
    objtot -= arg1, ajustapeso
    se r
      r.objtot += arg1, r.ajustapeso
      ret r
    senao
      ret criar(este, arg0, arg1)
    fimse
  senao r # Se já existe objeto no destino
    r.objtot += arg1, r.ajustapeso
    apagar(este), mdono(nulo)
    ret r
  senao # Senão, apenas muda o dono
    mdono(arg0), cmd_mudadono
    ret este
  fimse

func vestir # Veste o item, arg0=posição
  uint8 pos
  pos = arg0
  se !pos # Checa se deve remover
    ret !vestpos, nulo # Retorna se não está vestindo
    dono.recalc = 1 # Para recalcular atributos
    refvar r = objproc(dono.dentro1) # Procura objeto que não está vestindo
    se r # Encontrou: aumenta a quantidade
      r.objtot += 1, r.ajustapeso, apagar(este), mdono(nulo)
    senao # Não encontrou: move
      vestpos = 0, idono.remove, idono = dono.dentro1.addfim(este)
    fimse
  senao vestpos || objtot <= 1 # Se já está vestindo ou só tem um objeto
    dono.recalc = 1 # Para recalcular atributos
    vestpos = pos
    idono.remove, idono = dono.dentro2.addfim(este)
    vestpos == 50 && (dono.iempu = idono)
  senao # Tem mais de um objeto, cria objeto e veste
    dono.recalc = 1 # Para recalcular atributos
    objtot -= 1, ajustapeso
    refvar r = criar(este)
    r.mdono(dono), r.vestpos = pos
    r.idono.remove, r.idono = dono.dentro2.addfim(r)
    pos == 50 && (r.dono.iempu = r.idono)
  fimse

func apagar # Apaga o item (arg0 = quantidade)
  se !(objtot -= arg0)
    apagar(este), mdono(nulo)


classe comum_itemperso
herda comum_item
# Itens completos
const item = 3 # Para identificar que é item
listaobj persolugar # Quem está sentado ou deitado
# const i_abertoini = 0 # Valor inicial de aberto
sav uint8 i_aberto # Situação atual do container, ou 0 se não for container
const luztipo = intpos(luztempo) ? 2 : 0
sav inttempo luztempo # Quanto tempo produz luz, <0 se estiver apagado
# const luzitem = 0 # Tipo de luz
# const luzini = 1000 # Duração da luz
# const luztxt = "" # Mensagem quando a luz acaba
# const luzfim = 0 # Se item some quando a luz acaba
const luzliga = "$P acende $o."

func fim # Objeto foi apagado
  persolugar.limpar, comum_obj:fim

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  persolugar.limpar, mdono(arg0), cmd_mudadono
  ret este

func recalc_exec # Acerta variáveis do item
  bitver = 17, bitinv = luztempo ? 1 : 3, atribs.limpar, cmd_recalc1(este)
  int(i_abertoini) < 2 || i_aberto < 2 ? (i_aberto = i_abertoini)
  atribs_exec
  se int(luzitem) != 7 # Se não acende ao vestir
  senao vestpos && luztempo < 0 # Vestiu: acende
    luztempo.pos, ajustapeso
# $mens.p(arg0, nulo, r)
# $mens.mvis1(r.luzliga ? r.luzliga : "$P acende $o.")
    listaobj l
    epara l.addfim(dono.evento, evento), l, l.ini.remove
      ret l.objini.cmd_acendeu(dono, este), nulo
    efim
  senao !vestpos && luztempo > 0 # Removeu: apaga
    luztempo.neg, ajustapeso
    listaobj l
    epara l.addfim(dono.evento, evento), l, l.ini.remove
      ret l.objini.cmd_apagou(dono, este), nulo
    efim
  fimse
  se intpos(luztempo) > 0
    textopos p
    p = atribs.ini, p.txtproc("\nBrilhando\n", 0) >= 0 && p.remove
    atribs.addini("Aceso")

func luztempo_exec # A luz apagou
  se luztxt
    ref r
    epara r = dono, r.perso, r = r.dono
    efim
    r.msg(luztxt)
  fimse
  luzfim ? apagar(este) : ajustapeso + recalc_exec

func vestir # Veste o item, arg0=posição
  luzitem == 7 && (recalc = 1) # Para acender ou apagar o item
  dono.recalc = 1 # Para recalcular atributos
  idono.remove, vestpos = arg0
  se vestpos
    idono = dono.dentro2.addfim(este)
    vestpos == 50 && (dono.iempu = idono)
  senao
    idono = dono.dentro1.addfim(este)


classe comum_corpo
herda comum_item
# Corpo de um personagem que morreu
const i_aberto = 1 # Para indicar que é container (sempre aberto)
uint32 pesoobj # Peso do objeto (em gramas)
uint32 volobj # Volume do objeto quando estiver vazio
const volmax = 0 # Para não poder colocar nada no corpo
const msexo = 1 # Sexo: 0=feminino, 1=masculino
const nome = "corpo"
txt100 descnome
txt100 ident
inttempo tempo

func ini
# arg0 = personagem que morreu
# arg1 = verdadeiro se deve transferir os itens do personagem que morreu
  tempo = 1200, volobj = arg0.volobj, pesoobj = arg0.pesoobj
  descnome = arg0.descnome
  se txt2(descnome)
    casovar txtmin(txt1(descnome))
    casose "o"
    casose "a"
    casose "os"
    casose "as"
      descnome = "O corpo d" + txtmin(txt1(descnome)) + " " + txt2(descnome)
      sair
    casose
      descnome = "O corpo de " + descnome
    casofim
  senao
    descnome = "O corpo de " + descnome
  fimse
  ident = "corpo " + arg0.ident
  comum_obj:ini
  arg0.dono && mudadono(arg0.dono)
  recalc_exec
  se arg1
    var.z_moedas = arg0.var.z_moedas
    listaobj l
    epara l.addfim(arg0.dentro1, arg0.dentro2), l, l.ini.remove
      l.objini.item && l.objini.mudadono(este, 100000)
    efim
    se var.z_moedas
      $mens.p(arg0)
      se dentro1.total
        $mens.mvis2("", "Você nota alguns itens e moedas em " + descnome + ".")
      senao
        $mens.mvis2("", "Você nota algumas moedas em " + descnome + ".")
      fimse
    senao dentro1.total
      $mens.p(arg0)
      $mens.mvis2("Você nota alguns itens em " + descnome + ".")
    fimse

func tempo_exec
  dono.msg(txtcopiamai(descnome, "A") + " se decompôs totalmente.")
  este.apagar(100000)
