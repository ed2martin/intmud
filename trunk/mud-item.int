classe comum_item
herda comum_persoitem
# Itens
const item = 1 # Para identificar que é item
const sexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "sem nome"
const ident = nome
const descpos = txtmaimin(nome) + " está aqui."
const jogsav = 1 # Se deve salvar o item ao salvar personagem do jogador
sav uint16 pnivel # Nível atual (apenas para mostrar ao jogador)
sav uint8 vestpos # Em que posição está vestindo, 0=nenhuma

func ini # Objeto foi criado (arg0=dono, arg1=nível)
  se arg2 || inivar
    textotxt t
    epara t.addfim(txttroca(txt(arg2) + "\n" + inivar, ",", "\n")), t.linhas, var.mudar(t.remove)
    efim
  fimse
  i_aberto = i_abertoini, luztempo = luzini
  pnivel = arg1 ? arg1 : nivel, comum_obj:ini
  cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)
  epara nulo, var.ini("e_"), var.mudar(var.ini("e_"))
    criar(var.ini("e_"), este, var.valor(var.ini("e_")))
  efim
  recalc_exec

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  dono = arg0, cmd_mudadono

func vestir # Veste o item, arg0=posição
  dono.recalc = 1 # Para recalcular atributos
  ref r
  r = dono, idono.remove, vestpos = arg0
  se vestpos
    idono = r.dentro2.addfim(este)
    vestpos == 30 && (r.iempu.0 ? r.iempu.1 : r.iempu.0 = idono)
  senao
    idono = r.dentro1.addfim(este)

const apagar = dono = nulo, apagar(este) # Apaga o item (arg0 = quantidade)


classe comum_itemgrupo
herda comum_item
# Itens mais simples:
# Quando houver mais de um em um mesmo lugar, eles são agrupados em um
# único objeto. A única exceção é quando forem vestidos (não são agrupados).
const item = 2 # Para identificar que é item
const pnivel = 0
sav uint8 objtot # Quantidade de itens

func objproc # Procura um objeto do mesmo tipo em uma listaobj
# Objetivo: saber se pode agrupar objetos
# arg0 = variável listaobj
# Retorna: o objeto correspondente ou nulo se não houver
  ret arg0.objini(este)

func ini # Objeto foi criado (arg0=dono, arg1=quantidade)
  objtot = arg1
  !objtot && (objtot = 1) # Garante pelo menos um item
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0, objtot)
  recalc_exec

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  ret !ref(arg0) || 0 >= arg1, nulo
  ref r
  r = objproc(arg0.dentro1) # r = objeto no novo dono
  se objtot > arg1 # Se não vai mover tudo
    se r
      r.objtot += arg1, r.ajustapeso
    senao
      criar(este, arg0, arg1)
    fimse
    objtot -= arg1, ajustapeso
  senao r # Se já existe objeto no destino
    r.objtot += arg1, r.ajustapeso
    dono = nulo, apagar(este)
  senao # Senão, apenas muda o dono
    dono = arg0, cmd_mudadono
  fimse

func vestir # Veste o item, arg0=posição
  uint8 pos
  pos = arg0
  se !pos # Checa se deve remover
    ret !vestpos, nulo # Retorna se não está vestindo
    dono.recalc = 1 # Para recalcular atributos
    ref r
    r = objproc(dono.dentro1) # Procura objeto que não está vestindo
    se r # Encontrou: aumenta a quantidade
      r.objtot += 1, r.ajustapeso, dono = nulo, apagar(este)
    senao # Não encontrou: move
      vestpos = 0, r = dono, idono.remove, idono = r.dentro1.addfim(este)
    fimse
  senao vestpos || objtot <= 1 # Se já está vestindo ou só tem um objeto
    dono.recalc = 1 # Para recalcular atributos
    vestpos = pos
    ref r
    r = dono, idono.remove, idono = r.dentro2.addfim(este)
    vestpos == 30 && (r.iempu.0 ? r.iempu.1 : r.iempu.0 = idono)
  senao # Tem mais de um objeto, cria objeto e veste
    dono.recalc = 1 # Para recalcular atributos
    objtot -= 1, ajustapeso
    ref r
    r = criar(este)
    r.dono = dono, r.vestpos = pos
    r.idono.remove, r.idono = dono.dentro2.addfim(r)
    vestpos == 30 && (r.iempu.0 ? r.iempu.1 : r.iempu.0 = idono)
  fimse

func apagar # Apaga o item (arg0 = quantidade)
  se !(objtot -= arg0)
    dono = nulo, apagar(este)


classe comum_itemperso
herda comum_item
# Itens completos
const item = 3 # Para identificar que é item
listaobj persolugar # Quem está sentado ou deitado
# const i_abertoini = 0 # Valor inicial de aberto
sav uint8 i_aberto # Situação atual do container, ou 0 se não for container
const luztipo = intpos(luztempo) ? 2 : 0
sav inttempo luztempo # Quanto tempo produz luz, <0 se estiver apagado
# const luzitem = 0 # Tipo de luz
# const luzini = 1000 # Duração da luz
# const luztxt = "" # Mensagem quando a luz acaba
# const luzfim = 0 # Se item some quando a luz acaba
const luzliga = "$P acende $o."

func fim # Objeto foi apagado
  persolugar.limpar, comum_obj:fim

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  persolugar.limpar, dono = arg0, cmd_mudadono

func recalc_exec # Acerta variáveis do item
  bitver = 1, bitinv = luztempo ? 1 : 3, cmd_recalc1(este)
  se int(i_abertoini) < 2 || i_aberto < 2
    i_aberto = i_abertoini

func luztempo_exec # A luz apagou
  se luztxt
    ref r
    epara r = dono, r.perso, r = r.dono
    efim
    r.msg(luztxt)
  fimse
  luzfim ? apagar(este) : ajustapeso + recalc_exec

func atribs # Retorna texto com os atributos do item ou personagem
  ret intpos(luztempo) ? "(aceso) " : bitinv & 2 ? "" : "(brilhando) "
