classe comum_item
herda comum_obj
# Itens
const bitinv = 3 # Grau de invisibilidade do personagem/item
const item = 1 # Para identificar que é item
const sexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "item"
const ident = txts(nome)
const descpos = txtmaimin(nome) + " está aqui."
const descver = "Você não vê nada de especial."
const jogsav = 1 # Se deve salvar o item ao salvar personagem do jogador
sav uint32 vestpos # Em que posição está vestindo, 0=nenhuma
# const abertoini = 0 # Valor inicial de aberto
# uint8 aberto # 0=não é container, 1=está sempre aberto
# 2=está aberto, 3=está fechado, 4=está trancado

func ini # Objeto foi criado (arg1 = quantidade)
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)

func fim # Objeto foi apagado
  ref r
  r = dono, comum_obj:fim, cmd_fim(r)

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  cmd_mudadono(arg0), dono = arg0

func vestir # Veste o item, arg0=posição
  dono.recalc = 1 # Para recalcular atributos
  ref r
  r = dono, idono.remove, vestpos = arg0
  se vestpos
    idono = r.dentro2.addfim(este)
  senao
    idono = r.dentro1.addfim(este)


classe comum_itemgrupo
herda comum_item
# Itens mais simples:
# Quando houver mais de um em um mesmo lugar, eles são agrupados em um
# único objeto. A única exceção é quando forem vestidos (não são agrupados).
sav uint8 objtot # Quantidade de itens

func objproc # Procura um objeto do mesmo tipo em uma listaobj
# Objetivo: saber se pode agrupar objetos
# arg0 = variável listaobj
# Retorna: o objeto correspondente ou nulo se não houver
  ret arg0.objini(este)

func ini # Objeto foi criado (arg0=dono, arg1=quantidade)
  objtot = arg1
  !objtot && (objtot = 1) # Garante pelo menos um item
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0, objtot)

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  ret !ref(arg0) || 0 >= arg1, nulo
  ref r
  r = objproc(arg0.dentro1) # r = objeto no novo dono
  se objtot > arg1 # Se não vai mover tudo
    se r
      r.objtot += arg1, r.ajustapeso
    senao
      criar(este, arg0, arg1)
    fimse
    objtot -= arg1, ajustapeso
  senao r # Se já existe objeto no destino
    r.objtot += arg1, r.ajustapeso
    apagar(este)
  senao # Senão, apenas muda o dono
    cmd_mudadono(arg0), dono = arg0
  fimse

func vestir # Veste o item, arg0=posição
  uint8 pos
  pos = arg0
  se !pos # Checa se deve remover
    ret !vestpos, nulo # Retorna se não está vestindo
    dono.recalc = 1 # Para recalcular atributos
    ref r
    r = objproc(dono.dentro1) # Procura objeto que não está vestindo
    se r # Encontrou: aumenta a quantidade
      r.objtot += 1, r.ajustapeso, apagar(este)
    senao # Não encontrou: move
      vestpos = 0, r = dono, idono.remove, idono = r.dentro1.addfim(este)
    fimse
  senao vestpos # Se já está vestindo, muda a posição
    dono.recalc = 1 # Para recalcular atributos
    vestpos = pos
  senao objtot <= 1 # Se tem só um objeto, veste
    dono.recalc = 1 # Para recalcular atributos
    vestpos = pos
    ref r
    r = dono, idono.remove, idono = r.dentro2.addfim(este)
  senao # Tem mais de um objeto, cria objeto e veste
    dono.recalc = 1 # Para recalcular atributos
    objtot -= 1, ajustapeso
    ref r
    r = criar(este)
    r.dono = dono, r.vestpos = pos
    r.idono.remove, r.idono = dono.dentro2.addfim(r)
  fimse


classe comum_itemperso
herda comum_item
# Itens em que personagens podem sentar-se e deitar-se
listaobj persolugar # Quem está sentado ou deitado
const i_perso = 1 # 1=pode sentar, 2=pode sentar e deitar
const i_lugar = 1 # Quantos personagens podem sentar
# Cada personagem deitado ocupa três vagas de i_lugar

func ini # Objeto foi criado (arg1 = quantidade)
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)

func fim # Objeto foi apagado
  ref r
  persolugar.limpar, r = dono, comum_obj:fim, cmd_fim(r)

func mudadono # Item muda de dono (arg0 = novo dono, arg1 = quantidade)
  persolugar.limpar, cmd_mudadono(arg0), dono = arg0
