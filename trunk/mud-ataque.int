classe adm_atk
# Comandos de habilidades e magias, geralmente ataques
#
const adm_hab = "\b\c3Habilidades e magias\b\n\
\c2LHAB\b [nome]\n\
\c2LMAG\b [nome]\n\
  Lista habilidades ou magias que começam com o nome especificado.\n\
\c2CHAB\b <nome>\n\
\c2CMAG\b <nome>\n\
  Cria uma habilidade ou magia. Nome deve ser o nome da habilidade ou\n\
  magia, e deve ser composto de letras, mas pode ter espaços no meio.\n\
\c2EHAB\b <nome>\n\
\c2EMAG\b <nome>\n\
  Edita uma habilidade ou uma magia.\n\
\c2AHAB\b <nome>\n\
\c2AMAG\b <nome>\n\
  Apaga uma habilidade ou uma magia."

func cmd_lhab # Listar habilidades
  prog p
  textotxt t
  txt100 lin
  epara p.iniclasse("cmd_"), p.lin && t.linhas < 499, p.depois
    continuar !$[p.texto].cmdmenu # Continua se não é uma habilidade
    lin = txtcopiamai(txt2(txte(p.texto)), "A") + ", "
    se $[p.texto].tipoalvo < 6
      lin += txtsublin(config:atknomes, $[p.texto].tipoatk, 1)
    fimse
    casovar $[p.texto].tipoalvo
    casose "1"
      lin += ", Outros"
      sair
    casose "2"
      lin += ", Todos dividindo ataque"
      sair
    casose "3"
      lin += ", Outros dividindo ataque"
      sair
    casose "4"
      lin += ", Todos sem dividir ataque"
      sair
    casose "5"
      lin += ", Outros sem dividir ataque"
      sair
    casose "6"
      lin += "Não agressivo"
      sair
    casose "7"
      lin += "Não agressivo, O próprio"
      sair
    casose "8"
      lin += "Automático"
      sair
    casose "9"
      lin += "Nenhum"
      sair
    casofim
    t.addfim(lin)
  efim
  se t.linhas
    msg2("\b\c6Habilidade, Tipo, Alvo\b\n" + t.remove(500))
  senao
    msg("\bNenhuma habilidade encontrada.")
  fimse
  ret 1

func cmd_lmag # Listar magias
  prog p
  textotxt t
  txt100 lin
  epara p.iniclasse("magia_"), p.lin && t.linhas < 499, p.depois
    continuar !$[p.texto].cmdmenu # Continua se não é uma magia editável
    lin = txtcopiamai(txt2(txte(p.texto)), "A") + ", "
    se $[p.texto].tipoalvo < 6
      lin += txtsublin(config:atknomes, $[p.texto].tipoatk, 1)
    fimse
    casovar $[p.texto].tipoalvo
    casose "1"
      lin += ", Outros"
      sair
    casose "2"
      lin += ", Todos dividindo ataque"
      sair
    casose "3"
      lin += ", Outros dividindo ataque"
      sair
    casose "4"
      lin += ", Todos sem dividir ataque"
      sair
    casose "5"
      lin += ", Outros sem dividir ataque"
      sair
    casose "6"
      lin += "Não agressivo"
      sair
    casose "7"
      lin += "Não agressivo, O próprio"
      sair
    casose "8"
      lin += "Automático"
      sair
    casose "9"
      lin += "Nenhum"
      sair
    casofim
    t.addfim(lin)
  efim
  se t.linhas
    msg2("\b\c6Magia, Tipo, Alvo\b\n" + t.remove(500))
  senao
    msg("\bNenuma magia encontrada.")
  fimse
  ret 1

func cmd_chab # Criar habilidade
  prog p
  txt80 nome
  uint16 num
# Checa se digitou nome do ataque
  se arg0 == ""
    msg("Tecle o nome da habilidade após CHAB")
    ret 1
  fimse
# Checa se nome válido
  nome = txte(txtremove(arg0, EMDSA))
  se txtsepara(nome, "DO+DOL,DOL+DO") != nome
    msg("Nome inválido para habilidade: " + nome)
    ret 1
  senao p.existe("cmd_" + nome)
    msg("Já existe o comando: " + nome)
    ret 1
  senao p.existe("soc_" + nome)
    msg("Já existe o comando social: " + nome)
    ret 1
  fimse
# Pergunta que tipo de habilidade criar
  var.opcclasse = "cmd_" + txts(txtmin(nome))
  var.opcvar = "h_" + txtcopiamai(txte(nome), "A")
  var.opctipo = "habilidade"
  ret p_chab("\b")

func cmd_cmag # Criar magia
  prog p
  txt80 nome
  uint16 num
# Checa se digitou nome do ataque
  se arg0 == ""
    msg("Tecle o nome da magia após CMAG")
    ret 1
  fimse
# Checa se nome válido
  nome = txte(txtremove(arg0, EMDSA))
  se txtsepara(nome, "DO+DOL,DOL+DO") != nome
    msg("Nome inválido para magia: " + nome)
    ret 1
  senao p.existe("magia_" + nome)
    msg("Já existe a magia: " + nome)
    ret 1
  fimse
# Pergunta que tipo de magia criar
  var.opcclasse = "magia_" + txts(txtmin(nome))
  var.opcvar = "m_" + txtcopiamai(txte(nome), "A")
  var.opctipo = "magia"
  ret p_chab("\b")

func p_chab # Escolher o tipo de habilidade ou magia
  txt40 deriv
  casovar txtmin(arg0)
  casose
    msg("Opção inválida")
  casose "\b"
  casose ""
    passo = "chab"
    msg("Entre com o tipo de " + var.opctipo + ", O mostra as opções, Z cancela")
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = "", var.opcclasse = "", var.opcnome = "", var.opctipo = ""
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim("C Habilidade ou magia comum")
    txtmais.addfim("I Identificar")
    txtmais.addfim("R Retornar")
    txtmostra
    ret 1
  casose "c"
    deriv = "comando_ataque"
    sair
  casose "i"
    deriv = "comando_identificar"
    sair
  casose "r"
    deriv = "comando_retornar"
    sair
  casofim
# Cria habilidade ou magia
  txt512 lin
  lin = var.opcclasse + "\nb-hab\nherda " + deriv
  lin += "\nconst nomevar = \"" + var.opcvar + "\""
  lin += "\nconst msgatk0 = \"\\n\\n\\n$P ataca $a, $m\\n\\n$P ataca $a, $m\\n\\n\\n"
  lin += "$P ataca e mata $a, $m\\n\\n\\n$P ataca $a, errou\\n\\n\\n"
  lin += "$P ataca $a, nada acontece\\n\\n\\n\""
  prog p
  p.criar(lin)
  criar("admordena", "b-hab")
# config:salvar
  msg("\bCriou " + var.opctipo + ": " + txt(var.opcvar, 2))
  admlog("criou " + var.opctipo + " " + txt(var.opcvar, 2))
  passo = "", var.opcclasse = "", var.opcnome = "", var.opctipo = ""
  ret 1

func cmd_ahab # Apagar habilidade
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes de habilidades após AHAB")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("cmd_" + txtsub(arg0, x, 1))
      msg("Habilidade não existe: " + txtsub(arg0, x, 1))
      ret 1
    senao !$cmd_[txtsub(arg0, x, 1)].cmdmenu
      msg("Comando não é uma habilidade: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_ahab
  ret 1

func p_ahab # Confirmar que quer apagar habilidade
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("cmd_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Habilidade apagada: " + tpasso)
      admlog("apagou habilidade " + tpasso)
    senao
      msg("Habilidades apagados: " + tpasso)
      admlog("apagou habilidades " + tpasso)
    fimse
  senao
    passo = "ahab"
    refvar m1 = txt2(tpasso) ? "habilidades" : "habilidade"
    msg("Apagar " + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_amag # Apagar magia
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes de magias após AMAG")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("magia_" + txtsub(arg0, x, 1))
      msg("Magia não existe: " + txtsub(arg0, x, 1))
      ret 1
    senao !$magia_[txtsub(arg0, x, 1)].cmdmenu
      msg("Magia não pode ser apagada: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_amag
  ret 1

func p_amag # Confirmar que quer apagar magia
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("magia_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Magia apagada: " + tpasso)
      admlog("apagou magia " + tpasso)
    senao
      msg("Magias apagadas: " + tpasso)
      admlog("apagou magias " + tpasso)
    fimse
  senao
    passo = "amag"
    refvar m1 = txt2(tpasso) ? "magias" : "magia"
    msg("Apagar " + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_ehab # Editar habilidade
  prog p
  se arg0 == ""
    msg("Tecle o nome da habilidade após EHAB")
  senao !p.existe("cmd_" + arg0)
    msg("Habilidade não existe: " + arg0)
  senao !$cmd_[arg0].cmdmenu
    msg("Comando não é uma habilidade: " + arg0)
  senao
    var.classe1 = "cmd_" + txts(txtmin(arg0))
    var.menufim = "menu_hab_" + $cmd_[arg0].cmdmenu
    m_menu(var.menufim)
  fimse
  ret 1

func cmd_emag # Editar magia
  prog p
  se arg0 == ""
    msg("Tecle o nome da magia após EMAG")
  senao !p.existe("magia_" + arg0)
    msg("Magia não existe: " + arg0)
  senao !$magia_[arg0].cmdmenu
    msg("Comando não é uma magia editável: " + arg0)
  senao
    var.classe1 = "magia_" + txts(txtmin(arg0))
    var.menufim = "menu_magia_" + $magia_[arg0].cmdmenu
    m_menu(var.menufim)
  fimse
  ret 1


classe menu_hab_custo
const titulo = "Consome"
const menufim = var.menufim
const colunas = 25
#
const nome1 = "Tempo de espera"
const info1 = "Tempo mínimo que deve esperar, em décimos de segundo"
const tipo1 = "numero"
const clas1 = var.classe1
const vari1 = "c_espera"
const extr1 = "5 150"
#
const nome2 = "Vida iniciante"
const info2 = "Quantos pontos de vida consome no nível iniciante"
const tipo2 = "numero"
const clas2 = var.classe1
const vari2 = "c_vida1"
#
const nome3 = "Vida perito"
const info3 = "Quantos pontos de vida consome no nível perito"
const tipo3 = "numero"
const clas3 = var.classe1
const vari3 = "c_vida2"
#
const nome4 = "Mana iniciante"
const info4 = "Quantos pontos de mana consome no nível iniciante"
const tipo4 = "numero"
const clas4 = var.classe1
const vari4 = "c_mana1"
#
const nome5 = "Mana perito"
const info5 = "Quantos pontos de mana consome no nível perito"
const tipo5 = "numero"
const clas5 = var.classe1
const vari5 = "c_mana2"
#
const nome6 = "Vigor iniciante"
const info6 = "Quantos pontos de vigor consome no nível iniciante"
const tipo6 = "numero"
const clas6 = var.classe1
const vari6 = "c_move1"
#
const nome7 = "Vigor perito"
const info7 = "Quantos pontos de vigor consome no nível perito"
const tipo7 = "numero"
const clas7 = var.classe1
const vari7 = "c_move2"


classe menu_hab_alvo
const titulo = "Afeta o alvo"
const menufim = var.menufim
const colunas = 25
#
const nome1 = "Condição"
const tipo1 = "opcao"
const clas1 = var.classe1
const vari1 = "a_cond"
const extr1 = "Um ou mais pontos de vida\nNenhum ponto de vida\nNenhuma condição"
#
const nome2 = "Vida"
const info2 = "Quantos pontos de vida ganha"
const tipo2 = "numero"
const clas2 = var.classe1
const vari2 = "a_vida1"
#
const nome3 = "Vida por nível"
const info3 = "Quantos pontos de vida ganha a cada nível"
const tipo3 = "numero"
const clas3 = var.classe1
const vari3 = "a_vida2"
#
const nome4 = "Mana"
const info4 = "Quantos pontos de mana ganha"
const tipo4 = "numero"
const clas4 = var.classe1
const vari4 = "a_mana1"
#
const nome5 = "Mana por nível"
const info5 = "Quantos pontos de mana ganha a cada nível"
const tipo5 = "numero"
const clas5 = var.classe1
const vari5 = "a_mana2"
#
const nome6 = "Vigor"
const info6 = "Quantos pontos de vigor ganha"
const tipo6 = "numero"
const clas6 = var.classe1
const vari6 = "a_move1"
#
const nome7 = "Vigor por nível"
const info7 = "Quantos pontos de vigor ganha a cada nível"
const tipo7 = "numero"
const clas7 = var.classe1
const vari7 = "a_move2"
#
const nome8 = "Nota vida/mana/vigor"
const extr8 = "Os valores de vida, mana e vigor são para o nível itermediário.\n\
Eles podem diminuir em até 50% (iniciante) ou aumentar em até 50% (perito)."
#
const nome9 = "Efeito 1"
const info9 = "Nome do efeito"
const tipo9 = "linha"
const clas9 = var.classe1
const vari9 = "a_efeito1"
#
const nome10 = "Precisão 1"
const info10 = "Probabilidade de criar o efeito, 100=não falha"
const tipo10 = "numero"
const clas10 = var.classe1
const vari10 = "a_prob1"
const extr10 = "0 100"
#
const nome11 = "Efeito 2"
const info11 = "Nome do efeito"
const tipo11 = "linha"
const clas11 = var.classe1
const vari11 = "a_efeito2"
#
const nome12 = "Precisão 2"
const info12 = "Probabilidade de criar o efeito, 100=não falha"
const tipo12 = "numero"
const clas12 = var.classe1
const vari12 = "a_prob2"
const extr12 = "0 100"
#
const nome13 = "Efeito 3"
const info13 = "Nome do efeito"
const tipo13 = "linha"
const clas13 = var.classe1
const vari13 = "a_efeito3"
#
const nome14 = "Precisão 3"
const info14 = "Probabilidade de criar o efeito, 100=não falha"
const tipo14 = "numero"
const clas14 = var.classe1
const vari14 = "a_prob3"
const extr14 = "0 100"
#
const nome15 = "Remover efeitos"
const info15 = "Efeitos que serão removidos; uma linha por efeito"
const tipo15 = "texto"
const clas15 = var.classe1
const vari15 = "a_remove"


classe menu_hab_msg0
const titulo = "Mensagens 1"
const menufim = var.menufim
const colunas = 25
#
const titu1 = " * Ao usar, exceto poções comidas etc"
#
const nome1 = "Perso"
const tipo1 = "txtlinha"
const clas1 = var.classe1
const vari1 = "msgatk" + txtfim(tpasso, 1)
const extr1 = "0"
#
const nome2 = "Alvo"
const info2 = "Se vazio, pega mensagem da opção 1"
const tipo2 = "txtlinha"
const clas2 = var.classe1
const vari2 = "msgatk" + txtfim(tpasso, 1)
const extr2 = "1"
#
const nome3 = "Outros"
const info3 = "Se vazio, pega mensagem da opção 1"
const tipo3 = "txtlinha"
const clas3 = var.classe1
const vari3 = "msgatk" + txtfim(tpasso, 1)
const extr3 = "2"
#
const titu4 = " * Acertou em si mesmo"
#
const nome4 = "Perso"
const tipo4 = "txtlinha"
const clas4 = var.classe1
const vari4 = "msgatk" + txtfim(tpasso, 1)
const extr4 = "3"
#
const nome5 = "Outros"
const info5 = "Se vazio, pega mensagem da opção 4"
const tipo5 = "txtlinha"
const clas5 = var.classe1
const vari5 = "msgatk" + txtfim(tpasso, 1)
const extr5 = "4"
#
const titu6 = " * Acertou outro personagem"
#
const nome6 = "Perso"
const tipo6 = "txtlinha"
const clas6 = var.classe1
const vari6 = "msgatk" + txtfim(tpasso, 1)
const extr6 = "5"
#
const nome7 = "Alvo"
const info7 = "Se vazio, pega mensagem da opção 6"
const tipo7 = "txtlinha"
const clas7 = var.classe1
const vari7 = "msgatk" + txtfim(tpasso, 1)
const extr7 = "6"
#
const nome8 = "Outros"
const info8 = "Se vazio, pega mensagem da opção 6"
const tipo8 = "txtlinha"
const clas8 = var.classe1
const vari8 = "msgatk" + txtfim(tpasso, 1)
const extr8 = "7"
#
const titu9 = " * Matou o alvo"
#
const nome9 = "Perso"
const tipo9 = "txtlinha"
const clas9 = var.classe1
const vari9 = "msgatk" + txtfim(tpasso, 1)
const extr9 = "8"
#
const nome10 = "Alvo"
const info10 = "Se vazio, pega mensagem da opção 9"
const tipo10 = "txtlinha"
const clas10 = var.classe1
const vari10 = "msgatk" + txtfim(tpasso, 1)
const extr10 = "9"
#
const nome11 = "Outros"
const info11 = "Se vazio, pega mensagem da opção 9"
const tipo11 = "txtlinha"
const clas11 = var.classe1
const vari11 = "msgatk" + txtfim(tpasso, 1)
const extr11 = "10"
#
const titu12 = " * Errou o alvo"
#
const nome12 = "Perso"
const tipo12 = "txtlinha"
const clas12 = var.classe1
const vari12 = "msgatk" + txtfim(tpasso, 1)
const extr12 = "11"
#
const nome13 = "Alvo"
const info13 = "Se vazio, pega mensagem da opção 12"
const tipo13 = "txtlinha"
const clas13 = var.classe1
const vari13 = "msgatk" + txtfim(tpasso, 1)
const extr13 = "12"
#
const nome14 = "Outros"
const info14 = "Se vazio, pega mensagem da opção 12"
const tipo14 = "txtlinha"
const clas14 = var.classe1
const vari14 = "msgatk" + txtfim(tpasso, 1)
const extr14 = "13"
#
const titu15 = " * Não teve efeito"
#
const nome15 = "Perso"
const tipo15 = "txtlinha"
const clas15 = var.classe1
const vari15 = "msgatk" + txtfim(tpasso, 1)
const extr15 = "14"
#
const nome16 = "Alvo"
const info16 = "Se vazio, pega mensagem da opção 15"
const tipo16 = "txtlinha"
const clas16 = var.classe1
const vari16 = "msgatk" + txtfim(tpasso, 1)
const extr16 = "15"
#
const nome17 = "Outros"
const info17 = "Se vazio, pega mensagem da opção 15"
const tipo17 = "txtlinha"
const clas17 = var.classe1
const vari17 = "msgatk" + txtfim(tpasso, 1)
const extr17 = "16"


classe menu_hab_msg1
herda menu_hab_msg0
const titulo = "Mensagens 2"


classe menu_hab_msg2
herda menu_hab_msg0
const titulo = "Mensagens 3"


classe menu_hab_msg3
herda menu_hab_msg0
const titulo = "Mensagens 4"


classe menu_hab_msg4
herda menu_hab_msg0
const titulo = "Mensagens 5"


classe menu_hab_comum
const nome3 = "Precisão"
const info3 = "Em porcentagem, maior que 100 nunca falha"
const tipo3 = "numero"
const clas3 = var.classe1
const vari3 = "precisao"
#
const nome4 = "Requer arma"
const info4 = "Deixar vazio se funciona independente da arma usada."
const tipo4 = "vetor"
const clas4 = var.classe1
const vari4 = "tipoarma"
const extr4 = config:arma_txt
#
const nome5 = "Consome"
const tipo5 = "menu--"
const clas5 = "menu_hab_custo"
#
const nome6 = "Preço da aula"
const info6 = "Quantas moedas os personagens cobram para ensinar"
const tipo6 = "numero"
const clas6 = var.classe1
const vari6 = "valor"
#
const nome7 = "Depende de"
const info7 = "Habilidades, magias e idiomas necessários para aprender esse ataque"
const tipo7 = "tipodep"
const clas7 = var.classe1
const vari7 = "depende"
#
const nome8 = "Iniciante nível"
const info8 = "A partir de que nível pode ter a primeira aula"
const tipo8 = "numero"
const clas8 = var.classe1
const vari8 = "aulaini"
#
const nome9 = "Perito nível"
const info9 = "A partir de que nível pode ter todas as aulas"
const tipo9 = "numero"
const clas9 = var.classe1
const vari9 = "aulafim"
#
const nome10 = "Somente tipos"
const info10 = "Se estiver vazio, todas as classes e raças podem aprender"
const tipo10 = "tipos"
const clas10 = var.classe1
const vari10 = "tipoperso"


classe menu_hab_ataque
herda menu_hab_comum
const titulo = "Hab " + txt(var.classe1, 4)
const colunas = 25
#
const nome1 = "Alvo"
const tipo1 = "opcao"
const clas1 = var.classe1
const vari1 = "tipoalvo"
const extr1 = "Qualquer um; ataque\n\
Exceto o personagem; ataque\n\
Todos dividindo o ataque\n\
Outros dividindo o ataque\n\
Todos sem dividir o ataque\n\
Outros sem dividir o ataque\n\
Qualquer um; não é ataque\n\
O personagem; não é ataque\n\
Ataque automático\n\
Nenhum (não ataca)"
#
#
const nome2 = "Condição"
const tipo2 = "opcao"
const clas2 = var.classe1
const vari2 = "a_batalha"
const extr2 = "Nenhuma\nDurante a batalha\nFora da batalha"
#
const nome11 = "Afeta o alvo"
const tipo11 = "menu--"
const clas11 = "menu_hab_alvo"
#
const titu12 = " * Ataque"
#
const nome12 = "Tipo"
const tipo12 = "opcao"
const clas12 = var.classe1
const vari12 = "tipoatk"
const extr12 = config:atknomes
#
const nome13 = "Força"
const info13 = "Em porcentagem"
const tipo13 = "numero"
const clas13 = var.classe1
const vari13 = "ataque"
#
const nome14 = "Velocidade"
const info14 = "Em porcentagem"
const tipo14 = "numero"
const clas14 = var.classe1
const vari14 = "vel"
#
const nome15 = "Bônus"
const info15 = "Quais raças e classes atacam com mais força"
const tipo15 = "tipos"
const clas15 = var.classe1
const vari15 = "tipobonus"
#
const titu16 = " * Textos"
#
const nome16 = "Informações"
const info16 = "Informações extras"
const tipo16 = "texto"
const clas16 = var.classe1
const vari16 = "msgextra"
#
const nome17 = "Mensagens 1"
const tipo17 = "menu--"
const clas17 = "menu_hab_msg0"
#
const nome18 = "Mensagens 2"
const tipo18 = "menu--"
const clas18 = "menu_hab_msg1"
#
const nome19 = "Mensagens 3"
const tipo19 = "menu--"
const clas19 = "menu_hab_msg2"
#
const nome20 = "Mensagens 4"
const tipo20 = "menu--"
const clas20 = "menu_hab_msg3"
#
const nome21 = "Mensagens 5"
const tipo21 = "menu--"
const clas21 = "menu_hab_msg4"


classe menu_magia_ataque
herda menu_hab_ataque
const titulo = "Magia " + txt(var.classe1, 6)
const colunas = 25


classe comando_hab
herda comando_comum
const objcmd = arg0.persobat.var.[nomevar] ? este
const atkajuda = arg0.persobat.var.[nomevar] ? este
const posic = 7
const precisao = 100 # Precisão do golpe, maior que 100 nunca falha
const tipoalvo = 6

func checahab1 # Checa se personagem pode usar habilidade/magia e avisa o personagem
# arg0 = personagem
# arg1 = item usado, ou nulo se não usou nenhum item
  ret checahab2(arg0, (arg0.var.[nomevar] - 1) / 7, arg1)

func checahab2 # Checa se personagem pode usar habilidade/magia e avisa o personagem
# arg0 = personagem
# arg1 = quanto sabe da habilidade ou magia (0=iniciante até 1=perito)
# arg2 = item usado, ou nulo se não usou nenhum item
# Retorna verdadeiro se pode usar
  se !arg0.pvida
    refvar lin = arg0 == arg0.contr ? "Você" : txtcopiamai(arg0.nome, "A")
    arg0.contr.msg(lin + " está desmaiad" + (arg0.msexo ? "o." : "a."))
    ret
  senao arg2.item # Usou algum objeto: não checa a posição e a arma usada
  senao arg0.posicao < posic # Checa a posição necessária
    refvar lin = arg0 == arg0.contr ? "Você" : txtcopiamai(arg0.nome, "A")
    casovar arg0.posicao
    casose "0"
      arg0.contr.msg(lin + " desmaiou.")
      ret
    casose "1"
    casose "2"
    casose "3"
      arg0.contr.msg(lin + " está frac" + (arg0.msexo ? "o" : "a") + " demais.")
      ret
    casose "4"
      arg0.contr.msg(lin + " está dormind" + (arg0.msexo ? "o" : "a") + ".")
      ret
    casose "5"
      arg0.contr.msg(lin + " está descansand" + (arg0.msexo ? "o" : "a") + ".")
      ret
    casose "6"
      arg0.contr.msg(lin + " está sentad" + (arg0.msexo ? "o" : "a") + ".")
      ret
    casose "7"
      arg0.contr.msg(lin + " está lutand" + (arg0.msexo ? "o" : "a") + ".")
      ret
    casofim
    arg0.contr.msg(lin + " não consegue fazer isso.")
    ret
  senao !tipoarma # Nenhum tipo de arma definido: aceita qualquer arma
  senao !arg0.iempu # Não está usando uma arma
    se !(tipoarma & 1)
      arg0.contr.msg("Não possui a arma necessária.")
      ret
    fimse
  senao arg0.iempu && tipoarma & intbit(arg0.iempu.obj.armatipo)
  senao tipoarma == 1
    arg0.contr.msg("Empunhando uma arma?")
    ret
  senao
    arg0.contr.msg("Com essa arma?")
    ret
  fimse
  se arg0.dono.s_semmagia && txt(nomevar, 0, 1) == "m"
    arg0.msg("A magia não teve efeito.")
    ret
  senao arg2.item # Usou algum objeto: não tem custo
  senao arg0.pvida <= arg1 * (c_vida2 - c_vida1) + c_vida1
    arg0.contr.msg("Pontos de vida insuficientes.")
    ret
  senao arg0.pmana < arg1 * (c_mana2 - c_mana1) + c_mana1
    arg0.contr.msg("Mana insuficiente.")
    ret
  senao arg0.pmove < arg1 * (c_move2 - c_move1) + c_move1
    arg0.contr.msg("Vigor insuficiente.")
    ret
  fimse
  ret 1

func autohab1 # Checa se personagem pode usar habilidade/magia em ataque automático
# arg0 = personagem
  ret autohab2(arg0, (arg0.var.[nomevar] - 1) / 7)

func autohab2 # Checa se personagem pode usar habilidade/magia em ataque automático
# arg0 = personagem
# arg1 = quanto sabe da habilidade ou magia (0=iniciante até 1=perito)
# Retorna verdadeiro se pode usar
  ret !arg0.pvida || arg0.posicao < posic, nulo
  ret arg0.dono.s_semmagia && txt(nomevar, 0, 1) == "m", nulo
  ret arg0.pvida <= arg1 * (c_vida2 - c_vida1) + c_vida1, nulo
  ret arg0.pmana < arg1 * (c_mana2 - c_mana1) + c_mana1, nulo
  ret arg0.pmove < arg1 * (c_move2 - c_move1) + c_move1, nulo
  ret !arg0.contr.dono.s_luta && tipoalvo != 6 && tipoalvo != 7, nulo
  ret 1

func costohab1 # Aplica os custos da habilidade/magia
# arg0 = personagem
  ret custohab2(arg0, (arg0.var.[nomevar] - 1) / 7)

func custohab2 # Aplica os custos da habilidade/magia
# arg0 = personagem
# arg1 = quanto sabe da habilidade ou magia (0=iniciante até 1=perito)
  arg0.pvida -= arg1 * (c_vida2 - c_vida1) + c_vida1
  arg0.pmana -= arg1 * (c_mana2 - c_mana1) + c_mana1
  arg0.pmove -= arg1 * (c_move2 - c_move1) + c_move1
  arg0.contr.p_espera < c_espera && (arg0.contr.p_espera = c_espera)


classe comando_ataque
herda comando_hab
const objcmd = tipoalvo < 8 && arg0.persobat.var.[nomevar] ? este
const cmdmenu = "ataque" # Editável via "menu_hab_ataque" e "menu_magia_ataque"
const nomevar = "" # Nome da variável que indica o quanto sabe do ataque
const tipoalvo = 0 # Alvo
const tipoatk = 0 # Tipo de golpe
const ataque = 50 # Força de ataque, 100 significa 100%
const vel = 50 # Velocidade do golpe, 100 significa 100%
const a_prob1 = 100
const a_prob2 = 100
const a_prob3 = 100
const c_espera = 15 # Tempo de esperar após usar esse comando
int32 mudavida # Para calcular mudança nos pontos de vida do alvo
int8 result # Resultado da batalha:
# 0=acertou o alvo, 1=não teve efeito, 2=errou o alvo, 3=cancelar ataque
ref arma1 # Arma usada
#
# Ordem que deve organizar as constantes:
const admordem = "nomevar\n\
tipoalvo\n\
a_batalha\n\
a_cond\n\
a_efeito1 a_efeito2 a_efeito3\n\
a_prob1 a_prob2 a_prob3\n\
a_mana1 a_mana2\n\
a_move1 a_move2\n\
a_remove\n\
a_vida1 a_vida2\n\
c_espera\n\
c_vida1 c_vida2\n\
c_mana1 c_mana2\n\
c_move1 c_move2\n\
ataque\n\
aulaini aulafim\n\
depende\n\
precisao\n\
tipoarma\n\
tipoatk\n\
tipobonus\n\
tipoperso\n\
valor\n\
vel\n\
msgextra msgatk0 msgatk1 msgatk2 msgatk3 msgatk4"

func txtajuda # Retorna um texto que contém informações
  textotxt t
  se depende
    t.addfim(depende)
    textopos pos
    epara pos = t.ini, pos, pos.depois
      pos.mudar(misc:nomevar(pos.texto))
    efim
    t.addfim("Requer conhecimentos de: " + txttroca(t.remove(1000), "\n", ", "))
    t.juntar, t.dividelin(40, 75)
  fimse
  txt100 lin
  lin = "\c3" + misc:nomevar(nomevar)
  se tipoalvo < 6
    lin += "\b\nAtaque do nível " + int(aulafim)
    lin += ", " + txtsublin(config:atknomes, tipoatk, 1)
    lin += ", Força " + ataque + ", Velocidade " + vel
    lin += precisao <= 100 ? ", Precisao " + precisao : ", Não falha"
    t.addini(lin)
  senao
    lin += "\b\nNível " + int(aulafim)
    lin += precisao < 100 ? ", Acerta " + precisao + "%" : ", Não falha"
    t.addini(lin)
  fimse
  msgextra && t.addfim(msgextra)
  se c_vida1 || c_vida2
    refvar min = int(c_vida2)
    refvar max = int(c_vida1)
    se min != max
      t.addfim("Consome de " + min + " a " + max + " pontos de vida.")
    senao min == 1
      t.addfim("Consome 1 ponto de vida.")
    senao
      t.addfim("Consome " + min + " pontos de vida.")
    fimse
  fimse
  se c_mana1 || c_mana2
    refvar min = int(c_mana2)
    refvar max = int(c_mana1)
    se min != max
      t.addfim("Consome de " + min + " a " + max + " pontos de mana.")
    senao min == 1
      t.addfim("Consome 1 ponto de mana.")
    senao
      t.addfim("Consome " + min + " pontos de mana.")
    fimse
  fimse
  se c_move1 || c_move2
    refvar min = int(c_move2)
    refvar max = int(c_move1)
    se min != max
      t.addfim("Consome de " + min + " a " + max + " pontos de movimento.")
    senao min == 1
      t.addfim("Consome 1 ponto de movimento.")
    senao
      t.addfim("Consome " + min + " pontos de movimento.")
    fimse
  fimse
  se tipoperso
    t.addfim("Somente classes/raças: " + txttroca(tipoperso, "\n", ", "))
  fimse
  ret t.remove(1000)

func escr # Atacar alguém
# arg0 = personagem
# arg1 = o que o personagem digitou; usado para obter o personagem alvo
# arg2 = item usado, ou nulo se não usou nenhum item
# arg3 = nível da magia, se usou algum item
  ref r
  se arg1 # Digitou o alvo
    listaitem i
    nomeobj nome
    nome.ini(arg1, 1)
    epara i = arg0.dono.dentro2.ini, i, i.depois
      sair i.obj.visivel(arg0) && nome.nome(i.obj.ident)
    efim
    r = i.obj
    ret !r, arg0.msg("Você não vê isso.")
  senao tipoalvo >= 6 # Hab não agressiva: o alvo é o próprio personagem
    r = arg0
  senao arg2.f_tipo == 4 # Hab agressiva usando pergaminho
    r = arg0.atkenv.objlista
    (!r || r.dono != arg0.dono) && (r = arg0)
  senao arg2.item # Hab agressiva usando outro item
    r = arg0
  senao # Hab agressiva sem usar um item: o alvo é quem está batalhando
    r = arg0.atkenv.objlista
    ret !r || r.dono != arg0.dono, arg0.msg("Atacar quem?")
  fimse
  refvar p = arg0.persobat
  se arg2
    exechab(p, r.persobat, 0.5, arg3, arg2)
  senao
    exechab(p, r.persobat, intpos(p.var.[nomevar] - 1) / 7, p.pnivel)

func exechab # Chamado quando personagem usa habilidade ou magia
# arg0 = quem está usando a habilidade ou magia
# arg1 = personagem alvo
# arg2 = quanto sabe da habilidade ou magia (0=iniciante até 1=perito)
# arg3 = nível da habilidade ou magia (=nível do personagem)
# arg4 = item usado, ou nulo se não usou nenhum item
  ret !checahab2(arg0, arg2, arg4), nulo
# Checa a condição de batalha
  se a_batalha == 1 && !arg0.contr.atkenv
    ret arg0.contr.msg("Você não está lutando com ninguém.")
  senao a_batalha == 2 && arg0.contr.atkenv
    ret arg0.contr.msg("Você está lutando pela sua vida.")
# Checa condição do alvo
  senao !a_cond
    ret !arg1.pvida, arg0.contr.msg("Alvo está desmaiado.")
  senao a_cond == 1
    ret arg1.pvida, arg0.contr.msg("Alvo não está desmaiado.")
  senao dono.s_semmagia && txt(nomevar, 0, 1) == "m"
    ret msg("A magia não teve efeito.")
  fimse
# Obtém a arma usada
  arma1 = nulo
  tipoarma && (arma1 = arg0.iempu.obj)
# Técnicas não agressivas
  listaobj l
  casovar tipoalvo
  casose "7"
    se arg0 != arg1
      refvar msg = txt(nomevar, 0, 1) == "m" ? "magia" : "habilidade"
      arg0.contr.msg("Essa " + msg + " não pode ser usada nos outros.")
      ret
    fimse
  casose "6"
    ret cmd_alvo(arg0, arg1, este), nulo
    epara l.addfim(arg0.contr.evento, arg1.contr.evento), l, l.ini.remove
      ret l.objini.cmd_alvocontr(arg0, arg1, este), nulo
    efim
    epara l.addfim(arg0.evento, arg1.evento), l, l.ini.remove
      ret l.objini.cmd_alvo(arg0, arg1, este), nulo
    efim
    se !arg4.item
      custohab2(arg0, arg2)
      mensinicio(arg0, arg1)
    fimse
    mudavida = 0
    se arg0.contr.dono.s_semmagia && txt(nomevar, 0, 1) == "m"
      result = 1 # Sem efeito
    senao rand(100) >= precisao
      result = 2 # Errou o alvo
    senao
      result = 0 # Acertou o alvo
      efeitohab(arg0, arg1, arg2, arg3)
    fimse
    mensgolpe(arg0, arg1)
    cmd_alvofim(arg0, arg1, este)
    epara l.addfim(arg0.evento, arg1.evento), l, l.ini.remove
      l.objini.cmd_alvofim(arg0, arg1, este)
    efim
    result == 10 ? arg1.morreu(arg0) : arg1.acertapos(1)
    arg0 != arg1 && arg0.acertapos(1)
    ret
  casose "1" # Ataque que não pode ser ao próprio personagem
  casose "3"
  casose "5"
    sair arg0 != arg1
    ret arg0.contr.msg("Em você mesm" + (arg0.msexo ? "o?" : "a?"))
  casofim
# Checa o alvo e dispara eventos
  se !arg0.contr.dono.s_luta
    ret arg0.contr.msg(arg4.item ? "A magia falhou." : "Aqui é um lugar pacífico.")
  senao !arg1.contr.p_agressivo(arg0)
    ret arg0.contr.msg(arg1.contr.descnome + " não quer brigar.")
  fimse
  ret cmd_atacar(arg0, arg1, este), nulo
  epara l.addfim(arg0.contr.evento, arg1.contr.evento), l, l.ini.remove
    ret l.objini.cmd_atacarcontr(arg0, arg1, este), nulo
  efim
  epara l.addfim(arg0.evento, arg1.evento), l, l.ini.remove
    ret l.objini.cmd_atacar(arg0, arg1, este), nulo
  efim
# Custo da hab/magia e checa se é permitido usar ataques
  se !arg4.item
    custohab2(arg0, arg2)
    mensinicio(arg0, arg1)
  fimse
  se arg0.contr.dono.s_luta == 1 && arg0.contr.jog && arg1.contr.jog && arg0 != arg1
    result = 1
    mensgolpe(arg0, arg1)
    ret arg0.acertapos(1)
  senao arg0.contr.dono.s_semmagia && txt(nomevar, 0, 1) == "m"
    result = 1
    mensgolpe(arg0, arg1)
    ret arg0.acertapos(1)
  fimse
# Força do ataque e alvos secundários
  real2 atk
  casovar tipoalvo
  casose # Casos 0 e 1: Ataca um personagem
    atk = ataque * (arg2 + 0.5)
    sair
  casose "2" # Todos dividindo o ataque
  casose "3"
    l.addfim(arg0.contr.dono.dentro2)
    l.remove(arg0.contr, arg1.contr)
    atk = ataque / (l.total + 1) * (arg2 + 0.5)
    sair
  casose "4" # Todos sem dividir o ataque
  casose "5"
    l.addfim(arg0.contr.dono.dentro2)
    l.remove(arg0.contr, arg1.contr)
    atk = ataque * (arg2 + 0.5)
    sair
  casose "6" # Ataque automático
    atk = ataque * (arg2 + 0.5) * config:atkfor / 100
    sair
  casofim
# Checa a arma usada
  se arma1
    real2 carga
    carga = (arg0.pesoden - arg0.pesovest + arma1.pesoobj * 4) / (arg0.pesomax + 1)
    se carga > 1.2 # Muito pesado
      atk /= carga < 1.4 ? 10 : 100
      arg0.contr.msg("É muito peso!")
    senao carga > 1 # Um pouco pesado
      atk *= 5 - 4 * carga # se carga=1,atk*=1  se carga=1.2,atk*=0.2
      arg0.contr.msg("Bastante peso!")
    fimse
  fimse
# Checa sede e fome
  atk /= (2 + $miscfome.f.[arg0.p_sede] + $miscfome.f.[arg0.p_fome]) / 2
# Ataca o alvo escolhido
  ref r
  listaobj e
  tipoalvo != 8 && velgolpe(arg0, arg1) # Tempo do golpe
  execgolpe(arg0, arg1, atk) # Ataca
  se result != 3
    !result && efeitohab(arg0, arg1, arg2, arg3) # Acertou: aplica os efeitos
    mensgolpe(arg0, arg1)
    cmd_atacou(arg0, arg1, este)
    epara e.addfim(arg0.evento, arg1.evento), e, e.ini.remove
      e.objini.cmd_atacou(arg0, arg1, este)
    efim
    result == 10 ? arg1.morreu(arg0) : arg1.acertapos(1)
  fimse
# Ataca os alvos secundários
  enquanto l
    r = l.objini, l.ini.remove
    continuar r.jog || r.perso < 2 # Não prossegue se for jogador
    r = r.persobat
    tipoalvo != 8 && velgolpe(arg0, r) # Tempo do golpe
    execgolpe(arg0, r, atk) # Ataca
    continuar result == 3
    !result && efeitohab(arg0, r, arg2, arg3) # Acertou: aplica os efeitos
    mensgolpe(arg0, r, 1)
    cmd_atacou(arg0, r, este)
    epara e.addfim(arg0.evento, r.evento), e, e.ini.remove
      e.objini.cmd_atacou(arg0, r, este)
    efim
    result == 10 ? r.morreu(arg0) : r.acertapos(1)
  efim
  arg0.acertapos(1)

func efeitohab # Efeito da habilidade ou magia sobre o alvo
# arg0 = quem lançou a habilidade ou magia
# arg1 = personagem alvo
# arg2 = quanto sabe da habilidade ou magia (0=iniciante até 1=perito)
# arg3 = nível da habilidade ou magia (=nível do personagem)
# Nota: Altera mudavida conforme pontos de vida alterados
  a_efeito1 && criar("e_" + a_efeito1, arg1, rand(100) < a_prob1 ? arg3 : -1)
  a_efeito2 && criar("e_" + a_efeito2, arg1, rand(100) < a_prob2 ? arg3 : -1)
  a_efeito3 && criar("e_" + a_efeito3, arg1, rand(100) < a_prob3 ? arg3 : -1)
  se a_remove
    textotxt t
    epara t.addfim(a_remove), t.linhas, apagar(arg1.dentro2.objini("e_" + t.remove))
    efim
  fimse
  real2 valor
  valor = (a_move1 + a_move2 * arg3) * (0.5 + arg2)
  valor && (arg1.pmove = intmin(arg1.pmove + valor, arg1.pmovemax))
  valor = (a_mana1 + a_mana2 * arg3) * (0.5 + arg2)
  valor && (arg1.pmana = intmin(arg1.pmana + valor, arg1.pmanamax))
  ret !(valor = (a_vida1 + a_vida2 * arg3) * (0.5 + arg2)), nulo
  refvar vida = int(arg1.pvida)
  arg1.pvida = intmin(vida + valor, arg1.pvidamax)
  mudavida += arg1.pvida - vida
  !vida && arg1.pvida && arg1.dono.perso && arg1.dono.escolhebat

func velgolpe # Acerta o tempo de espera conforme o golpe
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# vel = velocidade do golpe
# Se velocidades dos personagens iguais e velocidade do golpe=100: tempo=30
  real2 tempo
  tempo = arg1.pveloc * 3000 / (arg0.pveloc * veloc + 1)
  tempo = intmax(8, intmin(70, tempo))
  arg0.contr.p_espera < tempo && (arg0.contr.p_espera = tempo)
  ret
# Outra fórmula:
  tempo = arg0.pveloc + arg1.pveloc # Tempo total
  tempo = tempo * 1500 / (arg0.pveloc * veloc + 1)
  tempo = intmax(8, intmin(70, tempo))
  arg0.contr.p_espera < tempo && (arg0.contr.p_espera = tempo)

func execgolpe # Realiza um ataque e coloca resultado em result e mudavida
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2 = força do ataque (inclui quanto sabe do golpe), 0=não calcular danos
# tipoatk = tipo de ataque, arma1 = arma usada
  real2 dano
# Checa se pode realmente atacar
  result = 3, mudavida = 0
  listaobj l
  ret cmd_atkenv(arg0, arg1, este), nulo
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_atkenv(arg0, arg1, este), nulo
  efim
  epara l.addfim(arg1.evento), l, l.ini.remove
    ret l.objini.cmd_atkrec(arg0, arg1, este), nulo
  efim
# Indica que atacou, recebe experiência se vencer
  arg0.batalhaini(arg1)
  se arg0.podepegar && arg1.contr.var.o_agenda # Coloca na agenda
    refvar v1 = arg1.contr.var.a_[arg0.nome]
    !v1 && (v1 = 1)
  fimse
# Checa se acertou o alvo
  result = 2
  se precisao <= 100
    dano = rand(1, 20)
    se dano == 20 || arg1.posicao == 4 # Acertou automaticamente
    senao dano == 1 # Errou o alvo automaticamente
      ret
    senao arg0.jog && rand($miscfome.bebeatk, $miscfome.cheio) < arg0.p_bebida
      ret # Quem ataca errou o golpe devido à embriaguês
    senao arg1.jog && rand($miscfome.bebeatk, $miscfome.cheio) < arg1.p_bebida # Embriagado
    senao # Checa se acertou
      dano += precisao * arg0.precisao * (arma1 ? arma1.armaprecisao : 100) / 10000
      dano -= arg1.evasao
      !arg1.visivel(arg0) && (dano -= 5) # Invisível é mais difícil de acertar
      ret dano <= 0, nulo
    fimse
  fimse
# Checa bônus ao combinar o tipo de ataque com o tipo de defesa
  dano = arg0.atktipo.[2 + tipoatk] * arg1.deftipo.[2 + tipoatk]
  se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
    dano *= arg0.atktipo.1 * arg1.deftipo.1
  senao
    dano *= arg0.atktipo.0 * arg1.deftipo.0
  fimse
  se dano == 0 # Imune
    result = 1
    ret
  fimse
  result = 0
  ret !arg2, nulo
# Checa bônus do personagem
  se tipobonus
    refvar tbonus = "\n" + txte(tipobonus) + "\n"
    se arg0.tipo1 && txtproc(tbonus, "\n" + arg0.tipo1 + "\n") >= 0
      dano *= 1.5
    senao arg0.tipo2 && txtproc(tbonus, "\n" + arg0.tipo2 + "\n") >= 0
      dano *= 1.5
    senao arg0.tipo3 && txtproc(tbonus, "\n" + arg0.tipo3 + "\n") >= 0
      dano *= 1.5
    fimse
  fimse
# Calcula dano com arma
  se arma1
    dano *= rand(arma1.armamin, arma1.armamax)
    se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
      dano *= arg0.atkesp * arg2 / (arg1.defesp * 300)
    senao
      dano *= arg0.atknorm * arg2 / (arg1.defnorm * 300)
    fimse
# Calcula dano sem arma
  senao
    se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
      dano *= arg0.atkesp * arg0.atkesp * arg2 / (arg1.defesp * rand(270, 330))
    senao
      dano *= arg0.atknorm * arg0.atknorm * arg2 / (arg1.defnorm * rand(270, 330))
    fimse
    dano *= 1 + (arg0.pnivel - arg1.pnivel) / (arg0.pnivel + arg1.pnivel + 10)
  fimse
# Modificadores de posição
  casovar arg1.posicao
  casose "0" # Morto
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    dano *= 2.666
    sair
  casose "3" # Muito fraco
    dano *= 2.333
    sair
  casose "4" # dormindo
    dano *= 2
    sair
  casose "5" # descansando
    dano *= 1.666
    sair
  casose "6" # sentado
    dano *= 1.333
    sair
  casofim
# Atualiza pontos de vida conforme os danos (pelo menos 1 de dano)
  mudavida = dano < 1 ? -1 : -dano
  arg1.pvida += mudavida

func mensinicio # Envia mensagem inicial da habilidade ou magia
# arg0 = personagem que está usando a habilidade ou magia
# arg1 = personagem alvo
  txt512 lin.3
  ret menssub(lin, 0), nulo
  se arg0 == arg1
    $mens.p(arg0, arg1, arma1)
    $mens.mtodos2(lin.0, lin.2)
  senao
    $mens.p(arg0, arg1, arma1)
    $mens.mtodos3(lin.0, lin.1, lin.2)

func mensgolpe # Envia mensagens de acordo com o resultado do ataque
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2 = verdadeiro se for alvo secundário (não mostra todas as mensagens)
# Faz result=10 se o alvo morreu, mas não chama a função morreu
  $mens.p(arg0, arg1, arma1)
  txt512 lin.3
  casovar result
  casose "0" # Acertou o alvo
    $mens.mens = mudavida
    arg1.p_imortal && (arg1.pvida = intmax(arg1.pvida, arg1.pvidamax)) # Imortal
    se !arg1.pvida # Se morreu
      result = 10
      ret menssub(lin, 8), nulo
      ret $mens.mtodos3(lin.0, lin.1, lin.2)
    senao arg2 # Se for alvo secundário
      ret menssub(lin, 5), nulo
      ret arg1.contr.msginv(lin.1)
    senao arg0 == arg1 # Se o alvo for o próprio personagem
      ret menssub(lin, 3), nulo
      ret $mens.mtodos2(lin.0, lin.1)
    senao # Outros casos
      ret menssub(lin, 5), nulo
      ret $mens.mtodos3(lin.0, lin.1, lin.2)
    fimse
    ret
  casose "1" # Não teve efeito
    ret menssub(lin, 14), nulo
    ret arg2, arg1.contr.msginv(lin.1)
    ret $mens.mtodos3(lin.0, lin.1, lin.2)
  casose "2" # Errou o alvo
    ret menssub(lin, 11), nulo
    ret arg2, arg1.contr.msginv(lin.1)
    ret $mens.mtodos3(lin.0, lin.1, lin.2)
  casofim

func menssub # Usado em mensgolpe
# arg0 = variável txt512 lin.3
# arg1 = índice da mensagem a obter
# Retorna 1 se mensagem vazia
  textotxt t
  txtsublin(msgatk0, arg1, 1) && t.addfim("msgatk0")
  txtsublin(msgatk1, arg1, 1) && t.addfim("msgatk1")
  txtsublin(msgatk2, arg1, 1) && t.addfim("msgatk2")
  txtsublin(msgatk3, arg1, 1) && t.addfim("msgatk3")
  txtsublin(msgatk4, arg1, 1) && t.addfim("msgatk4")
  ret !t.linhas, 1
  t.remove(rand(t.linhas))
  arg0.separar(txtsublin([t.remove], arg1, 3), "\n")
  arg0.0 = txtvis(arg0.0)
  arg0.1 = txtvis(arg0.1 ? arg0.1 : arg0.0)
  arg0.2 = txtvis(arg0.2 ? arg0.2 : arg0.0)
  ret 0


classe cmd_resgatar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Resgatar\b\n\
Sintaxe: RESGATAR <personagem>\n\
Resgata um jogador em uma batalha. É como se você se colocasse entre\n\
o jogador e quem está atacando ele."

func escr
  ret arg0.dono.s_naoresg, arg0.msg("Aqui não é possível resgatar.")
  ret !arg1, arg0.msg("Resgatar quem?")
  nomeobj n
  listaitem i
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro2.ini, i, i.depois
    continuar !i.obj.visivel(arg0) || !n.nome(i.obj.ident)
    ref r
    r = i.obj
# Checa se é possível resgatar
    ret arg0 == r, arg0.msg("Resgatar você mesmo?")
    ret !r.jog, arg0.msg(i.obj.descnome + " não é jogador.")
    ret !r.atkrec.objini, arg0.msg(i.obj.descnome + " não está lutando.")
    ret r.atkenv.objlista == arg0, arg0.msg(i.obj.descnome + " está lutando com você.")
# Checa se personagens permitem resgate
    epara i = r.atkrec.ini, i, i.depois
      continuar !i.obj.p_naoresg
      arg0.msg("Não é possível resgatar " + r.descnome + " de " + i.obj.descnome + ".")
      ret
    efim
# Eventos
    listaobj l
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_resgatar(arg0, r), nulo
    efim
# Resgata
    enquanto r.atkrec.objini
      r.atkrec.objini.batalhaini(arg0)
    efim
    $mens.p(arg0, r)
    $mens.mvis1("$P resgata $a.")
    ret
  efim
  arg0.msg("Você não vê " + arg1 + ".")


classe cmd_matar
herda comando_ataque
const objcmd = config:matartipo ? este
const objajuda = config:matartipo ? este
const txtajuda = "\b\c3Matar\b\n\
Sintaxe: MATAR <personagem>\n\
Começa um combate com um personagem."
const cmdmenu = ""

func exechab # Chamado quando personagem (arg0) quer atacar alguém (arg1)
  se arg0.atkenv
    arg0.msg("Você já está lutando.")
  senao !arg0.persobat.atkauto(arg1, 8) # Realiza um ataque automático
    arg0.msg("Você não sabe como atacar " + arg1.descnome + ".")
  senao arg0.atkenv # Se está lutando
    arg0.p_espera = intmax(arg0.p_espera, config:atktempo)
