classe jog_admatk
# Comandos de itens
#
const adm_atk = "\b\c3Comandos de ataques\b\n\
\c2LHAB\b [nome]\n\
\c2LMAG\b [nome]\n\
  Lista habilidades ou magias que começam com o nome especificado.\n\
\c2CHAB\b <nome>\n\
\c2CMAG\b <nome>\n\
  Cria uma habilidade ou magia. Nome deve ser o nome da habilidade ou\n\
  magia, e deve ser composto de letras, mas pode ter espaços no meio.\n\
\c2EHAB\b <nome>\n\
\c2EMAG\b <nome>\n\
  Edita uma habilidade ou uma magia.\n\
\c2AHAB\b <nome>\n\
\c2AMAG\b <nome>\n\
  Apaga uma habilidade ou uma magia."

func cmd_lhab # Listar habilidades
  prog p
  textotxt t
  txt100 lin
  epara p.iniclasse("cmd_"), p.lin && t.linhas < 499, p.depois
    continuar !$[p.texto].cmdmenu # Continua se não é uma habilidade
    lin = txtcopiamai(txt2(txte(p.texto)), "A") + ", "
    lin += txtsublin(config:atknomes, $[p.texto].tipoatk, 1)
    casovar $[p.texto].tipoalvo
    casose "1"
      lin += ", todos dividindo ataque"
      sair
    casose "2"
      lin += ", todos sem dividir ataque"
      sair
    casofim
    t.addfim(lin)
  efim
  se t.linhas
    msg2("\bHabilidade, Tipo, Alvo\n" + t.remove(500))
  senao
    msg("\bNenhuma habilidade encontrada.")
  fimse
  ret 1

func cmd_lmag # Listar magias
  prog p
  textotxt t
  txt100 lin
  epara p.iniclasse("magia_"), p.lin && t.linhas < 499, p.depois
    continuar !$[p.texto].cmdmenu # Continua se não é uma magia editável
    lin = txtcopiamai(txt2(txte(p.texto)), "A") + ", "
    lin += txtsublin(config:atknomes, $[p.texto].tipoatk, 1)
    casovar $[p.texto].tipoalvo
    casose "1"
      lin += ", todos dividindo ataque"
      sair
    casose "2"
      lin += ", todos sem dividir ataque"
      sair
    casofim
    t.addfim(lin)
  efim
  se t.linhas
    msg2("\bMagia, Tipo, Alvo\n" + t.remove(500))
  senao
    msg("\bNenuma magia encontrada.")
  fimse
  ret 1

func cmd_chab # Criar habilidade
  prog p
  txt80 nome
  uint16 num
# Checa se digitou nome do ataque
  se arg0 == ""
    msg("Tecle o nome da habilidade após CHAB")
    ret 1
  fimse
# Checa se nome válido
  nome = txte(txtremove(arg0, EMDSA))
  se txtsepara(nome, "DO+DOL,DOL+DO") != nome
    msg("Nome inválido para habilidade: " + nome)
    ret 1
  senao p.existe("cmd_" + nome)
    msg("Já existe o comando: " + nome)
    ret 1
  senao p.existe("soc_" + nome)
    msg("Já existe o comando social: " + nome)
    ret 1
  fimse
# Pergunta que tipo de habilidade criar
  var.opcclasse = "cmd_" + txts(txtmin(nome))
  var.opcvar = "h_" + txtcopiamai(txte(nome), "A")
  var.opctipo = "habilidade"
  ret p_chab("\b")

func cmd_cmag # Criar magia
  prog p
  txt80 nome
  uint16 num
# Checa se digitou nome do ataque
  se arg0 == ""
    msg("Tecle o nome da magia após CMAG")
    ret 1
  fimse
# Checa se nome válido
  nome = txte(txtremove(arg0, EMDSA))
  se txtsepara(nome, "DO+DOL,DOL+DO") != nome
    msg("Nome inválido para magia: " + nome)
    ret 1
  senao p.existe("magia_" + nome)
    msg("Já existe a magia: " + nome)
    ret 1
  fimse
# Pergunta que tipo de magia criar
  var.opcclasse = "magia_" + txts(txtmin(nome))
  var.opcvar = "m_" + txtcopiamai(txte(nome), "A")
  var.opctipo = "magia"
  ret p_chab("\b")

func p_chab # Escolher o tipo de habilidade
  txt40 deriv
  casovar txtmin(arg0)
  casose
    msg("Opção inválida")
  casose "\b"
  casose ""
    passo = "chab"
    msg("Entre com o tipo de " + var.opctipo + ", O mostra as opções, Z cancela")
    ret 1
  casose "z"
    msg("Retornando ao jogo")
    passo = "", var.opcclasse = "", var.opcnome = "", var.opctipo = ""
    ret 1
  casose "o"
    txtmais.limpar
    txtmais.addfim("A Ataque")
    txtmais.addfim("C Curar")
    txtmais.addfim("I Identificar")
    txtmais.addfim("R Retornar")
    txtmostra
    ret 1
  casose "a"
    deriv = "comando_ataque"
    sair
  casose "c"
    deriv = "comando_curar"
    sair
  casose "i"
    deriv = "comando_identificar"
    sair
  casose "r"
    deriv = "comando_retornar"
    sair
  casofim
# Cria habilidade ou magia
  txt200 lin
  lin = var.opcclasse + "\nb-hab\nherda " + deriv
  lin += "\nconst nomevar = \"" + var.opcvar + "\""
  prog p
  p.criar(lin)
  config:salvar
  msg("\bCriou " + var.opctipo + ": " + txt(var.opcvar, 2))
  admlog("criou " + var.opctipo + " " + txt(var.opcvar, 2))
  passo = "", var.opcclasse = "", var.opcnome = "", var.opctipo = ""
  ret 1

func cmd_ahab # Apagar habilidade
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes de habilidades após AHAB")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("cmd_" + txtsub(arg0, x, 1))
      msg("Habilidade não existe: " + txtsub(arg0, x, 1))
      ret 1
    senao !$cmd_[txtsub(arg0, x, 1)].cmdmenu
      msg("Comando não é uma habilidade: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_ahab
  ret 1

func p_ahab # Confirmar que quer apagar habilidade
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("cmd_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Habilidade apagada: " + tpasso)
      admlog("apagou habilidade " + tpasso)
    senao
      msg("Habilidades apagados: " + tpasso)
      admlog("apagou habilidades " + tpasso)
    fimse
  senao
    txt20 m1
    passo = "ahab"
    m1 = txt2(tpasso) ? "habilidades" : "habilidade"
    msg("Apagar " + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_amag # Apagar magia
  prog p
  se arg0 == ""
    msg("Tecle um ou mais nomes de magias após AMAG")
    ret 1
  fimse
  uint16 x
  enquanto txtsub(arg0, x, 1)
    se !p.existe("magia_" + txtsub(arg0, x, 1))
      msg("Magia não existe: " + txtsub(arg0, x, 1))
      ret 1
    senao !$magia_[txtsub(arg0, x, 1)].cmdmenu
      msg("Magia não pode ser apagada: " + txtsub(arg0, x, 1))
      ret 1
    fimse
    x += 1
  efim
  tpasso = arg0, p_amag
  ret 1

func p_amag # Confirmar que quer apagar magia
  passo = ""
  se arg0 == "n"
    msg("Cancelado")
  senao arg0 == "s"
    prog p
    uint16 x
    enquanto txtsub(tpasso, x, 1)
      p.apagar("magia_" + txtsub(tpasso, x, 1))
      x += 1
    efim
    config:salvar
    se x < 2
      msg("Magia apagada: " + tpasso)
      admlog("apagou magia " + tpasso)
    senao
      msg("Magias apagadas: " + tpasso)
      admlog("apagou magias " + tpasso)
    fimse
  senao
    txt20 m1
    passo = "amag"
    m1 = txt2(tpasso) ? "magias" : "magia"
    msg("Apagar " + m1 + " " + tpasso + "? Tecle S ou N")
  fimse
  ret 1

func cmd_ehab # Editar habilidade
  prog p
  se arg0 == ""
    msg("Tecle o nome da habilidade após EHAB")
  senao !p.existe("cmd_" + arg0)
    msg("Habilidade não existe: " + arg0)
  senao !$cmd_[arg0].cmdmenu
    msg("Comando não é uma habilidade: " + arg0)
  senao
    var.classe1 = "cmd_" + txts(txtmin(arg0))
    m_menu("menu_hab_" + $cmd_[arg0].cmdmenu)
  fimse
  ret 1

func cmd_emag # Editar magia
  prog p
  se arg0 == ""
    msg("Tecle o nome da magia após EMAG")
  senao !p.existe("magia_" + arg0)
    msg("Magia não existe: " + arg0)
  senao !$magia_[arg0].cmdmenu
    msg("Comando não é uma magia editável: " + arg0)
  senao
    var.classe1 = "magia_" + txts(txtmin(arg0))
    m_menu("menu_magia_" + $magia_[arg0].cmdmenu)
  fimse
  ret 1


classe menu_hab_comum
const nome6 = "Requer arma"
const info6 = "Deixar vazio se funciona independente da arma usada."
const tipo6 = "vetor"
const clas6 = var.classe1
const vari6 = "tipoarma"
const extr6 = config:arma_txt
#
const nome7 = "Consome vida"
const info7 = "Quantos pontos de vida consome"
const tipo7 = "numero"
const clas7 = var.classe1
const vari7 = "usavida"
#
const nome8 = "Consome mana"
const info8 = "Quantos pontos de mana consome"
const tipo8 = "numero"
const clas8 = var.classe1
const vari8 = "usamana"
#
const nome9 = "Consome vigor"
const info9 = "Quantos pontos de vigor consome"
const tipo9 = "numero"
const clas9 = var.classe1
const vari9 = "usamove"
#
const nome13 = "Preço da aula"
const info13 = "Quantas moedas os personagens cobram para ensinar"
const tipo13 = "numero"
const clas13 = var.classe1
const vari13 = "valor"
#
const nome14 = "Depende de"
const info14 = "Habilidades, magias e idiomas necessários para aprender esse ataque"
const tipo14 = "tipodep"
const clas14 = var.classe1
const vari14 = "depende"
#
const nome15 = "Iniciante nível"
const info15 = "A partir de que nível pode ter a primeira aula"
const tipo15 = "numero"
const clas15 = var.classe1
const vari15 = "aulaini"
#
const nome16 = "Perito nível"
const info16 = "A partir de que nível pode ter todas as aulas"
const tipo16 = "numero"
const clas16 = var.classe1
const vari16 = "aulafim"
#
const nome17 = "Somente tipos"
const info17 = "Se estiver vazio, todas as classes e raças podem aprender"
const tipo17 = "tipos"
const clas17 = var.classe1
const vari17 = "tipoperso"


classe menu_hab_ataque
herda menu_hab_comum
const titulo = "Hab " + txt(var.classe1, 4)
const colunas = 23
#
const nome1 = "Tipo de ataque"
const tipo1 = "opcao"
const clas1 = var.classe1
const vari1 = "tipoatk"
const extr1 = config:atknomes
#
const nome2 = "Alvo"
const tipo2 = "opcao"
const clas2 = var.classe1
const vari2 = "tipoalvo"
const extr2 = "Um alvo\nTodos dividindo o ataque\nTodos sem dividir o ataque"
#
const nome3 = "Precisão"
const info3 = "Em porcentagem, maior que 100 nunca falha"
const tipo3 = "numero"
const clas3 = var.classe1
const vari3 = "precisao"
#
const nome4 = "Força"
const info4 = "Em porcentagem"
const tipo4 = "numero"
const clas4 = var.classe1
const vari4 = "ataque"
#
const nome5 = "Velocidade"
const info5 = "Em porcentagem"
const tipo5 = "numero"
const clas5 = var.classe1
const vari5 = "vel"
#
const nome10 = "Msg acertou"
const info10 = "Mensagem quando quando acertou o alvo"
const tipo10 = "linha"
const clas10 = var.classe1
const vari10 = "msgacertou"
#
const nome11 = "Msg errou"
const info11 = "Mensagem quando quando errou o alvo"
const tipo11 = "linha"
const clas11 = var.classe1
const vari11 = "msgerrou"
#
const nome12 = "Msg sem efeito"
const info12 = "Mensagem quando quando o golpe não teve efeito"
const tipo12 = "linha"
const clas12 = var.classe1
const vari12 = "msgnulo"
#
const nome18 = "Bônus tipos"
const info18 = "Quais raças e classes atacam com mais força"
const tipo18 = "tipos"
const clas18 = var.classe1
const vari18 = "tipobonus"


classe menu_magia_ataque
herda menu_hab_ataque
const titulo = "Magia " + txt(var.classe1, 6)
const colunas = 23


classe comando_hab
herda comando_comum
const objcmd = arg0.persobat.var.[nomevar] ? este
const atkajuda = arg0.persobat.var.[nomevar] ? este
const posic = 7

func checahab # Checa se personagem pode usar habilidade/magia e avisa o personagem
# arg0 = personagem
# Retorna verdadeiro se pode usar
  ref r
  r = arg0.persobat
  se !tipoarma # Nenhum tipo de arma definido: aceita qualquer arma
  senao !r.iempu # Não está usando uma arma
    se !(tipoarma & 1)
      arg0.msg("Não possui a arma necessária.")
      ret
    fimse
  senao r.iempu && tipoarma & 1 << r.iempu.obj.armatipo
  senao tipoarma == 1
    arg0.msg("Empunhando uma arma?")
    ret
  senao
    arg0.msg("Com essa arma?")
    ret
  fimse
  se r.pvida <= int(usavida)
    arg0.msg("Pontos de vida insuficientes")
    ret
  senao r.pmana < int(usamana)
    arg0.msg("Mana insuficiente")
    ret
  senao r.pmove < int(usamove)
    arg0.msg("Vigor insuficiente")
    ret
  fimse
  ret 1


classe comando_ataque
herda comando_hab
const cmdmenu = "ataque" # Editável via "menu_hab_ataque" e "menu_magia_ataque"
const nomevar = "" # Nome da variável que indica o quanto sabe do ataque
const tipoatk = 0 # Tipo de golpe
const precisao = 100 # Precisão do golpe, maior que 100 nunca falha
const ataque = 50 # Força de ataque, 100 significa 100%
const vel = 50 # Velocidade do golpe, 100 significa 100%
const msgacertou = "$R ataca $c"
const msgerrou = msgacertou + " mas erra"
const msgnulo = msgacertou + ", nada acontece"
int32 result # Danos de batalha, ou 0=nenhum -1=errou o alvo -2=cancelar ataque
ref arma1 # Arma usada

func txtajuda
  textotxt t
  se depende
    t.addfim(depende)
    textopos pos
    epara pos = t.ini, pos, pos.depois
      pos.mudar(misc:nomevar(pos.texto))
    efim
    t.addfim("Requer conhecimentos de: " + txttroca(t.remove(1000), "\n", ", "))
    t.juntar, t.dividelin(40, 75)
  fimse
  extra && t.addini(extra)
  txt100 lin
  lin = "\c3" + misc:nomevar(nomevar) + "\b\nAtaque do nível " + int(aulafim)
  lin += ", " + txtsublin(config:atknomes, tipoatk, 1)
  t.addini(lin + ", Força " + ataque + ", Velocidade " + vel)
  se tipoperso
    t.addfim("Somente classes/raças: " + txttroca(tipoperso, "\n", ", "))
  fimse
  ret t.remove(1000)

func escr # Atacar alguém
  ref r
  se !checahab(arg0)
    ret
  senao arg0.ataqueini
    arg0.msg(arg0.ataqueini)
    ret
  senao arg1
    listaitem i
    nomeobj nome
    nome.ini(arg1, 1)
    epara i = arg0.dono.dentro2.ini, i, i.depois
      sair i.obj.visivel(arg0) && nome.nome(i.obj.ident)
    efim
    r = i.obj
    ret !r, arg0.msg("Você não vê isso.")
    ret r == arg0, arg0.msg("Atacar a si mesmo?")
  senao
    r = arg0.atkenv.objlista
    se !r || r.dono != arg0.dono
      arg0.msg("Atacar quem?")
      ret
    fimse
  fimse
  se !arg0.dono.s_luta
    arg0.msg("Aqui é um lugar pacífico.")
  senao arg0.jog && r.jog && arg0.dono.s_luta < 2
    arg0.msg(r.descnome + " é jogador e aqui não é uma arena.")
  senao !r.p_agressivo(arg0)
    arg0.msg(r.descnome + " não quer brigar.")
  senao
    ataca(arg0, r)

func ataca # Chamado quando personagem (arg0) quer atacar alguém (arg1)
  ref r
  r = arg0.persobat
# Obtém a arma usada
  arma1 = nulo
  tipoarma && (arma1 = r.iempu.obj)
# Eventos
  listaobj l
  epara l.addfim(arg0.evento, arg1.evento), l, l.ini.remove
    ret l.objini.cmd_atacar(arg0, arg1, este), nulo
  efim
# Custo do ataque
  r.pvida -= usavida, r.pmana -= usamana, r.pmove -= usamove
# Obtém a força do ataque e os alvos secundários
  real atk
  tipoalvo && l.addfim(arg0.dono.dentro1) + l.remove(arg0, arg1)
  atk = tipoalvo == 1 ? ataque / l.total : ataque
  se arma1
    real carga
    carga = (arg0.pesoden - arg0.pesovest + arma1.pesoobj * 4) / (arg0.pesomax + 1)
    se carga > 1.2 # Muito pesado
      atk /= carga < 1.4 ? 10 : 100
      arg0.msg("É muito peso!")
    senao carga > 1 # Um pouco pesado
      atk *= 5 - 4 * carga # se carga=1,atk*=1  se carga=1.2,atk*=0.2
      arg0.msg("Bastante peso!")
    fimse
  fimse
# Ataca o alvo escolhido
  velgolpe(arg0, arg1) # Tempo do golpe
  execgolpe(arg0, arg1, atk, 2 + arg0.persobat.var.[nomevar]) # Ataca
  result != -2 && $mens.p(arg0, arg1) + $mens.mtodos1(mensgolpe)
  arg1.persobat.acertapos(1)
# Ataca os alvos secundários
  enquanto l
    r = l.objini, l.ini.remove
    continuar r.jog || r.perso < 3 # Não prossegue se for jogador
    velgolpe(arg0, r) # Tempo do golpe
    execgolpe(arg0, r, atk, 2 + arg0.persobat.var.[nomevar]) # Ataca
    result != -2 && $mens.p(arg0, r) + r.msginv(mensgolpe)
    r.acertapos(1)
  efim
  arg0.persobat.acertapos(1)

func velgolpe # Acerta o tempo de espera conforme o golpe
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# vel = velocidade do golpe
  real tempo
# Se velocidades dos personagens iguais e velocidade do golpe=100: tempo=30
# Fórmula 1
# tempo = arg0.persobat.pveloc + arg1.persobat.pveloc # Tempo total
# tempo = tempo * 1500 / (arg0.persobat.pveloc * veloc + 1)
# Fórmula 2
  tempo = arg1.persobat.pveloc * 3000 / (arg0.persobat.pveloc * veloc + 1)
# Acerta o tempo
  tempo < 8 && (tempo = 8)
  tempo > 70 && (tempo = 70)
  arg0.p_espera < tempo && (arg0.p_espera = tempo)

func execgolpe # Realiza um ataque e coloca resultado em result
# arg0 = personagem que está atacando
# arg1 = personagem alvo
# arg2 = força do ataque, 0=não calcular danos
# arg3 = o quanto sabe do golpe, de 0 a 10
# tipoatk = tipo de ataque, arma1 = arma usada
  real dano
  ref r # Personagem que ataca
  ref s # Personagem que recebe o ataque
# Checa se pode realmente atacar
  r = arg0.persobat, s = arg1.persobat, result = -2
  listaobj l
  epara l.addfim(r.evento), l, l.ini.remove
    ret l.objini.cmd_atkenv(arg0, arg1, este), nulo
  efim
  epara l.addfim(s.evento), l, l.ini.remove
    ret l.objini.cmd_atkrec(arg0, arg1, este), nulo
  efim
# Indica que atacou, recebe experiência se vencer
  arg0.batalhaini(arg1)
  se r.podepegar && arg1.var.o_agenda # Coloca na agenda
    refvar v1 = arg1.var.a_[r.nome]
    !v1 && (v1 = 1)
  fimse
# Checa se acertou o alvo
  result = -1
  se precisao <= 100
    dano = rand(1, 20)
    se dano == 20 || arg1.posicao == 4 # Acertou automaticamente
    senao dano == 1 # Errou o alvo automaticamente
      ret
    senao # Checa se acertou
      dano += precisao * r.precisao * (arma1 ? arma1.armaprecisao : 100) / 10000
      dano -= s.evasao
      !s.visivel(r) && (dano -= 5) # Invisível é mais difícil de acertar
      ret dano <= 0, nulo
    fimse
  fimse
# Checa bônus ao combinar o tipo de ataque com o tipo de defesa
  dano = r.atktipo.[2 + tipoatk] * s.deftipo.[2 + tipoatk] / 1000000
  se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
    dano *= r.atktipo.1 * s.deftipo.1 / 1000000
  senao
    dano *= r.atktipo.0 * s.deftipo.0 / 1000000
  fimse
  se dano == 0 # Imune
    result = 0
    ret
  fimse
# Checa bônus do personagem
  se !tipobonus
  senao r.tipo1 && txtproc("\n" + tipobonus + "\n", "\n" + r.tipo1 + "\n") >= 0
    dano *= 1.5
  senao r.tipo2 && txtproc("\n" + tipobonus + "\n", "\n" + r.tipo2 + "\n") >= 0
    dano *= 1.5
  senao r.tipo3 && txtproc("\n" + tipobonus + "\n", "\n" + r.tipo3 + "\n") >= 0
    dano *= 1.5
  fimse
# Calcula dano com arma
  se arma1
    dano *= rand(arma1.armamin, arma1.armamax)
    se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
      dano *= r.atkesp * arg2 / (s.defesp * 500)
    senao
      dano *= r.atknorm * arg2 / (s.defnorm * 500)
    fimse
# Calcula dano sem arma; valor do rand é por volta de 500
  senao
    se misc:atkesp(tipoatk) # Checa se golpe normal ou especial
      dano *= r.atkesp * r.atkesp * arg2 / (s.defesp * rand(450, 550))
    senao
      dano *= r.atknorm * r.atknorm * arg2 / (s.defnorm * rand(450, 550))
    fimse
    dano *= 1 + (r.pnivel - s.pnivel) / (r.pnivel + s.pnivel + 10)
  fimse
# Modificadores de posição
  casovar s.posicao
  casose "0" # Morto
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    dano *= 2.666
    sair
  casose "3" # Muito fraco
    dano *= 2.333
    sair
  casose "4" # dormindo
    dano *= 2
    sair
  casose "5" # descansando
    dano *= 1.666
    sair
  casose "6" # sentado
    dano *= 1.333
    sair
  casofim
# Atualiza pontos de vida conforme os danos (pelo menos 1 de dano)
  result = dano < 1 ? 1 : dano
  arg2 && (s.pvida -= result)

func mensgolpe # Retorna mensagem do golpe de acordo com result
  casovar result
  casose "-1" # Errou o alvo
    ret msgerrou
  casose "0" # O golpe não teve efeito
    ret msgnulo
  casose # Acertou o alvo
    ret msgacertou + ", " + -result
  casose "-2" # Ataque foi cancelado
  casofim


classe comando_atkauto
herda comando_ataque
# Para realizar ataques automáticos
const objcmd = nulo
const objajuda = nulo
txt100 msgacertou
txt100 msgerrou
txt100 msgnulo
const ataque = 100
const vel = 50
const extra = "Ataque automático"
uint8 tipoatk # Tipo de ataque

func ataca # arg0 ataca arg1
  uint8 aulas # O quanto sabe do golpe, de 0 a 10
  arma1 = ref(arg0.persobat.iempu.obj)
  arma1.armamanual && (arma1 = nulo)
  tipoatk = arma1.armatipoatk
  aulas = 2 + arg0.persobat.var.[txtsublin(config:arma_txt, arma1.armatipo, 1)]
# Acerta mensagens
  msgacertou = txtsublin(config:arma_acertou, arma1.armatipo, 1)
  msgerrou = txtsublin(config:arma_errou, arma1.armatipo, 1)
  msgnulo = txtsublin(config:arma_nulo, arma1.armatipo, 1)
  !msgacertou && (msgacertou = "$R dá um golpe em $c")
  !msgerrou && (msgerrou = "$R tenta dar um golpe em $c mas erra")
  !msgnulo && (msgnulo = "$R dá um golpe em $c mas nada acontece")
# Primeiro ataque
  execgolpe(arg0, arg1, ataque, aulas) # Ataca
  result != -2 && $mens.p(arg0, arg1) + $mens.mtodos1(mensgolpe)
  arg1.acertapos(1), arg0.acertapos(1)
# Segundo ataque
  ret !arg0.atkenv || !arg0.persobat.var.h_segundo_ataque, nulo
  execgolpe(arg0, arg1, ataque, aulas * (2 + arg0.persobat.var.h_segundo_ataque) / 10)
  result != -2 && $mens.p(arg0, arg1) + $mens.mtodos1(mensgolpe)
  arg1.acertapos(1), arg0.acertapos(1)
# Terceiro ataque
  ret !arg0.atkenv || !arg0.persobat.var.h_terceiro_ataque, nulo
  execgolpe(arg0, arg1, ataque, aulas * (2 + arg0.persobat.var.h_terceiro_ataque) / 10)
  result != -2 && $mens.p(arg0, arg1) + $mens.mtodos1(mensgolpe)
  arg1.acertapos(1), arg0.acertapos(1)


classe cmd_resgatar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Resgatar\b\n\
Sintaxe: RESGATAR <personagem>\n\
Resgata um jogador em uma batalha. É como se você se colocasse entre\n\
o jogador e quem está atacando ele."

func escr
  ret arg0.dono.s_naoresg, arg0.msg("Aqui não é possível resgatar.")
  ret !arg1, arg0.msg("Resgatar quem?")
  nomeobj n
  listaitem i
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro2.ini, i, i.depois
    continuar !i.obj.visivel(arg0) || !n.nome(i.obj.ident)
    ref r
    r = i.obj
# Checa se é possível resgatar
    ret arg0 == r, arg0.msg("Resgatar você mesmo?")
    ret !r.jog, arg0.msg(i.obj.descnome + " não é jogador.")
    ret !r.atkrec.objini, arg0.msg(i.obj.descnome + " não está lutando.")
    ret r.atkenv.objlista == arg0, arg0.msg(i.obj.descnome + " está lutando com você.")
# Checa se personagens permitem resgate
    epara i = r.atkrec.ini, i, i.depois
      ret i.obj.p_naoresg, arg0.msg("Não é possível resgatar " + r.descnome + " de " + i.obj.desc\
nome + ".")
    efim
# Eventos
    listaobj l
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_resgatar(arg0, r), nulo
    efim
# Resgata
    enquanto r.atkrec.objini
      r.atkrec.objini.batalhaini(arg0)
    efim
    $mens.p(arg0, r)
    $mens.mvis1("$P resgata $a.")
    ret
  efim
  arg0.msg("Você não vê " + arg1 + ".")


classe cmd_matar
herda comando_ataque
const objcmd = config:atktipo ? este
const objajuda = config:atktipo ? este
const txtajuda = "\b\c3Matar\b\n\
Sintaxe: MATAR <personagem>\n\
Começa uma batalha com um personagem."
const cmdmenu = ""

func ataca # Chamado quando personagem (arg0) quer atacar alguém (arg1)
  ret arg0.atkenv, msg("Você já está lutando.")
  int8 x
  x = arg1.atktempo
# Realiza um ataque, retorna se não atacou
  $comando_atkauto.ataca(arg0, arg1)
  ret !arg0.atkenv, nulo
  arg0.atktempo = config:atktempo
  arg0.p_espera < config:atktempo && (arg0.p_espera = config:atktempo)
# Faz o adversário atacar
  ret x, nulo
  arg1.atktempo = 1
  arg1.p_espera < config:atktempo && (arg1.p_espera = config:atktempo)
