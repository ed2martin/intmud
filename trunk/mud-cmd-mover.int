classe comando_mover
herda comando_comum
const m_entra1 = "$P chegou."
const m_entra2 = m_entra1
const m_entra3 = m_entra1
const m_sai1 = "$P foi embora."
const m_sai2 = m_sai1
const m_sai3 = m_sai1
const m_fugir = "$P fugiu."
const dir = ""
listaobj lseg # Para não seguir ciclicamente
int8 andou # Se conseguiu andar (deve fechar a porta)
debug dbg
txt300 abriu1 # Mensagem, se abriu a porta da casa
txt300 abriu2

func escr # Executa o comando
# arg0 = personagem
  $comando_mover.lseg.limpar
  $comando_mover.andou = 0
  refvar sala = ref(arg0.dono)
# Anda
  txt100 dir1
  se !arg0.jog || rand($miscfome.bebedir, $miscfome.cheio) > arg0.p_bebida
    dir1 = dir, mover(arg0)
  senao # Bêbado andando em uma direção aleatória
    dir1 = fugirdir(arg0)
    !dir1 && (dir1 = dir)
    $cmd_[dir1].mover(arg0)
  fimse
# Fecha a porta
  se sala.fecha_[dir1] && $comando_mover.andou
    refvar m = sala.porta_[dir1] < 2 ? "$M se $2."
    sala.mudaporta(dir1, sala.tranc_[dir1] == 2 ? 3 : 2, m, m)
  fimse

func mover # Personagem anda em uma direção
# arg0 = personagem
  listaobj l
  ref s1 # Sala aonde está
  ref s2 # Sala para onde vai
  dbg.ini
  $comando_mover.lseg.addfim(arg0)
  misc:obj = arg0
  abriu1 = abriu2 = ""
  s1 = arg0.dono, s2 = s1.dir_[dir]
  se s2 == nulo
    ret arg0.msg("Impossível seguir nessa direção.")
  senao s1.porta_[dir] & 3 >= 2 && !arg0.jogconfig.14
    ret !s1.socktot, nulo
    refvar cod = $c_[s1.fechadura_[dir]].chave
    ret !cod, arg0.msg($mens_porta.mens("$P est$o fechad$a.", arg0.dono, dir))
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i.obj, arg0.msg($mens_porta.mens("$P est$o fechad$a.", arg0.dono, dir))
    abriu1 = config:casaabriu1
    abriu2 = config:casaabriu2
    abriu2 && (abriu2 += "\n")
  senao s1.voar_[dir] && !(arg0.bitver & 512 || arg0.bitinv & 48)
    ret arg0.msg("Você não consegue porque não está flutuando.")
  fimse
  uint8 total
  total = s1.totalmove + s2.totalmove
  !s1.visivel(arg0) && (total *= 2) # No escuro gasta mais movimentos
  total *= (2 + $miscfome.f.[arg0.p_sede] + $miscfome.f.[arg0.p_fome]) / 2
  (arg0.bitver & 512 || arg0.bitinv & 48) && (total /= 2) # Flutuando gasta menos movimentos
  se arg0.pmove < intdiv((total + 1) / 2)
    arg0.msg("Você está cansad" + (arg0.msexo ? "o" : "a") + " demais.")
    ret
  fimse
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_mover(arg0, arg0.dono, dir), nulo
  efim
  $comando_mover.andou = 1
  !arg0.jogconfig.14 && (arg0.pmove -= intdiv((total + 1) / 2))
  arg0.p_espera = total > 30 ? 60 : total ? total * 2 : 2
  se !(s1.socktot || s2.socktot) # Não tem jogador por perto
    arg0.mudadono(s2)
  senao arg0.p_bebida >= $miscfome.bebedir - rand(20) # Cambaleando não anda em silêncio
    $mens.p(arg0) + $mens.mvis2(abriu1, abriu2 + m_sai4)
    arg0.mudadono(s2)
    $mens.p(arg0) + $mens.mvis2("", m_entra4)
  senao arg0.bitinv & 48 # Voando ou voando alto
    mover2(arg0, s2, abriu2 + m_sai3, m_entra3)
  senao arg0.bitver & 0x200 # Flutuando
    mover2(arg0, s2, abriu2 + m_sai2, m_entra2)
  senao # Não está voando nem flutuando
    mover2(arg0, s2, abriu2 + m_sai1, m_entra1)
  fimse
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_moveu(arg0, arg0.dono, dir)
  efim
# Checa se morre ao entrar
  se arg0.dono.s_morre && !arg0.jogconfig.14
    se arg0.dono.s_morre == 2 # Se apaga os itens
      epara l.addfim(arg0.dentro1, arg0.dentro2), l, l.ini.remove
        l.objini.item && !l.objini.manterperso && apagar(l.objini)
      efim
      arg0.var.z_moedas = ""
    fimse
    ret arg0.morreu
  fimse
# Seguir
  epara l.addfim(arg0.lseguir), l, l.ini.remove
    continuar l.objini.posicao < 8 || l.objini.dono != s1
    continuar $comando_mover.lseg.possui(l.objini)
    continuar !arg0.visivel(l.objini) || !s1.visivel(l.objini)
    l.objini.msg("Você segue " + arg0.descnome + ".")
    mover(l.objini)
  efim

func mover2 # Chamado por mover, para mudar de sala enviando mensagem
# arg0 = personagem
# arg1 = sala destino
# arg2 = mensagem saiu
# arg3 = mensagem chegou
# abriu1 = mensagem para o personagem
  listaobj l
  $mens.p(arg0)
  abriu1 && arg0.msgvis(abriu1)
  se arg0.bitver & 256 # Anda em silêncio
    $mens.mens = " em silêncio"
    l.addfim(arg0.dono.dentro2)
    epara l.remove(arg0), l, l.ini.remove
      l.objini.bitver & 0x1000 && l.objini.msgvis(arg2)
    efim
    arg0.mudadono(arg1)
    $mens.p(arg0), $mens.mens = " em silêncio"
    l.addfim(arg0.dono.dentro2)
    epara l.remove(arg0), l, l.ini.remove
      l.objini.bitver & 0x1000 && l.objini.msgvis(arg3)
    efim
  senao
    $mens.mens = "", $mens.mvis2("", arg2)
    arg0.mudadono(arg1)
    $mens.p(arg0)
    $mens.mens = "", $mens.mvis2("", arg3)
  fimse

func fugirdir # Obtém direção para onde pode fugir
# Entrada: arg0 = personagem
# Retorna: direção ou "" se não há para onde fugir
  misc:obj = arg0
  refvar r = ref(arg0.dono)
  txt100 t
  prog p
  se arg0.jog
    epara p.inifunctudo(r, "dir_"), p.lin, p.depois
      refvar y = txt(p.texto, 4)
      r.[p.texto] && !r.fugir_[y] && int(r.porta_[y]) < 2 && (t += y + " ")
    efim
  senao
    epara p.inifunctudo(r, "dir_"), p.lin, p.depois
      refvar x = ref(r.[p.texto])
      continuar !x || x.dentro2.total - x.socktot >= x.s_pnj
      refvar y = txt(p.texto, 4)
      !r.fugir_[y] && int(r.porta_[y]) < 2 && (t += y + " ")
    efim
  fimse
  ret t ? txtsub(t, rand(intsub(t)), 1) : ""


classe cmd_n
herda comando_mover
const m_entra1 = "$P chegou do sul$m."
const m_entra2 = "$P flutuou do sul$m."
const m_entra3 = "$P voou do sul$m."
const m_entra4 = "$P chegou do sul cambaleando."
const m_sai1 = "$P foi para o norte$m."
const m_sai2 = "$P flutuou o norte$m."
const m_sai3 = "$P voou para o norte$m."
const m_sai4 = "$P foi para o norte cambaleando."
const m_fugir = "$P fugiu para o norte."
const m_porta = "a porta norte"
const dir = "n"


classe cmd_s
herda comando_mover
const m_entra1 = "$P chegou do norte$m."
const m_entra2 = "$P flutuou do norte$m."
const m_entra3 = "$P voou do norte$m."
const m_entra4 = "$P chegou do norte cambaleando."
const m_sai1 = "$P foi para o sul$m."
const m_sai2 = "$P flutuou para o sul$m."
const m_sai3 = "$P voou para o sul$m."
const m_sai4 = "$P foi para o sul cambaleando."
const m_fugir = "$P fugiu para o sul."
const m_porta = "a porta sul"
const dir = "s"


classe cmd_l
herda comando_mover
const m_entra1 = "$P chegou do oeste$m."
const m_entra2 = "$P flutuou do oeste$m."
const m_entra3 = "$P voou do oeste$m."
const m_entra4 = "$P chegou do oeste cambaleando."
const m_sai1 = "$P foi para leste$m."
const m_sai2 = "$P flutuou para leste$m."
const m_sai3 = "$P voou para leste$m."
const m_sai4 = "$P foi para leste cambaleando."
const m_fugir = "$P fugiu para leste."
const m_porta = "a porta leste"
const dir = "l"


classe cmd_e
herda comando_comum
const objcmd = $cmd_l.objcmd(arg0, arg1)


classe cmd_o
herda comando_mover
const m_entra1 = "$P chegou do leste$m."
const m_entra2 = "$P flutuou do leste$m."
const m_entra3 = "$P voou do leste$m."
const m_entra4 = "$P chegou do leste cambaleando."
const m_sai1 = "$P foi para oeste$m."
const m_sai2 = "$P flutuou para oeste$m."
const m_sai3 = "$P voou para oeste$m."
const m_sai4 = "$P foi para oeste cambaleando."
const m_fugir = "$P fugiu para oeste."
const m_porta = "a porta oeste"
const dir = "o"


classe cmd_w
herda comando_comum
const objcmd = $cmd_o.objcmd(arg0, arg1)


classe cmd_c
herda comando_mover
const m_entra1 = "$P chegou de baixo$m."
const m_entra2 = "$P flutuou de baixo$m."
const m_entra3 = "$P voou de baixo$m."
const m_entra4 = "$P chegou de baixo cambaleando."
const m_sai1 = "$P subiu$m."
const m_sai2 = "$P flutuou para cima$m."
const m_sai3 = "$P voou para cima$m."
const m_sai4 = "$P subiu cambaleando."
const m_fugir = "$P fugiu para cima."
const m_porta = "a passagem para cima"
const dir = "c"


classe cmd_u
herda comando_comum
const objcmd = $cmd_c.objcmd(arg0, arg1)


classe cmd_b
herda comando_mover
const m_entra1 = "$P chegou de cima$m."
const m_entra2 = "$P flutuou de cima$m."
const m_entra3 = "$P voou de cima$m."
const m_entra4 = "$P chegou de cima cambaleando."
const m_sai1 = "$P desceu$m."
const m_sai2 = "$P flutuou para baixo$m."
const m_sai3 = "$P voou para baixo$m."
const m_sai4 = "$P desceu cambaleando."
const m_fugir = "$P fugiu para baixo."
const m_porta = "a passagem para baixo"
const dir = "b"


classe cmd_d
herda comando_comum
const objcmd = $cmd_b.objcmd(arg0, arg1)


classe cmd_ne
herda comando_mover
const m_entra1 = "$P chegou do sudoeste$m."
const m_entra2 = "$P flutuou do sudoeste$m."
const m_entra3 = "$P voou do sudoeste$m."
const m_entra4 = "$P chegou do sudoeste cambaleando."
const m_sai1 = "$P foi para o nordeste$m."
const m_sai2 = "$P flutuou para o nordeste$m."
const m_sai3 = "$P voou para o nordeste$m."
const m_sai4 = "$P foi para o nordeste cambaleando."
const m_fugir = "$P fugiu para o nordeste."
const m_porta = "a porta nordeste"
const dir = "ne"


classe cmd_no
herda comando_mover
const m_entra1 = "$P chegou do sudeste$m."
const m_entra2 = "$P flutuou do sudeste$m."
const m_entra3 = "$P voou do sudeste$m."
const m_entra4 = "$P chegou do sudeste cambaleando."
const m_sai1 = "$P foi para o noroeste$m."
const m_sai2 = "$P flutuou para o noroeste$m."
const m_sai3 = "$P voou para o noroeste$m."
const m_sai4 = "$P foi para o noroeste cambaleando."
const m_fugir = "$P fugiu para o noroeste."
const m_porta = "a porta noroeste"
const dir = "no"


classe cmd_nw
herda comando_comum
const objcmd = $cmd_no.objcmd(arg0, arg1)


classe cmd_se
herda comando_mover
const m_entra1 = "$P chegou do noroeste$m."
const m_entra2 = "$P flutuou do noroeste$m."
const m_entra3 = "$P voou do noroeste$m."
const m_entra4 = "$P chegou do noroeste cambaleando."
const m_sai1 = "$P foi para o sudeste$m."
const m_sai2 = "$P flutuou para o sudeste$m."
const m_sai3 = "$P voou para o sudeste$m."
const m_sai4 = "$P foi para o sudeste cambaleando."
const m_fugir = "$P fugiu para o sudeste."
const m_porta = "a porta sudeste"
const dir = "se"


classe cmd_so
herda comando_mover
const m_entra1 = "$P chegou do nordeste$m."
const m_entra2 = "$P flutuou do nordeste$m."
const m_entra3 = "$P voou do nordeste$m."
const m_entra4 = "$P chegou do nordeste cambaleando."
const m_sai1 = "$P foi para o sudoeste$m."
const m_sai2 = "$P flutuou para o sudoeste$m."
const m_sai3 = "$P voou para o sudoeste$m."
const m_sai4 = "$P foi para o sudoeste cambaleando."
const m_fugir = "$P fugiu para o sudoeste."
const m_porta = "a porta sudoeste"
const dir = "so"


classe cmd_sw
herda comando_comum
const objcmd = $cmd_so.objcmd(arg0, arg1)


classe cmd_entrar
herda comando_mover
const m_entra1 = "$P entrou aqui$m."
const m_entra2 = "$P flutuou de fora$m."
const m_entra3 = "$P voou de fora$m."
const m_entra4 = "$P entrou aqui cambaleando."
const m_sai1 = "$P entrou$m."
const m_sai2 = "$P flutuou para dentro$m."
const m_sai3 = "$P voou para dentro$m."
const m_sai4 = "$P entrou cambaleando."
const m_fugir = "$P fugiu para dentro."
const m_porta = "dentro"
const dir = "entrar"


classe cmd_sair
herda comando_mover
const m_entra1 = "$P chegou de dentro$m."
const m_entra2 = "$P flutuou de dentro$m."
const m_entra3 = "$P voou de dentro$m."
const m_entra4 = "$P chegou de dentro cambaleando."
const m_sai1 = "$P saiu$m."
const m_sai2 = "$P flutuou para fora$m."
const m_sai3 = "$P voou para fora$m."
const m_sai4 = "$P saiu cambaleando."
const m_fugir = "$P fugiu para fora."
const m_porta = "fora"
const dir = "sair"


classe cmd_seguir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Seguir\b\n\
Sintaxe: SEGUIR [personagem]\n\
Segue um personagem.\n\
Se o personagem for omitido ou for você mesmo, você passa a não seguir\n\
ninguém. Para outros personagens não seguirem você, veja a opção SEGUIR\n\
do comando CONFIG."
const posic = 5

func escr
# Sem argumentos: deixa de seguir
  se !arg1
    arg0.iseguir.remove
    arg0.msg("Você não segue ninguém.")
    ret
  fimse
# Procura o personagem
  nomeobj n # Para reconhecer os personagens
  listaitem i
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro2.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  ret !i, arg0.msg("Você não vê " + arg1 + ".")
# Segue o personagem
  se i.obj == arg0
    arg0.iseguir.remove
    arg0.msg("Você não segue ninguém.")
  senao i.obj.p_naoseguir(arg0)
    arg0.msg("Você não consegue seguir " + i.obj.descnome + ".")
  senao
    arg0.iseguir.remove
    arg0.iseguir = i.obj.lseguir.addfim(arg0)
    arg0.msg("Você segue " + i.obj.descnome + ".")


classe cmd_abrir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Abrir\b\n\
Sintaxe: ABRIR <objeto ou direção>\n\
Abre um objeto ou uma porta."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Abrir um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Abrir o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está aberto
  ref r
  r = i.obj
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está abert" + (r.msexo ? "o." : "a."))
  casose "4"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " está trancad" + (r.msexo ? "o." : "a."))
  casose
    ret arg0.msg("Não foi possível abrir " + r.descnome + ".")
  casose "3"
  casose "5"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_abrirobj(arg0, r), nulo
  efim
# Abre o item
  r.i_aberto = 2
  $mens.p(arg0, r)
  $mens.mtodos1("$P abriu $a.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_abriuobj(arg0, r)
  efim

func escrdir # Abrir uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está aberto
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg($mens_porta.mens("$P já est$o abert$a.", arg0.dono, arg1))
  casose "3"
    ret arg0.msg($mens_porta.mens("$P est$o trancad$a.", arg0.dono, arg1))
  casose "2"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_abrirdir(arg0, arg0.dono, arg1), nulo
  efim
# Abre a porta
  $mens.p(arg0)
  arg0.dono.mudaporta(arg1, 1, "$P abriu $m.", "$M se $1.") # Abre a porta
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_abriudir(arg0, arg0.dono, arg1)
  efim


classe cmd_fechar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Fechar\b\n\
Sintaxe: FECHAR <objeto ou direção>\n\
Fecha um objeto ou uma porta."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Fechar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Fechar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está fechado
  ref r
  r = i.obj
  casovar r.i_aberto
  casose "3"
  casose "4"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está fechad" + (r.msexo ? "o." : "a."))
  casose
    ret arg0.msg("Não foi possível fechar " + r.descnome + ".")
  casose "2"
  casose "5"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_fecharobj(arg0, r), nulo
  efim
# Fecha o item
  r.i_aberto = r.i_tranc == 2 ? 4 : 3
  $mens.p(arg0, r)
  $mens.mtodos1("$P fechou $a.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_fechouobj(arg0, r)
  efim

func escrdir # Fechar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está fechado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "2"
  casose "3"
    ret arg0.msg($mens_porta.mens("$P já est$o fechad$a.", arg0.dono, arg1))
  casose "1"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_fechardir(arg0, arg0.dono, arg1), nulo
  efim
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Fecha a porta
  $mens.p(arg0)
  se arg0.dono.tranc_[arg1] == 2
    arg0.dono.mudaporta(arg1, 3, "$P fechou $m.", "$M se $2.") # Tranca a porta
  senao
    arg0.dono.mudaporta(arg1, 2, "$P fechou $m.", "$M se $2.") # Fecha a porta
  fimse
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_fechoudir(arg0, arg0.dono, arg1)
  efim


classe cmd_destrancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Destrancar\b\n\
Sintaxe: DESTRANCAR <objeto ou direção>\n\
Destranca um objeto ou uma porta.\n\
Nota: pode ser necessário possuir uma chave para destrancar."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Destrancar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Destrancar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está trancado
  ref r
  r = i.obj, misc:obj = arg0
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " está abert" + (r.msexo ? "o." : "a."))
  casose "3"
    ret !r.i_tranc, arg0.msg(txtcopiamai(r.descnome, "A") + " não pode ser trancad" + (r.msexo ? \
"o." : "a."))
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " não está trancad" + (r.msexo ? "o." : "a."))
  casose
    ret arg0.msg("Não foi possível destrancar " + r.descnome + ".")
  casose "4"
  casose "5"
  casofim
# Procura a chave
  ref chave
  se r.i_fechadura && !arg0.jogconfig.14
    epara i = arg0.dentro1.ini, i, i.depois
      sair r.i_fechadura == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave de " + r.descnome + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_destrancarobj(arg0, r, chave), nulo
  efim
# Destranca o item
  r.i_aberto = 3
  $mens.p(arg0, r)
  $mens.mtodos1("$P destrancou $a.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_destrancouobj(arg0, r, chave)
  efim

func escrdir # Destrancar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está trancado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg($mens_porta.mens("$P est$o abert$a.", arg0.dono, arg1))
  casose "2"
    se arg0.dono.tranc_[arg1]
      ret arg0.msg($mens_porta.mens("$P não est$o trancad$a.", arg0.dono, arg1))
    senao
      ret arg0.msg($mens_porta.mens("$P não pode$m ser trancad$a.", arg0.dono, arg1))
    fimse
  casose "3"
  casofim
# Procura a chave
  txt100 mporta # Nome da porta
  txt100 cod # Código da fechadura
  ref chave # Chave que abre a fechadura
  misc:obj = arg0
  cod = arg0.dono.fechadura_[arg1], $c_[cod] && (cod = $c_[cod].chave)
  mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  se cod && !arg0.jogconfig.14
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave para destrancar " + mporta + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_destrancardir(arg0, arg0.dono, arg1, chave), nulo
  efim
# Destranca a porta
  arg0.dono.mudaporta(arg1, 2) # Destranca a porta
  $mens.p(arg0)
  $mens.mens = mporta
  $mens.mtodos1("$P destrancou $m.")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_destrancoudir(arg0, arg0.dono, arg1, chave)
  efim


classe cmd_trancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Trancar\b\n\
Sintaxe: TRANCAR <objeto ou direção>\n\
Tranca um objeto ou uma porta.\n\
Nota: pode ser necessário possuir uma chave para trancar."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Trancar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Trancar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está destrancado
  ref r
  r = i.obj, misc:obj = arg0
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.nome, "A") + " está abert" + (r.msexo ? "o." : "a."))
  casose "4"
    ret arg0.msg(txtcopiamai(r.nome, "A") + " já está trancad" + (r.msexo ? "o." : "a."))
  casose
    ret arg0.msg("Não foi possível trancar " + r.nome + ".")
  casose "3"
  casose "5"
  casofim
  ret !r.i_tranc, arg0.msg(txtcopiamai(r.nome, "A") + " não pode ser trancad" + (r.msexo ? "o." \
: "a."))
# Procura a chave
  ref chave
  se r.i_fechadura && !arg0.jogconfig.14
    epara i = arg0.dentro1.ini, i, i.depois
      sair r.i_fechadura == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave de " + r.nome + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_trancarobj(arg0, r, chave), nulo
  efim
# Tranca o item
  r.i_aberto = 4
  $mens.p(arg0, r)
  $mens.mtodos1("$P trancou $a.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_trancouobj(arg0, r, chave)
  efim

func escrdir # Trancar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está trancado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg($mens_porta.mens("$P est$o abert$a.", arg0.dono, arg1))
  casose "3"
    ret arg0.msg($mens_porta.mens("$P já est$o trancad$a.", arg0.dono, arg1))
  casose "2"
  casofim
  se !arg0.dono.tranc_[arg1]
    ret arg0.msg($mens_porta.mens("$P não pode$m ser trancad$a.", arg0.dono, arg1))
  fimse
# Procura a chave
  txt100 mporta # Nome da porta
  txt100 cod # Código da fechadura
  ref chave # Chave que abre a fechadura
  misc:obj = arg0
  cod = arg0.dono.fechadura_[arg1], $c_[cod] && (cod = $c_[cod].chave)
  mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  se cod && !arg0.jogconfig.14
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave para trancar " + mporta + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_trancardir(arg0, arg0.dono, arg1, chave), nulo
  efim
# Tranca a porta
  arg0.dono.mudaporta(arg1, 3) # Tranca a porta
  $mens.p(arg0)
  $mens.mens = mporta
  $mens.mtodos1("$P trancou $m.")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_trancoudir(arg0, arg0.dono, arg1, chave)
  efim


classe cmd_levantar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Levantar\b\nSintaxe: LEVANTAR\nFica em pé."

func escr
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
  casose "6" # Sentado
    sair
  casose "8" # Em pé
    ret arg0.msg("\c9Você já está em pé.\b")
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Ficar em pé
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_levantar(arg0), nulo
  efim
  arg0.poslugar.remove
  arg0.posicao = 8
  $mens.p(arg0)
  $mens.mtodos1("$P levantou-se.")
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_levantou(arg0)
  efim


classe cmd_sentar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sentar\b\n\
Sintaxe: SENTAR [objeto]\n\
Senta-se no chão. Com o nome de um objeto, tenta sentar no objeto."

func escr
  ref r
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
    r = arg0.poslugar.objlista
    sair
  casose "6" # Sentado
    ret arg0.msg("\c9Você já está sentad" + (arg0.msexo ? "o" : "a") + ".\b")
  casose "8" # Em pé
    sair
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Obtém aonde quer se sentar
  se arg1
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret r && r != i.obj, arg0.msg("\c9Talvez você deva se levantar primeiro.\b")
    r = i.obj
  fimse
  listaobj l
# Sentar em algum objeto
  se r
    se !r.i_movel
      ret arg0.msg("Não é possível descansar em " + r.descnome + ".")
    senao r != arg0.poslugar.objlista && r.i_lugar <= r.persolugar.total
      ret arg0.msg("Não cabe mais ninguém em " + r.descnome + ".")
    fimse
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_sentarobj(arg0, r, arg1), nulo
    efim
    arg0.poslugar.remove
    arg0.poslugar = r.persolugar.addfim(arg0)
    arg0.posicao = 6
    $mens.p(arg0, nulo, r)
    $mens.mtodos1("$P sentou-se em $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      l.objini.cmd_sentouobj(arg0, r, arg1)
    efim
# Sentar-se num objeto que não existe
  senao arg1
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_sentarobj(arg0, nulo, arg1), nulo
    efim
    arg0.msg("Você não vê " + arg1 + ".")
    ret
# Sentar-se no chão
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_sentarchao(arg0), nulo
    efim
    arg0.poslugar.remove
    arg0.posicao = 6
    $mens.p(arg0)
    $mens.mtodos1("$P sentou-se.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_sentouchao(arg0)
    efim


classe cmd_descansar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sentar\b\n\
Sintaxe: DESCANSAR [objeto]\n\
Descansa no chão. Com o nome de um objeto, tenta descansar no objeto."

func escr
  ref r
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
    ret arg0.msg("\c9Você já está descansando.\b")
  casose "6" # Sentado
    r = arg0.poslugar.objlista
    sair
  casose "8" # Em pé
    sair
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Obtém aonde quer descansar
  se arg1
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret r && r != i.obj, arg0.msg("\c9Talvez você deva se levantar primeiro.\b")
    r = i.obj
  fimse
  listaobj l
# Descansar em algum objeto
  se r
    se !r.i_movel
      ret arg0.msg("Não é possível descansar em " + r.descnome + ".")
    senao r != arg0.poslugar.objlista && r.i_lugar <= r.persolugar.total
      ret arg0.msg("Não cabe mais ninguém em " + r.descnome + ".")
    fimse
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_descansarobj(arg0, r, arg1), nulo
    efim
    arg0.poslugar.remove
    arg0.poslugar = r.persolugar.addfim(arg0)
    arg0.posicao = 5
    $mens.p(arg0, nulo, r)
    $mens.mtodos1("$P descansa em $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      l.objini.cmd_descansouobj(arg0, r, arg1)
    efim
# Descansar num objeto que não existe
  senao arg1
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_descansarobj(arg0, nulo, arg1), nulo
    efim
    arg0.msg("Você não vê " + arg1 + ".")
    ret
# Descansar no chão
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_descansarchao(arg0), nulo
    efim
    arg0.poslugar.remove
    arg0.posicao = 5
    $mens.p(arg0)
    $mens.mtodos1("$P descansa.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_descansouchao(arg0)
    efim


classe cmd_dormir
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Dormir\b\n\
Sintaxe: DORMIR [objeto]\n\
Dorme no chão. Com o nome de um objeto, tenta dormir no objeto."

func escr
  ref r
# Checa posição
  ret arg0.bitver & 0x800, arg0.msg("Você não consegue dormir.")
  casovar arg0.posicao
  casose "5" # Descansando
  casose "6" # Sentado
    r = arg0.poslugar.objlista
    sair
  casose "8" # Em pé
    sair
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Obtém aonde quer dormir
  se arg1
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret r && r != i.obj, arg0.msg("\c9Talvez você deva se levantar primeiro.\b")
    r = i.obj
  fimse
  listaobj l
# Dormir em algum objeto
  se r
    se txt(r.i_movel) != "2" && txt(r.i_movel) != "4"
      ret arg0.msg("Não é possível dormir em " + r.descnome + ".")
    senao r != arg0.poslugar.objlista && r.i_lugar <= r.persolugar.total
      ret arg0.msg("Não cabe mais ninguém em " + r.descnome + ".")
    fimse
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_dormirobj(arg0, r, arg1), nulo
    efim
    $mens.p(arg0, nulo, r)
    $mens.mtodos1("$P deita em $o e dorme.")
    arg0.poslugar.remove
    arg0.poslugar = r.persolugar.addfim(arg0)
    arg0.posicao = 4
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      l.objini.cmd_dormiuobj(arg0, r, arg1)
    efim
# Dormir num objeto que não existe
  senao arg1
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_dormirobj(arg0, nulo, arg1), nulo
    efim
    arg0.msg("Você não vê " + arg1 + ".")
    ret
# Dormir no chão
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_dormirchao(arg0), nulo
    efim
    $mens.p(arg0)
    $mens.mtodos1("$P deita e dorme.")
    arg0.poslugar.remove, arg0.posicao = 4
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_dormiuchao(arg0)
    efim


classe cmd_acordar
herda comando_comum, comando_ajuda
const posic = 4
const txtajuda = "\b\c3Acordar\b\n\
Sintaxe: ACORDAR [personagem]\n\
Acorda. Com o nome de um personagem, tenta acordar o personagem."

func escr
# Acordar outro personagem
  se arg1
    ret arg0.posicao == 4, arg0.msg(arg0.erropos)
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro2.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ref r
    r = i.obj
    se !r
      ret arg0.msg("Você não vê " + arg1 + ".")
    senao r.posicao != 4
      ret arg0.msg(txtcopiamai(r.descnome, "A") + " não está dormindo.")
    senao r.bitver & 0xC00 == 0x400
      $mens.p(arg0, r)
      $mens.mtodos1("$P tenta acordar $a.")
      ret
    fimse
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_acordar(arg0, r), nulo
    efim
    r.posicao = 5
    $mens.p(arg0, r)
    $mens.mtodos1("$P acorda $a.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_acordou(arg0, r)
    efim
# Acordar o próprio personagem
  senao arg0.posicao > 4
    ret arg0.msg("\c9Mas você já está acordad" + (arg0.msexo ? "o.\b" : "a.\b"))
  senao arg0.bitver & 0xC00 == 0x400
    ret arg0.msg("Você não consegue acordar.")
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_acordar(arg0, arg0), nulo
    efim
    arg0.posicao = 5
    $mens.p(arg0)
    $mens.mtodos1("$P acorda.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_acordou(arg0, arg0)
    efim


classe cmd_fugir
herda comando_comum, comando_ajuda
const posic = 7
const txtajuda = "\b\c3Fugir\b\n\
Sintaxe: FUGIR [número]\n\
Tenta fugir de uma batalha.\n\
Seguido de um número, muda os pontos para a fuga. Quando os pontos\n\
de vida do seu personagem estiverem abaixo desse número, ele tentará\n\
fugir automaticamente.\n\
Para saber quantos pontos foram definidos, tecle fugir fora da batalha."

func escr
# Checa posição
  se arg1
    ret txt(intpos(arg1)) != arg1, arg0.msg("Pontos de vida inválidos: " + arg1)
    arg0.p_fugir = arg1
    ret arg0.msg("Pontos de vida para fugir mudaram para: " + arg1)
  senao arg0.posicao != 7
    ret arg0.msg("Pontos de vida para fugir: " + arg0.p_fugir)
  senao
    ret arg0.pmove < 5 && !arg0.jogconfig.14, arg0.msg("Você está sem fôlego.")
    arg0.p_espera = 5
    fugir(arg0)

func fugir # Tenta fugir da luta
# arg0 = personagem
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_fugir(arg0), nulo
  efim
# Checa se consegue fugir
  real2 valor
  listaitem i
  epara i = arg0.atkrec.ini, i, i.depois
    valor += i.obj.persobat.precisao
  efim
  valor = valor * rand(70, 130) - arg0.persobat.evasao * 150
  se valor > 0 && !arg0.jogconfig.14
    $mens.p(arg0)
    $mens.mtodos1("$P tenta fugir, mas não consegue.")
    ret
  fimse
# Obtém direção para onde fugir
  refvar dir = $comando_mover.fugirdir(arg0)
  refvar r = ref(arg0.dono.dir_[dir])
  se !r || !dir
    $mens.p(arg0)
    $mens.mtodos1("$P tenta fugir mas não vê para onde.")
    ret
  fimse
# Foge
  arg0.pmove -= 5
  arg0.batalhafim
  $mens.p(arg0)
  $mens.mtodos1($cmd_[dir].m_fugir)
  arg0.mudadono(r)
  !(arg0.bitver & 256) && $mens.mvis2("", $cmd_[dir].m_entra1)


classe comando_retornar
herda comando_hab
# Herdado pela classe magia_retornar
const posic = 8
const objcmd = arg0.persobat.var.[nomevar] || arg0.pnivel <= nivel ? este
const objajuda = int(nivel) >= 0 ? este
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\n" + msgextra
const cmdmenu = "retornar" # Editável via "menu_hab_retornar" e "menu_magia_retornar"
const tipoalvo = 6 # Não agressivo
const c_espera = 15 # Tempo de esperar após usar esse comando
const msgantes2 = "$P some em um redemoinho de fumaça."
const msgdepois2 = "$P aparece de um redemoinho de fumaça."
const msgerrou1 = "Por algum motivo a magia falhou."
const msgnulo1 = "Por algum motivo a magia não teve efeito."
#
# Ordem que deve organizar as constantes:
const admordem = "nomevar nivel sala\n\
c_espera\n\
c_vida1 c_vida2\n\
c_mana1 c_mana2\n\
c_move1 c_move2\n\
aulaini aulafim\n\
depende\n\
precisao\n\
tipoarma\n\
tipoperso\n\
valor\n\
msgextra msgini1 msgini2\n\
msgantes1 msgantes2 msgdepois1 msgdepois2\n\
msgerrou1 msgerrou2 msgnulo1 msgnulo2"

func escr # Personagem retorna
# arg0 = personagem
# arg1 = não usado; apenas para compatibilidade com outras habilidades e magias
# arg2 = item usado, ou nulo se não usou nenhum item
  ref r
  r = sala
  !r && (r = $[arg0.var.z_salafim])
  se arg2.item
    ret !checahab1(arg0.persobat, arg2), nulo
    ret !r || r == arg0.dono, $mens.p(arg0) + $mens.mvis2(msgerrou1, msgerrou2)
  senao
    ret !r, arg0.msg("Você não possui ponto de retorno.")
    ret !checahab1(arg0.persobat, arg2), nulo
    ret r == arg0.dono, $mens.p(arg0) + $mens.mvis2(msgerrou1, msgerrou2)
    custohab1(arg0.persobat)
    $mens.p(arg0) + $mens.mvis2(msgini1, msgini2)
  fimse
  arg0.acertapos(1) # Porque os pontos de vida podem ter mudado
  se arg0.dono.s_semmagia && txt(nomevar, 0, 1) == "m"
    ret $mens.p(arg0) + $mens.mvis2(msgnulo1, msgnulo2)
  senao arg0.dono.s_retornar == 1
    ret $mens.p(arg0) + $mens.mvis2(msgnulo1, msgnulo2)
  senao rand(100) >= precisao || arg0.atkenv # Checa a precisão e se está batalhando
    ret $mens.p(arg0) + $mens.mvis2(msgerrou1, msgerrou2)
  fimse
  $mens.p(arg0)
  $mens.mvis2(msgantes1, msgantes2)
  arg0.mudadono(r)
  $mens.mvis2(msgdepois1, msgdepois2)


classe menu_magia_retornar
herda menu_hab_retornar
const titulo = "Magia " + txt(var.classe1, 6)


classe menu_hab_retornar
herda menu_hab_comum
const titulo = "Hab " + txt(var.classe1, 4)
const colunas = 25
#
const nome1 = "Gratuito até nível"
const info1 = "Até que nível pode-se usar esse comando sem precisar aprender\n\
Se menor que 0, não usa sem aprender"
const tipo1 = "numero"
const clas1 = var.classe1
const vari1 = "nivel"
#
const nome11 = "Ir para sala"
const info11 = "Se a sala não existir, o personagem vai para o ponto de retorno"
const tipo11 = "sala"
const clas11 = var.classe1
const vari11 = "sala"
#
const nome12 = "Informações"
const info12 = "Informações extras"
const tipo12 = "texto"
const clas12 = var.classe1
const vari12 = "msgextra"
#
const nome13 = "Mensagens"
const tipo13 = "menu--"
const clas13 = "menu_hab_retornar0"


classe menu_hab_retornar0
const titulo = "Mensagens"
const menufim = var.menufim
const colunas = 25
#
const titu1 = " * Ao usar, exceto poções comidas etc"
#
const nome1 = "Perso"
const tipo1 = "linha"
const clas1 = var.classe1
const vari1 = "msgini1"
#
const nome2 = "Outros"
const tipo2 = "linha"
const clas2 = var.classe1
const vari2 = "msgini2"
#
const titu3 = " * Antes do retorno"
#
const nome3 = "Perso"
const tipo3 = "linha"
const clas3 = var.classe1
const vari3 = "msgantes1"
#
const nome4 = "Outros"
const tipo4 = "linha"
const clas4 = var.classe1
const vari4 = "msgantes2"
#
const titu5 = " * Depois do retorno"
#
const nome5 = "Perso"
const tipo5 = "linha"
const clas5 = var.classe1
const vari5 = "msgdepois1"
#
const nome6 = "Outros"
const tipo6 = "linha"
const clas6 = var.classe1
const vari6 = "msgdepois2"
#
const titu7 = " * Falhou"
#
const nome7 = "Perso"
const tipo7 = "linha"
const clas7 = var.classe1
const vari7 = "msgerrou1"
#
const nome8 = "Outros"
const tipo8 = "linha"
const clas8 = var.classe1
const vari8 = "msgerrou2"
#
const titu9 = " * Não teve efeito"
#
const nome9 = "Perso"
const tipo9 = "linha"
const clas9 = var.classe1
const vari9 = "msgnulo1"
#
const nome10 = "Outros"
const tipo10 = "linha"
const clas10 = var.classe1
const vari10 = "msgnulo2"
