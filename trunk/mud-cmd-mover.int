classe comando_mover
herda comando_comum
const m_entra = "$P chegou"
const m_sai = "$P foi embora"
const dir = ""
const comando_mover = 1 # Para indicar que é comando de movimentação do jogador
listaobj lseg # Para não seguir ciclicamente
debug dbg

func escr # Executa o comando
# arg0 = personagem
# arg1 = o que digitou ou "\n" se está seguindo alguém
  ref s1 # Sala aonde está
  ref s2 # Sala para onde vai
  dbg.exec = 5000
  arg1 != "\n" && lseg.limpar, lseg.addfim(arg0)
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_[dir](arg0, arg0.dono), nulo
  efim
  misc:obj = arg0
  s1 = arg0.dono, s2 = s1.dir_[dir]
  ret s2 == nulo, arg0.msg("Impossível seguir nessa direção.")
  ret s1.porta_[dir] & 3 >= 2, arg0.msg("A porta está fechada.")
  uint8 total
  total = s1.totalmove + s2.totalmove
  !s1.visivel(arg0) && (total *= 2) # No escuro gasta mais movimentos
  se arg0.pmove < total
    arg0.msg("Você está cansad" + misc:sletra[arg0.sexo] + " demais.")
    ret
  fimse
  arg0.pmove -= total / 2
  arg0.p_espera = total ? total * 2 : 2
  $mens.p(arg0)
  !arg0.p_silencio && $mens.mvis2("", m_sai)
  arg0.mudadono(s2)
  !arg0.p_silencio && $mens.mvis2("", m_entra)
  arg0.dono.s_morre && arg0.morreu
# Seguir
  epara l.addfim(arg0.lseguir), l, l.ini.remove
    continuar l.objini.posicao < 8 || l.objini.dono != s1 || lseg.possui(l.objini)
    continuar !arg0.visivel(l.objini) || !s1.visivel(l.objini)
    l.objini.msg("Você segue " + arg0.descnome + ".")
    escr(l.objini, "\n")
  efim


classe cmd_n
herda comando_mover
const m_entra = "$P chegou do sul."
const m_sai = "$P foi para o norte."
const m_porta = "a porta norte"
const dir = "n"


classe cmd_s
herda comando_mover
const m_entra = "$P chegou do norte."
const m_sai = "$P foi para o sul."
const m_porta = "a porta sul"
const dir = "s"


classe cmd_l
herda comando_mover
const m_entra = "$P chegou do oeste."
const m_sai = "$P foi para leste."
const m_porta = "a porta leste"
const dir = "l"


classe cmd_e
herda comando_comum
const objcmd = $cmd_l.objcmd(arg0, arg1)


classe cmd_o
herda comando_mover
const m_entra = "$P chegou do leste."
const m_sai = "$P foi para oeste."
const m_porta = "a porta oeste"
const dir = "o"


classe cmd_w
herda comando_comum
const objcmd = $cmd_o.objcmd(arg0, arg1)


classe cmd_c
herda comando_mover
const m_entra = "$P chegou de baixo."
const m_sai = "$P subiu."
const m_porta = "a passagem para cima"
const dir = "c"


classe cmd_u
herda comando_comum
const objcmd = $cmd_c.objcmd(arg0, arg1)


classe cmd_b
herda comando_mover
const m_entra = "$P chegou de cima."
const m_sai = "$P desceu."
const m_porta = "a passagem para baixo"
const dir = "b"


classe cmd_d
herda comando_comum
const objcmd = $cmd_b.objcmd(arg0, arg1)


classe cmd_ne
herda comando_mover
const m_entra = "$P chegou do sudoeste."
const m_sai = "$P foi para o nordeste."
const m_porta = "a porta nordeste"
const dir = "ne"


classe cmd_no
herda comando_mover
const m_entra = "$P chegou do sudeste."
const m_sai = "$P foi para o noroeste."
const m_porta = "a porta noroeste"
const dir = "no"


classe cmd_nw
herda comando_comum
const objcmd = $cmd_no.objcmd(arg0, arg1)


classe cmd_se
herda comando_mover
const m_entra = "$P chegou do noroeste."
const m_sai = "$P foi para o sudeste."
const m_porta = "a porta sudeste"
const dir = "se"


classe cmd_so
herda comando_mover
const m_entra = "$P chegou do nordeste."
const m_sai = "$P foi para o sudoeste."
const m_porta = "a porta sudoeste"
const dir = "so"


classe cmd_sw
herda comando_comum
const objcmd = $cmd_so.objcmd(arg0, arg1)


classe cmd_seguir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Seguir\b\n\
Sintaxe: SEGUIR [personagem]\n\
Segue um personagem.\n\
Se o personagem for omitido ou for você mesmo, você passa a não seguir\n\
ninguém. Para outros personagens não seguirem você, veja a opção SEGUIR\n\
do comando CONFIG."
const posic = 5

func escr
# Sem argumentos: deixa de seguir
  se !arg1
    arg0.iseguir.remove
    arg0.msg("Você não segue ninguém.")
    ret
  fimse
# Procura o personagem
  nomeobj n # Para reconhecer os personagens
  listaitem i
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro2.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  ret !i, arg0.msg("Você não vê " + arg1 + ".")
# Segue o personagem
  se i.obj == arg0
    arg0.iseguir.remove
    arg0.msg("Você não segue ninguém.")
  senao i.obj.jog ? !i.obj.jogconfig.5 : i.obj.p_naoseguir(arg0)
    arg0.msg("Você não consegue seguir " + i.obj.descnome + ".")
  senao
    arg0.iseguir.remove
    arg0.iseguir = i.obj.lseguir.addfim(arg0)
    arg0.msg("Você segue " + i.obj.descnome + ".")


classe cmd_abrir
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Abrir\b\n\
Sintaxe: ABRIR <objeto ou direção>\n\
Abre um objeto ou uma porta."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Abrir um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Abrir o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está aberto
  ref r
  r = i.obj
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está abert" + misc:sletra[r.sexo] + \
".")
  casose "4"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " está trancad" + misc:sletra[r.sexo] + ".")
  casose
    ret arg0.msg("Não foi possível abrir " + r.descnome + ".")
  casose "3"
  casose "5"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_abrirobj(arg0, r), nulo
  efim
# Abre o item
  r.i_aberto = 2
  $mens.p(arg0, r)
  $mens.mtodos1("$P abriu $A.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_abriuobj(arg0, r)
  efim

func escrdir # Abrir uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está aberto
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg("Porta já está aberta.")
  casose "3"
    ret arg0.msg("Porta está trancada.")
  casose "2"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_abrirdir(arg0, arg0.dono, arg1), nulo
  efim
# Abre a porta
  arg0.dono.mudaporta(arg1, 1) # Abre a porta
  txt100 mporta
  mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  $mens.p(arg0)
  $mens.mtodos1("$P abriu " + mporta + ".")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_abriudir(arg0, arg0.dono, arg1)
  efim


classe cmd_fechar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Fechar\b\n\
Sintaxe: FECHAR <objeto ou direção>\n\
Fecha um objeto ou uma porta."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Fechar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Fechar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está fechado
  ref r
  r = i.obj
  casovar r.i_aberto
  casose "3"
  casose "4"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " já está fechad" + misc:sletra[r.sexo] + \
".")
  casose
    ret arg0.msg("Não foi possível fechar " + r.descnome + ".")
  casose "2"
  casose "5"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_fecharobj(arg0, r), nulo
  efim
# Fecha o item
  r.i_aberto = r.i_tranc == 2 ? 4 : 3
  $mens.p(arg0, r)
  $mens.mtodos1("$P fechou $A.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_fechouobj(arg0, r)
  efim

func escrdir # Fechar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está fechado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "2"
  casose "3"
    ret arg0.msg("Porta já está fechada.")
  casose "1"
  casofim
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_fechardir(arg0, arg0.dono, arg1), nulo
  efim
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Fecha a porta
  se arg0.dono.tranc_[arg1] == 2
    arg0.dono.mudaporta(arg1, 3) # Tranca a porta
  senao
    arg0.dono.mudaporta(arg1, 2) # Fecha a porta
  fimse
  txt100 mporta
  mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  $mens.p(arg0)
  $mens.mtodos1("$P fechou " + mporta + ".")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_fechoudir(arg0, arg0.dono, arg1)
  efim


classe cmd_destrancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Destrancar\b\n\
Sintaxe: DESTRANCAR <objeto ou direção>\n\
Destranca um objeto ou uma porta.\n\
Nota: pode ser necessário possuir uma chave para destrancar."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Destrancar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Destrancar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está trancado
  ref r
  r = i.obj, misc:obj = arg0
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " está abert" + misc:sletra[r.sexo] + ".")
  casose "3"
    ret !r.i_tranc, arg0.msg(txtcopiamai(r.descnome, "A") + " não pode ser trancad" + misc:sletra\
[r.sexo] + ".")
    ret arg0.msg(txtcopiamai(r.descnome, "A") + " não está trancad" + misc:sletra[r.sexo] + \
".")
  casose
    ret arg0.msg("Não foi possível destrancar " + r.descnome + ".")
  casose "4"
  casose "5"
  casofim
# Procura a chave
  ref chave
  se r.i_fechadura
    epara i = arg0.dentro1.ini, i, i.depois
      sair r.i_fechadura == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave de " + r.descnome + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_destrancarobj(arg0, r, chave), nulo
  efim
# Destranca o item
  r.i_aberto = 3
  $mens.p(arg0, r)
  $mens.mtodos1("$P destrancou $A.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_destrancouobj(arg0, r, chave)
  efim

func escrdir # Destrancar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está trancado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg("Porta está aberta.")
  casose "2"
    ret !arg0.dono.tranc_[arg1], arg0.msg("Essa porta não pode ser trancada.")
    ret arg0.msg("Porta não está trancada.")
  casose "3"
  casofim
# Procura a chave
  txt100 mporta # Nome da porta
  txt100 cod # Código da fechadura
  ref chave # Chave que abre a fechadura
  misc:obj = arg0
  cod = arg0.dono.fechadura_[arg1], mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  se cod
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave para destrancar " + mporta + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_destrancardir(arg0, arg0.dono, arg1, chave), nulo
  efim
# Destranca a porta
  arg0.dono.mudaporta(arg1, 2) # Destranca a porta
  $mens.p(arg0)
  $mens.mtodos1("$P destrancou " + mporta + ".")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_destrancoudir(arg0, arg0.dono, arg1, chave)
  efim


classe cmd_trancar
herda comando_comum, comando_ajuda
const txtajuda = "\b\c3Trancar\b\n\
Sintaxe: TRANCAR <objeto ou direção>\n\
Tranca um objeto ou uma porta.\n\
Nota: pode ser necessário possuir uma chave para trancar."
const posic = 5

func escr
  txt10 dir
  dir = misc:d1[arg1]
  dir ? escrdir(arg0, dir) : escrobj(arg0, arg1)

func escrobj # Trancar um item
  listaitem i # Para procurar o item
  nomeobj n # Para reconhecer os itens
# Procura o item
  ret !arg1, arg0.msg("Trancar o que?")
  n.ini(arg1, 1)
  epara i = arg0.dono.dentro1.ini, i, i.depois
    sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
  efim
  se !i
    epara i = arg0.dentro1, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    ret !i, arg0.msg("Você não vê " + arg1 + ".")
  fimse
# Checa se está destrancado
  ref r
  r = i.obj, misc:obj = arg0
  casovar r.i_aberto
  casose "2"
    ret arg0.msg(txtcopiamai(r.nome, "A") + " está abert" + misc:sletra[r.sexo] + ".")
  casose "4"
    ret arg0.msg(txtcopiamai(r.nome, "A") + " já está trancad" + misc:sletra[r.sexo] + ".")
  casose
    ret arg0.msg("Não foi possível trancar " + r.nome + ".")
  casose "3"
  casose "5"
  casofim
  ret !r.i_tranc, arg0.msg(txtcopiamai(r.nome, "A") + " não pode ser trancad" + misc:sletra[r.sex\
o] + ".")
# Procura a chave
  ref chave
  se r.i_fechadura
    epara i = arg0.dentro1.ini, i, i.depois
      sair r.i_fechadura == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave de " + r.nome + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_trancarobj(arg0, r, chave), nulo
  efim
# Tranca o item
  r.i_aberto = 4
  $mens.p(arg0, r)
  $mens.mtodos1("$P trancou $A.")
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    l.objini.cmd_trancouobj(arg0, r, chave)
  efim

func escrdir # Trancar uma porta
# Checa se porta existe
  ret !arg0.dono.dir_[arg1], arg0.msg("Não há porta nessa direção.")
# Checa se está trancado
  casovar 3 & arg0.dono.porta_[arg1]
  casose
    ret arg0.msg("Não há porta nessa direção.")
  casose "1"
    ret arg0.msg("Porta está aberta.")
  casose "3"
    ret arg0.msg("Porta já está trancada.")
  casose "2"
  casofim
  ret !arg0.dono.tranc_[arg1], arg0.msg("Porta não pode ser trancada.")
# Procura a chave
  txt100 mporta # Nome da porta
  txt100 cod # Código da fechadura
  ref chave # Chave que abre a fechadura
  misc:obj = arg0
  cod = arg0.dono.fechadura_[arg1], mporta = arg0.dono.portanome_[arg1]
  !mporta && (mporta = $cmd_[arg1].m_porta)
  !mporta && (mporta = "uma porta")
  se cod
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    ret !i, arg0.msg("Você não possui a chave para trancar " + mporta + ".")
    chave = i.obj
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    ret l.objini.cmd_trancardir(arg0, arg0.dono, arg1, chave), nulo
  efim
# Tranca a porta
  arg0.dono.mudaporta(arg1, 3) # Tranca a porta
  $mens.p(arg0)
  $mens.mtodos1("$P trancou " + mporta + ".")
  epara l.addfim(arg0.evento, arg0.dono.evento), l, l.ini.remove
    l.objini.cmd_trancoudir(arg0, arg0.dono, arg1, chave)
  efim


classe cmd_levantar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sentar\b\nSintaxe: LEVANTAR\nFica em pé."

func escr
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
  casose "6" # Sentado
    sair
  casose "8" # Em pé
    ret arg0.msg("\c9Você já está em pé.\b")
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Ficar em pé
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_levantar(arg0), nulo
  efim
  arg0.poslugar.remove
  arg0.posicao = 8
  $mens.p(arg0)
  $mens.mtodos1("$P levantou-se.")
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_levantou(arg0)
  efim


classe cmd_sentar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sentar\b\n\
Sintaxe: SENTAR [objeto]\n\
Senta-se no chão. Com o nome de um objeto, tenta sentar no objeto."

func escr
  ref r
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
    r = arg0.poslugar.objlista
    sair !arg1
    ret arg0.msg("\c9Talvez você deva se levantar primeiro.\b")
  casose "6" # Sentado
    ret arg0.msg("\c9Você já está sentad" + misc:sletra[arg0.sexo] + ".\b")
  casose "8" # Em pé
    sair
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Obtém aonde quer se sentar
  se arg1
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    r = i.obj
  fimse
  listaobj l
# Sentar em algum objeto
  se r
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_sentarobj(arg0, r, arg1), nulo
    efim
    txt100 nome
    nome = misc:sum[r.sexo] + " " + r.nome + "."
    ret !r.i_movel, arg0.msg("Não é possível sentar-se em " + nome)
    ret r.i_lugar <= r.persolugar.total, arg0.msg("Não cabe mais ninguém em " + nome)
    arg0.poslugar.remove
    arg0.poslugar = r.persolugar.addfim(arg0)
    arg0.posicao = 6
    $mens.p(arg0, nulo, r)
    $mens.mtodos1("$P sentou-se em $u $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      l.objini.cmd_sentouobj(arg0, r, arg1)
    efim
# Sentar-se num objeto que não existe
  senao arg1
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_sentarobj(arg0, nulo, arg1), nulo
    efim
    arg0.msg("Você não vê " + arg1 + ".")
    ret
# Sentar-se no chão
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_sentarchao(arg0), nulo
    efim
    arg0.poslugar.remove
    arg0.posicao = 6
    $mens.p(arg0)
    $mens.mtodos1("$P sentou-se.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_sentouchao(arg0)
    efim


classe cmd_descansar
herda comando_comum, comando_ajuda
const posic = 5
const txtajuda = "\b\c3Sentar\b\n\
Sintaxe: DESCANSAR [objeto]\n\
Descansa no chão. Com o nome de um objeto, tenta descansar no objeto."

func escr
  ref r
# Checa posição
  casovar arg0.posicao
  casose "5" # Descansando
    ret arg0.msg("\c9Você já está descansando.\b")
  casose "6" # Sentado
    r = arg0.poslugar.objlista
    sair !arg1
    ret arg0.msg("\c9Talvez você deva se levantar primeiro.\b")
  casose "8" # Em pé
    sair
  casose # Outras posições
    ret arg0.msg(arg0.erropos)
  casofim
# Obtém aonde quer descansar
  se arg1
    listaitem i # Para procurar o item
    nomeobj n # Para reconhecer os itens
    n.ini(arg1, 1)
    epara i = arg0.dono.dentro1.ini, i, i.depois
      sair i.obj.visivel(arg0) && n.nome(i.obj.ident, i.obj.objtot)
    efim
    r = i.obj
  fimse
  listaobj l
# Descansar em algum objeto
  se r
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_descansarobj(arg0, r, arg1), nulo
    efim
    txt100 nome
    nome = misc:sum[r.sexo] + " " + r.nome + "."
    ret !r.i_movel, arg0.msg("Não é possível descansar em " + nome)
    ret r.i_lugar <= r.persolugar.total, arg0.msg("Não cabe mais ninguém em " + nome)
    arg0.poslugar.remove
    arg0.poslugar = r.persolugar.addfim(arg0)
    arg0.posicao = 5
    $mens.p(arg0, nulo, r)
    $mens.mtodos1("$P descansa em $u $o.")
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      l.objini.cmd_descansouobj(arg0, r, arg1)
    efim
# Descansar num objeto que não existe
  senao arg1
    epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
      ret l.objini.cmd_descansarobj(arg0, nulo, arg1), nulo
    efim
    arg0.msg("Você não vê " + arg1 + ".")
    ret
# Descansar no chão
  senao
    epara l.addfim(arg0.evento), l, l.ini.remove
      ret l.objini.cmd_descansarchao(arg0), nulo
    efim
    arg0.poslugar.remove
    arg0.posicao = 5
    $mens.p(arg0)
    $mens.mtodos1("$P descansa.")
    epara l.addfim(arg0.evento), l, l.ini.remove
      l.objini.cmd_descansouchao(arg0)
    efim


classe cmd_fugir
herda comando_comum, comando_ajuda
const posic = 7
const txtajuda = "\b\c3Fugir\b\nSintaxe: FUGIR\nTenta fugir de uma batalha."

func escr
# Checa posição
  ret arg0.posicao != 7, arg0.msg("Você não está lutando.")
  ret arg0.pmove < 5, arg0.msg("Você está sem fôlego.")
  arg0.p_espera = 5
# Gera eventos
  listaobj l
  epara l.addfim(arg0.evento, r.evento), l, l.ini.remove
    ret l.objini.cmd_fugir(arg0), nulo
  efim
# Checa se consegue fugir
  real valor
  listaitem i
  epara i = arg0.atkrec.ini, i, i.depois
    valor += i.obj.persobat.precisao
  efim
  valor = valor * rand(70, 130) - arg0.persobat.evasao * 100
  se valor > 0
    $mens.p(arg0)
    $mens.mtodos1("$P tenta fugir, mas não consegue.")
    ret
  fimse
# Obtém direção para onde fugir
  txt10 dir
  ref r
  dir = fugirdir(arg0)
  r = arg0.dono.dir_[dir]
  se !r || !dir
    $mens.p(arg0)
    $mens.mtodos1("$P tenta fugir mas não vê para onde.")
    ret
  fimse
# Foge
  arg0.pmove -= 5
  arg0.batalhafim
  $mens.p(arg0)
  !arg0.p_silencio && $mens.mtodos1(txttroca($cmd_[dir].m_sai, " foi ", " fugiu "))
  arg0.mudadono(r)
  !arg0.p_silencio && $mens.mvis2("", $cmd_[dir].m_entra)

func fugirdir # Obtém direção para onde pode fugir
# Entrada: arg0 = personagem
# Retorna: direção ou "" se não há para onde fugir
  txt100 t
  ref r
  misc:obj = arg0
  r = arg0.dono
  r.dir_n && int(r.porta_n) < 2 && (t += "n ")
  r.dir_s && int(r.porta_s) < 2 && (t += "s ")
  r.dir_l && int(r.porta_l) < 2 && (t += "l ")
  r.dir_o && int(r.porta_o) < 2 && (t += "o ")
  r.dir_c && int(r.porta_c) < 2 && (t += "c ")
  r.dir_b && int(r.porta_b) < 2 && (t += "b ")
  r.dir_ne && int(r.porta_ne) < 2 && (t += "ne ")
  r.dir_no && int(r.porta_no) < 2 && (t += "no ")
  r.dir_se && int(r.porta_se) < 2 && (t += "se ")
  r.dir_so && int(r.porta_so) < 2 && (t += "so ")
  ret t ? txtsub(t, rand(intsub(t)), 1) : ""


classe comando_retornar
herda comando_comum
# Herdado pela classe magia_retornar
const objcmd = arg0.persobat.var.[nomevar] ? este
const atkajuda = arg0.persobat.var.[nomevar] ? este
const posic = 8
const txtajuda = "\c3" + misc:nomevar(nomevar) + "\b\nTeletransporta o seu personagem para o \
ponto de retorno."

func escr
  exec(arg0, 2 + arg0.persobat.var.[nomevar])

func exec # Personagem retorna
# arg0 = personagem
# arg1 = o quanto sabe da magia, de 0 a 10
  ref r
  r = $[arg0.var.z_salafim]
  ret !r, arg0.msg("Você não possui ponto de retorno.")
  ret r == arg0.dono, arg0.msg("Você já está no ponto de retorno.")
  ret r.s_retornar == 1, arg0.msg("Você não consegue retornar.")
  ret arg0.pmana < int(usamana), arg0.msg("Mana insuficiente")
  arg0.pmana -= int(usamana)
  arg0.p_espera < 15 && (arg0.p_espera = 15)
  ret rand(10) >= arg1, arg0.msg("Por algum motivo, a magia falhou.")
  $mens.p(arg0)
  !arg0.p_silencio && $mens.mvis2("", "$P some em um redemoinho de fumaça.")
  arg0.mudadono(r)
  !arg0.p_silencio && $mens.mvis2("", "$P aparece de um redemoinho de fumaça.")


classe cmd_retornar
herda comando_retornar
const objcmd = arg0.pnivel <= config:retornar ? este
const objajuda = config:retornar >= 0 ? este
const txtajuda = "\b\c3Retornar\b\nSintaxe: RETORNAR\nTeletransporta o seu personagem para o \
ponto de retorno, geralmente sua\ncidade natal. Esse comando existe para jogadores até o nível " \
+ config:retornar + "."

func escr
  exec(arg0, 10)
