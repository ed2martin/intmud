Especificações - IntMUD (Interpretador MUD)

O programa é um interpretador de comandos que trabalha com um ou mais
arquivos cujos nomes terminam com ".int". São arquivos de texto que contém
os comandos (o programa interpretado) executados pelo IntMUD.

Via de regra, o arquivo principal chama-se "intmud.int" (o nome do arquivo
executável terminado com "int"). Mas pode-se usar outro arquivo, bastando
renomear o executável ou executar o IntMUD seguido do nome. Exemplo:
intmud teste.int
ou apenas:
intmud teste
Em ambiente gráfico, pode-se arrastar o arquivo .int para o executável com
o botão esquerdo do mouse.

O arquivo intmud.int começa com algumas definições no seguinte padrão:
opção = valor

As opções são as seguintes:

mapagrande = 0
Se diferente de zero, o programa interpretado está distribuído em mais
de um arquivo. Nesse caso, os nomes dos demais arquivos sempre começam
com "intmud-" e terminam com ".int".
Exemplo: intmud-teste.int
Se ausente, assume 0 (somente um arquivo ".int").

exec = 5000
Quantas instruções uma função chamada pelo programa pode executar antes
do controle retornar automaticamente ao programa.
Se ausente, assume 5000.

telatxt = 0
Se zero, o programa roda em segundo plano. Não abre nenhuma janela.
Se diferente de zero, abre uma janela de texto. Nesse caso, a comunicação
com o usuário se dá através da variável telatxt no programa interpretado.
Em Unix ou Linux, se diferente de zero, executar o programa em um terminal.
Se ausente, assume 0.

log = 0
Aonde apresentar as mensagens de erro, caso tenha erro no programa.
0 = na tela (no Windows é aberta uma janela)
1 = em arquivo .log
Se ausente, assume 0.

Após as opções vem as definições de classes (tipos de objetos), que constituem
o programa interpretado. Segue a sintaxe:

classe nome da classe
herda <classe 1>, <classe 2>, ..., <classe N>
variáveis e constantes do objeto
funções (func) e constantes (const) do objeto

Nomes de classes podem ser compostos dos caracteres de A a Z, c cedilha,
dígitos de 0 a 9, e arroba. Podem conter espaços, mas eles são tratados como
se fossem o caracter "_" no restante do programa.

Nomes de funções, variáveis e constantes seguem o mesmo padrão, mas não podem
começar com um dígito de 0 a 9.

Cada função:

func <nome da função>
variáveis e instruções da função

Tudo o que estiver abaixo da linha func <nome da função> pertence à função,
até a definição da próxima função ou constante.

As variáveis são definidas com:
<tipo da variável>  <nome da variável>
Exemplos:
int8 v1
txt50 v2

Basicamente o programa lida com quatro tipos de variáveis:
- Numérico, como: 0, -5, 4.3
- Texto, como: "bom dia"
- Referência a um objeto, como a palavra este, que se refere ao objeto atual
- Nulo, que corresponde a um valor nulo.
Os tipos de variáveis serão vistos adiante.

Tipos constantes são definidos com:
const  <nome>  =  <valor>
Exemplos:
const x = "teste"
const y = 10

A linha "herda", se estiver presente, significa herança.
A classe contém também as variáveis e funções das classes especificadas.
Herda também as classes herdadas por essas. Exemplo:
classe A
herda B
int8 dia
classe B
herda C
int8 mes
classe C
int8 ano

A classe C contém a variável ano. A classe B contém as variáveis ano e mes.
A classe A contém mes, dia e ano. Está herdando C através de B.

Quando houver um nome de variável ou função repetido na herança, prevalece
a primeira encontrada. As demais são ignoradas. Exemplo:
classe A
herda B
int8 x
classe B
txt10 x
Nesse caso a classe A tem a variável "int8 x", mas não contém a variável
"txt10 x".

Uma função pode conter os seguintes tipos de instrução:
1. Atribuir um valor ou expressão numérica a uma variável, ex:
x = 10
y = x + abs(z) * 3

2. Executar uma função, sem atribuir o resultado a nenhuma variável, ex:
x("teste")

3. Uma instrução de controle de fluxo do programa: se, fimse, enquanto, etc.
Exemplo:
se x==10
...
fimse

4. Comentários: linhas que começam com # seguido ou não de um texto.
São ignorados pelo programa. Exemplo:
# teste

As linhas de instruções são interpretadas da esquerda para a direita,
verificando:
1. Operadores, como + - * / == < > | &
2. Números: começam com um dígito de 0 a 9 e podem ter sinal de menos na frente
3. Textos: começam e terminam com aspas dupla (").
   Apenas aspas dupla dentro do texto deve ser escrito assim: \"
4. Variáveis e funções: começam com uma letra ou colchetes ([).
A única exceção são os operadores de atribuição (=, =+, =-, etc.), que são
processados da direita para esquerda. Exemplo:
a=b=c # Primeiro faz b=c, depois faz a=b

O programa interpreta variáveis e funções da seguinte forma:
A. Se houver um ponto separando duas palavras, liga a segunda ao retorno da
   primeira. Exemplo, a palavra este corresponde ao objeto atual.
   este.abs deve corresponder à função ou variável abs do objeto.
B. Se houver colchetes, interpreta o que estiver entre colchetes como uma
   expressão numérica. O resultado disso fará parte do nome da variável ou
   função. Exemplo:
   x["1"] = 10
   y = "_teste"
   x[y] = 20
        É equivalente a:
   x1 = 10
   x_teste = 20

O programa processa variáveis e funções da seguinte forma:
A. Se houver dois pontos, executa a função (depois dos dois pontos)
   da classe especificada (antes dos dois pontos), como se pertencesse ao
   objeto atual. Exemplo:
   item:luminosidade(10)
   Executa função luminosidade da classe item, como se essa função
   pertencesse ao objeto "este".
B. Verifica se é uma função nativa do programa (exemplo: abs).
C. Verifica se é uma variável da função que está sendo executada.
D. Verifica se é uma variável ou função do objeto.
E. Se não existe, interpreta com se fosse uma variável de valor NULO.


*** Variáveis básicas

As variáveis definidas antes das funções pertencem ao objeto.
As que forem definidas em uma função pertencem à ela. São criadas
quando a função é chamada e deixam de existir quando a função termina.
Variáveis definidas dentro de um bloco se ~ fimse, enquanto ~ efim, etc.
só existem dentro dele. Em outras palavras, deixam de existir quando
saem do escopo. No caso de um bloco enquanto ~ efim, também deixam de
existir quando volta para a instrução enquanto.

int1 <nomedavariável>
    Pode ser 0 ou 1
int8 <nomedavariável>
    Número inteiro de -128 a 127
int16 <nomedavariável>
    Número inteiro de -32768 a 32767
int32 <nomedavariável>
    Número inteiro de -2147483648 a 2147483647
uint8 <nomedavariável>
    Número inteiro de 0 a 255
uint16 <nomedavariável>
    Número inteiro de 0 a 65535
uint32 <nomedavariável>
    Número inteiro de 0 a 4294967295
intdec <nomedavariável>
    Número inteiro de 0 a 1048575, que é subtraido 1 a cada décimo
    de segundo, até chegar a 0.
    intdec aceita valores negativos, mas nesse caso a contagem fica parada.
    Possui as funções e variáveis:
    neg = Faz a variável ser menor que zero, multiplicando por -1 se necessário
    pos = Faz a variável ser maior que zero, multiplicando por -1 se necessário
    abs = Valor de intdec sem o sinal
    Exemplo:
    intdec x
    x = 10
    x.neg # Faz x ser negativo; nesse caso faz x=-10
    n = x.abs # x.abs = 10
    x.pos # Faz x ser positivo; nesse caso, 10
    x.abs = 5
intinc <nomedavariável>
    Número inteiro de 0 a 1048575, que é somado 1 a cada décimo de segundo,
    até chegar a 1048575 (29 horas, 7 minutos e 37.5 segundos).
    intinc aceita valores negativos, mas nesse caso a contagem fica parada.
    Possui as funções neg, pos e abs, exatamente como intdec (vide acima).
real
    Corresponde ao tipo "double" em C++
txt1 a txt512 seguido do nome da variável:
    Define uma variável que contém um texto, de até 1 a 512 caracteres,
    respectivamente. Exemplo:
    Para criar uma variável: vartxt10 x
    Para colocar um texto nessa variável: x = "bom dia"
ref <nomedavariável>
    Referência para um objeto; corresponde a um objeto qualquer.
    A palavra "nulo" é usada para indicar que a referência
    não corresponde a nenhum objeto. Quando o objeto é apagado,
    automaticamente a referência passa a ser "nulo".
    Exemplo:
    ref ref1
    # Cria objeto
    ref1 = criar("teste")
    # Muda variável x do objeto
    ref1.x = 2
    # Faz a referência não corresponder a nenhum objeto
    # mas não apaga o objeto criado
    ref1 = nulo

Antes dos tipos das variáveis é permitido colocar as seguintes palavras:

comum
    Variável é a mesma para todos os objetos da classe.
    Independente da quantidade de objetos, só existe uma variável.
sav
    Variável deve ser salva em arquivo, vide arqsav.


*** Vetores

São conjuntos de variáveis do mesmo tipo.
Define-se um vetor acrescentando-se após o nome da variável um ponto
e a quantidade de variáveis, de 1 a 255.
Exemplo:
int8 teste.3

Nesse caso existem 3 variáveis:
teste.0
teste.1
teste.2

Exemplo de como tratar eventos de um vetor:
classe x
inttempo n.5
func n_exec # Evento para as 5 variáveis "n"
# Aqui arg0 é o índice da variável no vetor (de 0 a 4)
# n.[arg0] corresponde à variável que gerou o evento

Nota: Funções e constantes não podem ser definidos como vetor.


*** Funções

Funções podem ser chamadas de duas formas, em relação aos argumentos:
1. Sem argumentos
<nomedafunção>

2. Com um ou mais argumentos
<nomedafunção> ( argumento 1, argumento 2, ..., argumento N )

Exemplos:
teste
teste("bom dia", 10)

Quando a função é chamada, as variáveis definidas na função são criadas.
Deixam de existir quando retorna (termina).
Dentro da função, as seguintes palavras tem um significado próprio:
args = número de argumentos
arg0 a arg9 = argumentos passados para a função
este = objeto ao qual a função pertence

Os argumentos são passados por referência: alterar arg0 a arg9 dentro
da função altera a variável que foi passada.

Para retornar um valor, a instrução é:
ret <valor de retorno>
Exemplos:
ret 10
ret arg0+1

Se não for especificado o valor de retorno, ret retorna nulo.
Após a última linha da função é como se tivesse uma instrução ret nulo.

Exemplo - dada uma função x, definida como:
func x
ret arg0+1
O retorno pode ser usado da seguinte forma:
y = x(10)
z = x(2) - x(1)
Nesse exemplo, fará y=11 e z=1.

Outros exemplos:
classe abc
int1 x
int8 y
func teste1
  ret "bom dia"
func teste2
  ret x + y
func teste3
  y = arg0 + arg1
func fatorial
  se args!=1 | arg0<=1
    ret 1
  fimse
  ret arg0 * fatorial(arg0-1)

Internamente constantes se comportam como funções. Exemplo:
func x
  ret arg0 * 10
Pode ser escrito também como:
const x = arg0 * 10

Existe um outro tipo de função, que se comporta como se fosse uma variável.
É definida com varfunc ao invés de func.
Quando for feita uma leitura a variável, ao invés disso a função é chamada
com nenhum argumento, e deve retornar o valor lido.
Alterar a variável chama a função com um argumento (o novo valor).
O valor de retorno da função é ignorado.

Exemplo:
varfunc x
  se args=0
# Leitura da variável: retorna "bom dia"
    ret "bom dia"
  fimse
# Mudar a variável: chama outra função
  este.msg(arg0)
func teste
  vartxt10 n
# Vai fazer: n = "bom dia"
  n = x
# Vai fazer: este.msg("teste")
  x = "teste"

Varfunc também pode ser escrita na forma de constante. Nesse caso, deve-se
definir como varconst ao invés de const. Exemplo:
int16 x1
varconst x = args ? (x1 = arg0 * 100) : x1 / 100
É o mesmo que:
int16 x1
varfunc x
  se args
    x1 = arg0 * 100
  senao
    ret x1 / 100


*** Operadores

Podem ser usados os seguintes operadores - sendo a e b duas variáveis
e/ou números:

!a      Se for falso (=0) vira verdadeiro (1)
        Se for verdadeiro (diferente de 0) vira falso (0)
~a      Complemento de a
a*b     Multimplica a por b
a/b     Divide: a/b; pode resultar em um número quebrado (não inteiro)
a%b     É o resto da divisão de a por b
a+b     Soma
a-b     Subtrai
a<<b    Deslocamento à esquerda, sendo que a=valor e b=quantidade de bits
a>>b    Deslocamento à direita, sendo que a=valor e b=quantidade de bits
a|b     "Ou" para bits entre a e b
a^b     "Ou exclusivo" para bits entre a e b
a&b     "E" para bits entre a e b
a<b     Verdadeiro (=1) se a<b; Falso (=0) se a>=b
a<=b    Verdadeiro se a<=b
a==b    Verdadeiro se a for igual a b
a===b   Verdadeiro se a for exatamente igual a b
        Em textos: diferencia letras minúsculas de letras maiúsculas
a!==b   Verdadeiro se a não for exatamente igual a b
a>=b    Verdadeiro se a>=b
a>b     Verdadeiro se a>b
a!=b    Verdadeiro se a for diferente de b
a&&b    Verdadeiro (=1) somente se a for verdadeiro e b também for
a||b    Verdadeiro (=1) se a for verdadeiro ou b for verdadeiro
a=b     Operador de atribuição: faz a = b
Pode-se usar também os parênteses em expressões
Exemplo:  2*(3+4)

Os operadores +=, -=, *= e /= são formas compactas:
variável += valor
variável -= valor
variável *= valor
variável /= valor

São o mesmo que:
variável = variável + valor
variável = variável - valor
variável = variável * valor
variável = variável / valor

Operadores ? e : são semelhantes às instruções se e senao:
a ? b : c
Se a for verdadeiro, o resultado é b. Se for falso, é c.
a ? b
Se a for verdadeiro, o resultado é b. Se for falso, é nulo.
a : b
Pouco usado. Calcula a e b, mas o resultado é sempre b.
Pode-se combinar vários ? e : como a seguir:
a ? b : c ? d : e
Nesse caso, se a for verdadeiro, o resultado é b.
Se for falso, checa c. Se c for verdadeiro o resultado é d.
Caso contrário, é e.
Importante: deve-se separar os operadores ? e : com espaço. Exemplo:
a ? b : c # a verdadeiro, o resultado é b, a falso o resultado é c
a ? b:c # Nesse caso, se a for verdadeiro, chama a função c da classe b

Via de regra, os operadores binários convertem o segundo operando para
o mesmo tipo do primeiro. Exemplos:
10 > 2 # Verdadeiro; está comparando números
10 > "2" # Verdadeiro; o texto "2" é transformado em número antes da comparação
"10" > "2" # Falso; está comparando dois textos; o "1" vem antes do "2"
"10" > 2 # Falso; o número 2 é transformado em texto antes da comparação
"1" + 2 # É o mesmo que "1" + "2", portanto resulta em "12"
1 + "2" # É o mesmo que 1 + 2, portanto resulta em 3

Existe uma ordem de precedência entre os operadores. Por exemplo,
multiplicações e divisões são calculadas antes de soma e subtração.
Porém, uma soma entre parênteses é calculada antes, pois os parênteses
tem precedência sobre a multiplicação e a divisão.

O IntMUD segue a seguinte ordem de precedência:
! e ~           Não lógico e complemento
* / %           Multiplicação, divisão e resto
+ -             Soma e subtração
<< >>           Rotação para esquerda e para direita
&               E para bits
^               Ou exclusivo para bits
|               Ou para bits
<= < > >=       Comparação
== === != !==   Igual a, exatamente igual a, diferente de, não exatamente igual
&&              E lógico
||              Ou lógico
? e :           Comparação, semelhante às instruções se e senao
= *= /= += -=   Atribuição e formas compactas de atribuição

Todos os operadores são processados da esquerda para a direita, com exceção
dos operadores de atribuição, que são processados da direita para esquerda.
Exemplo:
x=a+b+c # Soma a com b, e depois soma com c; coloca em x o resultado
a=b=c # Faz b=c, depois faz a=b


*** Operadores de bit

Variáveis int1 usam um bit para representar um valor numérico, por isso
só podem ser 0 ou 1. Os operadores de bit com int1 funcionam assim:

~ inverte os bits:
    ~1=0, ~0=1
| resulta em um se qualquer um dos dois números for 1:
    0|0=0, 0|1=1, 1|0=1, 1|1=1
& resulta em 1 somente se os dois números forem 1:
    0&0=0, 0&1=0, 1&0=0, 1&1=1
^ resulta em um se um número for 1 e o outro for 0:
    0^0=0, 0^1=1, 1^0=1, 1^1=1

Essas operações também são possível com variáveis int8, uint8, int16, etc.,
Para entender como funcionam, é necessário desmembrar em variáveis int1.
Os bits são numerados a partir do 0, sendo que cada um representa um
valor distinto:
bit 0 = 0 ou 1
bit 1 = 0 ou 2
bit 2 = 0 ou 4
bit 3 = 0 ou 8
bit 4 = 0 ou 16
bit 5 = 0 ou 32
bit 6 = 0 ou 64
bit 7 = 0 ou 128
etc.
Exemplo, o número 5 corresponde a 4+1 (bits 0 e 2).

Usos mais comuns dos operadores de bits:
uint8 x
x = 1
x = x | 4 # Faz o bit 2 = 1
x = x & ~4 # Fazer o bit 2 = 0
x = x ^ 4 # Inverte o bit 2
x = x & 4 # Faz todos os bits de x serem 0, exceto o bit 2
se x & 8 # Checa se o bit 3 é 0 ou 1
  msg("bit 3 de x = 1\n")
senao
  msg("bit 3 de x = 0\n")
fimse

Outra forma de trabalhar com bits é usando um vetore de int1. A variável
bits do vetor contém o valor numérico correspondente. Exemplo:
int1 x.32
x.bits = 3 # Faz bits 0 e 1 serem 1 e os demais bits são 0
x.3 = 1 # Faz o bit 3 ser 1; agora x.bits passa a ser 11
msg("O resultado é " + x.bits + "\n")


Os operadores de deslocamento têm funcionalidade parecida à de multiplicação
e divisão, porém arredondando para baixo (ex. 9.7 é arredondado para 9):
x=x<<1  multiplica x por 2
x=x<<2  multiplica x por 4
x=x<<3  multiplica x por 8
etc.
x=x>>1  divide x por 2
x=x>>2  divide x por 4
etc.

Essas operações, no entanto, são feitas copiando o valor de um bit
(que pode ser 0 ou 1) para o outro.
Exemplo, x >> 1 significa:
copiar do bit 1 para o bit 0
copiar do bit 2 para o bit 1
copiar do bit 3 para o bit 2
e assim por diante, até o último bit do número.

Nota 1:
Internamente todos os valores são convertidos em int32 antes de realizar
qualquer operação com bit.

Nota 2:
Nas variáveis int8, int16 e int32, o bit de maior valor é usado para
indicar se o número é negativo ou não. Porém, para a matemática funcionar
corretamente, multiplicar uma dessas variáveis por menos um tem o mesmo
efeito de inverter todos os bits e somar 1.

Exemplo, em uma variável int8:
0 significa todos os bits em 0.
1 significa somente o bit 0 em 1
-1 significa todos os bits em 1
-2 significa todos os bits em 1 exceto o bit 0


*** Caracteres especiais em textos

\n significa fim de uma linha de texto (deve passar para a próxima linha).

Para conseguir cores usa-se os caracteres \b, \c e \d nas mensagens:
    \b define cor dos caracteres: branco com fundo preto
    \c seguido de um dígito: define a cor dos caracteres
    \d seguido de um dígito: define a cor de fundo

O dígito após \c e \d pode ser:
    0 = preto           4 = azul
    1 = vermelho        5 = magenta
    2 = verde           6 = ciano
    3 = marrom          7 = branco

Somente após \c:
    8 = cinza               C = azul intenso
    9 = vermelho intenso    D = magenta intenso
    A = verde intenso       E = ciano intenso
    B = amarelo             F = branco intenso


*** Instruções de controle de fluxo - não podem ser usadas em cálculos

se <expressão>  ... fimse
se <expressão>  ... senão ... fimse
se <expressão>  ... senão <expressão>  ... fimse
    Decisão

enquanto <expressão>  ... efim
    Laço de repetição
    Se a expressão for verdadeira, executa as instruções que estiverem entre
    o enquanto e o efim e volta para a instrução enquanto, para testar
    a <expressão> novamente.

sair
    Sai de um laço enquanto ou um laço casovar.

continuar
    Fecha um ciclo de um laço enquanto, como se tivesse chegado na instrução
    efim. A diferença entre continuar e efim é que efim define aonde termina
    o laço.

casovar <expressão> ... casofim
casose
casose "texto"
    Avalia a expressão e transforma em texto. Em seguida, vai para a instrução
    casose que contém o texto correspondente (letras maiúsculas e minúsculas
    são consideradas diferentes). Se não encontrar o texto, vai para
    a instrução casose sem argumentos ou, se essa instrução não existir,
    vai para o casofim.
    A instrução sair sai do laço casovar, indo direto para o casofim.
    Nota: um casovar com vários casose é mais eficiente que várias instruções
    se e senão.

    Exemplo 1:
    casovar x
    casose "abc"
    msg("x é abc")
    sair
    casose "def"
    msg("x é def")
    sair
    casose
    msg("x não é abc nem def")
    casofim

    É o mesmo que:
    se txt(x)==="abc"
    msg("x é abc")
    senao txt(x)==="def"
    msg("x é def")
    senao
    msg("x não é abc nem def")
    fimse

    Exemplo 2:
    casovar n+2
    casose "1"
    casose "2"
    msg("a")
    casose "3"
    msg("b")
    casofim

    É o mesmo que:
    se txt(n+2)==="1" || txt(n+2)==="2"
    msg("a")
    msg("b")
    senao txt(n+2)==="3"
    msg("b")
    fimse

terminar
    Encerra o programa


*** Funções chamadas pelo programa

ini
    Executada quando o objeto é criado
fim
    Executada quando o objeto é apagado
iniclasse
    Executada quando a classe é criada
    Recebe um argumento (arg0), que é o nome da classe

Outras funções podem ser chamadas, por variáveis específicas, que constituem
uma extensão do programa.


*** Funções predefinidas

intpos(a)
    Retorna a se a>=0. Caso contrário retorna 0.

intabs(a)
    O mesmo que a sem sinal.
    Exemplo: abs(-1) e abs(1) são iguais a 1

int(a)
    O valor inteiro de a (semelhante a variáveis int32).

intdiv(a)
    O valor inteiro de a (int32), ignorando os dígitos após a vírgula.
    Por exemplo, intdiv(1.7) resulta em 1, enquanto que int(1.7) resulta em 2.

rand(a)
    Um número aleatório, inteiro, de 0 a a-1. Exemplo, rand(10) gera
    um número aleatório de 0 a 9.

rand(a, b)
    Um número aleatório inteiro, de a a b. Exemplo, rand(2,4) gera
    um número aleatório de 2 a 4.

ref(a)
    Referência constante; retorna o mesmo objeto que a.
    Se a não for um objeto, retorna nulo.
    Se for fornecido mais de uma referência (exemplo: ref(a,b,c)),
    retorna a primeira que não for nula.

txtnum(<número>, <formato>)
    Retorna um texto correspondente a um número ou variável numérica.
    Formato é um texto que pode conter:
    Um dígito de 0 a 9 = número de casas após a vírgula
    Uma vírgula: separar o número com vírgulas
    Um ponto: separar número com pontos, o ponto decimal vira vírgula
    Letra E: mostrar em notação científica; as opções anteriores são ignoradas
    Exemplo:
    txtnum(1005.23, "3.") é o mesmo que "1.005,230"
    Nota: números muito grandes (mais de 18 dígitos antes da vírgula)
    são mostrados em notação científica.
    Exemplo: 5.9E+18 significa 59 seguido de 17 zeros.

txt(<texto>)
    Texto constante (não pode ser alterado) igual a <texto>.
    Se <texto> não for um texto, retorna um texto vazio.
    Se for objeto, retorna o nome da classe.

txt(<texto>, <caracter inicial>)
txt(<texto>, <caracter inicial>, <quantidade de caracteres>)
    Retorna um texto que é parte do texto especificado. Exemplo:
    txt("abcdef", 2, 2) é o mesmo que "cd".

txtfim(<texto>, <quantidade de caracteres>)
    Retorna um texto que contém os últimos caracteres do texto
    especificado. Exemplo:
    txtfim("abcdef", 3) é o mesmo que "def".

txt1(<texto>)
    Retorna a primeira palavra do texto.

txt2(<texto>)
    Retorna tudo exceto a primeira palavra do texto.

intsub(<texto>)
    Retorna a quantidade de palavras contidas no texto.

txtsub(<texto>, <palavra inicial>)
txtsub(<texto>, <palavra inicial>, <quantidade de palavras>)
    Retorna um texto que é parte do texto especificado.
    As palavras são sempre separadas por espaço.
    Palavra inicial é a primeira palavra, 0=início do texto.
    Se a quantidade de palavras for omitida, assume até o final do texto.
    Exemplos:
    txtsub("bom dia boa tarde", 2) é o mesmo que "boa tarde".
    txtsub("bom dia boa tarde", 1, 1) é o mesmo que "dia".

txtcor(<texto>)
    Retorna o texto sem as definições de cores. Exemplo:
    txtcor("\cF\d4Teste\b") é o mesmo que "Teste".

txtmai(<texto>)
    Retorna o texto em letras maiúsculas.

txtmin(<texto>)
    Retorna o texto em letras minúsculas.

txtmaiini(<texto>)
    Retorna o texto passando a primeira letra para maiúscula.
    Se encontrar algum ponto, a próxima letra também será maiúscula.

txtmaimin(<texto>)
    Retorna o texto com a primeira letra maiúscula e as demais minúsculas.
    Se encontrar um ponto, a próxima letra será maiúscula.

txtmudamai(<texto>)
txtmudamai(<texto>, <porcentagem>)
    Retorna um texto que é o texto original com letras maiúsculas
    trocadas com minúsculas.
    Exemplo: txtmudamai("Bom Dia") é o mesmo que "bOM dIA"
    A porcentagem, se estiver presente, é a chance de fazer uma troca.
    Exemplo: 0=não trocar, 100=trocar sempre, 50=50% de chances de trocar

txtcopiamai(<texto1>, <texto2>)
    Retorna texto1, mas passando letras para maiúscula ou minúscula
    conforme as letras correspondentes em <texto2>.
    Exemplo: txtcopiamai("teste", "XYZnn") é o mesmo que "TESte"

txtfiltro(<texto>)
    Filtra mensagens. Retorna o texto filtrado.

txtesp(<quantidade de espaços>)
    Retorna um texto que é a quantidade de espaços requisitada.
    O texto retornado tem de 0 a 100 caracteres.

txtrepete(<texto>, <quantidade de repetições>)
    Retorna um texto que é o texto especificado repetido o número
    especificado. Exemplos:
    txtrepete("a", 3) # é o mesmo que "aaa"
    txtrepete("xyz", 2) # é o mesmo que "xyzxyz"

txtshs(<texto>)
    Calcula e retorna o SHS de um texto.
    O texto original é codificado de modo que não é possível decodificar.
    O resultado do SHS é compactado em um texto de 27 caracteres contendo
    letras maiúsculas e alguns símbolos.

txtnome(<texto>)
    Codifica apelido para comparação.
    Retorna o mesmo texto para dois apelidos parecidos.
    Nota: o texto retornado nunca é maior que o apelido.

intnome(<texto>)
    Verifica se texto é válido para apelido. Retorna:
    0 = apelido válido
    1 = muito pequeno (menos de 2 caracteres)
    2 = contém caracteres inválidos

intsenha(<texto>)
    Verifica se texto é válido para senha. Retorna:
    0 = senha válida
    1 = muito pequena (menos de 5 caracteres)
    2 = contém caracteres inválidos
    3 = contém só letras ou só números

txtcod(<texto>)
    Codifica um texto de modo que possa ser usado como nome de variável.
    Caracteres válidos em nomes de variáveis não são alterados, com exceção
    do espaço, que muda para '_'.

    Os caracteres modificados são:
    @ /b /c /d /n  mudam para  @@ @b @c @d @n
    " ! # $ %  mudam para  @a @e @f @g @h
    & ' ( ) *  mudam para  @i @j @k @l @m
    + , - . /  mudam para  @o @p @q @r @s
    : ; < = >  mudam para  @t @u @v @w @x
    ? [ \ ] ^  mudam para  @y @z @0 @1 @2
    ` { | } ~  mudam para  @3 @4 @5 @6 @7

    Vide exemplo em txtdec (abaixo).

txtdec(<texto>)
    Decodifica um texto. Processo inverso de txtcod.

    Exemplo de como testar txtcod e txtdec:
    telatxt = 1
    classe tela
    telatxt tela
    func iniclasse
      criar(arg0)
    func tela_msg
      tela.msg("txtcod = \"" + txtcod(arg0) + "\"\n")
      tela.msg("txtdec = \"" + txtdec(txtcod(arg0)) + "\"\n")

txturlcod(<texto>)
    Codifica um texto formando uma URL válida.
    Atua da seguinte forma:
    O primeiro \n é substituído por interrogação.
    Os próximos \n são substituídos pelo caracter &.
    O espaço é substituído pelo um sinal de soma.
    Letras A a Z maiúsculas e minúsculas, dígitos de 0 a 9, hífen, ponto,
    sinal de igual e "/" não são alterados.
    Qualquer outro caracter é substituído por um "%" seguido de dois
    dígitos, que são código ASCII do caracter, em hexadecimal.

    Exemplo:
    txturlcod("/x.html\na=1\nb=bom dia!")
    Resulta em "/x.html?a=1&b=bom+dia%21"
    Em um servidor HTTP, isso geralmente significa acessar a página "/x.html"
    passando as variáveis a="1" e b="bom dia!".

txturldec(<texto>)
    Decodifica uma URL formando um texto.
    Processo inverso de txturlcod.

    Exemplo:
    txturldec("/x.html?a=1&b=bom+dia%21")
    Resulta em "/x.html\na=1\nb=bom dia!"

txtvis(<texto>)
    Torna visíveis caracteres especiais, como \n e \b.
    "\b\c\d\n"   mudam para  "\\b\\c\\d\\n"
    "\"" muda para "\\\""
    "\\" muda para "\\\\"
    Exemplo 1:
    txtvis("\C1 \"Bom dia\" \B") é o mesmo que "\\C1 \\\"Bom dia\\\" \\B".
    Exemplo 2:
    txt10 x
    x = "\b\""
    msg("A variável x contém \"" + txtvis(x) + "\"\n")

txtinvis(<texto>)
    Processo inverso da função txtvis.

intchr(<texto>)
intchr(<texto>, <número do caracter>)
    Retorna o código ASCII de um caracter, de 32 a 255, ou um dos
    seguintes códigos usados no IntMUD:
    0=não é um caracter (ex. texto vazio)
    1=\b,   2=\c,   3=\d,   10=\n
    Se a posição do caracter no texto for omitida, é considerado como
    se fosse 0 (o primeiro caracter do texto).

txtchr(<valor numérico>)
    Retorna o caracter correspondente a um código ASCII, ou um texto
    vazio se não for um código ASCII válido.

intdist(<texto1>, <texto2>)
    Calcula a distância "Levenshtein" entre os dois textos.
    Em outras palavras, calcula o quanto os dois textos são diferentes.
    Retorna a quantidade de mudanças necessárias; 0=textos iguais.

    As funções intdistmai e intdistdif fazem a mesma coisa, exceto que:
    intdist - considera iguais letras minúsculas, maiúsculas e acentuadas.
    intdistmai - considera iguais letras maiúsculas e minúsculas.
    intdistdif - diferencia letras maiúsculas, minúsculas e acentuadas.

txtremove(<texto1>, <texto2>)
    Retorna um texto semelhante a <texto1>, mas removendo espaços e/ou
    cores, conforme <texto2>. As letras interpretadas em <texto2> são:
    E = remover espaços à esquerda.
    M = remover espaços extras, exceto à esquerda e à direita.
    D = remover espaços à direita.
    C = remover cores (tem o mesmo efeito da função txtcor).
    S = remover aspas simples trocando espaços entre duas aspas por sublinhado.
    A = remover aspas duplas trocando espaços entre duas aspas por sublinhado.
    7 = usar letras sem acentuação (caracteres em 7 bits).
        Exemplo, "ã É ì" vira "a E i".
    Exemplos:
    txtremove("  bom  dia  ", "EMD") é o mesmo que "bom dia"
    txtremove("  bom  dia  ", "ED") é o mesmo que "bom  dia"
    txtremove("\cF\d4Teste\b", "C") é o mesmo que "Teste"
    txtremove("tenha um 'bom dia' !", "S") é o mesmo que "tenha um bom_dia !"

txtsepara(<texto>, <opções>, <texto usado como separador>)
    Separa números e palavras de um texto, acrescentando um texto separador.
    Se o texto separador for omitido, será usado um espaço.

    Opções é um texto, sendo que cada letra significa um tipo de caracter:
    D = dígito de 0 a 9
    N = um número (pode começar com um sinal de menos e ter um ponto)
    L = letra (de A a Z, acentuada ou não)
    E = espaço vazio
    O = outros caracteres
    V = vazio (antes do início do texto ou depois do fim)

    Para indicar aonde o texto separador deve ser acrescentado, escreve-se
    uma ou mais letras, que correspondem a um tipo de caracter, seguido do
    sinal de mais e uma ou mais letras, correspondentes ao caracter seguinte.
    Exemplo, para separar os números, acrescentando um espaço na frente,
    o texto de opções é "LNO+N", que significa letra, número ou outros
    caracteres seguido de número.
    txtsepara("1,10abc-40", "LNO+N") resulta em: "1, 10abc -40"
    Exemplo 2: txtsepara("bom dia boa tarde", "L+EV", "!")
    é o mesmo que: "bom! dia! boa! tarde!"

    Pode-se usar mais de uma condição, separando-as com vírgulas.
    Exemplo: txtsepara("1,10abc-40", "LON+N,N+LON")
    é o mesmo que: "1 , 10 abc -40"

txtproc(<texto>, <texto procurado>)
txtproc(<texto>, <texto procurado>, <caracter inicial>)
    Procura <texto procurado> em <texto>
    Retorna -1 se não encontrou ou o número do caracter se encontrou
    <caracter inicial> = a partir de onde procurar no texto
            0 = primeiro caracter, 1 = segundo, etc.

    As funções txtprocmai e txtprocdif fazem a mesma coisa, exceto que:
    txtproc - considera iguais letras minúsculas, maiúsculas e acentuadas.
    txtprocmai - considera iguais letras maiúsculas e minúsculas.
    txtprocdif - diferencia letras maiúsculas, minúsculas e acentuadas.

txttroca(<texto>, <valor anterior>, <novo valor>)
    Troca <valor anterior> por <novo valor> no <texto>.
    Retorna o texto modificado ao invés de alterar o texto original.
    Nota: Se <valor anterior> for um texto vazio, retorna <texto>.
    Exemplo:
    txttroca("possibilidade", "i", "e") é o mesmo que "possebeledade".

    As funções txttrocamai e txttrocadif fazem a mesma coisa, exceto que:
    txttroca - considera iguais letras minúsculas, maiúsculas e acentuadas.
    txttrocamai - considera iguais letras maiúsculas e minúsculas.
    txttrocadif - diferencia letras maiúsculas, minúsculas e acentuadas.

vartroca(<texto>, <texto2>, <variável>)
vartroca(<texto>, <texto2>, <variável>, <porcentagem>)
vartroca(<texto>, <texto2>, <variável>, <porcentagem>, <espaço>)
    Procura textos em <texto> e substitui variáveis/funções do objeto "este".
    Os textos procurados são <texto2> seguido de uma palavra qualquer.
    Os nomes das funções são <variável> seguido da mesma palavra.
    Exemplo:
      const t_1 = "joão"  # $1 = joão
      const t_2 = "maria" # $2 = maria
      vartroca("$1 falou com $2", "$", "t_")
                  # É o mesmo que: t_1 + " falou com " + t_2
                  # Produz o texto "joão falou com maria"
    A porcentagem, se estiver presente, é a chance de fazer uma troca.
    Exemplo: 0=não trocar, 100=trocar sempre, 50=50% de chances de trocar
    O espaço, se estiver presente, é um número que indica quantas trocas
    não deve fazer após fazer uma troca com sucesso.
    Exemplo: 1=cada vez que trocar, ignora a próxima troca
    Quando vartroca chama uma função, coloca em arg0 o texto encontrado.
    Exemplo de como diferenciar letras maiúsculas de minúsculas:
      func teste_a
        se arg0 === "A" # Se for exatamente igual
          ret "A maiúsculo"
        senão
          ret "A minúsculo"
      vartroca("$A $a", "$", "teste_")
                  # Produz o texto "A maiúsculo A minúsculo"
    Outra forma de escrever:
      const teste_a = t_a[arg0=="A"]
      const t_a0 = "A maiúsculo"
      const t_a1 = "A minúsculo"
      vartroca("$A $a", "$", "teste_")

criar(<nome da classe>)
criar(<nome da classe>, <argumentos da função ini>)
    Cria um objeto e chama a função ini do objeto.
    Entrada: texto que contém o nome da classe.
    Retorna: uma referência para o objeto, ou nulo se classe não existe.
    Exemplos:
    ref x
    x = criar("teste1")
    criar("teste2")

apagar(<objeto>)
    Marca um objeto para ser apagado. O objeto só será realmente apagado
    após o controle retornar ao programa. Mesmo assim, antes de apagar
    ainda será chamada a função fim do objeto.
    Entrada: referência para o objeto.
    Exemplo:
    apagar(este)

$ seguido do nome da classe
    Retorna o primeiro objeto da classe especificada.
    Exemplos: $jog  ou  $["jog"]

objantes(<objeto>)
    Retorna o objeto anterior da classe ou NULO se não houver.

objdepois(<objeto>)
    Retorna o próximo objeto da classe ou NULO se não houver.

inttotal(<variável>)
    Se for objeto, retorna a quantidade de objetos da classe.
    Se for texto, retorna o tamanho do texto em caracteres.
    Se for vetor, retorna a quantidade de variáveis do vetor.
    Se for fornecido mais de um argumento, é retornada a soma.
    Exemplo: inttotal(a,b)
    É o mesmo que: inttotal(a) + inttotal(b)


*** Funções existentes em variáveis numéricas

As variáveis do tipo real e as numéricas começadas com int (int1 a int32,
uint1 a uint32, intinc, intdec, inttempo) possuem a seguinte função:

limpar
    Zera todas as variáveis do vetor (faz todas as variáveis = 0).

bits
    Existente somente em vetores de int1. É uma variável do tipo int32,
    que corresponde ao valor numérico das variáveis do vetor.


*** Funções existentes em vetores de variáveis txt1 a txt512

limpar
    Limpa todas as variáveis do vetor (faz todas as variáveis = "").
    Exemplo:
    txt10 x.3
    x.limpar
    É o mesmo que:
    txt10 x.3
    x.0 = ""
    x.1 = ""
    x.2 = ""

texto
texto(<número da primeira variável>)
texto(<número da primeira variável>, <número da última variável>)
    Retorna um texto que corresponde a todas as variáveis concatenadas
    Exemplo:
    txt10 x.3
    x.0 = "a"
    x.1 = "b"
    x.2 = "c"
    msg(x.texto) # É o mesmo que msg("abc")
    msg(x.texto(0,1)) # É o mesmo que msg("ab")

palavras(<texto>)
palavras(<texto>, <número de palavras>)
    Divide o texto em palavras.
    As palavras são separadas por espaço ou "\n".
    Retorna o número de palavras (pode ser zero).
    Exemplo:
    txt10 x.2
    x.palavras("bom dia !")
    É o mesmo que:
    txt10 x.2
    x.0 = "bom"
    x.1 = "dia !"

linhas(<texto>)
linhas(<texto>, <número de colunas>)
    Preenche as variáveis do vetor com o texto, da seguinte forma:
    Cada variável recebe uma linha do texto (o caracter "\n" indica
    o fim de uma linha).
    Linhas que não cabem em uma variável são divididas automaticamente,
    de preferência no último espaço entre <número de colunas> e o tamanho
    da variável.
    Retorna o número de linhas (pelo menos uma linha).

separar(<texto>, <delimitador>)
separar(<texto>, <delimitador>, <número de textos>)
    Divide o texto com o delimitador especificado.
    Cada variável do vetor recebe um texto.
    A última variável recebe o restante do texto.
    Retorna o número de variáveis (pelo menos uma variável).

    As funções separarmai e separardif fazem a mesma coisa, exceto que:
    separar - considera iguais letras minúsculas, maiúsculas e acentuadas.
    separarmai - considera iguais letras maiúsculas e minúsculas.
    separardif - diferencia letras maiúsculas, minúsculas e acentuadas.

    Exemplo:
    txt10 x.4
    x.separar("abc:10::def:20", ":")
    É o mesmo que:
    txt10 x.4
    x.0 = "abc"
    x.1 = "10"
    x.2 = ""
    x.3 = "def:20"

juntar(<delimitador>)
juntar(<delimitador>, <número de variáveis>)
    Concatena o número de variáveis do vetor especificadas, acrescentando
    o delimitador entre duas variáveis. Retorna o texto obtido.
    Exemplo:
    x.juntar(",", 3) é o mesmo que:
    x.0 + "," + x.1 + "," + x.2

txtremove(<texto>)
    Altera todos os textos do vetor com a função txtremove.
    Exemplo:
    txt10 x.2
    x.0 = txtremove(x.0, "C")
    x.1 = txtremove(x.1, "C")
    É o mesmo que:
    txt10 x.2
    x.txtremove("C")

*** Outros tipos de variáveis

Constituem uma extensão do programa interpretador. Algumas permitem
a comunicação com o mundo externo, outras possibilitam mais recursos.

Possuem funções/variáveis e podem gerar eventos (executar funções
do objeto em que pertencem).

Definição de um tipo:
<tipo de variável>  <nome da variável>
Exemplo:  listaobj x

Executar uma função:
<nome da variável>.<função>
Exemplos:
x.limpar
x.addini(este)

Eventos (funções chamadas pela variável):
func <nome da variável>_<nome do evento>
Exemplo, uma função teste para a variável x, acima, pode ser definida como:
func x_teste


*** Lista de variáveis

listaobj <nomedavariável>
    Lista de objetos.
    Um objeto pode ser adicionado várias vezes em uma lista.
    Como valor numérico, é 0 se a lista estiver vazia ou 1 se não estiver.
    Quando um objeto é apagado, é executada a função apagaobj de todas
    as variáveis listaobj do objeto.

    Funções:
    addini(<objetos e/ou listaobj>)
        Adiciona no topo da lista.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addfim(<objetos e/ou listaobj>)
        Adiciona no final da lista.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addini1 e addfim1
        Mesmo que addini e addfim, exceto que não adiciona objetos
        se já estiverem na listaobj.
    remove
        Remove objetos repetidos na lista.
        Retorna a quantidade de objetos removidos.
    remove(<objetos e/ou listaobj>)
        Retira objetos da lista. Retorna a quantidade de objetos removidos.
    rand
        Muda a ordem dos objetos aleatoriamente.
    limpar
        Retira todos os objetos da lista.
    possui(<objetos e/ou listaobj>)
        Retorna quantos objetos estão na lista (0=não estão na lista).
    apagar
        Marca todos os objetos da lista para exclusão, usando a função apagar()
    total
        Quantidade de itens da lista.
    objlista
        Objeto que contém a lista; pode ser NULO.
    ini
        Primeiro item da lista (variável listaitem).
        Nota: ini.obj = primeiro objeto da lista.
    fim
        Último item da lista (variável listaitem).
        Nota: fim.obj = último objeto da lista.

listaitem <nomedavariável>
    É usado para acessar os objetos de listaobj. Representa um objeto.
    Como valor numérico, é 1 se for um objeto ou 0 se não for.

    Funções:
    addantes(<objetos e/ou listaobj>)
        Adiciona objetos antes desse.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    adddepois(<objetos e/ou listaobj>)
        Adiciona objetos depois desse.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addantes1 e adddepois1
        Mesmo que addantes e adddepois, exceto que não adiciona objetos
        se já estiverem na listaobj.
    antes
        Passa para o objeto anterior.
    antes(<número de objetos>)
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois(<número de objetos>)
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    remove
        Remove objeto da lista, listaitem passa a não ser um objeto válido.
    removeantes
        Remove objeto da lista e passa para o anterior.
        Nota: não confundir com "remover o objeto anterior".
    removedepois
        Remove objeto da lista e passa para o próximo.
        Nota: não confundir com "remover o próximo objeto".
    obj
        Objeto.
    total
        Quantidade de itens da lista.
    objlista
        Objeto que contém a lista; pode ser NULO.

    Exemplo:
    listaobj l
    listaitem i
    l.addantes( este ) # Adiciona no topo da lista
    l.adddepois( este ) # Adiciona no final da lista
    l.remove( l.ini.obj ) # remove um objeto da lista
    l.possui( este) # retorna !=0 se objeto está na lista
    l.ini.obj # é o primeiro objeto da lista
    l.fim.obj # é o último objeto da lista
    i = l.ini  # i é o primeiro item da lista
    enquanto i    # Enquanto i for um objeto (não acabou a lista)
      i.obj.l = 1   # Faz a variável l do objeto = 1
      i.depois      # Passa para o próximo objeto
    efim

textotxt <nomedavariável>
    Lista de textos. É o equivalente ao texto de um editor de textos.
    Todas as linhas de texto terminam com um caracter \n.

    Funções:
    ini
        Primeira linha do texto (variável textopos).
    fim
        Fim do texto, após a última linha do texto (variável textopos).
    linhas
        Retorna o número de linhas de texto.
    bytes
        Retorna a quantidade de bytes de texto.
    limpar
        Limpa o texto
    addini(<texto>)
        Adiciona linhas no início do textotxt.
    addfim(<texto>)
        Adiciona linhas no fim do textotxt.
    remove(<quantidade de linhas>)
        Retorna um texto que contém uma quantidade de linhas do início do
        textotxt. Retira essas linhas do textotxt.
        Se a quantidade de linhas for omitida, remove uma linha apenas.
    ordena
        Organiza as linhas em ordem alfabética.
    ordenalin
        Organiza as linhas em ordem alfabética, sendo que:
        A primeira palavra de cada linha é a quantidade de textos.
        Da segunda palavra em diante é o texto propriamente dito.
        As linhas que não começam com um número são apagadas.
        Linhas iguais são somadas.
        Exemplo:
            "1 Carro pequeno\n"
            "3 Carro pequeno\n"
            "2 Caminhão\n"
        Vira:
            "2 Caminhão\n"
            "4 Carro pequeno\n"
    ordenalin(<texto1>, <texto2>)
        Mesmo que ordenalin sem argumentos, exceto que após ordenar altera
        as linhas de acordo com a quantidade (a primeira palavra):
        Se for 0 ou não for um número: apaga a linha
        Se for 1: apaga o número no começo da linha
        Se for 2 ou mais: adiciona <texto1> antes do número e <texto2> depois.
        Exemplo:
            "0 Bolsa\n"
            "1 Garrafa\n"
            "5 Copo\n"
        Após numerolin("(", "x)"), essas linhas mudam para:
            "(5x) Copo\n"
            "Garrafa\n"
    juntalin
    juntalin(<texto1>, <texto2>)
        Junta as linhas repetidas exatamente como ordenalin, porém mantém
        a ordem original das linhas.
    juntar
        Acrescenta um espaço entre as linhas e junta todas as linhas do
        textotxt, formando uma só. Pode ser bastante útil antes de dividelin
        ou dividelincor.
    dividelin(<colmin>, <colmax>)
        Linhas que tiverem mais que <colmax> colunas são divididas entre
        as colunas <colmin> e <colmax>, preferêncialmente no último espaço
        encontrado. Se <colmin> ou <colmax> for menor que dois, essa
        função não tem efeito.
    dividelincor(<colmin>, <colmax>)
        Mesmo que dividelin, porém não considera definições de cores na
        contagem de caracteres por linha.
    rand
        Muda a ordem das linhas aleatoriamente.
    txtremove(<texto>)
        Altera todas as linhas do textotxt com a função txtremove.
        Exemplo:
        textotxt t
        t.addfim(txtremove("  bom  dia  ", "MC"))
        t.addfim(txtremove("\cF\d4Teste\b", "MC"))
        É o mesmo que:
        textotxt t
        t.addfim("  bom  dia  ")
        t.addfim("\cF\d4Teste\b")
        t.txtremove("MC")
    ler(<nome do arquivo>)
        Lê um arquivo de texto e coloca em textotxt.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Nota 1: Não acessa arquivos executáveis ou terminados em:
                .exe, .com, .bat, .pif, .scr ou .log
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível acessar arquivos de outros lugares.
    salvar(<nome do arquivo>)
        Salva o conteúdo de textotxt em um arquivo de texto.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Notas: vide função ler (acima)

textopos <nomedavariável>
    É usado para acessar o texto de textotxt. Representa uma linha.
    Como valor numérico, é 1 se linha existe ou 0 se está no fim do texto.

    Variável:
    linha
        Número da linha atual; começa em 0.
        Nota 1: prefira usar "linha.depois" ao invés de "linha+=1".
        Nota 2: Internamente muda de linha chamando as funções antes e depois.

    Funções:
    byte
        Retorna a quantidade de bytes desde o início do texto; começa no 0.
    lin
        É 1 se linha válida ou 0 se chegou no fim do texto.
    antes
        Passa para a linha anterior.
    antes(<número de linhas>)
        Recua o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Vai para a próxima linha.
    depois(<número de linhas>)
        Avança o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    texto
    texto(<caracter inicial>)
    texto(<caracter inicial>, <quantidade de caracteres>)
        Retorna o texto da linha atual ou de parte da linha atual.
    textolin(<número de linhas>)
        Retorna texto correspondente ao número de linhas especificado.
    mudar(<novo texto>)
    mudar(<novo texto>, <caracter inicial>)
    mudar(<novo texto>, <caracter inicial>, <quantidade de caracteres>)
        Muda o texto da linha atual ou parte do texto da linha atual.
        Caracter inicial e quantidade de caracteres referem-se à linha atual.
    add(<novo texto>)
        Adiciona linha antes da linha atual.
        Após essa função, textopos corresponde ao texto adicionado.
    add(<textopos início>, <número de linhas>)
        Adiciona as linhas correspondente ao texto especificado.
    remove
        Remove a linha atual.
    remove(<número de linhas>)
        Remove a quantidade de linhas especificadas, a partir da linha atual.
    juntar
        Junta a linha atual com a anterior.
        Retorna 1 se juntou linhas ou 0 se não juntou.
        Nota: Para dividir uma linha, adicionar texto "\n" com a função mudar.
    txtproc(<texto procurado>, <caracter inicial>, <quantidade de linhas>)
        Procura um texto a partir da linha atual.
        "\n" no começo do texto significa: deve estar no começo de uma linha.
        "\n" no fim do texto significa: deve estar no fim de uma linha.
        Se não for especificada uma quantidade de linhas a procurar, procura
        até o final do texto.
        Se o caracter inicial não for especificado, assume início da linha.
        Se não encontrou, retorna -1. Se encontrou, posiciona na linha que
        contém o texto e retorna o número do caracter (0=início da linha).

        As funções txtprocmai e txtprocdif fazem a mesma coisa, exceto que:
        txtproc - considera iguais letras minúsculas, maiúsculas e acentuadas.
        txtprocmai - considera iguais letras maiúsculas e minúsculas.
        txtprocdif - diferencia letras maiúsculas, minúsculas e acentuadas.

textovar <nomedavariável>
    Lista de variáveis organizadas em ordem alfabética.
    Semelhante a textotxt, porém as linhas contém variáveis de texto
    no formato "nome da variável=valor", organizadas em ordem alfabética.
    Cada variável pode conter qualquer texto, inclusive caracteres como
    "\b", "\n" e "=".

    Funções:
    ini
        Retorna nome da primeira variável.
    fim
        Retorna nome da última variável.
    ini(<texto>)
        Retorna nome da primeira variável cujo nome começa com o texto.
    fim(<texto>)
        Retorna nome da última variável cujo nome começa com o texto.
    antes(<nome da variável>)
        Retorna nome da variável anterior ou "" se não existe.
    depois(<nome da variável>)
        Retorna nome da próxima variável ou "" se não existe.
    valor(<nome da variável>)
        Retorna o conteúdo da variável (um texto) ou "" se não existe.
    nomevar(<nome da variável>)
        Retorna o nome da variável (um texto) ou "" se não existe.
    mudar("variável=valor")
        Cria uma variável ou muda se já existir.
        Para apagar variável, basta atribuir um texto vazio.
        Exemplo, mudar("x=") ou mudar("x") apaga a variável x.
    limpar
        Apaga todas as variáveis do textovar.
    limpar(<texto>)
        Apaga todas as variáveis cujos nomes começam com o texto.

    Outros nomes:
        Correspondem a uma variável de textovar, do tipo texto.
        Para a variável ser tratada como numérica, acrescentar sublinhado
        após o nome da variável.

    Exemplos:
    textovar v
    v.mudar("x=teste") # Cria variável x faz ser "teste"
    v.x = "teste" # Mesma coisa que v.mudar, acima
    v.mudar("y=10") # Cria variável y = 10
    v.y_ = 10 # Mesma coisa, porém y é numérico, enquanto que x é texto
    v.y_ += 2 # Faz a variável y ser 12 (10 + 2)
    # Exemplo de como mostrar todas as variáveis de um textovar
    telatxt tela
    txt80 nome
    nome = v.ini
    enquanto nome
      tela.msg(nome + "=" + v.valor(nome) + "\n")
      nome = v.depois(nome)
    efim

nomeobj <nomedavariável>
    Usado para obter um ou mais objetos, correspondente ao que o usuário
    digitou.
    Funções:
    ini(<texto>, <quantidade>)
        Inicia a busca.
        <texto> é o nome procurado (geralmente o que o usuário digitou).
        Exemplo: "poção"
        Pode-se digitar o número do objeto, escrevendo um número seguido
        de ponto e um nome. Exemplo: "2.poção" corresponde à segunda poção.
        Pode-se digitar também a quantidade, se for mais de um.
        Exemplo: "10 poção"
        <quantidade> é a quantidade máxima de objetos que podem ser
        encontrados. Exemplo, se não for desejável processar mais de 10
        objetos, <quantidade> deve ser o número 10.
    nome(<texto>)
    nome(<texto>, <texto2>, ..., <textoN>)
        <texto> contém um ou mais nomes (separados por espaço) correspondentes
        a um objeto. Exemplo, "chave chave_verde" significa um objeto que
        pode ser referenciado por esses dois nomes: chave e chave_verde.
        Essa função retorna 1 se for o objeto procurado ou 0 se não for.

    Exemplo com as duas funções:
    nomeobj x
    x.ini("2.ch", 5)# Achar no máximo 5 itens que começam com "ch"
                    # No entanto, como o texto é "2.ch", procurará só o segundo
    x.nome("bolsa") # Retorna 0 porque não é o item procurado
    x.nome("chave_azul")  # Retorna 0; não é o segundo item que começa com ch
    x.nome("chave_verde") # Retorna 1
    x.nome("chave_azul")  # Retorna 0 porque já encontrou o item

arqdir <nomedavariável>
    Acesso a diretórios.

    Funções:
    abrir(<nome do diretório>)
        Inicia a busca de arquivos/diretórios em um diretório.
        Retorna "" se sucesso ou um texto contendo o erro.
    fechar
        Encerra a busca em um diretório
    lin
        É 1 se entrada válida ou 0 se chegou no fim do diretório.
    texto
        Nome da entrada.
    depois
        Passa para a próxima entrada.
        Fecha o diretório se não houver próxima entrada.
    tipo
    tipo(<nome da entrada>)
        Sem argumentos, retorna o tipo da entrada encontrada em abrir()
        Retorna o tipo:
        "A" = arquivo, "D" = diretório, "O" = outro tipo de entrada
        "?" = não existe
    tamanho(<nome da entrada>)
        Retorna o tamanho do arquivo.
    atempo(<nome da entrada>)
        Retorna quando o arquivo foi acessado; um texto no formato:
        ano mês dia hora minuto segundo milhonésimos de segundo
        Exemplo: "2010 1 20 14 30 02 1500"
        Retorna um texto vazio se o arquivo não existir ou não permitido.
    mtempo(<nome da entrada>)
        Retorna quando o arquivo foi modificado, da mesma forma que atempo.
    criardir(<nome do diretório>)
        Cria um diretório.
    apagardir(<nome do diretório>)
        Apaga um diretório, exceto se não estiver vazio.
    apagar(<nome do arquivo>)
        Apaga um arquivo.
    renomear(<antigo nome>, <novo nome>)
        Renomeia uma entrada.

arqlog <nomedavariável>
    Para gravar mensagens em arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.

    Funções:
    valido(<nome do arquivo>)
        Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.
    existe(<nome do arquivo>)
        Retorna 1 se arquivo existe ou 0 se não existe.
    abrir(<nome do arquivo>)
        Abre arquivo, cria se não existir.
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu.
        Nota 1: O nome do arquivo sempre terminará com ".log".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível criar arquivos em outros lugares.
    fechar
        Fecha o arquivo.
    msg(<texto>)
        Grava texto em uma nova linha, no final do arquivo.
        Nota 1: Definições de cores e linhas vazias não são gravadas.
        Nota 2: Pode demorar até 2 segundos para o texto ser realmente
                gravado no arquivo.

arqsav <nomedavariável>
    Para salvar objetos em arquivos e recuperar posteriormente.
    Nota 1: Não acessa arquivos executáveis ou terminados em:
            .exe, .com, .bat, .pif, .scr ou .log
    Nota 2: O arquivo deve pertencer ao diretório atual ou a um
    subdiretório dele. Não é possível criar arquivos em outros lugares.

    Os objetos que serão salvos devem ser colocados em uma listaobj.
    As variáveis salvas devem ser definidas com a palavra "sav" antes.
    Exemplo:
    classe x
    sav int8 a # Essa variável é salva por arqsav
    int8 b # Já essa não é salva

    Variáveis que acessam recursos externos nunca são salvas:
    arqlog, arqsav, arqtxt, telatxt, serv, socket
    Essas outras também não, por motivos óbvios:
    nomeobj, prog, indiceitem
    Referência a outros objetos (ref, listaobj, listaitem, etc.) são salvas
    quando se referem a outro objeto que também será salvo no mesmo arquivo.

    Funções:
    valido(<nome do arquivo>)
        Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.
    existe(<nome do arquivo>)
        Retorna 1 se arquivo existe ou 0 se não existe.
    senha(<nome do arquivo>, <senha>)
        Retorna 1 se senha correta ou 0 se incorreta.
    dias(<nome do arquivo>)
        Retorna quantos dias faltam para o arquivo expirar.
        Retorna 0 se expirou, -1 se nunca expira.
    ler(<nome do arquivo>, <listaobj>)
    ler(<nome do arquivo>, <listaobj>, <quantidade máxima de objetos lidos>)
        Lê Arquivo.
        O primeiro objeto do arquivo vai para o primeiro da listaobj.
        O segundo do arquivo vai para o segundo da listaobj, e assim por
        diante. Se a listaobj tiver menos objetos que o arquivo, serão
        criados objetos na listaobj.
        Retorna a quantidade de objetos lidos.
    salvar(<nome do arquivo>, <listaobj>, <dias>, <senha>)
        Salva em arquivo todos os objetos de uma listaobj.
        <dias> é a quantidade de dias para apagar o arquivo, 0=nunca apagar
        Retorna 1 se conseguiu salvar ou 0 se não conseguiu.
    apagar(<nome do arquivo>)
        Apaga arquivo.
        Retorna 1 se conseguiu apagar ou arquivo não existia.
        Retorna 0 se não conseguiu apagar.
    limpar(<nome do diretório>)
        Inicia checagem dos arquivos .sav no diretório especificado; apaga
        arquivos que expiraram. Os arquivos são verificados aos poucos para
        ficar transparente aos usuários.
        Retorna 1 se conseguiu ou 0 se diretório não permitido.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual, em segundo plano
    limpar
        Checa todos os diretórios pendentes de uma vez, ao invés de checar
        aos poucos, em segundo plano.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual
        sav.limpar # Checa todos os arquivos de uma vez

arqtxt <nomedavariável>
    Para ler ou gravar arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.
    Nota: A escrita em arquivo não é tão eficiente quanto arqlog.

    Funções:
    valido(<nome do arquivo>)
        Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.
    existe(<nome do arquivo>)
        Retorna 1 se arquivo existe ou 0 se não existe.
    abrir(<nome do arquivo>, <modo>)
        Abre arquivo. Retorna 1 se conseguiu ou 0 se não conseguiu.
        Modo pode ser:
        0 = somente leitura
        1 = leitura e escrita
        2 = somente escrita; o tamanho do arquivo é truncado para 0 bytes
        3 = para escrever no final do arquivo
        Os modos 0 e 1 não criam um novo arquivo, caso ele não exista.
        Nota 1: Não acessa arquivos executáveis ou terminados em:
                .exe, .com, .bat, .pif, .scr ou .log
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível acessar arquivos de outros lugares.
    fechar
        Fecha o arquivo.
    truncar(<arquivo>, <tamanho>)
        Trunca o tamanho de um arquivo no tamanho especificado.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Exemplo: truncar("a.txt", 0) limpa o conteúdo do arquivo a.txt
    msg(<texto>)
        Escreve texto no arquivo.
        Se for especificado mais de um texto, serão concatenados no arquivo.
        Exemplo, escr("ab", "\n") é o mesmo que escr("ab\n")
    flush
        Grava em arquivo as alterações pendentes.
    ler
        Lê uma linha do arquivo; retorna a linha lida sem o \n no final.
        Pode ler menos se chegou no fim do arquivo.
    ler(<tamanho>)
        Lê um determinado número de caracteres do arquivo.
        Pode ler menos se chegou no fim do arquivo.
        Exemplo: ler(1) lê um caracter.
    pos
        Retorna a posição atual no arquivo (0=está no início do arquivo).
    pos(<posição>, <modo>)
        Muda a posição atual no arquivo. Modo pode ser:
        0 = a partir do início do arquivo
        1 = a partir da posição atual
        2 = a partir do fim do arquivo
    eof
        1 se chegou no fim do arquivo, 0 se não chegou.

inttempo <nomedavariável>
    Uma variável inteira de 0 a 1048575, subtraída 1 a cada décimo de segundo.
    A diferença de inttempo para intdec é que quando chega a 0, uma função
    do objeto é executada. O nome da função é <nomedavariável>_exec.
    Na função: arg0 = índice da variável vetor, se não for vetor arg0=0
    Nota: o valor 1048575 corresponde a 29 horas, 7 minutos e 37.5 segundos.
    inttempo aceita valores negativos, mas nesse caso a contagem fica parada.
    Possui as funções e variáveis:
    neg = Faz a variável ser menor que zero, multiplicando por -1 se necessário
    pos = Faz a variável ser maior que zero, multiplicando por -1 se necessário
    abs = Valor de inttempo sem o sinal

    Exemplo:
    classe x
    inttempo n
    func n_exec
      # Essa função é executada quando a variável n chegar a zero
    func s
    n = 20 # 20 segundos
    n.neg # Pára a contagem (n=-20)
    n.abs = 4 # n passa a ser -4
    n.pos # Volta a contar (n=4)
    teste = n.abs # Mesmo que teste=4

intexec <nomedavariável>
    Pode ser 0 ou 1, exatamente como int1.
    Assim que o controle retorna ao IntMUD, se essa variável for 1, ela muda
    para 0 e em seguida é executada uma função dessa variável. O nome da função
    é <nomedavariável>_exec.
    Se houver alguma alteração pendente no programa (vide variável prog) ou
    algum objeto a ser apagado, esses procedimentos serão executados antes
    da função de intexec.
    Qualquer outro evento também tem preferência em relação a intexec.
    Por exemplo, se houver dois eventos de inttempo, um de socket e um de
    intexec, mesmo os quatro ocorrendo simultaneamente, o evento de intexec
    será executado por último.

    Exemplo:
    telatxt = 1
    classe x
    intexec n # Para gerar evento
    prog p # Para alterar o programa
    func iniclasse # Classe x foi criada
    criar(arg0) # Cria objeto
    func ini # Objeto foi criado
    p.criar("x", "int8 y") # Cria variável y na classe x
    n = 1 # Gerar evento depois disso
    func n_exec # Essa função é executada depois da variável y ser criada
    telatxt t
    t.msg("Variável y é do tipo: " + p.vartipo("x", "y") + "\n")

telatxt <nome da variável>
    Semelhante a socket, mas trabalha com uma tela de texto, chamada console.
    Essa tela é semelhante ao "prompt de comando", no Windows, ou o próprio
    terminal, em Unix.

    Funções e variáveis:
    proto
        0 se a tela de texto não estiver aberta
        6 se estiver aberta
        O valor de proto depende da opção "telatxt" no arquivo intmud.cfg.
    posx
        Posição do cursor: quantos caracteres enviou após o último \n.
        Caracteres especiais, como definição da cor, não contam
    msg(<mensagem>)
        Envia mensagem para telatxt.
    tecla(<nome da tecla>)
        Processa uma tecla, como se tivesse sido digitada pelo usuário.
        Nota: não gera eventos.
    texto
        Conteúdo da linha sendo digitada pelo usuário. Pode ser mudado.
    total
        Tamanho da linha sendo editada, de 1 a 1023. Pode ser mudado.
    linha
        Linha em que o cursor está. 0 é a linha de edição, 1=última linha
        de texto, 2 = linha anterior, etc.
    bipe
        Gera um bipe.
    limpa
        Limpa a tela.

    Eventos:
    <nomedavariável>_msg
        Recebeu mensagem
        arg0 = mensagem recebida
        arg1 = índice da variável vetor, se não for vetor arg1=0
    <nomedavariável>_tecla
        Chamado sempre que o usuário pressionar uma tecla.
        arg0 = nome da tecla
        arg1 = índice da variável vetor, se não for vetor arg1=0
        Se retornar verdadeiro, significa que a função já processou a tecla.
        Portanto, não será processada pelo IntMUD.

    Nomes das teclas especiais:
    Teclas de função: F1 a F12
    Setas: UP DOWN LEFT RIGHT (nessa ordem: cima, baixo, esquerda, direita)
    Outras: INS DEL HOME END PGUP PGDN TAB ENTER ESC BACK
    Com SHIFT: S_F1 a S_F12 S_TAB S_ENTER
    Com CONTROL: C_INS C_DEL C_HOME C_END C_PGUP C_PGDN
    Setas com CONTROL: C_UP C_DOWN C_LEFT C_RIGHT
    Letras A-Z com CONTROL: C_A a C_Z
    Notas - em um terminal Unix ou Linux:
    1. Control+C encerra o programa (não gera evento _tecla)
    2. Control+Z coloca o programa em segundo plano (não gera evento _tecla)
    3. Control+I é a tacla TAB
    4. Control+M é a tecla ENTER

socket <nomedavariável>
    Representa uma conexão TCP/IP com outro programa.
    Como valor numérico, é 1 se proto!=0 (está conectado) ou 0 se proto=0.
    Nota: uma conexão pode ser copiada de um objeto socket para outro.
    Nesse caso, os eventos são gerados em mais de uma variável socket.

    Funções e variáveis:
    proto
        Define o protocolo; um número com o significado:
        0 = não está conectado
        1 = conectando
        2 = Telnet, só recebe mensagens completas
        3 = Telnet, pode receber mensagens incompletas (sem o \n no fim)
        4 = IRC
        5 = Papovox (sem cores)
        Nota: pode-se mudar entre 2 e 4 para socket conectado
    cores
        0 = nenhuma cor
        1 = cores somente ao receber
        2 = cores somente ao enviar
        3 = cores ao enviar e receber
    aflooder
        O anti flooder impede o recebimento de muitas mensagens ao mesmo tempo.
        0 desativa o anti flooder, outro valor ativa.
    eco
        Define se o que o usuário digitar deve ser ecoado na tela.
        0 não ecoa, 1 ecoa. Não tem efeito em IRC e Papovox.
    posx
        Posição do cursor: quantos caracteres enviou após o último \n.
        Caracteres especiais, como definição da cor, não contam.
    ip
        Endereço IP correspondente a quem está conectado.
    iplocal
        Endereço IP local.
    abrir(<endereço>, <porta>)
        Tenta conectar-se a um endereço.
        Após conectar, faz proto=3 e chama o evento _con (vide abaixo).
        Retorna 1 se conexão em progresso ou 0 se ocorreu erro
        (0 geralmente significa endereço inválido)
    fechar
        Encerra a conexão; não gera o evento fechou.
    msg(<mensagem>)
        Envia mensagem para o socket.
        Retorna 1 se conseguiu enviar ou 0 se buffer cheio.
        Nota: Se o protocolo for Papovox, devido às limitações do Papovox,
        é acrescentado \n no final da mensagem se já não houver um \n.

    Eventos:
    <nomedavariável>_msg
        Recebeu mensagem
        arg0 = mensagem recebida
        arg1 = 1 se mensagem completa, 0 se incompleta (sem o \n)
        arg2 = índice da variável vetor, se não for vetor arg2=0
    <nomedavariável>_env
        Todas as mensagens foram transmitidas (buffer de transmissão
        ficou vazio).
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_fechou
        O socket foi fechado remotamente
        arg0 = motivo (texto)
        arg1 = índice da variável vetor, se não for vetor arg1=0
        Se essa função não existir, o objeto que contém o socket é apagado
    <nomedavariável>_con
        Conseguiu conectar
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_err
        Não conseguiu conectar
        arg0 = mensagem de erro
        arg1 = índice da variável vetor, se não for vetor arg1=0

serv <nomedavariável>
    Funções:
    abrir(endereço, porta)
        Abrir para receber conexões
        Se não quiser especificar um endereço, colocar "" no endereço
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu
    fechar
        Deixa de receber conexões

    Eventos:
    <nomedavariável>_socket
        arg0 = socket correspondente à conexão (com proto=2)
        arg1 = índice da variável vetor, se não for vetor arg1=0

    Exemplo de uso com socket:
    classe x
    comum serv servidor
    socket conec
    func iniclasse
      x:servidor.abrir("", 2000)
    func servidor_socket
      ref novo
      novo = criar("x")
      novo.conec = arg0
      novo.conec.msg("Benvindo\n")
    func conec_msg
      conec.msg("você escreveu " + arg1 + "\n")

prog <nomedavariável>
    Para ler e alterar o próprio programa.
    Nota: pode ser usado um objeto no lugar do nome de uma classe.

    As próximas funções iniciam uma consulta e retornam 1 se há algum
    resultado (pelo menos uma linha) para a consulta ou 0 se não há.
    iniclasse
    iniclasse(<texto>)
        Obter os nomes das classes que começam com o texto especificado.
        Em ordem alfabética.
    inifunc(<nome da classe>)
    inifunc(<nome da classe>, <texto>)
        Obter os nomes das funções e variáveis definidas em uma classe.
        Somente as variáveis e funções que começam com o texto especificado.
        Em ordem alfabética.
    inifunctudo(<nome da classe>)
    inifunctudo(<nome da classe>, <texto>)
        Mesmo que inifunc, mas inclui também as variáveis e funções herdadas.
    iniherda(<nome da classe>)
        Obter os nomes das classes definidas na instrução "herda".
        Na ordem definida na classe.
    iniherdatudo(<nome da classe>)
        Obter a lista de classes herdadas por uma classe.
        Inclui também as classes herdadas indiretamente.
        Na ordem em que as classes são herdadas.
    iniherdainv(<nome da classe>)
        Herança inversa: obter os nomes das classes que herdam uma classe.
        A ordem em que as classes são listadas é imprevisível.
    inilinha(<nome da classe>)
        Obter as linhas correspondentes a uma classe.
    inilinha(<nome da classe>, <nome da função>)
        Obter as linhas correspondentes a uma variável ou função da classe
        (definida na classe ou herdada).

    As próximas funções permitem ler o resultado da consulta.
    lin
        É 1 se linha válida ou 0 se chegou no fim da consulta.
    depois
        Vai para a próxima linha.
    depois(<número de linhas>)
        Avança o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    texto
        Retorna o texto da linha atual.
    nivel
        Retorna um número, que é o nível de indentação. Usado somente com
        inilinha.

    As próximas funções funcionam independente das demais.
    existe(<nome da classe>)
        Retorna 1 se a classe existe ou 0 se não existe.
    existe(<nome da classe>, <nome da variável>)
        Retorna 0 se a variável ou função não existe, 1 se estiver
        definido na própria classe ou 2 se foi herdada.
    arquivo(<nome da classe>)
        Retorna o sufixo do nome do arquivo que contém a classe.
        Exemplo, "abc" corresponde ao arquivo "intmud-abc.int".
        Um texto vazio significa arquivo "intmud.int".
    vartipo(<nome da classe>, <nome da variável>)
        Retorna o tipo de variável ou "" se a variável não existe.
    varnum(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante numérica do tipo:
        const variável = valor numérico
        ou 0 se não for.
    vartexto(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante de texto do tipo:
        const variável = "texto"
        ou 0 se não for.
    varcomum(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for comum ou 0 se não for.
    varsav(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for sav ou 0 se não for.
    varvetor(<nome da classe>, <nome da variável>)
        Retorna a quantidade de variáveis do vetor ou 0 se não for vetor.
    const(<nome da classe>, <nome da variável>)
        Retorna o texto de uma variável constante do tipo:
        const variável = valor    (nesse caso retorna valor)
        const variável = "texto"  (nesse caso retorna texto)
        Retorna um texto vazio para outros tipos de variáveis.

    As próximas funções permitem alterar o programa. Porém, as alterações
    só serão efetuadas quando o controle retornar ao IntMUD.
    apagar(<classe>)
    apagar(<classe>, <variável>)
        Apaga classe ou variável.
        Retorna: 1=sucesso, 0=falha (classe ou variável não existe)
    criar(<texto>)
        Cria uma classe. Se já existia, altera ao invés de criar.
        A primeira linha é o nome da classe.
        A segunda linha de <texto> é o sufixo do nome do arquivo.
            Exemplo, "abc" corresponde ao arquivo "intmud-abc.int".
            Um texto vazio corresponde ao arquivo "intmud.int".
        Da terceira linha em diante são as instruções (o contéudo da classe).
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplo:
            prog p
            p.criar("abc\n\nint8 x\nconst n = 10")
        Cria a seguinte classe no arquivo intmud.int:
            classe abc
            int8 x
            const n = 10
        Para criar a mesma classe, mas no arquivo intmud-x.int:
            p.criar("abc\nx\nint8 x\nconst n = 10")
    criar(<nome da classe>, <texto>)
        Cria uma função ou variável de uma classe.
        Se já existia, antes apaga a função ou variável.
        <texto> contém todas as instruções da função ou variável.
        Se houver mais de uma linha, usar \n para separar as linhas.
        A primeira linha deve conter o nome e o tipo.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplos:
            prog p
            p.criar("abc", "int8 n") # Cria a variável n na classe abc
            p.criar("xyz", "func x\nret 10") # cria a função x na classe xyz
    apagarlin(<nome da classe>, <número da linha>)
    apagarlin(<nome da classe>, <nome da variável>, <número da linha>)
        Apaga uma linha de uma classe ou variável.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    criarlin(<nome da classe>, <linha inicial>, <texto>)
    criarlin(<nome da classe>, <nome da variável>, <linha inicial>, <texto>)
        Adiciona linhas na classe ou função especificada.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    salvar
    salvar(<texto>)
        Salva as alterações nos arquivos correspondentes, depois que todas
        as alterações pendentes nas classes forem efetuadas.
        O texto é composto de letras seguidas de números, que indicam como
        o arquivo deve ser salvo. As opções são as seguintes:
        L = quantidade máxima de caracteres por linha, de 70 a 4000
        N = se deve dividir linhas grandes (conforme opção L) em caracteres \n
            0=não divide, 1=somente em const contendo apenas texto, 2=sempre
        I = espaços usados para indentação, de 0 a 8
        C = linhas entre classes, de 0 a 10
        F = linhas vazias entre funções, de 0 a 10
        V = linhas vazias entre variáveis e constantes, de 0 a 10
        A função salvar sem parâmetros é o mesmo que:
        salvar("L4000N0I2C1F1V0")
        Significa não dividir linhas, 2 espaços para indentação,
        1 linha vazia entre classes e entre funções e nenhuma linha vazia
        entre variáveis.
    salvartudo
    salvartudo(<texto>)
        Mesmo que a função salvar, porém salva todos os arquivos,
        independete de terem sido alterados ou não.

debug <nomedavariável>
    Para auxiliar a detectar erros no programa.

    Variável:
    exec
        Contador de instruções - opção "exec" no início do arquivo int.
        A cada instrução executada essa variável é subtraída de 1.
        Quando chega a 0, o controle retorna automaticamente ao IntMUD.

    Funções:
    ini
        Inicializa exec com o valor definido na opção "exec" no início
        do arquivo int.
    cmd(<texto>)
    cmd(<objeto>, <texto>)
        Executa a instrução que está no texto especificado.
        Se for mais de uma instrução, separar com "\n".
        Retorna mensagem de erro se instrução não for válida.
        Nota 1: instruções ret no texto retornam para o cmd (vide abaixo).
        Nota 2: variáveis criadas no cmd só existem dentro do cmd.
        Exemplos:
        debug d
        d.cmd("x = 10")
        d.cmd("x=x+1\nteste(\"x=\"+x+\"\\n\")")
        d.cmd("ret \"teste\"") # d.cmd retorna "teste"
        d.cmd("int8 x\nx=1+2\nret x") # d.cmd retorna 3
    passo(<objeto>, <texto>)
    passo()
        Antes de executar cada instrução chama a função de <objeto>
        com o nome especificado em <texto>. Se a função não existir, passa
        a executar instruções sem chamar nenhuma função.
        Na função:
        arg0=objeto "este"
        arg1=texto contendo a instrução que será executada executada
    func
        Retorna o nível de funções: quantas funções foram chamadas até chegar
        na instrução atual. Exemplo:
        classe x
        func iniclasse
          # Aqui debug.func será 0 quando a classe for criada
          x:teste
        func teste
          # Aqui debug.func será 1 porque foi chamado por x:iniclasse
    tempo
        Quanto tempo o programa usou do processador, em milésimos de segundos.
        Se não for possível obter essa informação, tempo será -1.

indiceobj <nomedavariável>
    É semelhante a uma variável txt64, porém o texto é associado ao objeto
    que contém essa variável. O processo inverso, obter um objeto a partir
    de um texto, é possível com a variável indiceitem.

indiceitem <nomedavariável>
    Permite obter os objetos que contém uma variável indiceobj com um
    determinado texto. Ignora variáveis indiceobj com texto nulo.

    Funções:
    ini(<texto>)
        Vai para o primeiro objeto com o texto ou parte dele.
    fim(<texto>)
        Vai para o último objeto com o texto ou parte dele.
    antes
        Passa para o objeto anterior.
    antes(<número de objetos>)
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois(<número de objetos>)
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    obj
        Objeto.
    txt
        Texto associado ao objeto.
    obj(<texto>)
        Objeto que contém o texto exato.
        Essa função funciona independente das demais.

    Nota: Pode-se passar mais de um texto para as funções que possuem texto.
    Nesse caso, a função procurará por todos os textos.

datahora <nomedavariável>
    Operações envolvendo data e/ou hora, como obter a data atual e calcular
    quantidade de dias entre duas datas.

    Funções:
    novadata(<ano>, <mês>, <dia>)
        Muda ano, mês e dia.
    novahora(<hora>, <minuto>, <segundo>)
        Muda hora, minuto e segundo.
    antes
        Muda data para o dia anterior.
    depois
        Muda data para o próximo dia.
    agora
        Muda para data e hora atuais.
    diasem
        Dia da semana, de 0 a 6 (0=domingo).
    bissexto
        É 1 se o ano for bissexto, 0 se não for.

    Variáveis:
    ano
        Ano, de 1 a 9999.
    mes
        Mês, de 1 a 12.
    dia
        Dia, de 1 a 31. Conforme o mês pode não chegar a 31.
    hora
        Hora, de 0 a 23.
    min
        Minuto, de 0 a 59.
    seg
        Segundo, de 0 a 59.
    numdias
        Número de dias desde 1/1/1.
    numseg
        Número de segundos desde o início do dia.
    numtotal
        Número de segundos desde 1/1/1.
