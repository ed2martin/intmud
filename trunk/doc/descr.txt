Especificações - IntMUD (Interpretador MUD)

O programa é um interpretador de comandos que trabalha com um ou mais
arquivos cujos nomes terminam com ".int". São arquivos de texto que contém
os comandos (o programa interpretado) executados pelo IntMUD.

Via de regra, o arquivo principal chama-se "intmud.int". Mas pode-se usar
outro arquivo, bastando executar o IntMUD seguido do nome. Exemplo:
intmud teste.int
ou apenas:
intmud teste
Em ambiente gráfico, pode-se arrastar o arquivo .int para o executável com
o botão esquerdo do mouse.

O arquivo intmud.int começa com algumas definições no seguinte padrão:
opção = valor

As opções são as seguintes:

mapagrande = 0
Se diferente de zero, o programa interpretado está distribuído em mais
de um arquivo. Nesse caso, os nomes dos demais arquivos sempre começam
com "intmud-" e terminam com ".int".
Exemplo: intmud-teste.int
Se ausente, assume 0 (somente um arquivo ".int").

exec = 5000
Quantas instruções uma função chamada pelo programa pode executar antes
do controle retornar automaticamente ao programa.
Se ausente, assume 5000.

telatxt = 0
Se zero, o programa roda em segundo plano. Não abre nenhuma janela.
Se diferente de zero, abre uma janela de texto. Nesse caso, a comunicação
com o usuário se dá através da variável telatxt no programa interpretado.
Em Unix ou Linux, se diferente de zero, executar o programa em um terminal.
Se ausente, assume 0.

log = 0
Aonde apresentar as mensagens de erro, caso tenha erro no programa.
0 = na tela (no Windows é aberta uma janela)
1 = em arquivo .log
Se ausente, assume 0.

Após as opções vem as definições de classes (tipos de objetos), que constituem
o programa interpretado. Segue a sintaxe:

classe nome da classe
herda <classe 1>, <classe 2>, ..., <classe N>
variáveis e constantes do objeto
funções (func) e constantes (const) do objeto

Nomes de classes podem ser compostos dos caracteres de A a Z, c cedilha,
dígitos de 0 a 9, e arroba. Podem conter espaços, mas eles são tratados como
se fossem o caracter "_" no restante do programa.

Nomes de funções, variáveis e constantes seguem o mesmo padrão, mas não podem
começar com um dígito de 0 a 9.

Cada função:

func <nome da função>
variáveis da função
instruções da função

Tudo o que estiver abaixo da linha func <nome da função> pertence à função,
até a definição da próxima função ou constante.

As variáveis são definidas com:
<tipo da variável>  <nome da variável>
Exemplos:
int8 v1
txt50 v2

Basicamente o programa lida com quatro tipos de variáveis:
- Numérico, como: 0, -5, 4.3
- Texto, como: "bom dia"
- Referência a um objeto, como a palavra este, que se refere ao objeto atual
- Nulo, que corresponde a um valor nulo.
Os tipos de variáveis serão vistos adiante.

Tipos constantes são definidos com:
const  <nome>  =  <valor>
Exemplos:
const x = "teste"
const y = 10

A linha "herda", se estiver presente, significa herança.
A classe contém também as variáveis e funções das classes especificadas.
Herda também as classes herdadas por essas. Exemplo:
classe A
herda B
int8 dia
classe B
herda C
int8 mes
classe C
int8 ano

A classe C contém a variável ano. A classe B contém as variáveis ano e mes.
A classe A contém mes, dia e ano. Está herdando C através de B.

Quando houver um nome de variável ou função repetido na herança, prevalece
a primeira encontrada. As demais são ignoradas. Exemplo:
classe A
herda B
int8 x
classe B
txt10 x
Nesse caso a classe A tem a variável "int8 x", mas não contém a variável
"txt10 x".

Uma função pode conter os seguintes tipos de instrução:
1. Atribuir um valor ou expressão numérica a uma variável, ex:
x = 10
y = x + abs(z) * 3

2. Executar uma função, sem atribuir o resultado a nenhuma variável, ex:
x("teste")

3. Uma instrução de controle de fluxo do programa: se, fimse, enquanto, etc.
Exemplo:
se x=10
...
fimse

4. Comentários: linhas que começam com # seguido ou não de um texto.
São ignorados pelo programa. Exemplo:
# teste

As linhas de instruções são interpretadas da esquerda para a direita,
verificando:
1. Operadores, como + - * / = < > | &
2. Números: começam com um dígito de 0 a 9 e podem ter sinal de menos na frente
3. Textos: começam e terminam com aspas dupla (").
   Apenas aspas dupla dentro do texto deve ser escrito assim: \"
4. Variáveis e funções: começam com uma letra ou colchetes ([).

O programa interpreta variáveis e funções da seguinte forma:
A. Se houver um ponto separando duas palavras, liga a segunda ao retorno da
   primeira. Exemplo, a palavra este corresponde ao objeto atual.
   este.abs deve corresponder à função ou variável abs do objeto.
B. Se houver colchetes, interpreta o que estiver entre colchetes como uma
   expressão numérica. O resultado disso fará parte do nome da variável ou
   função. Exemplo:
   x["1"] = 10
   y = "_teste"
   x[y] = 20
        É equivalente a:
   x1 = 10
   x_teste = 20

O programa processa variáveis e funções da seguinte forma:
A. Se houver dois pontos, executa a função (depois dos dois pontos)
   da classe especificada (antes dos dois pontos), como se pertencesse ao
   objeto atual. Exemplo:
   item:luminosidade(10)
   Executa função luminosidade da classe item, como se essa função
   pertencesse ao objeto "este".
B. Verifica se é uma função nativa do programa (exemplo: abs).
C. Verifica se é uma variável da função que está sendo executada.
D. Verifica se é uma variável ou função do objeto.
E. Se não existe, interpreta com se fosse uma variável de valor NULO.


*** Variáveis básicas

As variáveis definidas antes das funções pertencem ao objeto.
As que forem definidas em uma função pertencem à ela. São criadas
quando a função é chamada e deixam de existir quando a função termina.

int1 <nomedavariável>
    Pode ser 0 ou 1
int8 <nomedavariável>
    Número inteiro de -128 a 127
int16 <nomedavariável>
    Número inteiro de -32768 a 32767
int32 <nomedavariável>
    Número inteiro de -2147483648 a 2147483647
uint8 <nomedavariável>
    Número inteiro de 0 a 255
uint16 <nomedavariável>
    Número inteiro de 0 a 65535
uint32 <nomedavariável>
    Número inteiro de 0 a 4294967295
intinc <nomedavariável>
    Número inteiro de 0 a 1048575, que é somado 1 a cada décimo de segundo,
    até chegar a 1048575 (29 horas, 7 minutos e 37.5 segundos).
intdec <nomedavariável>
    Número inteiro de 0 a 1048575, que é subtraido 1 a cada décimo
    de segundo, até chegar a 0.
real
    Corresponde ao tipo "double" em C++
txt1 a txt512 seguido do nome da variável:
    Define uma variável que contém um texto, de até 1 a 512 caracteres,
    respectivamente. Exemplo:
    Para criar uma variável: vartxt10 x
    Para colocar um texto nessa variável: x = "bom dia"
ref <nomedavariável>
    Referência para um objeto; corresponde a um objeto qualquer.
    A palavra "nulo" é usada para indicar que a referência
    não corresponde a nenhum objeto. Quando o objeto é apagado,
    automaticamente a referência passa a ser "nulo".
    Exemplo:
    ref ref1
    # Cria objeto
    ref1 = criar("teste")
    # Muda variável x do objeto
    ref1.x = 2
    # Faz a referência não corresponder a nenhum objeto
    # mas não apaga o objeto criado
    ref1 = nulo

Antes dos tipos das variáveis é permitido colocar as seguintes palavras:

comum
    Variável é a mesma para todos os objetos da classe.
    Independente da quantidade de objetos, só existe uma variável.
sav
    Variável deve ser salva em arquivo, vide arqsav.


*** Vetores

São conjuntos de variáveis do mesmo tipo.
Define-se um vetor acrescentando-se após o nome da variável um ponto
e a quantidade de variáveis, de 1 a 255.
Exemplo:
int8 teste.3

Nesse caso existem 3 variáveis:
teste.0
teste.1
teste.2

Exemplo de como tratar eventos de um vetor:
classe x
inttempo n.5
func n_exec # Evento para as 5 variáveis "n"
# Aqui arg0 é o índice da variável no vetor (de 0 a 4)
# n.[arg0] corresponde à variável que gerou o evento

Nota: Funções e constantes não podem ser definidos como vetor.


*** Funções

Funções podem ser chamadas de duas formas, em relação aos argumentos:
1. Sem argumentos
<nomedafunção>

2. Com um ou mais argumentos
<nomedafunção> ( argumento 1, argumento 2, ..., argumento N )

Exemplos:
teste
teste("bom dia", 10)

Quando a função é chamada, as variáveis definidas na função são criadas.
Deixam de existir quando retorna (termina).
Dentro da função, as seguintes palavras tem um significado próprio:
args = número de argumentos
arg0 a arg9 = argumentos passados para a função
este = objeto ao qual a função pertence

Os argumentos são passados por referência: alterar arg0 a arg9 dentro
da função altera a variável que foi passada.

Para retornar um valor, a instrução é:
ret <valor de retorno>
Exemplos:
ret 10
ret arg0+1

Se não for especificado o valor de retorno, ret retorna nulo.
Após a última linha da função é como se tivesse uma instrução ret nulo.

Exemplo - dada uma função x, definida como:
func x
ret arg0+1
O retorno pode ser usado da seguinte forma:
y = x(10)
z = x(2) - x(1)
Nesse exemplo, fará y=11 e z=1.

Outros exemplos:
classe abc
int1 x
int8 y
func teste1
  ret "bom dia"
func teste2
  ret x + y
func teste3
  y = arg0 + arg1
func fatorial
  se args!=1 | arg0<=1
    ret 1
  fimse
  ret arg0 * fatorial(arg0-1)

Internamente constantes se comportam como funções. Exemplo:
func x
  ret arg0 * 10
Pode ser escrito também como:
const x = arg0 * 10

Existe um outro tipo de função, que se comporta como se fosse uma variável.
É definida com varfunc ao invés de func.
Quando for feita uma leitura a variável, ao invés disso a função é chamada
com nenhum argumento, e deve retornar o valor lido.
Alterar a variável chama a função com um argumento (o novo valor).
O valor de retorno da função é ignorado.

Exemplo:
varfunc x
  se args=0
# Leitura da variável: retorna "bom dia"
    ret "bom dia"
  fimse
# Mudar a variável: chama outra função
  este.msg(arg0)
func teste
  vartxt10 n
# Vai fazer: n = "bom dia"
  n = x
# Vai fazer: este.msg("teste")
  x = "teste"


*** Operadores

Podem ser usados os seguintes operadores - sendo a e b duas variáveis
e/ou números:

!a      Se for falso (=0) vira verdadeiro (1)
        Se for verdadeiro (diferente de 0) vira falso (0)
a*b     Multimplica a por b
a/b     Divide: a/b; pode resultar em um número quebrado (não inteiro)
a%b     É o resto da divisão de a por b
a+b     Soma
a-b     Subtrai
a<b     Verdadeiro (=1) se a<b; Falso (=0) se a>=b
a<=b    Verdadeiro se a<=b
a=b     Verdadeiro se a for igual a b
a==b    Verdadeiro se a for exatamente igual a b
        Em textos: diferencia letras minúsculas de letras maiúsculas
a>=b    Verdadeiro se a>=b
a>b     Verdadeiro se a>b
a!=b    Verdadeiro se a for diferente de b
a&b     Verdadeiro (=1) somente se a for verdadeiro e b também for
a|b     Verdadeiro (=1) se a for verdadeiro ou b for verdadeiro
Pode-se usar também os parênteses em expressões
Exemplo:  2*(3+4)

Os operadores +=, -=, *= e /= são formas compactas:
variável += valor
variável -= valor
variável *= valor
variável /= valor

São o mesmo que:
variável = variável + valor
variável = variável - valor
variável = variável * valor
variável = variável / valor


*** Caracteres especiais em textos

\n significa fim de uma linha de texto (deve passar para a próxima linha).

Para conseguir cores usa-se os caracteres \b, \c e \d nas mensagens:
    \b define cor dos caracteres: branco com fundo preto
    \c seguido de um dígito: define a cor dos caracteres
    \d seguido de um dígito: define a cor de fundo

O dígito após \c e \d pode ser:
    0 = preto           4 = azul
    1 = vermelho        5 = magenta
    2 = verde           6 = ciano
    3 = marrom          7 = branco

Somente após \c:
    8 = cinza               C = azul intenso
    9 = vermelho intenso    D = magenta intenso
    A = verde intenso       E = ciano intenso
    B = amarelo             F = branco intenso


*** Instruções de controle de fluxo - não podem ser usadas em cálculos

se <expressão>  ... fimse
se <expressão>  ... senão ... fimse
se <expressão>  ... senão <expressão>  ... fimse
    Decisão

enquanto <expressão>  ... efim
    Laço de repetição
    Se a expressão for verdadeira, executa as instruções que estiverem entre
    o enquanto e o efim e volta para a instrução enquanto, para testar
    a <expressão> novamente.

sair
    Sai de um laço enquanto.

continuar
    Fecha um ciclo de um laço enquanto, como se tivesse chegado na instrução
    efim. A diferença entre continuar e efim é que efim define aonde termina
    o laço.

terminar
    Encerra o programa


*** Funções chamadas pelo programa

ini
    Executada quando o objeto é criado
fim
    Executada quando o objeto é apagado
iniclasse
    Executada quando a classe é criada
    Recebe um argumento (arg0), que é o nome da classe

Outras funções podem ser chamadas, por variáveis específicas, que constituem
uma extensão do programa.


*** Funções predefinidas

intpos(a)
    Retorna a se a>=0. Caso contrário retorna 0.

intabs(a)
    O mesmo que a sem sinal.
    Exemplo: abs(-1) e abs(1) são iguais a 1

int(a)
    O valor inteiro de a.

rand(a)
    Um número aleatório, inteiro, de 0 a a-1. Exemplo, rand(10) gera
    um número aleatório de 0 a 9.

ref(a)
    Referência constante; retorna o mesmo objeto que a.
    Se a não for um objeto, retorna nulo.
    Se for fornecido mais de uma referência (exemplo: ref(a,b,c)),
    retorna a primeira que não for nula.

txtnum(<número>, <formato>)
    Retorna um texto correspondente a um número ou variável numérica.
    Formato é um texto que pode conter:
    Um dígito de 0 a 9 = número de casas após a vírgula
    Uma vírgula: separar o número com vírgulas
    Um ponto: separar número com pontos, o ponto decimal vira vírgula
    Letra E: mostrar em notação científica; as opções anteriores são ignoradas
    Exemplo:
    txtnum(1005.23, "3.") é o mesmo que "1.005,230"
    Nota: números muito grandes (mais de 18 dígitos antes da vírgula)
    são mostrados em notação científica.
    Exemplo: 5.9E+18 significa 59 seguido de 17 zeros.

txt(<texto>)
    Texto constante (não pode ser alterado) igual a <texto>.
    Se <texto> não for um texto, retorna um texto vazio.
    Se for objeto, retorna o nome da classe.

txt(<texto>, <caracter inicial>)
txt(<texto>, <caracter inicial>, <quantidade de caracteres>)
    Retorna um texto que é parte do texto especificado. Exemplo:
    txt("abcdef", 2, 2) é o mesmo que "cd".

txt1(<texto>)
    Retorna a primeira palavra do texto.

txt2(<texto>)
    Retorna tudo exceto a primeira palavra do texto.

txtcor(<texto>)
    Retorna o texto sem as definições de cores. Exemplo:
    txtcor("\cF\d4Teste\b") é o mesmo que "Teste".

txtmai(<texto>)
    Retorna o texto em letras maiúsculas.

txtmin(<texto>)
    Retorna o texto em letras minúsculas.

txtmaiini(<texto>)
    Retorna o texto passando a primeira letra para maiúscula.
    Se encontrar algum ponto, a próxima letra também será maiúscula.

txtmaimin(<texto>)
    Retorna o texto com a primeira letra maiúscula e as demais minúsculas.
    Se encontrar um ponto, a próxima letra será maiúscula.

txtfiltro(<texto>)
    Filtra mensagens. Retorna o texto filtrado.

txtesp(<quantidade de espaços>)
    Retorna um texto que é a quantidade de espaços requisitada.
    O texto retornado tem de 0 a 100 caracteres.

txtshs(<texto>)
    Calcula e retorna o SHS de um texto.
    O texto original é codificado de modo que não é possível decodificar.
    O resultado do SHS é compactado em um texto de 27 caracteres contendo
    letras maiúsculas e alguns símbolos.

txtnome(<texto>)
    Codifica apelido para comparação.
    Retorna o mesmo texto para dois apelidos parecidos.
    Nota: o texto retornado nunca é maior que o apelido.

intnome(<texto>)
    Verifica se texto é válido para apelido. Retorna:
    0 = apelido válido
    1 = muito pequeno (menos de 2 caracteres)
    2 = contém caracteres inválidos

intsenha(<texto>)
    Verifica se texto é válido para senha. Retorna:
    0 = senha válida
    1 = muito pequena (menos de 5 caracteres)
    2 = contém caracteres inválidos
    3 = contém só letras ou só números

txtcod(<texto>)
    Codifica um texto de modo que possa ser usado como nome de variável.
    Caracteres válidos em nomes de variáveis não são alterados, com exceção
    do espaço, que muda para '_'.

    Os caracteres modificados são:
    @ /b /c /d /n  mudam para  @@ @b @c @d @n
    " ! # $ %  mudam para  @a @e @f @g @h
    & ' ( ) *  mudam para  @i @j @k @l @m
    + , - . /  mudam para  @o @p @q @r @s
    : ; < = >  mudam para  @t @u @v @w @x
    ? [ \ ] ^  mudam para  @y @z @0 @1 @2
    ` { | } ~  mudam para  @3 @4 @5 @6 @7

    Vide exemplo em txtdec (abaixo).

txtdec(<texto>)
    Decodifica um texto. Processo inverso de txtcod.

    Exemplo de como testar txtcod e txtdec:
    telatxt = 1
    classe tela
    telatxt tela
    func iniclasse
      criar(arg0)
    func tela_msg
      tela.msg("txtcod = \"" + txtcod(arg0) + "\"\n")
      tela.msg("txtdec = \"" + txtdec(txtcod(arg0)) + "\"\n")

txtvis(<texto>)
    Torna visíveis caracteres especiais, como \n e \b.
    "\b\c\d\n"   mudam para  "\\b\\c\\d\\n"
    "\"" muda para "\\\""
    "\\" muda para "\\\\"
    Exemplo 1:
    txtvis("\C1 \"Bom dia\" \B") é o mesmo que "\\C1 \\\"Bom dia\\\" \\B".
    Exemplo 2:
    txt10 x
    x = "\b\""
    msg("A variável x contém \"" + txtvis(x) + "\"\n")

txtinvis(<texto>)
    Processo inverso da função txtvis.

txtremove(<texto1>, <texto2>)
    Retorna um texto semelhante a <texto1>, mas removendo espaços e/ou
    cores, conforme <texto2>. As letras interpretadas em <texto2> são:
    E = remover espaços à esquerda.
    M = remover espaços extras, exceto à esquerda e à direita.
    D = remover espaços à direita.
    C = remover cores (tem o mesmo efeito da função txtcor).
    S = remover aspas simples trocando espaços entre duas aspas por sublinhado.
    A = remover aspas duplas trocando espaços entre duas aspas por sublinhado.
    7 = usar letras sem acentuação (caracteres em 7 bits).
        Exemplo, "ã É ì" vira "a E i".
    Exemplos:
    txtremove("  bom  dia  ", "EMD") é o mesmo que "bom dia"
    txtremove("  bom  dia  ", "ED") é o mesmo que "bom  dia"
    txtremove("\cF\d4Teste\b", "C") é o mesmo que "Teste"
    txtremove("tenha um 'bom dia' !", "S") é o mesmo que "tenha um bom_dia !"

txtproc(<texto>, <texto procurado>)
txtproc(<texto>, <texto procurado>, <caracter inicial>)
    Procura <texto procurado> em <texto>
    Retorna -1 se não encontrou ou o número do caracter se encontrou
    <caracter inicial> = a partir de onde procurar no texto
            0 = primeiro caracter, 1 = segundo, etc.
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever txtprocdif ao invés de txtproc.

txttroca(<texto>, <valor anterior>, <novo valor>)
    Troca <valor anterior> por <novo valor> no <texto>.
    Retorna o texto modificado ao invés de alterar o texto original.
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever txttrocadif ao invés de txttroca.
    Nota: Se <valor anterior> for um texto vazio, retorna <texto>.
    Exemplo:
    txttroca("possibilidade", "i", "e") é o mesmo que "possebeledade".

vartroca(<texto>, <texto2>, <variável>)
    Procura nomes de variáveis do objeto "este" que começam com <variável>.
    Troca <variável> por <texto2> e procura por isso em <texto>.
    Substitui pelos respectivos valores das variáveis.
    Exemplo:
      const t_1 = "joão"  # $1 = joão
      const t_2 = "maria" # $2 = maria
      vartroca("$1 falou com $2", "$", "t_")
                  # Produz o texto "joão falou com maria"
    Quando vartroca chama uma função, coloca em arg0 o texto encontrado.
    Exemplo de como diferenciar letras maiúsculas de minúsculas:
      func teste_a
        se arg0 == "A" # Se for exatamente igual
          ret "A maiúsculo"
        senão
          ret "A minúsculo"
      vartroca("$A $a", "$", "teste_")
                  # Produz o texto "A maiúsculo A minúsculo"
    Outra forma de escrever:
      const teste_a = t_a[arg0=="A"]
      const t_a0 = "A maiúsculo"
      const t_a1 = "A minúsculo"
      vartroca("$A $a", "$", "teste_")

criar(<nome da classe>)
criar(<nome da classe>, <argumentos da função ini>)
    Cria um objeto e chama a função ini do objeto.
    Entrada: texto que contém o nome da classe.
    Retorna: uma referência para o objeto, ou nulo se classe não existe.
    Exemplos:
    ref x
    x = criar("teste1")
    criar("teste2")

apagar(<objeto>)
    Marca um objeto para ser apagado. O objeto só será realmente apagado
    após o controle retornar ao programa. Mesmo assim, antes de apagar
    ainda será chamada a função fim do objeto.
    Entrada: referência para o objeto.
    Exemplo:
    apagar(este)

$ seguido do nome da classe
    Retorna o primeiro objeto da classe especificada.
    Exemplos: $jog  ou  $["jog"]

objantes(<objeto>)
    Retorna o objeto anterior da classe ou NULO se não houver.

objdepois(<objeto>)
    Retorna o próximo objeto da classe ou NULO se não houver.

inttotal(<variável>)
    Se for objeto, retorna a quantidade de objetos da classe.
    Se for texto, retorna o tamanho do texto em caracteres.
    Se for vetor, retorna a quantidade de variáveis do vetor.
    Se for fornecido mais de um argumento, é retornada a soma.
    Exemplo: inttotal(a,b)
    É o mesmo que: inttotal(a) + inttotal(b)


*** Funções existentes em vetores de variáveis txt1 a txt512

limpar
    Limpa todas as variáveis do vetor (faz todas as variáveis = "").
    Exemplo:
    txt10 x.3
    x.limpar
    É o mesmo que:
    txt10 x.3
    x.0 = ""
    x.1 = ""
    x.2 = ""

texto
texto(<número da primeira variável>)
texto(<número da primeira variável>, <número da última variável>)
    Retorna um texto que corresponde a todas as variáveis concatenadas
    Exemplo:
    txt10 x.3
    x.0 = "a"
    x.1 = "b"
    x.2 = "c"
    msg(x.texto) # É o mesmo que msg("abc")
    msg(x.texto(0,1)) # É o mesmo que msg("ab")

palavras(<texto>)
palavras(<texto>, <número de palavras>)
    Divide o texto em palavras.
    As palavras são separadas por espaço ou "\n".
    Retorna o número de palavras (pode ser zero).
    Exemplo:
    txt10 x.2
    x.palavras("bom dia !")
    É o mesmo que:
    txt10 x.2
    x.0 = "bom"
    x.1 = "dia !"

linhas(<texto>)
linhas(<texto>, <número de colunas>)
    Preenche as variáveis do vetor com o texto, da seguinte forma:
    Cada variável recebe uma linha do texto (o caracter "\n" indica
    o fim de uma linha).
    Linhas que não cabem em uma variável são divididas automaticamente,
    de preferência no último espaço entre <número de colunas> e o tamanho
    da variável.
    Retorna o número de linhas (pelo menos uma linha).

separar(<texto>, <delimitador>)
separar(<texto>, <delimitador>, <número de textos>)
    Divide o texto com o delimitador especificado.
    Cada variável do vetor recebe um texto.
    A última variável recebe o restante do texto.
    Retorna o número de variáveis (pelo menos uma variável).
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever separardif ao invés de separar.
    Exemplo:
    txt10 x.4
    x.separar("abc:10::def:20", ":")
    É o mesmo que:
    txt10 x.4
    x.0 = "abc"
    x.1 = "10"
    x.2 = ""
    x.3 = "def:20"

juntar(<delimitador>)
juntar(<delimitador>, <número de variáveis>)
    Concatena o número de variáveis do vetor especificadas, acrescentando
    o delimitador entre duas variáveis. Retorna o texto obtido.
    Exemplo:
    x.juntar(",", 3) é o mesmo que:
    x.0 + "," + x.1 + "," + x.2


*** Outros tipos de variáveis

Constituem uma extensão do programa interpretador. Algumas permitem
a comunicação com o mundo externo, outras possibilitam mais recursos.

Possuem funções/variáveis e podem gerar eventos (executar funções
do objeto em que pertencem).

Definição de um tipo:
<tipo de variável>  <nome da variável>
Exemplo:  listaobj x

Executar uma função:
<nome da variável>.<função>
Exemplos:
x.limpar
x.addini(este)

Eventos (funções chamadas pela variável):
func <nome da variável>_<nome do evento>
Exemplo, uma função teste para a variável x, acima, pode ser definida como:
func x_teste


*** Lista de variáveis

listaobj <nomedavariável>
    Lista de objetos.
    Um objeto pode ser adicionado várias vezes em uma lista.
    Como valor numérico, é 0 se a lista estiver vazia ou 1 se não estiver.
    Quando um objeto é apagado, é executada a função apagaobj de todas
    as variáveis listaobj do objeto.

    Funções:
    addini(<objetos e/ou listaobj>)
        Adiciona no topo da lista.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addfim(<objetos e/ou listaobj>)
        Adiciona no final da lista.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addini1 e addfim1
        Mesmo que addini e addfim, exceto que não adiciona objetos
        se já estiverem na listaobj.
    remove
        Remove objetos repetidos na lista.
        Retorna a quantidade de objetos removidos.
    remove(<objetos e/ou listaobj>)
        Retira objetos da lista. Retorna a quantidade de objetos removidos.
    rand
        Muda a ordem dos objetos aleatoriamente.
    limpar
        Retira todos os objetos da lista.
    possui(<objetos e/ou listaobj>)
        Retorna quantos objetos estão na lista (0=não estão na lista).
    apagar
        Marca todos os objetos da lista para exclusão, usando a função apagar()
    total
        Quantidade de itens da lista.
    objlista
        Objeto que contém a lista; pode ser NULO.
    ini
        Primeiro item da lista (variável listaitem).
        Nota: ini.obj = primeiro objeto da lista.
    fim
        Último item da lista (variável listaitem).
        Nota: fim.obj = último objeto da lista.

listaitem <nomedavariável>
    É usado para acessar os objetos de listaobj. Representa um objeto.
    Como valor numérico, é 1 se for um objeto ou 0 se não for.

    Funções:
    addantes(<objetos e/ou listaobj>)
        Adiciona objetos antes desse.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    adddepois(<objetos e/ou listaobj>)
        Adiciona objetos depois desse.
        Retorna o primeiro item adicionado da lista (variável listaitem).
    addantes1 e adddepois1
        Mesmo que addantes e adddepois, exceto que não adiciona objetos
        se já estiverem na listaobj.
    antes
        Passa para o objeto anterior.
    antes(<número de objetos>)
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois(<número de objetos>)
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    remove
        Remove objeto da lista, listaitem passa a não ser um objeto válido.
    removeantes
        Remove objeto da lista e passa para o anterior.
        Nota: não confundir com "remover o objeto anterior".
    removedepois
        Remove objeto da lista e passa para o próximo.
        Nota: não confundir com "remover o próximo objeto".
    obj
        Objeto.
    total
        Quantidade de itens da lista.
    objlista
        Objeto que contém a lista; pode ser NULO.

    Exemplo:
    listaobj l
    listaitem i
    l.addantes( este ) -> Adiciona no topo da lista
    l.adddepois( este ) -> Adiciona no final da lista
    l.remove( l.ini.obj ) -> remove um objeto da lista
    l.possui( este) -> retorna !=0 se objeto está na lista
    l.ini.obj -> é o primeiro objeto da lista
    l.fim.obj -> é o último objeto da lista
    i = l.ini  -> i é o primeiro item da lista
    enquanto i    -> Enquanto i for um objeto (não acabou a lista)
      i.obj.l = 1   -> Faz a variável l do objeto = 1
      i.depois      -> Passa para o próximo objeto
    efim

textotxt <nomedavariável>
    Lista de textos. É o equivalente ao texto de um editor de textos.
    Todas as linhas de texto terminam com um caracter \n.

    Funções:
    ini
        Primeira linha do texto (variável textopos).
    fim
        Fim do texto, após a última linha do texto (variável textopos).
    linhas
        Retorna o número de linhas de texto.
    bytes
        Retorna a quantidade de bytes de texto.
    limpar
        Limpa o texto
    addini(<texto ou textotxt>)
        Adiciona linhas no início do textotxt.
    addfim(<texto ou textotxt>)
        Adiciona linhas no fim do textotxt.
    remove(<quantidade de linhas>)
        Retorna um texto que contém uma quantidade de linhas do início do
        textotxt. Retira essas linhas do textotxt.
    ordena
        Organiza as linhas em ordem alfabética.
    ordenalin
        Organiza as linhas em ordem alfabética, sendo que:
        A primeira palavra de cada linha é a quantidade de textos.
        Da segunda palavra em diante é o texto propriamente dito.
        As linhas que não começam com um número são apagadas.
        Linhas iguais são somadas.
        Exemplo:
            "1 Carro pequeno\n"
            "3 Carro pequeno\n"
            "2 Caminhão\n"
        Vira:
            "2 Caminhão\n"
            "4 Carro pequeno\n"
    ordenalin(<texto1>, <texto2>)
        Mesmo que ordenalin sem argumentos, exceto que após ordenar altera
        as linhas de acordo com a quantidade (a primeira palavra):
        Se for 0 ou não for um número: apaga a linha
        Se for 1: apaga o número no começo da linha
        Se for 2 ou mais: adiciona <texto1> antes do número e <texto2> depois.
        Exemplo:
            "0 Bolsa\n"
            "1 Garrafa\n"
            "5 Copo\n"
        Após numerolin("(", "x)"), essas linhas mudam para:
            "(5x) Copo\n"
            "Garrafa\n"
    juntalin
    juntalin(<texto1>, <texto2>)
        Junta as linhas repetidas exatamente como ordenalin, porém mantém
        a ordem original das linhas.
    dividelin(<colmin>, <colmax>)
        Linhas que tiverem mais que <colmax> colunas são divididas entre
        as colunas <colmin> e <colmax>, preferêncialmente no último espaço
        encontrado. Se <colmin> ou <colmax> for menor que dois, nada essa
        função não tem efeito.
    rand
        Muda a ordem das linhas aleatoriamente.
    ler(<nome do arquivo>)
        Lê um arquivo de texto e coloca em textotxt.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Nota 1: O nome do arquivo sempre terminará com ".txt".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível acessar arquivos de outros lugares.
    salvar(<nome do arquivo>)
        Salva o conteúdo de textotxt em um arquivo de texto.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Notas: vide função ler (acima)

textopos <nomedavariável>
    É usado para acessar o texto de textotxt. Representa uma linha.
    Como valor numérico, é 1 se linha existe ou 0 se está no fim do texto.

    Variável:
    linha
        Número da linha atual; começa em 0.
        Nota 1: prefira usar "linha.depois" ao invés de "linha+=1".
        Nota 2: Internamente muda de linha chamando as funções antes e depois.

    Funções:
    byte
        Retorna a quantidade de bytes desde o início do texto; começa no 0.
    lin
        É 1 se linha válida ou 0 se chegou no fim do texto.
    antes
        Passa para a linha anterior.
    antes(<número de linhas>)
        Recua o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Vai para a próxima linha.
    depois(<número de linhas>)
        Avança o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    texto
    texto(<caracter inicial>)
    texto(<caracter inicial>, <quantidade de caracteres>)
        Retorna o texto da linha atual ou de parte da linha atual.
    textolin(<número de linhas>)
        Retorna texto correspondente ao número de linhas especificado.
    mudar(<novo texto>)
    mudar(<novo texto>, <caracter inicial>)
    mudar(<novo texto>, <caracter inicial>, <quantidade de caracteres>)
        Muda o texto da linha atual ou parte do texto da linha atual.
        Caracter inicial e quantidade de caracteres referem-se à linha atual.
    add(<novo texto>)
        Adiciona linha antes da linha atual.
        Após essa função, textopos corresponde ao texto adicionado.
    add(<textopos início>, <número de linhas>)
        Adiciona as linhas correspondente ao texto especificado.
    remove
        Remove a linha atual.
    remove(<número de linhas>)
        Remove a quantidade de linhas especificadas, a partir da linha atual.
    juntar
        Junta a linha atual com a anterior.
        Retorna 1 se juntou linhas ou 0 se não juntou.
        Nota: Para dividir uma linha, adicionar texto "\n" com a função mudar.
    txtproc(<texto procurado>, <caracter inicial>, <quantidade de linhas>)
        Procura um texto a partir da linha atual.
        "\n" no começo do texto significa: deve estar no começo de uma linha.
        "\n" no fim do texto significa: deve estar no fim de uma linha.
        Se não for especificada uma quantidade de linhas a procurar, procura
        até o final do texto.
        Se o caracter inicial não for especificado, assume início da linha.
        Se não encontrou, retorna -1. Se encontrou, posiciona na linha que
        contém o texto e retorna o número do caracter (0=início da linha).
        Para diferenciar letras minúsculas de maiúsculas e acentuadas de
        não acentuadas, escrever txtprocdif ao invés de txtproc.

nomeobj <nomedavariável>
    Usado para obter um ou mais objetos, correspondente ao que o usuário
    digitou.
    Funções:
    ini(<texto>, <quantidade>)
        Inicia a busca.
        <texto> é o nome procurado (geralmente o que o usuário digitou).
        Exemplo: "poção"
        Pode-se digitar o número do objeto, escrevendo um número seguido
        de ponto e um nome. Exemplo: "2.poção" corresponde à segunda poção.
        Pode-se digitar também a quantidade, se for mais de um.
        Exemplo: "10 poção"
        <quantidade> é a quantidade máxima de objetos que podem ser
        encontrados. Exemplo, se não for desejável processar mais de 10
        objetos, <quantidade> deve ser o número 10.
    nome(<texto>)
    nome(<texto>, <texto2>, ..., <textoN>)
        <texto> contém um ou mais nomes (separados por espaço) correspondentes
        a um objeto. Exemplo, "chave chave_verde" significa um objeto que
        pode ser referenciado por esses dois nomes: chave e chave_verde.
        Essa função retorna 1 se for o objeto procurado ou 0 se não for.

    Exemplo com as duas funções:
    nomeobj x
    x.ini("2.ch", 5)# Achar no máximo 5 itens que começam com "ch"
                    # No entanto, como o texto é "2.ch", procurará só o segundo
    x.nome("bolsa") # Retorna 0 porque não é o item procurado
    x.nome("chave_azul")  # Retorna 0; não é o segundo item que começa com ch
    x.nome("chave_verde") # Retorna 1
    x.nome("chave_azul")  # Retorna 0 porque já encontrou o item

arqlog <nomedavariável>
    Para gravar mensagens em arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.

    Funções:
    abrir(<nome do arquivo>)
        Abre arquivo, cria se não existir.
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu.
        Nota 1: O nome do arquivo sempre terminará com ".log".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível criar arquivos em outros lugares.
    msg(<texto>)
        Grava texto em uma nova linha, no final do arquivo.
        Nota 1: Definições de cores e linhas vazias não são gravadas.
        Nota 2: Pode demorar até 2 segundos para o texto ser realmente
                gravado no arquivo.
    fechar
        Fecha o arquivo.

arqsav <nomedavariável>
    Para salvar objetos em arquivos e recuperar posteriormente.
    Nota 1: O nome do arquivo sempre terminará com ".sav".
    Nota 2: O arquivo deve pertencer ao diretório atual ou a um
    subdiretório dele. Não é possível criar arquivos em outros lugares.

    Os objetos que serão salvos devem ser colocados em uma listaobj.
    As variáveis salvas devem ser definidas com a palavra "sav" antes.
    Exemplo:
    classe x
    sav int8 a # Essa variável é salva por arqsav
    int8 b # Já essa não é salva

    Variáveis que acessam recursos externos nunca são salvas:
    arqlog, arqsav, arqtxt, telatxt, serv, socket
    Essas outras também não, por motivos óbvios:
    nomeobj, prog, indiceitem
    Referência a outros objetos (ref, listaobj, listaitem, etc.) são salvas
    quando se referem a outro objeto que também será salvo no mesmo arquivo.

    Funções:
    valido(<nome do arquivo>)
        Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.
    existe(<nome do arquivo>)
        Retorna 1 se arquivo existe ou 0 se não existe.
    senha(<nome do arquivo>, <senha>)
        Retorna 1 se senha correta ou 0 se incorreta.
    dias(<nome do arquivo>)
        Retorna quantos dias faltam para o arquivo expirar.
        Retorna 0 se expirou, -1 se nunca expira.
    ler(<nome do arquivo>, <listaobj>)
    ler(<nome do arquivo>, <listaobj>, <quantidade máxima de objetos lidos>)
        Lê Arquivo.
        O primeiro objeto do arquivo vai para o primeiro da listaobj.
        O segundo do arquivo vai para o segundo da listaobj, e assim por
        diante. Se a listaobj tiver menos objetos que o arquivo, serão
        criados objetos na listaobj.
        Retorna a quantidade de objetos lidos.
    salvar(<nome do arquivo>, <listaobj>, <dias>, <senha>)
        Salva em arquivo todos os objetos de uma listaobj.
        <dias> é a quantidade de dias para apagar o arquivo, 0=nunca apagar
        Retorna 1 se conseguiu salvar ou 0 se não conseguiu.
    apagar(<nome do arquivo>)
        Apaga arquivo.
        Retorna 1 se conseguiu apagar ou arquivo não existia.
        Retorna 0 se não conseguiu apagar.
    limpar(<nome do diretório>)
        Inicia checagem dos arquivos .sav no diretório especificado; apaga
        arquivos que expiraram. Os arquivos são verificados aos poucos para
        ficar transparente aos usuários.
        Retorna 1 se conseguiu ou 0 se diretório não permitido.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual, em segundo plano
    limpar
        Checa todos os diretórios pendentes de uma vez, ao invés de checar
        aos poucos, em segundo plano.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual
        sav.limpar # Checa todos os arquivos de uma vez

arqtxt <nomedavariável>
    Para ler ou gravar arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.
    Nota: A escrita em arquivo não é tão eficiente quanto arqlog.

    Funções:
    abrir(<nome do arquivo>, <modo>)
        Abre arquivo. Retorna 1 se conseguiu ou 0 se não conseguiu.
        Modo pode ser:
        0 = somente leitura
        1 = leitura e escrita
        2 = somente escrita; o tamanho do arquivo é truncado para 0 bytes
        3 = para escrever no final do arquivo
        Os modos 0 e 1 não criam um novo arquivo, caso ele não exista.
        Nota 1: O nome do arquivo sempre terminará com ".txt".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível acessar arquivos de outros lugares.
    fechar
        Fecha o arquivo.
    truncar(<arquivo>, <tamanho>)
        Trunca o tamanho de um arquivo no tamanho especificado.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Exemplo: truncar("a.txt", 0) limpa o conteúdo do arquivo a.txt
    msg(<texto>)
        Escreve texto no arquivo.
        Se for especificado mais de um texto, serão concatenados no arquivo.
        Exemplo, escr("ab", "\n") é o mesmo que escr("ab\n")
    flush
        Grava em arquivo as alterações pendentes.
    ler
        Lê uma linha do arquivo; retorna a linha lida sem o \n no final.
        Pode ler menos se chegou no fim do arquivo.
    ler(<tamanho>)
        Lê um determinado número de caracteres do arquivo.
        Pode ler menos se chegou no fim do arquivo.
        Exemplo: ler(1) lê um caracter.
    pos
        Retorna a posição atual no arquivo (0=está no início do arquivo).
    pos(<posição>, <modo>)
        Muda a posição atual no arquivo. Modo pode ser:
        0 = a partir do início do arquivo
        1 = a partir da posição atual
        2 = a partir do fim do arquivo
    eof
        1 se chegou no fim do arquivo, 0 se não chegou.

inttempo <nomedavariável>
    Uma variável inteira de 0 a 1048575, subtraída 1 a cada décimo de segundo.
    A diferença de inttempo para intdec é que quando chega a 0, uma função
    do objeto é executada. O nome da função é <nomedavariável>_exec.
    Na função: arg0 = índice da variável vetor, se não for vetor arg0=0
    Nota: o valor 1048575 corresponde a 29 horas, 7 minutos e 37.5 segundos.

    Exemplo:
    classe x
    inttempo n
    func n_exec
      # Essa função é executada quando a variável n chegar a zero

telatxt <nome da variável>
    Semelhante a socket, mas trabalha com uma tela de texto, chamada console.
    Essa tela é semelhante ao "prompt de comando", no Windows, ou o próprio
    terminal, em Unix.

    Funções e variáveis:
    proto
        0 se a tela de texto não estiver aberta
        5 se estiver aberta
        O valor de proto depende da opção "telatxt" no arquivo intmud.cfg.
    posx
        Posição do cursor: quantos caracteres enviou após o último \n.
        Caracteres especiais, como definição da cor, não contam
    msg(<mensagem>)
        Envia mensagem para telatxt.
    tecla(<nome da tecla>)
        Processa uma tecla, como se tivesse sido digitada pelo usuário.
        Nota: não gera eventos.
    texto
        Conteúdo da linha sendo digitada pelo usuário. Pode ser mudado.
    total
        Tamanho da linha sendo editada, de 1 a 1023. Pode ser mudado.
    linha
        Linha em que o cursor está. 0 é a linha de edição, 1=última linha
        de texto, 2 = linha anterior, etc.
    bipe
        Gera um bipe.
    limpa
        Limpa a tela.

    Eventos:
    <nomedavariável>_msg
        Recebeu mensagem
        arg0 = mensagem recebida
        arg1 = índice da variável vetor, se não for vetor arg1=0
    <nomedavariável>_tecla
        Chamado sempre que o usuário pressionar uma tecla.
        arg0 = nome da tecla
        arg1 = índice da variável vetor, se não for vetor arg1=0
        Se retornar verdadeiro, significa que a função já processou a tecla.
        Portanto, não será processada pelo IntMUD.

    Nomes das teclas especiais:
    Teclas de função: F1 a F12
    Setas: UP DOWN LEFT RIGHT (nessa ordem: cima, baixo, esquerda, direita)
    Outras: INS DEL HOME END PGUP PGDN TAB ENTER ESC BACK
    Com SHIFT: S_F1 a S_F12 S_TAB S_ENTER
    Com CONTROL: C_INS C_DEL C_HOME C_END C_PGUP C_PGDN
    Setas com CONTROL: C_UP C_DOWN C_LEFT C_RIGHT
    Letras A-Z com CONTROL: C_A a C_Z
    Notas - em um terminal Unix ou Linux:
    1. Control+C encerra o programa (não gera evento _tecla)
    2. Control+Z coloca o programa em segundo plano (não gera evento _tecla)
    3. Control+I é a tacla TAB
    4. Control+M é a tecla ENTER

socket <nomedavariável>
    Quando o socket está conectado à janela do programa:
    A janela possui 25 linhas de 80 colunas, sendo que a última linha
    sempre corresponde ao que o usuário está escrevendo.
    Como valor numérico, é 1 se proto!=0 (está conectado) ou 0 se proto=0.
    Nota: uma conexão pode ser copiada de um objeto socket para outro.
    Nesse caso, os eventos são gerados em mais de uma variável socket.

    Funções e variáveis:
    proto
        Define o protocolo; um número com o significado:
        0 = não está conectado
        1 = conectando
        2 = Telnet
        3 = IRC
        4 = Papovox (sem cores)
        Nota: pode-se mudar entre 2 e 4 para socket conectado
    cores
        0 = nenhuma cor
        1 = cores somente ao receber
        2 = cores somente ao enviar
        3 = cores ao enviar e receber
    aflooder
        O anti flooder impede o recebimento de muitas mensagens ao mesmo tempo.
        0 desativa o anti flooder, outro valor ativa.
    eco
        Define se o que o usuário digitar deve ser ecoado na tela.
        0 não ecoa, 1 ecoa. Não tem efeito em IRC e Papovox.
    posx
        Posição do cursor: quantos caracteres enviou após o último \n.
        Caracteres especiais, como definição da cor, não contam.
    ip
        Endereço IP correspondente a quem está conectado.
    iplocal
        Endereço IP local.
    abrir(<endereço>, <porta>)
        Tenta conectar-se a um endereço.
        Retorna 1 se conexão em progresso ou 0 se ocorreu erro
        (0 geralmente significa endereço inválido)
    fechar
        Encerra a conexão; não gera o evento fechou.
    colmin
    colmax
        Essas duas variáveis são números de 10 a 1000.
        Atuam nas mensagens enviadas ao socket, dividindo linhas grandes
        em duas ou mais. Isso é feito colocando "\n" no meio da mensagem.
        Colmin e colmax são os tamanhos mínimo e máximo das linhas.
        O programa tenta dividir sempre onde houver um caracter espaço.
    msg(<mensagem>)
        Envia mensagem para o socket.
        Retorna 1 se conseguiu enviar ou 0 se buffer cheio.
        Nota: Se o protocolo for Papovox, devido às limitações do Papovox,
        é acrescentado \n no final da mensagem se já não houver um \n.

    Eventos:
    <nomedavariável>_msg
        Recebeu mensagem
        arg0 = mensagem recebida
        arg1 = índice da variável vetor, se não for vetor arg1=0
    <nomedavariável>_env
        Todas as mensagens foram transmitidas (buffer de transmissão
        ficou vazio).
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_fechou
        O socket foi fechado remotamente
        arg0 = índice da variável vetor, se não for vetor arg0=0
        Se essa função não existir, o objeto que contém o socket é apagado
    <nomedavariável>_con
        Conseguiu conectar
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_err
        Não conseguiu conectar
        arg0 = mensagem de erro
        arg1 = índice da variável vetor, se não for vetor arg1=0

serv <nomedavariável>
    Funções:
    abrir(endereço, porta)
        Abrir para receber conexões
        Se não quiser especificar um endereço, colocar "" no endereço
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu
    fechar
        Deixa de receber conexões

    Eventos:
    <nomedavariável>_socket
    arg0 = socket correspondente à conexão
    arg1 = índice da variável vetor, se não for vetor arg1=0

    Exemplo de uso com socket:
    classe x
    comum serv servidor
    socket conec
    func iniclasse
      x:servidor.abrir("", 2000)
    func servidor_socket
      ref novo
      novo = criar("x")
      novo.conec = arg0
      novo.conec.msg("Benvindo\n")
    func conec_msg
      conec.msg("você escreveu " + arg1 + "\n")

prog <nomedavariável>
    Para ler e alterar o próprio programa.
    Nota: pode ser usado um objeto no lugar do nome de uma classe.

    As próximas funções iniciam uma consulta e retornam 1 se há algum
    resultado (pelo menos uma linha) para a consulta ou 0 se não há.
    iniclasse
    iniclasse(<texto>)
        Obter os nomes das classes que começam com o texto especificado.
        Em ordem alfabética.
    inifunc(<nome da classe>)
    inifunc(<nome da classe>, <texto>)
        Obter os nomes das funções e variáveis definidas em uma classe.
        Somente as variáveis e funções que começam com o texto especificado.
        Em ordem alfabética.
    inifunctudo(<nome da classe>)
    inifunctudo(<nome da classe>, <texto>)
        Mesmo que inifunc, mas inclui também as variáveis e funções herdadas.
    iniherda(<nome da classe>)
        Obter os nomes das classes definidas na instrução "herda".
        Na ordem definida na classe.
    iniherdatudo(<nome da classe>)
        Obter a lista de classes herdadas por uma classe.
        Inclui também as classes herdadas indiretamente.
        Na ordem em que as classes são herdadas.
    iniherdainv(<nome da classe>)
        Herança inversa: obter os nomes das classes que herdam uma classe.
        A ordem em que as classes são listadas é imprevisível.
    inilinha(<nome da classe>)
        Obter as linhas correspondentes a uma classe.
    inilinha(<nome da classe>, <nome da função>)
        Obter as linhas correspondentes a uma variável ou função da classe
        (definida na classe ou herdada).

    As próximas funções permitem ler o resultado da consulta.
    lin
        É 1 se linha válida ou 0 se chegou no fim da consulta.
    depois
        Vai para a próxima linha.
    depois(<número de linhas>)
        Avança o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    texto
        Retorna o texto da linha atual.
    nivel
        Retorna um número, que é o nível de indentação. Usado somente com
        inilinha.

    As próximas funções funcionam independente das demais.
    existe(<nome da classe>)
        Retorna 1 se a classe existe ou 0 se não existe.
    existe(<nome da classe>, <nome da variável>)
        Retorna 1 se a variável ou função existe ou 0 se não existe.
    arquivo(<nome da classe>)
        Retorna o sufixo do nome do arquivo que contém a classe.
        Exemplo, "abc" corresponde ao arquivo "intmud-abc.map".
        Um texto vazio significa arquivo "intmud.map".
    vartipo(<nome da classe>, <nome da variável>)
        Retorna o tipo de variável ou "" se a variável não existe.
    varnum(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante numérica do tipo:
        const variável = valor numérico
        ou 0 se não for.
    vartexto(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante de texto do tipo:
        const variável = "texto"
        ou 0 se não for.
    varcomum(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for comum ou 0 se não for.
    varsav(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for sav ou 0 se não for.
    varvetor(<nome da classe>, <nome da variável>)
        Retorna a quantidade de variáveis do vetor ou 0 se não for vetor.
    varlocal(<nome da classe>, <nome da variável>)
        Retorna 1 se variável estiver definida na própria classe
        (não foi herdada) ou 0 se não estiver.
    const(<nome da classe>, <nome da variável>)
        Retorna o texto de uma variável constante do tipo:
        const variável = valor    (nesse caso retorna valor)
        const variável = "texto"  (nesse caso retorna texto)
        Retorna um texto vazio para outros tipos de variáveis.

    As próximas funções permitem alterar o programa. Porém, as alterações
    só serão efetuadas quando o controle retornar ao IntMUD.
    apagar(<classe>)
    apagar(<classe>, <variável>)
        Apaga classe ou variável.
        Retorna: 1=sucesso, 0=falha (classe ou variável não existe)
    criar(<texto>)
        Cria uma classe. Se já existia, altera ao invés de criar.
        A primeira linha é o nome da classe.
        A segunda linha de <texto> é o sufixo do nome do arquivo.
            Exemplo, "abc" corresponde ao arquivo "intmud-abc.map".
            Um texto vazio corresponde ao arquivo "intmud.map".
        Da terceira linha em diante são as instruções (o contéudo da classe).
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplo:
            prog p
            p.criar("abc\n\nint8 x\nconst n = 10")
        Cria a seguinte classe no arquivo intmud.map:
            classe abc
            int8 x
            const n = 10
        Para criar a mesma classe, mas no arquivo intmud-x.map:
            p.criar("abc\nx\nint8 x\nconst n = 10")
    criar(<nome da classe>, <texto>)
        Cria uma função ou variável de uma classe.
        Se já existia, antes apaga a função ou variável.
        <texto> contém todas as instruções da função ou variável.
        Se houver mais de uma linha, usar \n para separar as linhas.
        A primeira linha deve conter o nome e o tipo.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplos:
            prog p
            p.criar("abc", "int8 n") # Cria a variável n na classe abc
            p.criar("xyz, "func x\nret 10") # cria a função x na classe xyz
    apagarlin(<nome da classe>, <número da linha>)
    apagarlin(<nome da classe>, <nome da variável>, <número da linha>)
        Apaga uma linha de uma classe ou variável.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    criarlin(<nome da classe>, <linha inicial>, <texto>)
    criarlin(<nome da classe>, <nome da variável>, <linha inicial>, <texto>)
        Adiciona linhas na classe ou função especificada.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    salvar
    salvar(<texto>)
        Salva as alterações nos arquivos correspondentes, depois que todas
        as alterações pendentes nas classes forem efetuadas.
        O texto é composto de letras seguidas de números, que indicam como
        o arquivo deve ser salvo. As opções são as seguintes:
        L = quantidade máxima de caracteres por linha, de 70 a 4000
        N = se deve dividir linhas em caracteres \n
            0=não divide, 1=somente em const contendo apenas texto, 2=sempre
        I = espaços usados para indentação, de 0 a 8
        C = linhas entre classes, de 0 a 10
        F = linhas vazias entre funções, de 0 a 10
        V = linhas vazias entre variáveis e constantes, de 0 a 10
        A função salvar sem parâmetros é o mesmo que:
        salvar("L4000N0I2C1F1V0")
        Significa não dividir linhas, 2 espaços para indentação,
        1 linha vazia entre classes e entre funções e nenhuma linha vazia
        entre variáveis.
    salvartudo
    salvartudo(<texto>)
        Mesmo que a função salvar, porém salva todos os arquivos,
        independete de terem sido alterados ou não.

debug <nomedavariável>
    Para auxiliar a detectar erros no programa.

    Variável:
    exec
        Contador de instruções - opção "exec" no início do arquivo int.
        A cada instrução executada essa variável é subtraída de 1.
        Quando chega a 0, o controle retorna automaticamente ao IntMUD.

    Funções:
    ini
        Inicializa exec com o valor definido na opção "exec" no início
        do arquivo int.
    cmd(<texto>)
    cmd(<objeto>, <texto>)
        Executa a instrução que está no texto especificado.
        Se for mais de uma instrução, separar com "\n".
        Retorna mensagem de erro se instrução não for válida.
        Nota 1: instruções ret no texto retornam para o cmd (vide abaixo).
        Nota 2: variáveis criadas no cmd só existem dentro do cmd.
        Exemplos:
        debug d
        d.cmd("x = 10")
        d.cmd("x=x+1\nteste(\"x=\"+x+\"\\n\")")
        d.cmd("ret \"teste\"") # d.cmd retorna "teste"
        d.cmd("int8 x\nx=1+2\nret x") # d.cmd retorna 3
    passo(<objeto>, <texto>)
    passo()
        Antes de executar cada instrução chama a função de <objeto>
        com o nome especificado em <texto>. Se a função não existir, passa
        a executar instruções sem chamar nenhuma função.
        Na função:
        arg0=objeto "este"
        arg1=texto contendo a instrução que será executada executada
    func
        Retorna o nível de funções: quantas funções foram chamadas até chegar
        na instrução atual. Exemplo:
        classe x
        func iniclasse
          # Aqui debug.func será 0 quando a classe for criada
          x:teste
        func teste
          # Aqui debug.func será 1 porque foi chamado por x:iniclasse

indiceobj <nomedavariável>
    É semelhante a uma variável txt64, porém o texto é associado ao objeto
    que contém essa variável. O processo inverso, obter um objeto a partir
    de um texto, é possível com a variável indiceitem.

indiceitem <nomedavariável>
    Permite obter os objetos que contém uma variável indiceobj com um
    determinado texto. Ignora variáveis indiceobj com texto nulo.

    Funções:
    ini(<texto>)
        Vai para o primeiro objeto com o texto ou parte dele.
    fim(<texto>)
        Vai para o último objeto com o texto ou parte dele.
    antes
        Passa para o objeto anterior.
    antes(<número de objetos>)
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois(<número de objetos>)
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    obj
        Objeto.
    txt
        Texto associado ao objeto.
    obj(<texto>)
        Objeto que contém o texto exato.
        Essa função funciona independente das demais.

    Nota: Pode-se passar mais de um texto para as funções que possuem texto.
    Nesse caso, a função procurará por todos os textos.

datahora <nomedavariável>
    Operações envolvendo data e/ou hora, como obter a data atual e calcular
    quantidade de dias entre duas datas.

    Funções:
    novadata(<ano>, <mês>, <dia>)
        Muda ano, mês e dia.
    novahora(<hora>, <minuto>, <segundo>)
        Muda hora, minuto e segundo.
    antes
        Muda data para o dia anterior.
    depois
        Muda data para o próximo dia.
    agora
        Muda para data e hora atuais.
    diasem
        Dia da semana, de 0 a 6 (0=domingo).
    bissexto
        É 1 se o ano for bissexto, 0 se não for

    Variáveis:
    ano
        Ano, de 1 a 9999.
    mes
        Mês, de 1 a 12.
    dia
        Dia, de 1 a 31. Conforme o mês pode não chegar a 31.
    hora
        Hora, de 0 a 23.
    min
        Minuto, de 0 a 59.
    seg
        Segundo, de 0 a 59.
    numdias
        Número de dias desde 1/1/1.
    numseg
        Número de segundos desde o início do dia
