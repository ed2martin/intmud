Especificações - IntMUD (Interpretador MUD)

O programa é um interpretador de comandos, que trabalha com pelo menos
mais dois arquivos:
- Um ou mais arquivos que contém os comandos (a linguagem).
- Arquivo de configuração, onde define-se algumas permissões, e se deve ou não
  abrir uma janela na tela.
- Na versão Windows é necessário um quarto arquivo, para relatar os erros
  encontrados ao ler o arquivo de comandos.

Quando um programa se torna grande, fica difícil trabalhar com um só arquivo.
Nesse caso acrescenta-se no começo do arquivo intmud.map a linha:
mapagrande
E o interpretador passa a trabalhar com vários arquivos, sendo que os nomes
dos demais arquivos sempre começam com "intmud-" e terminam com ".map".
Exemplo: intmud-teste.map

Os arquivos de comandos contém as classes (tipos de objetos), conforme
a sintaxe:

[nome da classe]
herda <classe 1>, <classe 2>, ..., <classe N>
variáveis e constantes do objeto
funções (func) e constantes (const) do objeto

Nota: Nomes de classe podem ter espaço, mas eles são tratados como o caracter
"_" no restante do programa.

Cada função:

func <nome da função>
variáveis da função
instruções da função

Tudo o que estiver abaixo da linha func <nome da função> pertence à função,
até a definição da próxima função ou constante.

As variáveis são definidas com:
<tipo da variável>  <nome da variável>
Exemplos:
int8 v1
txt50 v2

Basicamente o programa lida com quatro tipos de variáveis:
- Numérico, como: 0, -5, 4.3
- Texto, como: "bom dia"
- Referência a um objeto, como a palavra este, que se refere ao objeto atual
- Nulo, que corresponde a um valor nulo.
Os tipos de variáveis serão vistos adiante.

Tipos constantes são definidos com:
const  <nome>  =  <valor>
Exemplos:
const x = "teste"
const y = 10

A linha "herda", se estiver presente, significa herança.
A classe contém também as variáveis e funções das classes especificadas.
Herda também as classes herdadas por essas. Exemplo:
[A]
herda B
int8 dia
[B]
herda C
int8 mes
[C]
int8 ano

A classe C contém a variável ano. A classe B contém as variáveis ano e mes.
A classe A contém mes, dia e ano. Está herdando C através de B.

Quando houver um nome de variável ou função repetido na herança, prevalece
a primeira encontrada. As demais são ignoradas. Exemplo:
[A]
herda B
int8 x
[B]
txt10 x
Nesse caso a classe A tem a variável "int8 x", mas não contém a variável
"txt10 x".

Uma função pode conter os seguintes tipos de instrução:
1. Atribuir um valor ou expressão numérica a uma variável, ex:
x = 10
y = x + abs(z) * 3

2. Executar uma função, sem atribuir o resultado a nenhuma variável, ex:
x("teste")

3. Uma instrução de controle de fluxo do programa: se, fimse, enquanto, etc.
Exemplo:
se x=10
...
fimse

4. Comentários: linhas que começam com # seguido ou não de um texto.
São ignorados pelo programa. Exemplo:
# teste

As linhas de instruções são interpretadas da esquerda para a direita,
verificando:
1. Operadores, como + - * / = < > | &
2. Números: começam com um dígito de 0 a 9 e podem ter sinal de menos na frente
3. Textos: começam e terminam com aspas dupla (").
   Apenas aspas dupla dentro do texto deve ser escrito assim: \"
4. Variáveis e funções: começam com uma letra ou colchetes ([).

O programa interpreta variáveis e funções da seguinte forma:
A. Se houver um ponto separando duas palavras, liga a segunda ao retorno da
   primeira. Exemplo, a palavra este corresponde ao objeto atual.
   este.abs deve corresponder à função ou variável abs do objeto.
B. Se houver colchetes, interpreta o que estiver entre colchetes como uma
   expressão numérica. O resultado disso fará parte do nome da variável ou
   função. Exemplo:
   x["1"] = 10
   y = "_teste"
   x[y] = 20
        É equivalente a:
   x1 = 10
   x_teste = 20

O programa processa variáveis e funções da seguinte forma:
A. Se houver dois pontos, executa a função (depois dos dois pontos)
   da classe especificada (antes dos dois pontos), como se pertencesse ao
   objeto atual. Exemplo:
   item:luminosidade(10)
   Executa função luminosidade da classe item, como se essa função
   pertencesse ao objeto "este".
B. Verifica se é uma função nativa do programa (exemplo: abs).
C. Verifica se é uma variável da função que está sendo executada.
D. Verifica se é uma variável ou função do objeto.
E. Se não existe, interpreta com se fosse uma variável de valor NULO.


*** Variáveis básicas

As variáveis definidas antes das funções pertencem ao objeto.
As que forem definidas em uma função pertencem à ela. São criadas
quando a função é chamada e deixam de existir quando a função termina.

int1 <nomedavariável>
    Pode ser 0 ou 1
int8 <nomedavariável>
    Número inteiro de -128 a 127
int16 <nomedavariável>
    Número inteiro de -32768 a 32767
int32 <nomedavariável>
    Número inteiro de -2147483648 a 2147483647
uint8 <nomedavariável>
    Número inteiro de 0 a 255
uint16 <nomedavariável>
    Número inteiro de 0 a 65535
uint32 <nomedavariável>
    Número inteiro de 0 a 4294967295
intinc <nomedavariável>
    Número inteiro de 0 a 65535, que é somado 1 a cada
    décimo de segundo, até chegar a 65535
intdec <nomedavariável>
    Número inteiro de 0 a 65535, que é subtraido 1 a cada
    décimo de segundo, até chegar a 0
real
    Corresponde ao tipo "double" em C++
txt1 a txt512 seguido do nome da variável:
    Define uma variável que contém um texto, de até 1 a 512 caracteres,
    respectivamente. Exemplo:
    Para criar uma variável: vartxt10 x
    Para colocar um texto nessa variável: x = "bom dia"
ref <nomedavariável>
    Referência para um objeto; corresponde a um objeto qualquer.
    A palavra "nulo" é usada para indicar que a referência
    não corresponde a nenhum objeto. Quando o objeto é apagado,
    automaticamente a referência passa a ser "nulo".
    Exemplo:
    ref ref1
    # Cria objeto
    ref1 = criar("teste")
    # Muda variável x do objeto
    ref1.x = 2
    # Faz a referência não corresponder a nenhum objeto
    # mas não apaga o objeto criado
    ref1 = nulo

Antes dos tipos das variáveis é permitido colocar as seguintes palavras:

comum
    Variável é a mesma para todos os objetos da classe.
    Independente da quantidade de objetos, só existe uma variável.
sav
    Variável deve ser salva em arquivo, vide objeto salvar.


*** Vetores

São conjuntos de variáveis do mesmo tipo.
Define-se um vetor acrescentando-se após o nome da variável um ponto
e a quantidade de variáveis, de 1 a 255.
Exemplo:
int8 teste.3

Nesse caso existem 3 variáveis:
teste.0
teste.1
teste.2

Exemplo de como tratar eventos de um vetor:
[x]
inttempo n.5
func n_exec # Evento para as 5 variáveis "n"
# Aqui arg0 é o índice da variável no vetor (de 0 a 4)
# n.[arg0] corresponde à variável que gerou o evento

Nota: Funções e constantes não podem ser definidos como vetor.


*** Funções

Funções podem ser chamadas de duas formas, em relação aos argumentos:
1. Sem argumentos
<nomedafunção>

2. Com um ou mais argumentos
<nomedafunção> ( argumento 1, argumento 2, ..., argumento N )

Exemplos:
teste
teste("bom dia", 10)

Quando a função é chamada, as variáveis definidas na função são criadas.
Deixam de existir quando retorna (termina).
Dentro da função, as seguintes palavras tem um significado próprio:
args = número de argumentos
arg0 a arg9 = argumentos passados para a função
este = objeto ao qual a função pertence

Os argumentos são passados por referência: alterar arg0 a arg9 dentro
da função altera a variável que foi passada.

Para retornar um valor, a instrução é:
ret <valor de retorno>
Exemplos:
ret 10
ret arg0+1

Se não for especificado o valor de retorno, ret retorna nulo.
Após a última linha da função é como se tivesse uma instrução ret nulo.

Exemplo - dada uma função x, definida como:
func x
ret arg0+1
O retorno pode ser usado da seguinte forma:
y = x(10)
z = x(2) - x(1)
Nesse exemplo, fará y=11 e z=1.

Outros exemplos:
[abc]
int1 x
int8 y
func teste1
  ret "bom dia"
func teste2
  ret x + y
func teste3
  y = arg0 + arg1
func fatorial
  se args!=1 | arg0<=1
    ret 1
  fimse
  ret arg0 * fatorial(arg0-1)


Internamente constantes se comportam como funções. Exemplo:
func x
  ret arg0 * 10
Pode ser escrito também como:
const x = arg0 * 10


Existe um outro tipo de função, que se comporta como se fosse uma variável.
É definida com varfunc ao invés de func.
Quando for feita uma leitura a variável, ao invés disso a função é chamada
com nenhum argumento, e deve retornar o valor lido.
Alterar a variável chama a função com um argumento (o novo valor).
O valor de retorno da função é ignorado.

Exemplo:
varfunc x
  se args=0
# Leitura da variável: retorna "bom dia"
    ret "bom dia"
  fimse
# Mudar a variável: chama outra função
  este.msg(arg0)
func teste
  vartxt10 n
# Vai fazer: n = "bom dia"
  n = x
# Vai fazer: este.msg("teste")
  x = "teste"


*** Funções chamadas pelo programa:

ini
    Executada quando o objeto é criado
fim
    Executada quando o objeto é apagado
iniclasse
    Executada quando a classe é criada
    Recebe um argumento (arg0), que é o nome da classe

Outras funções podem ser chamadas, por variáveis específicas, que constituem
uma extensão do programa.


*** Operadores

Podem ser usados os seguintes operadores - sendo a e b duas variáveis
e/ou números:

!a      Se for falso (=0) vira verdadeiro (1)
        Se for verdadeiro (diferente de 0) vira falso (0)
a*b     Multimplica a por b
a/b     Divide: a/b; pode resultar em um número quebrado (não inteiro)
a%b     É o resto da divisão de a por b
a+b     Soma
a-b     Subtrai
a<b     Verdadeiro (=1) se a<b; Falso (=0) se a>=b
a<=b    Verdadeiro se a<=b
a=b     Verdadeiro se a for igual a b
a==b    Verdadeiro se a for exatamente igual a b
        Em textos: diferencia letras minúsculas de letras maiúsculas
a>=b    Verdadeiro se a>=b
a>b     Verdadeiro se a>b
a!=b    Verdadeiro se a for diferente de b
a&b     Verdadeiro (=1) somente se a for verdadeiro e b também for
a|b     Verdadeiro (=1) se a for verdadeiro ou b for verdadeiro
Pode-se usar também os parênteses em expressões
Exemplo:  2*(3+4)

Os operadores +=, -=, *= e /= são formas compactas:
variável += valor
variável -= valor
variável *= valor
variável /= valor

São o mesmo que:
variável = variável + valor
variável = variável - valor
variável = variável * valor
variável = variável / valor


*** Instruções de controle de fluxo - não podem ser usadas em cálculos

se <expressão>  ... fimse
se <expressão>  ... senão ... fimse
se <expressão>  ... senão <expressão>  ... fimse
    Decisão

enquanto <expressão>  ... efim
    Laço de repetição
    Se a expressão for verdadeira, executa as instruções que estiverem entre
    o enquanto e o efim e volta para a instrução enquanto, para testar
    a <expressão> novamente.

sair
    Sai de um laço enquanto.

continuar
    Fecha um ciclo de um laço enquanto, como se tivesse chegado na instrução
    efim. A diferença entre continuar e efim é que efim define aonde termina
    o laço.

terminar
    Encerra o programa


*** Funções predefinidas

exec(<texto>)
    Executa a instrução que está no texto especificado.
    Exemplo:
    exec("x = 10")

intpos(a)
    Retorna a se a>=0. Caso contrário retorna 0.

intabs(a)
    O mesmo que a sem sinal.
    Exemplo: abs(-1) e abs(1) são iguais a 1

int(a)
    O valor inteiro de a.

rand(a)
    Um número aleatório, inteiro, de 0 a a-1. Exemplo, rand(10) gera
    um número aleatório de 0 a 9.

ref(a)
    Referência constante; retorna o mesmo objeto que a.
    Se a não for um objeto, retorna nulo.
    Se for fornecido mais de uma referência (exemplo: ref(a,b,c)),
    retorna a primeira que não for nula.

txtnum(número, formato)
    Retorna um texto correspondente a um número ou variável numérica.
    Formato é um texto que pode conter:
    Um dígito de 0 a 9 = número de casas após a vírgula
    Uma vírgula: separar o número com vírgulas
    Um ponto: separar número com pontos, o ponto decimal vira vírgula
    Letra E: mostrar em notação científica; as opções anteriores são ignoradas
    Exemplo:
    txtnum(1005.23, "3.") é o mesmo que "1.005,230"
    Nota: números muito grandes (mais de 18 dígitos antes da vírgula)
    são mostrados em notação científica.
    Exemplo: 5.9E+18 significa 59 seguido de 17 zeros.

txt(a)
    Texto constante (não pode ser alterado) igual a a.
    Se a não for texto, retorna um texto vazio.
    Se for objeto, retorna o nome da classe.

txt(<texto>, <caracter inicial>)
txt(<texto>, <caracter inicial>, <quantidade de caracteres>)
    Retorna um texto que é parte do texto especificado. Exemplo:
    txt("abcdef", 2, 2) é o mesmo que "cd".

txt1(<texto>)
    Retorna a primeira palavra do texto.

txt2(<texto>)
    Retorna tudo exceto a primeira palavra do texto.

txtcor(<texto>)
    Retorna o texto sem as definições de cores. Exemplo:
    txtcor("\cF\d4Teste\b") é o mesmo que "Teste".

txtmai(<texto>)
    Retorna o texto em letras maiúsculas.

txtmin(<texto>)
    Retorna o texto em letras minúsculas.

txtmaiini(<texto>)
    Retorna o texto passando a primeira letra para maiúscula.
    Se encontrar algum ponto, a próxima letra também será maiúscula.

txtmaimin(<texto>)
    Retorna o texto com a primeira letra maiúscula e as demais minúsculas.
    Se encontrar um ponto, a próxima letra será maiúscula.

txtfiltro(<texto>)
    Filtra mensagens. Retorna o texto filtrado.

txtesp(<quantidade de espaços>)
    Retorna um texto que é a quantidade de espaços requisitada.
    O texto retornado tem de 0 a 100 caracteres.

txtshs(<texto>)
    Calcula e retorna o SHS de um texto.
    O texto original é codificado de modo que não é possível decodificar.
    O resultado do SHS é compactado em um texto de 27 caracteres contendo
    letras maiúsculas e alguns símbolos.

txtnome(<texto>)
    Codifica apelido para comparação.
    Retorna o mesmo texto para dois apelidos parecidos.
    Nota: o texto retornado nunca é maior que o apelido.

intnome(<texto>)
    Verifica se texto é válido para apelido. Retorna:
    0 = apelido válido
    1 = muito pequeno (menos de 2 caracteres)
    2 = contém caracteres inválidos

intsenha(<texto>)
    Verifica se texto é válido para senha. Retorna:
    0 = senha válida
    1 = muito pequena (menos de 5 caracteres)
    2 = contém caracteres inválidos
    3 = contém só letras ou só números

txtremove(<texto>, <valor>)
    Retorna um texto semelhante a <texto>, mas removendo espaços e/ou
    cores, conforme <valor>:
    1 = remover espaços à esquerda
    2 = remover espaços extras, exceto à esquerda e à direita
    4 = remover espaços à direita
    8 = remover cores (tem o mesmo efeito da função txtcor)
    Os valores podem ser somados para fazer mais de uma remoção.
    Exemplo, 5 remove espaços à esquerda e à direita (5 = 4 + 1)
    Exemplos de uso:
    txtremove("  bom  dia  ", 7) é o mesmo que "bom dia"
    txtremove("  bom  dia  ", 5) é o mesmo que "bom  dia"
    txtremove("\cF\d4Teste\b", 8) é o mesmo que "Teste"

txtproc(<texto>, <texto procurado>)
txtproc(<texto>, <texto procurado>, <caracter inicial>)
    Procura <texto procurado> em <texto>
    Retorna -1 se não encontrou ou o número do caracter se encontrou
    <caracter inicial> = a partir de onde procurar no texto
            0 = primeiro caracter, 1 = segundo, etc.
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever txtprocdif ao invés de txtproc.

txttroca(<texto>, <valor anterior>, <novo valor>)
    Troca <valor anterior> por <novo valor> no <texto>.
    Retorna o texto modificado ao invés de alterar o texto original.
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever txttrocadif ao invés de txttroca.
    Nota: Se <valor anterior> for um texto vazio, retorna <texto>.
    Exemplo:
    txttroca("possibilidade", "i", "e") é o mesmo que "possebeledade".

vartroca(<texto>, <texto2>, <variável>)
    Procura nomes de variáveis do objeto "este" que começam com <variável>.
    Troca <variável> por <texto2> e procura por isso em <texto>.
    Substitui pelos respectivos valores das variáveis.
    Exemplo:
      const t_1 = "joão"  # $1 = joão
      const t_2 = "maria" # $2 = maria
      vartroca("$1 falou com $2", "$", "t_")
                  # Produz o texto "joão falou com maria"
    Quando vartroca chama uma função, coloca em arg0 o texto encontrado.
    Exemplo de como diferenciar letras maiúsculas de minúsculas:
      func teste_a
        se arg0 == "A" # Se for exatamente igual
          ret "A maiúsculo"
        senão
          ret "A minúsculo"
      vartroca("$A $a", "$", "teste_")
                  # Produz o texto "A maiúsculo A minúsculo"
    Outra forma de escrever:
      const teste_a = t_a[arg0=="A"]
      const t_a0 = "A maiúsculo"
      const t_a1 = "A minúsculo"
      vartroca("$A $a", "$", "teste_")

criar(<nome da classe>)
criar(<nome da classe>, <argumentos da função ini>)
    Cria um objeto e chama a função ini do objeto.
    Entrada: texto que contém o nome da classe.
    Retorna: uma referência para o objeto, ou nulo se classe não existe.
    Exemplos:
    ref x
    x = criar("teste1")
    criar("teste2")

apagar(<objeto>)
    Marca um objeto para ser apagado. O objeto só será realmente apagado
    após o controle retornar ao programa. Mesmo assim, antes de apagar
    ainda será chamada a função fim do objeto.
    Entrada: referência para o objeto.
    Exemplo:
    apagar(este)

$ seguido do nome da classe
    Retorna o primeiro objeto da classe especificada.
    Exemplos: $jog  ou  $["jog"]

objantes(<objeto>)
    Retorna o objeto anterior da classe ou NULO se não houver.

objdepois(<objeto>)
    Retorna o próximo objeto da classe ou NULO se não houver.

inttotal(<variável>)
    Se for objeto, retorna a quantidade de objetos da classe.
    Se for texto, retorna o tamanho do texto em caracteres.
    Se for vetor, retorna a quantidade de variáveis do vetor.
    Se for fornecido mais de um argumento, é retornada a soma.
    Exemplo: inttotal(a,b)
    É o mesmo que: inttotal(a) + inttotal(b)


*** Funções existentes em vetores de variáveis txt1 a txt512:

limpar
    Limpa todas as variáveis do vetor (faz todas as variáveis = "").
    Exemplo:
    txt10 x.3
    x.limpar
    É o mesmo que:
    txt10 x.3
    x.0 = ""
    x.1 = ""
    x.2 = ""

texto
texto( <número da primeira variável> )
texto( <número da primeira variável> , <número da última variável> )
    Retorna um texto que corresponde a todas as variáveis concatenadas
    Exemplo:
    txt10 x.3
    x.0 = "a"
    x.1 = "b"
    x.2 = "c"
    msg(x.texto) # É o mesmo que msg("abc")
    msg(x.texto(0,1)) # É o mesmo que msg("ab")

palavras( <texto> )
palavras( <texto> , <número de palavras> )
    Divide o texto em palavras.
    As palavras são separadas por espaço ou "\n".
    Retorna o número de palavras (pode ser zero).
    Exemplo:
    txt10 x.2
    x.palavra("bom dia !")
    É o mesmo que:
    txt10 x.2
    x.0 = "bom"
    x.1 = "dia !"

linhas( <texto> )
linhas( <texto> , <número de colunas> )
    Preenche as variáveis do vetor com o texto, da seguinte forma:
    Cada variável recebe uma linha do texto (o caracter "\n" indica
    o fim de uma linha).
    Linhas que não cabem em uma variável são divididas automaticamente,
    de preferência no último espaço entre <número de colunas> e o tamanho
    da variável.
    Retorna o número de linhas (pelo menos uma linha).

separar( <texto> , <delimitador> )
separar( <texto> , <delimitador> , <número de textos> )
    Divide o texto com o delimitador especificado.
    Cada variável do vetor recebe um texto.
    A última variável recebe o restante do texto.
    Retorna o número de variáveis (pelo menos uma variável).
    Para diferenciar letras minúsculas de maiúsculas e acentuadas de
    não acentuadas, escrever separardif ao invés de separar.
    Exemplo:
    txt10 x.4
    x.separar("abc:10::def:20", ":")
    É o mesmo que:
    txt10 x.4
    x.0 = "abc"
    x.1 = "10"
    x.2 = ""
    x.3 = "def:20"

juntar( <delimitador> )
juntar( <delimitador> , <número de variáveis> )
    Concatena o número de variáveis do vetor especificadas, acrescentando
    o delimitador entre duas variáveis. Retorna o texto obtido.
    Exemplo:
    x.juntar(",", 3) é o mesmo que:
    x.0 + "," + x.1 + "," + x.2


*** Caracteres especiais

\n significa fim de uma linha de texto (deve passar para a próxima linha).

Para conseguir cores usa-se os caracteres \b, \c e \d nas mensagens:
    \b define cor dos caracteres: branco com fundo preto
    \c seguido de um dígito: define a cor dos caracteres
    \d seguido de um dígito: define a cor de fundo

O dígito após \c e \d pode ser:
    0 = preto           4 = azul
    1 = vermelho        5 = magenta
    2 = verde           6 = ciano
    3 = marrom          7 = branco

Somente após \c:
    8 = cinza               C = azul intenso
    9 = vermelho intenso    D = magenta intenso
    A = verde intenso       E = ciano intenso
    B = amarelo             F = branco intenso


*** Outros tipos de variáveis

Constituem uma extensão do programa interpretador. Algumas permitem
a comunicação com o mundo externo, outras possibilitam mais recursos.

Possuem funções/variáveis e podem gerar eventos (executar funções
do objeto em que pertencem).

Definição de um tipo:
<tipo de variável>  <nome da variável>
Exemplo:  listaobj x

Executar uma função:
<nome da variável>.<função>
Exemplos:
x.limpar
x.addini(este)

Eventos (funções chamadas pela variável):
func <nome da variável>_<nome do evento>
Exemplo, uma função teste para a variável x, acima, pode ser definida como:
func x_teste


*** Lista de variáveis

listaobj <nomedavariável>
    Lista de objetos.
    Um objeto pode ser adicionado várias vezes em uma lista.
    Como valor numérico, é 0 se a lista estiver vazia ou 1 se não estiver.
    Quando um objeto é apagado, é executada a função apagaobj de todas
    as variáveis listaobj do objeto.

    Possui as seguintes funções:
    addini( <objeto> )
        Adiciona no topo da lista.
        Retorna o item adicionado da lista (variável listaitem).
    addfim( <objeto> )
        Adiciona no final da lista.
        Retorna o item adicionado da lista (variável listaitem).
    remove( <objeto> )
        Retira primeira ocorrência do objeto da lista.
    limpar
        Retira todos os objetos da lista.
    possui( <objeto> )
        Retorna 1 se objeto está na lista ou 0 se não está.
    apagaobj
        Marca todos os objetos da lista para exclusão, usando a função apagar()
    objx
        Objeto que contém a lista; pode ser NULO.
    ini
        Primeiro item da lista (variável listaitem).
        Nota: ini.obj = primeiro objeto da lista.
    fim
        Último item da lista (variável listaitem).
        Nota: fim.obj = último objeto da lista.

listaitem <nomedavariável>
    É usado para acessar os objetos de listaobj. Representa um objeto.
    Como valor numérico, é 1 se for um objeto ou 0 se não for.

    Possui as seguintes funções:
    add1( <objeto> )
        Adiciona objeto antes desse.
    add2( <objeto> )
        Adiciona objeto depois desse.
    antes
        Passa para o objeto anterior.
    antes( <número de objetos> )
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois( <número de objetos> )
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    remove
        Remove objeto da lista, listaitem passa a não ser um objeto válido.
    remove1
        Remove objeto da lista e passa para o anterior.
    remove2
        Remove objeto da lista e passa para o próximo.
    obj
        Objeto.
    objx
        Objeto que contém a lista; pode ser NULO.

    Exemplo:
    listaobj l
    listaitem i
    l.add1( este ) -> Adiciona no topo da lista
    l.add2( este ) -> Adiciona no final da lista
    l.remove( l.ini.obj ) -> remove um objeto da lista
    l.possui( este) -> retorna !=0 se objeto está na lista
    l.ini.obj -> é o primeiro objeto da lista
    l.fim.obj -> é o último objeto da lista
    i = l.ini  -> i é o primeiro item da lista
    enquanto i    -> Enquanto i for um objeto (não acabou a lista)
      i.obj.l = 1   -> Faz a variável l do objeto = 1
      i.depois      -> Passa para o próximo objeto
    efim

listatxt <nomedavariável>
    Define uma lista de textos.

    Possui as seguintes funções:
    limpar       -> limpa a lista
    add(texto)   -> adiciona texto na lista
    add(texto, quantidade) -> adiciona uma quantidade do texto na lista
    remove(texto)  -> remove texto da lista
    remove(texto, quantidade) -> remove uma quantidade de textos da lista
    procurar(texto)   -> procura mensagem que começa com o texto especificado
                        retorna o texto completo se encontrou,
                        ou um texto vazio se não encontrou
    total(texto)     -> retorna a quantidade de textos que estão na lista

    Exemplos:
    listatxt x
    txt10 texto
    int8  num
    x.add("bom dia")
    x.add("boa tarde", 10)
    texto = x.procurar("boa")
    num = x.total(texto)

listamsg <nomedavariável>
    Lista de textos, para ser enviados a um usuário
    Possui as seguintes funções:
    limpar
        Limpa a lista
    add(<texto>)
        Adiciona texto na lista.
    add(<texto>, <separador>, <quantidade máxima>)
        Divide <texto> vários textos, separados pelo <separador>.
        <quantidade máxima> é a quantidade máxima de textos após a divisão.
        Em seguida adiciona esses textos na listamsg.
        Exemplo:
            listamsg x
            x.add("bom dia boa tarde", " ", 3)
        É o mesmo que:
            listamsg x
            x.add("bom")
            x.add("dia")
            x.add("boa tarde")
    remove(<quantidade de linhas>)
        Retorna um texto que contém uma quantidade de linhas; retira essas
        linhas da listamsg
    linha(<número da linha>)
        Retorna o texto da linha especificada. O primeiro texto adicionado
        corresponde à linha 0.

nomeobj <nomedavariável>
    Usado para obter um ou mais objetos, correspondente ao que o usuário
    digitou.
    Funções:
    ini( <texto> , <quantidade> )
        Inicia a busca.
        <texto> é o nome procurado (geralmente o que o usuário digitou).
        Exemplo: "poção"
        Pode-se digitar o número do objeto, escrevendo um número seguido
        de ponto e um nome. Exemplo: "2.poção" corresponde à segunda poção.
        Pode-se digitar também a quantidade, se for mais de um.
        Exemplo: "10 poção"
        <quantidade> é a quantidade máxima de objetos que podem ser
        encontrados. Exemplo, se não for desejável processar mais de 10
        objetos, <quantidade> deve ser o número 10.
    nome( <texto> )
    nome( <texto>, <texto2>, ..., <textoN> )
        <texto> contém um ou mais nomes (separados por espaço) correspondentes
        a um objeto. Exemplo, "chave chave_verde" significa um objeto que
        pode ser referenciado por esses dois nomes: chave e chave_verde.
        Essa função retorna 1 se for o objeto procurado ou 0 se não for.

    Exemplo com as duas funções:
    nomeobj x
    x.ini("2.ch", 5)# Achar no máximo 5 itens que começam com "ch"
                    # No entanto, como o texto é "2.ch", procurará só o segundo
    x.nome("bolsa") # Retorna 0 porque não é o item procurado
    x.nome("chave_azul")  # Retorna 0; não é o segundo item que começa com ch
    x.nome("chave_verde") # Retorna 1
    x.nome("chave_azul")  # Retorna 0 porque já encontrou o item

arqlog <nomedavariável>
    Para gravar mensagens em arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.

    Funções:
    abrir( <nome do arquivo> )
        Abre arquivo, cria se não existir.
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu.
        Nota 1: O nome do arquivo sempre terminará com ".log".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível criar arquivos em outros lugares.
    msg( <texto> )
        Grava texto em uma nova linha, no final do arquivo.
        Nota 1: Definições de cores e linhas vazias não são gravadas.
        Nota 2: Pode demorar até 2 segundos para o texto ser realmente
                gravado no arquivo.
    fechar
        Fecha o arquivo.

arqsav <nomedavariável>
    Para salvar objetos em arquivos e recuperar posteriormente.
    Nota 1: O nome do arquivo sempre terminará com ".sav".
    Nota 2: O arquivo deve pertencer ao diretório atual ou a um
    subdiretório dele. Não é possível criar arquivos em outros lugares.

    valido(<nome do arquivo>)
        Retorna 1 se <texto> for nome válido para arquivo ou 0 se não for.
    existe(<nome do arquivo>)
        Retorna 1 se arquivo existe ou 0 se não existe.
    senha(<nome do arquivo>, <senha>)
        Retorna 1 se senha correta ou 0 se incorreta.
    dias(<nome do arquivo>)
        Retorna quantos dias faltam para o arquivo expirar.
        Retorna 0 se expirou, -1 se nunca expira.
    ler(<nome do arquivo>, <listaobj>)
    ler(<nome do arquivo>, <listaobj>, <quantidade máxima de objetos lidos>)
        Lê Arquivo.
        O primeiro objeto do arquivo vai para o primeiro da listaobj.
        O segundo do arquivo vai para o segundo da listaobj, e assim por
        diante. Se a listaobj tiver menos objetos que o arquivo, serão
        criados objetos na listaobj.
        Retorna a quantidade de objetos lidos.
    salvar(<nome do arquivo>, <listaobj>, <dias>, <senha>)
        Salva em arquivo todos os objetos de uma listaobj.
        <dias> é a quantidade de dias para apagar o arquivo, 0=nunca apagar
        Retorna 1 se conseguiu salvar ou 0 se não conseguiu.
    apagar(<nome do arquivo>)
        Apaga arquivo.
        Retorna 1 se conseguiu apagar ou arquivo não existia.
        Retorna 0 se não conseguiu apagar.
    limpar(<nome do diretório>)
        Inicia checagem dos arquivos .sav no diretório especificado; apaga
        arquivos que expiraram. Os arquivos são verificados aos poucos para
        ficar transparente aos usuários.
        Retorna 1 se conseguiu ou 0 se diretório não permitido.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual, em segundo plano
    limpar
        Checa todos os diretórios pendentes de uma vez, ao invés de checar
        aos poucos, em segundo plano.
        Exemplo:
        arqsav sav
        sav.limpar(".") # Inicia checagem do diretório atual
        sav.limpar # Checa todos os arquivos de uma vez

arqtxt <nomedavariável>
    Para ler ou gravar arquivos de texto.
    Como valor numérico, é 1 se o arquivo estiver aberto ou 0 se não estiver.
    Nota: A escrita em arquivo não é tão eficiente quanto arqlog.

    Funções:
    abrir( <nome do arquivo>, <modo> )
        Abre arquivo. Retorna 1 se conseguiu ou 0 se não conseguiu.
        Modo pode ser:
        0 = somente leitura
        1 = leitura e escrita
        2 = somente escrita; o tamanho do arquivo é truncado para 0 bytes
        3 = para escrever no final do arquivo
        Os modos 0 e 1 não criam um novo arquivo, caso ele não exista.
        Nota 1: O nome do arquivo sempre terminará com ".txt".
        Nota 2: O arquivo deve pertencer ao diretório atual ou a um
        subdiretório dele. Não é possível acessar arquivos de outros lugares.
    fechar
        Fecha o arquivo.
    truncar( <arquivo> , <tamanho> )
        Trunca o tamanho de um arquivo no tamanho especificado.
        Retorna 1 se conseguiu ou 0 se não conseguiu.
        Exemplo: truncar("a.txt", 0) limpa o conteúdo do arquivo a.txt
    msg( <texto> )
        Escreve texto no arquivo.
        Se for especificado mais de um texto, serão concatenados no arquivo.
        Exemplo, escr("ab", "\n") é o mesmo que escr("ab\n")
    fflush
        Grava em arquivo as alterações pendentes.
    ler
        Lê uma linha do arquivo; retorna a linha lida sem o \n no final.
        Pode ler menos se chegou no fim do arquivo.
    ler( <tamanho> )
        Lê um determinado número de caracteres do arquivo.
        Pode ler menos se chegou no fim do arquivo.
        Exemplo: ler(1) lê um caracter.
    pos
        Retorna a posição atual no arquivo (0=está no início do arquivo).
    pos( <posição> , <modo> )
        Muda a posição atual no arquivo. Modo pode ser:
        0 = a partir do início do arquivo
        1 = a partir da posição atual
        2 = a partir do fim do arquivo
    eof
        1 se chegou no fim do arquivo, 0 se não chegou.

inttempo <nomedavariável>
    Uma variável inteira de 0 a 65535, subtraída 1 a cada décimo de segundo.
    A diferença de inttempo para intdec é que quando chega a 0, uma função
    do objeto é executada. O nome da função é <nomedavariável>_exec.
    Na função: arg0 = índice da variável vetor, se não for vetor arg0=0

    Exemplo:
    [x]
    inttempo n
    func n_exec
      # Essa função é executada quando a variável n chegar a zero

socket <nomedavariável>
    Quando o socket está conectado à janela do programa:
    A janela possui 25 linhas de 80 colunas, sendo que a última linha
    sempre corresponde ao que o usuário está escrevendo.
    Como valor numérico, é 1 se proto!=0 (está conectado) ou 0 se proto=0.
    Nota: uma conexão pode ser copiada de um objeto socket para outro.
    Nesse caso, os eventos são gerados em mais de uma variável socket.

    Funções e variáveis:
    proto
        Define o protocolo; um número com o significado:
        0 = não está conectado
        1 = conectando
        2 = Telnet
        3 = IRC
        4 = Papovox (sem cores)
        5 = janela do programa
        Nota: pode-se mudar entre 2 e 4 para socket conectado
    cores
        0 = nenhuma cor
        1 = cores somente ao receber
        2 = cores somente ao enviar
        3 = cores ao enviar e receber
    aflooder
        O anti flooder impede o recebimento de muitas mensagens ao mesmo tempo.
        0 desativa o anti flooder, outro valor ativa.
    eco
        Define se o que o usuário digitar deve ser ecoado na tela.
        0 não ecoa, 1 ecoa. Não tem efeito em IRC e Papovox.
    posx
        Posição do cursor: quantos caracteres enviou após o último \n.
        Caracteres especiais, como definição da cor, não contam.
    ip
        Endereço IP correspondente a quem está conectado.
    iplocal
        Endereço IP local.
    abrir(<endereço>, <porta>)
        Tenta conectar-se a um endereço.
        Retorna 1 se conexão em progresso ou 0 se ocorreu erro
        (0 geralmente significa endereço inválido)
    abrir("tela")
        Conecta à janela do programa. Cada linha recebida gera um evento _msg.
    fechar
        Encerra a conexão; não gera o evento fechou.
    colmin
    colmax
        Essas duas variáveis são números de 10 a 1000.
        Atuam nas mensagens enviadas ao socket, dividindo linhas grandes
        em duas ou mais. Isso é feito colocando "\n" no meio da mensagem.
        Colmin e colmax são os tamanhos mínimo e máximo das linhas.
        O programa tenta dividir sempre onde houver um caracter espaço.
    msg( <mensagem> )
        Envia mensagem para o socket.
        Retorna 1 se conseguiu enviar ou 0 se buffer cheio.
        Nota: Se o protocolo for Papovox, devido às limitações do Papovox,
        é acrescentado \n no final da mensagem se já não houver um \n.

    Eventos:
    <nomedavariável>_msg
        Recebeu mensagem
        arg0 = mensagem recebida
        arg1 = índice da variável vetor, se não for vetor arg1=0
    <nomedavariável>_env
        Todas as mensagens foram transmitidas (buffer de transmissão
        ficou vazio).
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_fechou
        O socket foi fechado remotamente
        arg0 = índice da variável vetor, se não for vetor arg0=0
        Se essa função não existir, o objeto que contém o socket é apagado
    <nomedavariável>_con
        Conseguiu conectar
        arg0 = índice da variável vetor, se não for vetor arg0=0
    <nomedavariável>_err
        Não conseguiu conectar
        arg0 = mensagem de erro
        arg1 = índice da variável vetor, se não for vetor arg1=0

serv <nomedavariável>
    Funções:
    abrir(endereço, porta)
        Abrir para receber conexões
        Se não quiser especificar um endereço, colocar "" no endereço
        Retorna 1 se conseguiu abrir ou 0 se não conseguiu
    fechar
        Deixa de receber conexões

    Eventos:
    <nomedavariável>_socket
    arg0 = socket correspondente à conexão
    arg1 = índice da variável vetor, se não for vetor arg1=0

    Exemplo de uso com socket:
    [x]
    comum serv servidor
    socket conec
    func iniclasse
      x:servidor.abrir("", 2000)
    func servidor_socket
      ref novo
      novo = criar("x")
      novo.conec = arg0
      novo.conec.msg("Benvindo\n")
    func conec_msg
      conec.msg("você escreveu " + arg1 + "\n")

prog <nomedavariável>
    Para ler e alterar o próprio programa (o mapa).
    Nota: pode ser usado um objeto no lugar do nome de uma classe.

    As próximas funções iniciam uma consulta e retornam 1 se há algum
    resultado (pelo menos uma linha) para a consulta ou 0 se não há.
    iniclasse
    iniclasse(<texto>)
        Obter os nomes das classes que começam com o texto especificado.
        Em ordem alfabética.
    inifunc(<nome da classe>)
    inifunc(<nome da classe>, <texto>)
        Obter os nomes das funções e variáveis definidas em uma classe.
        Somente as variáveis e funções que começam com o texto especificado.
        Em ordem alfabética.
    inifunctudo(<nome da classe>)
    inifunctudo(<nome da classe>, <texto>)
        Mesmo que inifunc, mas inclui também as variáveis e funções herdadas.
    iniherda(<nome da classe>)
        Obter os nomes das classes definidas na instrução "herda".
        Na ordem definida na classe.
    iniherdatudo(<nome da classe>)
        Obter a lista de classes herdadas por uma classe.
        Inclui também as classes herdadas indiretamente.
        Na ordem em que as classes são herdadas.
    iniherdainv(<nome da classe>)
        Herança inversa: obter os nomes das classes que herdam uma classe.
        A ordem em que as classes são listadas é imprevisível.
    inilinha(<nome da classe>)
        Obter as linhas correspondentes a uma classe.
    inilinha(<nome da classe>, <nome da função>)
        Obter as linhas correspondentes a uma variável ou função da classe
        (definida na classe ou herdada).

    As próximas funções permitem ler o resultado da consulta.
    lin
        É 1 se linha válida ou 0 se chegou no fim da consulta.
    depois
        Vai para a próxima linha.
    depois( <número de linhas> )
        Avança o número de linhas especificado.
        Nada faz se o número for menor ou igual a zero.
    texto
        Retorna o texto da linha atual.
    nivel
        Retorna um número, que é o nível de indentação. Usado somente com
        iniclasselin e inifunclin.

    As próximas funções funcionam independente das demais.
    existe(<nome da classe>)
        Retorna 1 se a classe existe ou 0 se não existe.
    existe(<nome da classe>, <nome da variável>)
        Retorna 1 se a variável ou função existe ou 0 se não existe.
    vartipo(<nome da classe>, <nome da variável>)
        Retorna o tipo de variável ou "" se a variável não existe.
    varnum(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante numérica do tipo:
        const variável = valor numérico
        ou 0 se não for.
    vartexto(<nome da classe>, <nome da variável>)
        Retorna 1 se for constante de texto do tipo:
        const variável = "texto"
        ou 0 se não for.
    varcomum(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for comum ou 0 se não for.
    varsav(<nome da classe>, <nome da variável>)
        Retorna 1 se variável for sav ou 0 se não for.
    varvetor(<nome da classe>, <nome da variável>)
        Retorna a quantidade de variáveis do vetor ou 0 se não for vetor.
    varlocal(<nome da classe>, <nome da variável>)
        Retorna 1 se variável estiver definida na própria classe
        (não foi herdada) ou 0 se não estiver.
    const(<nome da classe>, <nome da variável>)
        Retorna o texto de uma variável constante do tipo:
        const variável = valor    (nesse caso retorna valor)
        const variável = "texto"  (nesse caso retorna texto)
        Retorna um texto vazio para outros tipos de variáveis.

    As próximas funções permitem alterar o programa. Porém, as alterações
    só serão efetuadas quando o controle retornar ao IntMUD.
    apagar(<classe>)
    apagar(<classe>, <variável>)
        Apaga classe ou variável.
        Retorna: 1=sucesso, 0=falha (classe ou variável não existe)
    criar(<texto>)
        Cria uma classe. Se já existia, apaga todas as instruções antes.
        A primeira linha é o nome da classe.
        A segunda linha de <texto> é o prefixo do arquivo.
            Exemplo, "abc" corresponde ao arquivo "intmud-abc.map".
            Um texto vazio corresponde ao arquivo "intmud.map".
        Da terceira linha em diante são as instruções (o contéudo da classe).
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplo:
            prog p
            p.criar("abc\n\nint8 x\nconst n = 10")
        Cria a seguinte classe no arquivo intmud.map:
            [abc]
            int8 x
            const n = 10
        Para criar a mesma classe, mas no arquivo intmud-x.map:
            p.criar("abc\nx\nint8 x\nconst n = 10")
    criar(<nome da classe>, <texto>)
        Cria uma função ou variável de uma classe.
        Se já existia, antes apaga a função ou variável.
        <texto> contém todas as instruções da função ou variável.
        Se houver mais de uma linha, usar \n para separar as linhas.
        A primeira linha deve conter o nome e o tipo.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
        Exemplos:
            prog p
            p.criar("abc", "int8 n") # Cria a variável n na classe abc
            p.criar("xyz, "func x\nret 10") # cria a função x na classe xyz
    apagarlin(<nome da classe>, <número da linha>)
    apagarlin(<nome da classe>, <nome da variável>, <número da linha>)
        Apaga uma linha de uma classe ou variável.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    criarlin(<nome da classe>, <linha inicial>, <texto>)
    criarlin(<nome da classe>, <nome da variável>, <linha inicial>, <texto>)
        Adiciona linhas na classe ou variável especificada.
        Nota: A primeira linha é a número 1.
        Retorna um texto vazio se conseguiu criar ou a mensagem de erro
        se não conseguiu.
    salvar
    salvar( <texto> )
        Salva as alterações nos arquivos correspondentes, depois que todas
        as alterações pendentes nas classes forem efetuadas.
        O texto é composto de letras seguidas de números, que indicam como
        o arquivo deve ser salvo. As opções são as seguintes:
        I = espaços usados para indentação, de 0 a 8
        C = linhas entre classes, de 0 a 10
        F = linhas vazias entre funções, de 0 a 10
        V = linhas vazias entre variáveis e constantes, de 0 a 10
        A função salvar sem parâmetros é o mesmo que: salvar("I2C1F1V0")
        que significa 2 espaços para indentação, 1 linha vazia entre classes
        e entre funções e nenhuma linha vazia entre variáveis.
    salvartudo
    salvartudo( <texto> )
        Mesmo que a função salvar, porém salva todos os arquivos,
        independete de terem sido alterados ou não.

indiceobj <nomedavariável>
    É semelhante a uma variável txt64, porém o texto é associado ao objeto
    que contém essa variável. O processo inverso, obter um objeto a partir
    de um texto, é possível com a variável indiceitem.

indiceitem <nomedavariável>
    Permite obter os objetos que contém uma variável indiceobj com um
    determinado texto. Ignora variáveis indiceobj com texto nulo.

    Possui as seguintes funções:
    ini( <texto> )
        Vai para o primeiro objeto com o texto ou parte dele.
    fim( <texto> )
        Vai para o último objeto com o texto ou parte dele.
    antes
        Passa para o objeto anterior.
    antes( <número de objetos> )
        Recua o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    depois
        Passa para o próximo objeto.
    depois( <número de objetos> )
        Avança o número de objetos especificado.
        Nada faz se o número for menor ou igual a zero.
    obj
        Objeto.
    txt
        Texto associado ao objeto.
    obj( <texto> )
        Objeto que contém o texto exato.
        Essa função funciona independente das demais.

    Nota: Pode-se passar mais de um texto para as funções que possuem texto.
    Nesse caso, a função procurará por todos os textos.


*** Nota - Cores no protocolo Telnet

ESC [
Seguido de números, separados por ';'
Termina com um m
    ESC=0x1B
    0 = cores padrão
    1 = ativa negrito
    3x = cor de frente = x
    4x = cor de fundo = x


*** Nota - Cores no protocolo do IRC

Definição de cores:
    Ctrl-C       (1 byte)  -> Limpa a definição de cores
    Cltr-C N     (2 bytes)
    Ctrl-C NN    (3 bytes)
    Ctrl-C N,M   (4 bytes)
    Ctrl-C N,MM  (5 bytes)
    Ctrl-C NN,M  (5 bytes)
    Ctrl-C NN,MM (6 bytes)
Onde Ctrl-C é o caracter \x03 e M e N é um dígito de 0 a 9
N é a cor de frente, M é a cor de fundo (ausente significa padrão)
As cores padrão são letras pretas sobre um fundo branco.
Se o texto após a definição começar com um dígito de 0 a 9,
deve ser usada uma das definições:
    Ctrl-C N,MM  (5 bytes)
    Ctrl-C NN,MM (6 bytes)
Lista de cores:
    0 white                    8 yellow
    1 black                    9 lt.green (lime)
    2 blue     (navy)          10 teal    (a kinda green/blue cyan)
    3 green                    11 lt.cyan (cyan ?) (aqua)
    4 red                      12 lt.blue (royal)
    5 brown    (maroon)        13 pink    (light purple) (fuchsia)
    6 purple                   14 grey
    7 orange   (olive)         15 lt.grey (silver)
Referências:
    http://www.ircle.com/colorfaq.shtml
    http://www.mirc.co.uk/help/color.txt
