classe comum_perso
herda comum_persoitem
# Personagem sem estrutura de batalha
const perso = 1 # Para identificar que é personagem
comum listaobj objsolto # Lista de personagens soltos (não pertencem a outros)
sav int1 sexo # Sexo: 0=feminino, 1=masculino
const sexoini = 2 # Sexo inicial: 0=feminino, 1=masculino, 2=aleatório
const nome = "sem nome"
const ident = nome
const volexp = 1 # Volume expande se tiver itens dentro
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const jogsav = 1 # Se deve salvar o personagem ao salvar personagem do jogador
const objmax = 15 # Quantos itens pode carregar
const luztipo = 1 # 1=não é fonte de luz, mas repassa a luz
sav uint16 pnivel # Nível atual (apenas para mostrar ao jogador)
sav uint32 mortes # Quantas vezes morreu (chamou a função morreu)
inttempo p_espera # Tempo de espera para o próximo comando
sav uint8 posicao # Posição do personagem
const pospadr = 8 # Posição padrão do personagem
listaitem poslugar # Em qual móvel está sentado ou deitado
int1 jogconfig.24 # Mesmo que sock.jogconfig
listaitem iseguir # Quem o personagem está segundo
listaobj lseguir # Quem está seguindo o personagem
sav listaitem iempu # Arma que que está empunhando
const p_morreu1 = "$P morreu."
const p_morreu2 = "$A de $p desmaiou."

func ini # Coloca o objeto dentro de outro
  posicao = pospadr, p_proc = 1, p_tmove = 80, pnivel = arg1 ? arg1 : nivel
  sexo = sexoini == 2 ? rand(2) : sexoini
  se arg2 || inivar
    textotxt t
    epara t.addfim(txttroca(txt(arg2) + "\n" + inivar, ",", "\n")), t.linhas, var.mudar(t.remove)
    efim
  fimse
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)
  dono && !dono.perso && objsolto.addfim(este)
  epara nulo, var.ini("e_"), var.mudar(var.ini("e_"))
    criar(var.ini("e_"), este, var.valor(var.ini("e_")))
  efim
  recalc_exec

func fim # Objeto foi apagado
  se sock # Se estiver ligado a um jogador
    casovar txt1(sock.info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(sock)
      sair
    casose "l" # Jogando localmente
      terminar
    casose "b" # Como bot
      sock.reinicia
    casofim
    sock.perso = nulo # Desliga-se do jogador
    sock = nulo
  fimse
  batalhafim, comum_obj:fim
  epara nulo, lseguir, lseguir.ini.remove
    lseguir.objini.msg("Você pára de seguir " + nome + ".")
  efim

func mudadono # Coloca personagem em outra sala (arg0 = nova sala)
# Muda de sala
  atkrec.limpar, poslugar.remove, dono = arg0, cmd_mudadono
# Eventos cmd_saiu e variável donoantes.s_item
  listaobj l
  se donoantes && !donoantes.perso
    epara l.addfim(evento, donoantes.evento), l, l.ini.remove
      l.objini.cmd_saiu(este, donoantes)
    efim
    se !sock
    senao donoantes.dentro1.total && !donoantes.socktot
      donoantes.t_item = donoantes.s_item * 600
    senao
      donoantes.t_item = 0
    fimse
  fimse
# Checa se novo dono é sala
  se dono.perso
    p_proc = 1
    ret
  fimse
# Eventos cmd_chegou
# (sock || jog) && $reset.sala(dono, dono.s_reset) + dono.cmd_salaperso(este)
  (sock || jog) && dono.s_reset1 + dono.cmd_salaperso(este)
  epara l.addfim(evento, arg0.evento), l, l.ini.remove
    l.objini.cmd_chegou(este, arg0)
  efim
# Se for jogador, checa se tem personagens agressivos na sala
  se jog
    dono.s_retornar >= 2 && (!var.z_salafim || dono.s_retornar == 3) && (var.z_salafim = \
dono)
    epara l.addfim(arg0.dentro2), l, l.ini.remove
      l.objini.p_agressivo(este) == 2 && (l.objini.p_proc = 1)
    efim
  fimse
# Mostra descrição (jogador) ou processamento do personagem (não jogador)
  se !sock
    p_proc = 1
  senao dono.s_ocultar
    dono.t_item = 0
  senao
    dono.t_item = 0
    se jogconfig.16
      msg2(txt(dono, 2) + "  " + dono.descsala(este, (jogconfig.bits & 3) + 4))
    senao
      msg2(dono.descsala(este, (jogconfig.bits & 3) + 4))

func teclou # Processa comando (arg0=comando)
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  prog p # Para procurar o objeto
  ret !arg0, nulo
# Obtém o comando
  enquanto 1
    sair obj = $cmd_[txt1(arg0)].objcmd(este, arg0) # Checa comando exato
    sair obj = $soc_[txt1(arg0)].objcmd(este, arg0) # Checa social exato
    sair obj = $cmdfim_[txt1(arg0)].objcmdfim(este, arg0) # Checa comando exato
    epara p.iniclasse("cmd_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair obj
    epara p.iniclasse("soc_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair obj
    epara p.iniclasse("cmdfim_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair
  efim
# Checa se é magia
  se obj.lancamagia
    txt200 lin
    lin = txtremove(txt2(arg0), "EMDSA")
    obj = ref($magia_[txt1(lin)].objcmd(este, arg0))
    se !obj && lin
      epara p.iniclasse("magia_" + txt1(lin)), p.lin, p.depois
        sair obj = $[p.texto].objcmd(este, arg0)
      efim
    fimse
# Magia: Gera eventos
    listaobj l
    epara l.addfim(este.evento), l, l.ini.remove
      ret l.objini.cmd_escr(este, arg0, obj), nulo
    efim
# Magia: Executa comando
    se dono.s_semmagia
      msg("Você não consegue lançar magias aqui.")
    senao !lin
      msg("Lançar que magia?")
    senao !obj
      msg("Você não possui a magia " + lin)
    senao posicao < obj.posic
      msg(erropos)
    senao
      obj.escr(este, txt2(lin))
    fimse
    ret
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(este.evento), l, l.ini.remove
    ret l.objini.cmd_escr(este, arg0, obj), nulo
  efim
# Executa comando
  se !obj
    msg("O quê?")
  senao posicao < obj.posic
    msg(erropos)
  senao
    obj.escr(este, txt2(arg0))

func p_espera_exec # Pega o próximo comando
  sock ? sock.espera_exec : p_proc_exec

func erropos # Retorna uma mensagem conforme a posição
  casovar posicao
  casose "0"
    ret "\c9Você está mort" + misc:sletra[sexo] + "!!!\b"
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    ret "\c9Você está muito mal, incapaz de fazer qualquer coisa.\b"
  casose "3" # Fraco
    ret "\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b"
  casose "4" # Dormindo
    ret "\c9Nos seus sonhos...\b"
  casose "5" # Descansando
    ret "\c9Você se sente relaxad" + misc:sletra[sexo] + " demais para fazer isso.\b"
  casose "6" # Sentado
    ret "\c9Talvez você deva ficar em pé primeiro.\b"
  casose "7" # Lutando
    ret "\c9Sem chance! Você está lutando pela sua vida.\b"
  casose
    ret "\c9Você tenta, mas não consegue.\b"
  casofim

func descpos
  ret posicao == pospadr && descpadr, descpadr
  casovar posicao
  casose "0"
    ret txtcopiamai(nome, "A") + " jás aqui."
  casose "1"
    ret txtcopiamai(nome, "A") + " está aqui mortalmente ferid" + misc:sletra[sexo] + "."
  casose "2"
    ret txtcopiamai(nome, "A") + " está aqui incapacitad" + misc:sletra[sexo] + "."
  casose "3"
    ret txtcopiamai(nome, "A") + " está aqui, muito frac" + misc:sletra[sexo] + "."
  casose "4"
    ret !poslugar, txtcopiamai(nome, "A") + " dorme aqui."
    ref r
    r = poslugar.objlista
    ret txtcopiamai(nome, "A") + " dorme em " + misc:sum[r.sexo] + " " + r.nome + "."
  casose "5"
    ret !poslugar, txtcopiamai(nome, "A") + " descansa aqui."
    ref r
    r = poslugar.objlista
    ret txtcopiamai(nome, "A") + " descansa em " + misc:sum[r.sexo] + " " + r.nome + "."
  casose "6"
    ret !poslugar, txtcopiamai(nome, "A") + " está sentad" + misc:sletra[sexo] + "aqui."
    ref r
    r = poslugar.objlista
    ret txtcopiamai(nome, "A") + " está sentad" + misc:sletra[sexo] + " em " + misc:sum[r.sexo] \
+ " " + r.nome + "."
  casose "7"
    ret txtcopiamai(nome, "A") + " está lutando."
  casose "8"
    ret txtcopiamai(nome, "A") + " está em pé aqui."
  casofim
  ret txtcopiamai(nome, "A") + " está aqui."

func msgvis # Mensagem se o jogador estiver vendo o alvo
  se sock && posicao > 4 && $mens.perso.visivel(este) # Se tem jogador e está acordado
    msg($mens.proc(arg0, este))

func msginv # Mensagem mesmo se o alvo estiver invisível
  se sock && posicao > 4 # Se tem jogador e está acordado
    msg($mens.proc(arg0, este))

func morreu # Procedimentos quando morre
# Checa se pode morrer
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este), nulo
  efim
# Morreu
  mortes += 1
  p_morreu1 && $mens.p(este, dono) + $mens.mtodos1(p_morreu1)
  apagar(este)
  ref r
  r = sock, r.mudaperso(nulo), r.reinicia
# Gera eventos
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este)
  efim


classe comum_persobat
herda comum_perso
# Personagem que pode batalhar
const perso = 2 # Para identificar o tipo de personagem
const objmax = 1 # Quantos itens pode carregar
const pesoadd = !dono.perso && !(bitver & 48) # Se falso, está voando
const p_agressivo = 1 # Ataca se atacarem
#
const expmax = pnivel * pnivel + 20 # Experiência para subir de nível
sav uint32 expatual # Experiência atual
sav uint16 pnivel # Nível atual
sav uint32 pvida # Pontos de vida
sav uint32 pmana # Pontos de mana
sav uint32 pmove # Pontos de movimento
uint32 pvidamax # Quantidade máxima de vida
uint32 pmanamax # Quantidade máxima de mana
uint32 pmovemax # Quantidade máxima de movimento
uint16 pveloc1 # Velocidade calculada do personagem
const pveloc = pveloc1 - int((pesoden - pesovest) / 1500)
uint32 atknorm # Quantidade de ataque normal
uint32 defnorm # Quantidade de defesa normal
uint32 atkesp # Quantidade de ataque especial
uint32 defesp # Quantidade de defesa especial
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
uint32 pesoveste # Metade do peso de tudo que está vestindo
uint32 pesomax # Quanto peso consegue carregar
const tipo1 = "normal" # Tipo de personagem
# const tipo2 = "" # Segundo tipo do personagem
# const tipo3 = "" # Terceiro tipo do personagem
int8 deftipo.18
# Defesa contra os diversos tipos de danos
# Vide função misc:atknomes
# somar 2 = dobra defesa
# subtrair 2 = reduz defesa pela metade
# 80 ou mais = imune ao tipo de golpe
#
const persobat = este # Personagem usado na batalha
const persoesc = este # Personagem escolhido
listaobj atkrec # Quem atacou esse personagem; dá experiência se perder
listaitem atkenv # Item de atkrec; atkenv.objlista = alvo do personagem
listaobj atkdiv # Para dividir experiência entre personagens que atacaram
inttempo atktempo # Tempo para completar um turno da batalha
uint8 atkturno # Turno da batalha, usado para decidir se encerra
inttempo p_proc # Para processar comportamento do personagem
intdec p_tmove # Quanto para se mover novamente
const p_movervel = 140

func ini # Objeto foi criado
  comum_perso:ini(arg0, arg1, arg2, arg3, arg4)
  p_restaura = 100
  pvida = pvidamax, pmana = pmanamax, pmove = pmovemax
  persobat = este, persoesc = este

func ataqueini # Testa se pode atacar
# Retorna "" se pode atacar ou a mensagem com o motivo se não pode
  se persobat.pvida == 0
    ret "Você está desmaiad" + misc:sletra[sexo]
  senao dono.s_luta == 0
    ret "Não é permitido brigas aqui"
  senao
    ret ""

func acertapos # Acerta posição
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
  casovar pvida * 100 / pvidamax
  casose "0"
  casose "1"
    se pvida
      poslugar.remove, posicao = 1 # mortalmente ferido
    senao
      poslugar.remove, posicao = 0, arg0 && morreu # morto
    fimse
    ret
  casose "2"
    poslugar.remove, posicao = 2 # incapacitado
    ret
  casose "3"
    poslugar.remove, posicao = 3 # fraco
    ret
  casose
    se atkenv
      poslugar.remove, posicao = 7 # lutando
    senao posicao < 4 || posicao == 7
      poslugar.remove, posicao = pospadr # posição padrão
    fimse
  casofim

func recalc_exec # Ajusta variáveis, principalmente batalha
# Acerta atributos básicos
  bitver = 1, bitinv = 3
  atknorm = pnivel * 13 + 26
  defnorm = pnivel * 10 + 20
  atkesp = pnivel * 13 + 26
  defesp = pnivel * 10 + 20
  pvidamax = pnivel * 20 + 40 # Equilibrado seria atknorm*atknorm/defnorm
  pveloc1 = pnivel * 5 + 20
  pmanamax = pnivel + 30
  pmovemax = pnivel * 2 + 30
  evasao = pnivel * 2 + 30
  precisao = pnivel * 2 + 30
  deftipo.limpar # Todas as defesas em 100%
  pesoveste = 0
  pesomax = 20000
# Acerta atributos conforme o tipo de personagem
  tipo_[tipo1]:recalc, tipo_[tipo2]:recalc, tipo_[tipo3]:recalc
# Bônus do próprio personagem
  cmd_recalc1(este)
# Bônus conforme o que está vestindo e os efeitos
  listaitem l
  epara l = dentro2.ini, l, l.depois
    l.obj.cmd_recalc2(este), pesoveste += l.obj.pesotot
  efim
  pesoveste /= 2
  epara l = evento.ini, l, l.depois
    l.obj.cmd_recalc3(este)
  efim

func batalhaini # Indica que atacou outro personagem (está batalhando)
# arg0 = alvo do personagem
  se atkenv.objlista != arg0 # Se o alvo do ataque mudou...
    atkenv.remove
    atkenv = arg0.atkrec.addfim(este)
    atkdiv.limpar
    atktempo = config:atktempo, atkturno = 0
    posicao >= 4 && (posicao = 7)
  fimse
  atkdiv.addfim1(persobat) # Adiciona personagem para ganhar experiência
  se !arg0.atkenv # Se o alvo não está batalhando...
    arg0.atkenv = atkrec.addfim(arg0)
    arg0.atkdiv.limpar
    arg0.atkdiv.addfim(arg0.persobat)
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
    arg0.posicao >= 4 && (arg0.posicao = 7)
  fimse
  se !config:atktipo # Se for batalha manual
    atktempo = config:atktempo, atkturno = 0
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
  fimse
  !p_proc && (p_proc = 1)
  arg0.p_proc = 1 # Para gerar evento de PNJs

func batalhafim # Encerra a batalha
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
  atkenv.remove, atktempo = 0, acertapos(arg0)
  ref r
  enquanto atkrec.ini
    r = atkrec.objini, atkrec.ini.remove, r.atktempo = 0, r.acertapos(arg0)
  efim

func batalhaexp # Dá experiência a quem estiver atacando o personagem
# arg0 = fator do ganho de experiência; se 0 retira toda experiência
  listaitem i
  listaobj l
# Preenche lista com os personagens
  epara i = dono.perso ? dono.atkrec.ini : atkrec.ini, i, i.depois
    l.addfim(i.obj.atkdiv)
  efim
  epara i = l.ini, i, i.obj.pvida ? i.depois : i.removedepois
  efim
# Retira experiência
  se !arg0
    epara i = l.ini, i, i.depois
      i.obj.expatual = 0
    efim
    ret
  fimse
# Ganha experiência
  real v1
  ref r
  epara i = l.ini, i, i.depois
    v1 = intpos(pnivel - i.obj.pnivel + 8) / 16
    v1 > 1 && (v1 = 1)
    r = i.obj.dono
    r.perso && i.obj.var.z_dono != r.nome && (v1 *= 1.5)
    i.obj.ganhaexp(v1 * arg0 * (pnivel * 10 + 60) / (l.total + 1))
  efim

func ganhaexp # Personagem ganha experiência
# arg0 = experiência
# arg1 = verdadeiro se não deve mostrar mensagem de ganhar XP para o jogador
  uint32 exp1
  ret !(exp1 = arg0), nulo
  expatual += exp1
  se arg1
  senao !dono.perso
    se exp1 == 1
      msg("Você recebe 1 ponto de experiência.")
    senao
      msg("Você recebe " + exp1 + " pontos de experiência.")
    fimse
  senao exp1 == 1
    dono.msg(nome + " recebe 1 ponto de experiência.")
  senao
    dono.msg(nome + " recebe " + exp1 + " pontos de experiência.")
  fimse
  se expatual >= expmax
    expatual -= expmax
    pnivel += 1
    dono.msg(nome + " avança para o nível " + pnivel)
    recalc = 1 # Recalcular atributos do personagem

func atktempo_exec # Encerra a batalha depois de um tempo
  se !atkenv # Se não tem um alvo
    batalhafim(1)
  senao config:atktipo # Se for ataque automático
    $comando_atkauto.ataca(este, atkenv.objlista)
    atktempo = config:atktempo
  senao atkturno < 3 # Se não passou tempo suficiente
    atkturno += 1, atktempo = 30
    ret p_espera || posicao < 4, nulo
    $mens.p(este, atkenv.objlista)
    se atkturno == 1
      $mens.mvis1("$P se prepara.")
    senao atkturno == 2
      $mens.mvis1("$P procura uma brecha.")
    senao
      $mens.mvis1("$P encara $A.")
    fimse
  senao # Tempo suficiente: encerra a luta
    atkenv.objlista.msg("Batalha encerrada.")
    msg("Batalha encerrada.")
    batalhafim(1)

func restaurar # Restaura personagem (HP, mana, etc.)
  pmana = pmanamax, pmove = pmovemax
  se !pvida && dono.perso
    pvida = pvidamax
    dono.escolhebat # Atualiza persobat
  senao
    pvida = pvidamax

func morreu # Procedimentos quando morre
# Checa se pode morrer
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este), nulo
  efim
  mortes += 1
# Jogador: retira toda experiência e transfere jogador para outro lugar
  se jog
    expatual = 0, animal.0.expatual = 0, animal.1.expatual = 0
    animal.2.expatual = 0, animal.3.expatual = 0, animal.4.expatual = 0
    animal.5.expatual = 0, animal.6.expatual = 0, animal.7.expatual = 0
    pvida = intpos(pvidamax / 2 - 10) + 2
    pmana = pmanamax / 2
    pmove = pmovemax / 2
    p_restaura = rand(100, 130)
    batalhaexp(0), batalhafim # Retira toda experiência de quem atacou
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    mudadono(config:salafim)
    salvar # Salva o jogo
    !sock && apagar(este) # Sai do jogo se ninguém está controlando o personagem
# Animal do jogador: não dá experiência
  senao dono.jog
    p_morreu2 && $mens.p(dono, este) + $mens.mtodos2(p_morreu2)
    pvida = 0, batalhafim
    dono.escolhebat # Atualiza persobat
# Outro personagem: dá experiência
  senao dono.perso
    pvida = 0, batalhaexp(1.5), batalhafim
    p_morreu2 && $mens.p(dono, este) + $mens.mtodos2(p_morreu2)
    dono.escolhebat # Atualiza persobat
  senao
    pvida = 0, batalhaexp(1), batalhafim
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    apagar(este)
    ref r
    r = sock, r.mudaperso(nulo), r.reinicia
  fimse
# Gera eventos
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este)
  efim

func escolhehab # Escolhe e retorna o nome da variável de uma habilidade
  txt100 t1 # Nome da habilidade
  uint8 total
# Obtém a quantidade de habilidades
  t1 = persoesc.var.ini("h_")
  enquanto txt(t1, 0, 2) == "h_"
    total += 1, t1 = persoesc.var.depois(t1)
  efim
  ret !total, "" # Retorna se não tem nenhuma habilidade
# Escolhe uma habilidade
  t1 = persoesc.var.ini("h_")
  epara total = rand(total), total, total -= 1
    t1 = persoesc.var.depois(t1)
  efim
  ret t1

func escolheatk # Escolhe e retorna o nome da variável de uma habilidade ou magia
  textotxt t # Lista de habilidades e magias
  txt100 t1 # Nome da habilidade ou magia
  t1 = persoesc.var.ini("h_")
  enquanto txt(t1, 0, 2) == "h_"
    t.addfim(t1), t1 = persoesc.var.depois(t1)
  efim
  se !dono.s_semmagia
    t1 = persoesc.var.ini("m_")
    enquanto txt(t1, 0, 2) == "m_"
      t.addfim(t1), t1 = persoesc.var.depois(t1)
    efim
  fimse
  t.remove(rand(t.linhas - 1))
  ret t.ini.texto

func escolhejog # Escolhe e retorna um jogador
  listaitem i
  listaobj l
# Obtém a quantidade de jogadores
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.jog && i.obj.visivel(este) && l.addfim(i.obj)
  efim
  ret !l.objini, nulo # Retorna se não tem jogador
# Escolhe um jogador
  i = l.ini, i.depois(rand(l.total))
  ret i.obj

func p_proc_exec # Processar comportamento do personagem
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret dono.perso, nulo # Retorna se pertence a outro personagem
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
# Evento do personagem
  ret cmd_pnj_proc, nulo
# Obtém o alvo para realizar um ataque
  ref alvo
  se atkenv # Alvo durante a batalha
    alvo = atkenv.objlista
  senao dono.socktot # Escolhe um jogador como alvo
    listaitem i
    listaobj l
    epara i = dono.dentro2.ini, i, i.depois
      i.obj.jog && p_agressivo(i.obj) == 2 && i.obj.visivel(este) && l.addfim(i.obj)
    efim
    se l.total
      i = l.ini, i.depois(rand(l.total)), alvo = i.obj
    fimse
  fimse
# Realiza um ataque
  se alvo
    txt100 t1
    ref obj
    t1 = escolheatk
    obj = txt(t1, 0, 1) == "m" ? $magia_[txt(t1, 2)] : $cmd_[txt(t1, 2)]
    ret obj && !ataqueini, obj.checaatk(este) && obj.ataca(este, alvo)
  fimse
# Acerta condição do personagem
  pmove = pmovemax, pmana = pmanamax, pvida < pvidamax && (pvida += 1)
# Movimenta-se
  se p_mover
    ret p_tmove, p_proc = p_tmove + 1
    ref r
    textotxt t
    misc:obj = este, r = dono
    r.dir_n.s_pnj && t.addfim("n"), r.dir_ne.s_pnj && t.addfim("ne")
    r.dir_s.s_pnj && t.addfim("s"), r.dir_no.s_pnj && t.addfim("no")
    r.dir_l.s_pnj && t.addfim("l"), r.dir_se.s_pnj && t.addfim("se")
    r.dir_o.s_pnj && t.addfim("o"), r.dir_so.s_pnj && t.addfim("so")
    r.dir_c.s_pnj && t.addfim("c"), r.dir_b.s_pnj && t.addfim("b")
    t.remove(rand(t.linhas)) # Para escolher uma direção aleatoriamente
    txt10 dir
    dir = t.ini.texto # Direção escolhida
    ret !dir || p_mover == 1 && r.dir_[dir].s_area != r.s_area, p_proc = 50
    $cmd_[dir].escr(este)
    p_tmove = rand(70, 130) * p_movervel / 100, p_proc = p_tmove + 1


classe comum_persoanimal
herda comum_persobat
# Personagem que pode batalhar e carregar animais
const perso = 3 # Para identificar o tipo de personagem
const objmax = 15 # Quantos itens pode carregar
sav ref animal.8 # Animais que possui
sav ref persobat # Personagem usado na batalha
sav ref persoesc # Personagem escolhido pelo jogador

func escolhebat # Escolhe um personagem em condições de lutar
  se persoesc.pvida # Checa se personagem escolhido está em condições
    persobat = persoesc
  senao animal.0.pvida && config:animal1 >= 1
    persobat = animal.0
  senao animal.1.pvida && config:animal1 >= 2
    persobat = animal.1
  senao animal.2.pvida && config:animal1 >= 3
    persobat = animal.2
  senao animal.3.pvida && config:animal1 >= 4
    persobat = animal.3
  senao animal.4.pvida && config:animal1 >= 5
    persobat = animal.4
  senao animal.5.pvida && config:animal1 >= 6
    persobat = animal.5
  senao animal.6.pvida && config:animal1 >= 7
    persobat = animal.6
  senao animal.7.pvida && config:animal1 >= 8
    persobat = animal.7
  senao
    persobat = este
  fimse

func animalnum # Retorna o número do próximo lugar disponível para animal
# A variável animal.[animalnum-1] é o próximo lugar disponível
# Se retornar 0, significa que não há mais espaço
  ret !animal.0, config:animal1 >= 1 ? 1 : 0
  ret !animal.1, config:animal1 >= 2 ? 2 : 0
  ret !animal.2, config:animal1 >= 3 ? 3 : 0
  ret !animal.3, config:animal1 >= 4 ? 4 : 0
  ret !animal.4, config:animal1 >= 5 ? 5 : 0
  ret !animal.5, config:animal1 >= 6 ? 6 : 0
  ret !animal.6, config:animal1 >= 7 ? 7 : 0
  ret !animal.7, config:animal1 >= 8 ? 8 : 0
  ret 0

func p_proc_exec # Processar comportamento do personagem
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
# Animal em condições: escolhe
  se persoesc == este && animal.0.pvida
    persobat = persoesc = animal.0
# Animal desmaiado: escolhe outro
  senao !persoesc.pvida
    persoesc = persobat, p_proc = 5
    $mens.p(este, persoesc)
    ret persobat != este, $mens.mvis1("$P escolhe $a.")
    $mens.mvis1("$P não escolhe ninguém.")
    ret
  fimse
# Comportamento de PNJ que pode batalhar
  comum_persobat:p_proc_exec


classe perso_restaurar
# Somente para personagens que podem batalhar:
# Restaura status de tempos em tempos
sav inttempo p_restaura

func p_restaura_exec
  p_restaura = rand(100, 130)
  real recup
  casovar posicao
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    vida += 1
    ret
  casose "3" # Fraco
    vida += 2
    ret
  casose "4" # Dormindo
    recup = 5
    sair
  casose "5" # Descansando
    recup = 10
    sair
  casose "6" # Sentado
    recup = 15
    sair
  casose "7" # Lutando
  casose "8" # Em pé
    recup = 30
    sair
  casose
    ret
  casofim
  se pvida < pvidamax
    pvida += pvidamax / recup + 5
    pvida > pvidamax && (pvida = pvidamax)
  fimse
  se pmana < pmanamax
    pmana += pmanamax / recup + 5
    pmana > pmanamax && (pmana = pmanamax)
  fimse
  se pmove < pmovemax
    pmove += pmovemax / recup + (pnivel ? 5 : 20)
    pmove > pmovemax && (pmove = pmovemax)
  fimse
