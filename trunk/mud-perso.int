classe comum_perso
herda comum_obj
# Personagem sem estrutura de batalha
const perso = 1 # Para identificar que é personagem
const sexo = 0 # Sexo: 0=feminino, 1=masculino
const nome = "item"
const ident = txts(nome)
const volexp = 1 # Volume expande se tiver itens dentro
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const descver = "Você não vê nada de especial."
const jogsav = 1 # Se deve salvar o personagem ao salvar personagem do jogador
sav uint16 pnivel # Nível atual (apenas para mostrar ao jogador)
sav textovar var # Variáveis criadas sob demanda do personagem
inttempo p_espera # Tempo de espera para o próximo comando
sav uint8 posicao # Posição do personagem
const pospadr = 8 # Posição padrão do personagem
listaitem poslugar # Em qual móvel está sentado ou deitado
sav int1 jogconfig.24 # Para salvar sock.jogconfig

func ini # Coloca o objeto dentro de outro
  comum_obj:ini
  posicao = pospadr, pnivel = arg1, p_proc = 1
  arg0 && mudadono(arg0)
  se arg2
    textotxt t
    t.addfim(txttroca(arg2, ",", "\n"))
    enquanto t.linhas
      var.mudar(t.remove)
    efim

func fim # Objeto foi apagado
  se sock # Se estiver ligado a um jogador
    casovar txt1(sock.info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(sock)
      sair
    casose "l" # Jogando localmente
      terminar
    casose "b" # Como bot
      sock.reinicia
    casofim
    sock.perso = nulo # Desliga-se do jogador
    sock = nulo
  fimse
  comum_obj:fim

func mudadono # Coloca personagem em outra sala (arg0 = nova sala)
# Eventos cmd_saiu
  listaobj l
  epara l.addfim(evento, dono.evento), l, l.ini.remove
    l.objini.cmd_saiu(este, dono)
  efim
# Muda de sala
  cmd_mudadono(arg0), dono = arg0
  atkrec.limpar, poslugar.remove
# Eventos cmd_chegou
  dono.cmd_salaperso(este)
  epara l.addfim(evento, arg0.evento), l, l.ini.remove
    l.objini.cmd_chegou(este, arg0)
  efim
# Se for jogador, checa se tem personagens agressivos na sala
  se jog
    epara l.addfim(arg0.dentro2), l, l.ini.remove
      l.objini.p_agressivo && (l.objini.p_proc = 1)
    efim
  fimse
# Mostra descrição (jogador) ou processamento do personagem (não jogador)
  se !sock
    p_proc_exec
  senao dono.s_titulo
    se jogconfig.16
      msg2(txt(dono, 2) + "  " + dono.descsala(este, (jogconfig.bits & 3) + 4))
    senao
      msg2(dono.descsala(este, (jogconfig.bits & 3) + 4))

func teclou # Processa comando (arg0=comando)
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  ref obj2 # Objeto com menor prioridade
  prog p # Para procurar o objeto
  casovar txtmin(txt1(arg0))
  casose ""
    ret
  casose "m"
  casose "ma"
  casose "mag"
  casose "magi"
  casose "magia"
    ret dono.s_semmagia, msg("Você não consegue lançar magias aqui.")
    p.iniclasse("cmd_magia_" + txtsub(arg0, 1, 1))
    sair
  casose
    p.iniclasse("cmd_" + txt1(arg0))
    comando = txt2(comando)
  casofim
  epara nulo, p.lin, p.depois
    obj = $[p.texto].objcmd(este, arg0)
    continuar !obj # Continua se não encontrou um objeto
    sair !obj.ultimo # Sai se não for objeto com baixa prioridade
    obj2 = obj
  efim
  !obj && (obj = obj2)
# Gera eventos
  listaobj l
  epara l.addfim(este.evento), l, l.ini.remove
    ret l.objini.cmd_escr(este, arg0, obj), nulo
  efim
# Executa comando
  se !obj
    msg("O quê?")
  senao posicao < obj.posic
    msg(erropos)
  senao txt(obj, 0, 10) == "cmd_magia_"
    obj.escr(este, txtsub(arg0, 2))
  senao
    obj.escr(este, txt2(arg0))

func p_espera_exec # Pega o próximo comando
  sock ? sock.espera_exec : p_proc_exec

func erropos # Retorna uma mensagem conforme a posição
  casovar posicao
  casose "0"
    ret "\c9Você está mort" + misc:sletra[sexo] + "!!!\b"
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    ret "\c9Você está muito mal, incapaz de fazer qualquer coisa.\b"
  casose "3" # Fraco
    ret "\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b"
  casose "4" # Dormindo
    ret "\c9Nos seus sonhos...\b"
  casose "5" # Descansando
    ret "\c9Você se sente relaxad" + misc:sletra[sexo] + " demais para fazer isso.\b"
  casose "6" # Sentado
    ret "\c9Talvez você deva ficar em pé primeiro.\b"
  casose "7" # Lutando
    ret "\c9Sem chance! Você está lutando pela sua vida.\b"
  casose
    ret "\c9Você tenta, mas não consegue.\b"
  casofim

func descpos
  ret posicao == pospadr && descpadr, descpadr
  casovar posicao
  casose "0"
    ret txtmaimin(nome) + " jás aqui."
  casose "1"
    ret txtmaimin(nome) + " está aqui mortalmente ferid" + misc:sletra[sexo] + "."
  casose "2"
    ret txtmaimin(nome) + " está aqui incapacitad" + misc:sletra[sexo] + "."
  casose "3"
    ret txtmaimin(nome) + " está aqui, muito frac" + misc:sletra[sexo] + "."
  casose "4"
    ret !poslugar, txtmaimin(nome) + " dorme aqui."
    ref r
    r = poslugar.objlista
    ret txtmaimin(nome) + " dorme em " + misc:sum[r.sexo] + " " + r.nome + "."
  casose "5"
    ret !poslugar, txtmaimin(nome) + " descansa aqui."
    ref r
    r = poslugar.objlista
    ret txtmaimin(nome) + " descansa em " + misc:sum[r.sexo] + " " + r.nome + "."
  casose "6"
    ret !poslugar, txtmaimin(nome) + " está sentad" + misc:sletra[sexo] + "."
    ref r
    r = poslugar.objlista
    ret txtmaimin(nome) + " está sentad" + misc:sletra[sexo] + " em " + misc:sum[r.sexo] + " " + \
r.nome + "."
  casose "7"
    ret txtmaimin(nome) + " está lutando."
  casose "8"
    ret txtmaimin(nome) + " está em pé."
  casofim
  ret txtmaimin(nome) + " está aqui."

func msgvis # Mensagem se o jogador estiver vendo o alvo
  se sock && posicao > 4 && $mens.perso.visivel(este) # Se tem jogador e está acordado
    $mens.proc(arg0, este)

func msginv # Mensagem mesmo se o alvo estiver invisível
  se sock && posicao > 4 # Se tem jogador e está acordado
    $mens.proc(arg0, este)


classe comum_persobat
herda comum_perso
# Personagem que pode batalhar
const perso = 2 # Para identificar o tipo de personagem
uint8 bitver # O que o personagem/item pode ver
uint8 bitinv # Grau de invisibilidade do personagem/item
#
const sexo = 0 # Sexo: 0=feminino, 1=masculino
# sav int1 sexo # Sexo: 0=feminino, 1=masculino
sav uint32 moedas # Quantas moedas está carregando
#
const expmax = pnivel * pnivel + 20 # Experiência para subir de nível
sav uint32 expatual # Experiência atual
sav uint16 pnivel # Nível atual
sav uint32 pvida # Pontos de vida
sav uint32 pmana # Pontos de mana
sav uint32 pmove # Pontos de movimento
uint32 pvidamax # Quantidade máxima de vida
uint32 pmanamax # Quantidade máxima de mana
uint32 pmovemax # Quantidade máxima de movimento
uint16 pveloc # Velocidade do personagem
uint32 atknorm # Quantidade de ataque normal
uint32 defnorm # Quantidade de defesa normal
uint32 atkmag # Quantidade de ataque mágico/especial
uint32 defmag # Quantidade de defesa mágica/especial
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
const tipo1 = "normal" # Tipo de personagem
const tipo2 = "" # Segundo tipo do personagem
int8 deftipo.18
# Defesa contra os diversos tipos de danos
# Vide função misc:atktipo
# somar 2 = dobra defesa
# subtrair 2 = reduz defesa pela metade
# 80 ou mais = imune ao tipo de golpe
#
intexec recalc # Se deve recalcular defesa, ataque e velocidade
const persobat = este # Personagem usado na batalha
const persoesc = este # Personagem escolhido
listaobj atkrec # Quem atacou esse personagem; dá experiência se perder
listaitem atkenv # Item de atkrec; atkenv.objlista = alvo do personagem
listaobj atkdiv # Para dividir experiência entre personagens que atacaram
inttempo atktempo # Tempo para completar um turno da batalha
uint8 atkturno # Turno da batalha, usado para decidir se encerra
inttempo p_proc # Para processar comportamento do personagem

func ini # Objeto foi criado
  comum_perso:ini
  p_restaura = 100
  pnivel = arg1
  recalc_exec
  pvida = pvidamax
  pmana = pmanamax
  pmove = pmovemax
  arg0 && mudadono(arg0)
  se arg2
    textotxt t
    t.addfim(txttroca(arg2, ",", "\n"))
    enquanto t.linhas
      var.mudar(t.remove)
    efim

func fim # Objeto foi apagado
  comum_perso:fim
  atkrec.limpar, atkdiv.limpar

func ataqueini # Testa se pode atacar
# Retorna "" se pode atacar ou a mensagem com o motivo se não pode
  se persobat.pvida == 0
    ret "Você está desmaiado"
  senao dono.s_luta == 0
    ret "Não é permitido brigas aqui"
  senao
    ret ""

func acertapos # Acerta posição
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
  casovar pvida * 100 / pvidamax
  casose "0"
  casose "1"
    se pvida
      poslugar.remove, posicao = 1 # mortalmente ferido
    senao
      poslugar.remove, posicao = 0, arg0 && morreu # morto
    fimse
    ret
  casose "2"
    poslugar.remove, posicao = 2 # incapacitado
    ret
  casose "3"
    poslugar.remove, posicao = 3 # fraco
    ret
  casose
    se atkenv
      poslugar.remove, posicao = 7 # lutando
    senao posicao < 4 || posicao == 7
      poslugar.remove, posicao = pospadr # posição padrão
    fimse
  casofim

func recalc_exec # Ajusta variáveis, principalmente batalha
# Acerta atributos básicos
  bitver = bitinv = 3
  atknorm = (pnivel * 4 + 60) * pnivel + 30
  defnorm = pnivel * 3 + 6
  atkmag = (pnivel * 4 + 60) * pnivel + 30
  defmag = pnivel * 3 + 6
  pvidamax = pnivel * 2 + 25
# pveloc = (pnivel * 4 + 60) * pnivel + 30
  pveloc = pnivel + 50
  pmanamax = pnivel + 30
  pmovemax = pnivel * 2 + 30
  evasao = pnivel * 2 + 30
  precisao = pnivel * 2 + 30
  deftipo.limpar # Todas as defesas em 100%
# Acerta atributos conforme o tipo de personagem
  misc:tipo_[tipo1]
  misc:tipo_[tipo2]
# Bônus do próprio personagem
  cmd_recalc1(este)
# Bônus conforme o que está vestindo e os efeitos
  listaitem l
  epara l = dentro2.ini, l, l.depois
    l.obj.cmd_recalc2(este)
  efim
  epara l = evento.ini, l, l.depois
    l.obj.cmd_recalc2(este)
  efim

func batalhaini # Indica que atacou outro personagem (está batalhando)
# arg0 = alvo do personagem
  se atkenv.objlista != arg0 # Se o alvo do ataque mudou...
    atkenv.remove
    atkenv = arg0.atkrec.addfim(este)
    atkdiv.limpar
    atktempo = config:atktempo, atkturno = 0
    posicao >= 4 && (posicao = 7)
  fimse
  atkdiv.addfim1(persobat) # Adiciona personagem para ganhar experiência
  se !arg0.atkenv # Se o alvo não está batalhando...
    arg0.atkenv = atkrec.addfim(arg0)
    arg0.atkdiv.limpar
    arg0.atkdiv.addfim(arg0.persobat)
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
    arg0.posicao >= 4 && (arg0.posicao = 7)
  fimse
  se !config:atktipo # Se for batalha manual
    atktempo = config:atktempo, atkturno = 0
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
  fimse
  !p_proc && (p_proc = 1)
  arg0.p_proc = 1 # Para gerar evento de PNJs

func batalhafim # Encerra a batalha
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
  atkenv.remove, atktempo = 0, acertapos(arg0)
  ref r
  enquanto atkrec.ini
    r = atkrec.objini, atkrec.ini.remove, r.atktempo = 0, r.acertapos(arg0)
  efim

func atktempo_exec # Encerra a batalha depois de um tempo
  se !atkenv # Se não tem um alvo
    batalhafim(1)
  senao config:atktipo # Se for ataque automático
    $cmd_atkauto.ataca(este, atkenv.objlista)
    atktempo = config:atktempo
  senao atkturno < 3 # Se não passou tempo suficiente
    atkturno += 1, atktempo = 30
    ret p_espera || posicao < 4, nulo
    $mens.p(este, atkenv.objlista)
    se atkturno == 1
      $mens.mvis1("$P se prepara.")
    senao atkturno == 2
      $mens.mvis1("$P procura uma brecha.")
    senao
      $mens.mvis1("$P encara $A.")
    fimse
  senao # Tempo suficiente: encerra a luta
    atkenv.objlista.msg("Batalha encerrada.")
    msg("Batalha encerrada.")
    batalhafim(1)

func restaurar # Restaura personagem (HP, mana, etc.)
  pmana = pmanamax, pmove = pmovemax
  se !pvida && dono.perso
    pvida = pvidamax
    dono.escolhebat # Atualiza persobat
  senao
    pvida = pvidamax

func morreu # Procedimentos quando morre
  ref r
# Jogador: retira toda experiência e transfere jogador para outro lugar
  se jog
    expatual = 0, animal.0.expatual = 0, animal.1.expatual = 0
    animal.2.expatual = 0, animal.3.expatual = 0, animal.4.expatual = 0
    animal.5.expatual = 0, animal.6.expatual = 0, animal.7.expatual = 0
    pvida = intpos(pvidamax / 2 - 10) + 2
    pmana = pmanamax / 2
    pmove = pmovemax / 2
    p_restaura = rand(100, 130)
    batalhaexp(0), batalhafim # Retira toda experiência de quem atacou
    $mens.p(este)
    $mens.mtodos1("$P morreu.")
    mudadono(config:salafim)
    salvar # Salva o jogo
    ret
# Animal do jogador: não dá experiência
  senao dono.jog
    $mens.p(dono, este)
    $mens.mtodos1("$A de $P desmaiou.")
    pvida = 0, batalhafim
    dono.escolhebat # Atualiza persobat
    ret
  fimse
# Outro personagem: dá experiência
  se dono.perso
    pvida = 0, batalhaexp(1.5), batalhafim
    $mens.p(dono, este)
    $mens.mtodos1("$A de $P desmaiou.")
    dono.escolhebat # Atualiza persobat
  senao
    pvida = 0, batalhaexp(1), batalhafim
    $mens.p(este)
    $mens.mtodos1("$P morreu.")
    apagar(este)
    ref r
    r = sock, r.mudaperso(nulo)
    r.reinicia

func batalhaexp # Dá experiência a quem estiver atacando o personagem
# arg0 = fator do ganho de experiência; se 0 retira toda experiência
  listaitem i
  listaobj l
# Preenche lista com os personagens
  epara i = dono.perso ? dono.atkrec.ini : atkrec.ini, i, i.depois
    l.addfim(i.obj.atkdiv)
  efim
  epara i = l.ini, i, i.obj.pvida ? i.depois : i.removedepois
  efim
# Retira experiência
  se !arg0
    epara i = l.ini, i, i.depois
      i.obj.expatual = 0
    efim
    ret
  fimse
# Ganha experiência
  real v1
  epara i = l.ini, i, i.depois
    v1 = intpos(pnivel - i.obj.pnivel + 8) / 16
    v1 > 1 && (v1 = 1)
    i.obj.ganhaexp(v1 * arg0 * (pnivel * 5 + 30) / l.total)
  efim

func ganhaexp # Personagem ganha experiência
# arg0 = experiência
  expatual += arg0
  se expatual > expmax
    expatual -= expmax
    pnivel += 1
    dono.msg(nome + " foi para nível " + pnivel)
    recalc = 1 # Recalcular atributos do personagem

func escolhehab # Escolhe e retorna o nome de uma habilidade
  txt100 t1 # Nome da habilidade
  uint8 total
# Obtém a quantidade de habilidades
  t1 = var.ini("h_")
  enquanto txt(t1, 0, 2) == "h_"
    total += 1, t1 = var.depois(t1)
  efim
  ret !total, "" # Retorna se não tem nenhuma habilidade
# Escolhe uma habilidade
  t1 = var.ini("h_")
  epara total = rand(total), total, total -= 1
    t1 = var.depois(t1)
  efim
  ret txt(t1, 2)

func escolhejog # Escolhe e retorna um jogador
  listaitem i
  listaobj l
# Obtém a quantidade de jogadores
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.jog && i.obj.visivel(este) && l.addfim(i.obj)
  efim
  ret !l.objini, nulo # Retorna se não tem jogador
# Escolhe um jogador
  uint8 total
  epara total = rand(total), total, total -= 1
    l.ini.remove
  efim
  ret l.objini

func p_proc_exec # Processar comportamento do personagem
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret dono.perso, nulo # Retorna se pertence a outro personagem
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
# Evento do personagem
  ret cmd_pnj_proc, nulo
# Obtém o alvo para realizar um ataque
  ref alvo
  se atkenv
    alvo = atkenv.objlista
  senao p_agressivo
    alvo = escolhejog
  fimse
# Realiza um ataque
  se alvo
    txt100 t1
    t1 = escolhehab
    ret t1 && !ataqueini, $cmd_[t1].ataca(este, alvo)
  fimse


classe comum_persoanimal
herda comum_persobat
# Personagem que pode batalhar e carregar animais
const perso = 3 # Para identificar o tipo de personagem
sav ref animal.8 # Animais que possui
sav ref persobat # Personagem usado na batalha
sav ref persoesc # Personagem escolhido pelo jogador

func ini # Objeto foi criado
  comum_persobat:ini
  persobat = este
  persoesc = este

const fim = comum_persobat:fim

func escolhebat # Escolhe um personagem em condições de lutar
  se persoesc.pvida # Checa se personagem escolhido está em condições
    persobat = persoesc
  senao animal.0.pvida && config:animal1 >= 1
    persobat = animal.0
  senao animal.1.pvida && config:animal1 >= 1
    persobat = animal.1
  senao animal.2.pvida && config:animal1 >= 2
    persobat = animal.2
  senao animal.3.pvida && config:animal1 >= 3
    persobat = animal.3
  senao animal.4.pvida && config:animal1 >= 4
    persobat = animal.4
  senao animal.5.pvida && config:animal1 >= 5
    persobat = animal.5
  senao animal.6.pvida && config:animal1 >= 6
    persobat = animal.6
  senao animal.7.pvida && config:animal1 >= 7
    persobat = animal.7
  senao
    persobat = este
  fimse


classe perso_restaurar
# Somente para personagens que podem batalhar:
# Restaura status de tempos em tempos
sav inttempo p_restaura

func p_restaura_exec
  p_restaura = rand(100, 130)
  real recup
  casovar posicao
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    vida += 1
    ret
  casose "3" # Fraco
    vida += 2
    ret
  casose "4" # Dormindo
    recup = 5
    sair
  casose "5" # Descansando
    recup = 10
    sair
  casose "6" # Sentado
    recup = 15
    sair
  casose "7" # Lutando
  casose "8" # Em pé
    recup = 30
    sair
  casose
    ret
  casofim
  se pvida < pvidamax
    pvida += pvidamax / recup + 5
    pvida > pvidamax && (pvida = pvidamax)
  fimse
  se pmana < pmanamax
    pmana += pmanamax / recup + 5
    pmana > pmanamax && (pmana = pmanamax)
  fimse
  se pmove < pmovemax
    pmove += pmovemax / recup + (pnivel ? 5 : 20)
    pmove > pmovemax && (pmove = pmovemax)
  fimse
