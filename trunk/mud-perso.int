classe comum_perso
herda comum_persoitem
# Personagem sem estrutura de batalha
const perso = 1 # Para identificar que é personagem
comum listaobj objsolto # Lista de personagens soltos (não pertencem a outros)
sav int1 psexo # Sexo do personagem: 0=feminino, 1=masculino
const sexoini = msexo # Sexo inicial: 0=feminino, 1=masculino, 2=aleatório
const nome = "sem nome"
const ident = nome
const descnome = nome
const volexp = 1 # Volume expande se tiver itens dentro
const pesomax = 1000000 # Para poder receber itens
const persobat = este # Personagem usado na batalha; alguns comandos usam
const persoesc = este # Personagem escolhido; alguns comandos usam
const pvida = 1000 # Para não dizer que o alvo está desmaiado
const msg = sock.msg(arg0) # Mensagem pequena para o jogador
const msg2 = sock.msg2(arg0) # Mensagem grande para o jogador
ref sock # Objeto do jogador, se nulo não é contolado pelo jogador
const objsav = 2 # Se deve salvar o personagem ao salvar personagem do jogador
const objmax = 15 # Quantos itens pode carregar
const luztipo = 1 # 1=não é fonte de luz, mas repassa a luz
sav uint16 pnivel # Nível atual (apenas para mostrar ao jogador)
sav uint32 mortes # Quantas vezes morreu (chamou a função morreu)
inttempo p_espera # Tempo de espera para o próximo comando
sav uint8 posicao # Posição do personagem
const pospadr = 8 # Posição padrão do personagem
listaitem poslugar # Em qual móvel está sentado ou deitado
int1 jogconfig.24 # Mesmo que sock.jogconfig
listaitem iseguir # Quem o personagem está segundo
listaobj lseguir # Quem está seguindo o personagem
sav listaitem iempu # Arma que que está empunhando
const p_morreu1 = "$P morreu."
const p_morreu2 = "$P desmaiou."
const p_fome = 100 # Não está com fome
const p_sede = 100 # Não está com sede
#
# Ordem que deve organizar as constantes:
const admordem = "nome\n\
ident\n\
descnome\n\
descpadr\n\
descver\n\
descident\n\
msexo\n\
sexoini\n\
pesoobj\n\
volobj\n\
volmax\n\
volexp\n\
objmax\n\
nivel\n\
pospadr\n\
tipo1\n\
tipo2\n\
tipo3\n\
equip1\n\
equip2\n\
equip3\n\
lojaaula\n\
lojafim\n\
lojaini\n\
lojaitem\n\
lojanao\n\
taxaaula\n\
taxacompra\n\
taxavenda\n\
tipoitem\n\
p_agressivo\n\
p_atktipo\n\
p_captura\n\
p_comecorpo\n\
p_corpo\n\
p_exp\n\
p_fugir\n\
p_imortal\n\
p_morreu1\n\
p_morreu2\n\
p_mover\n\
p_movervel\n\
p_naoresg\n\
p_naoseguir\n\
p_recebe\n\
p_soltar\n\
inivar\n\
evhora\n\
eveste\n\
evperso\n\
evitem\nevsala"

func ini # Coloca o objeto dentro de outro
  posicao = pospadr, p_proc = 1, p_tmove = 80, pnivel = arg1 ? arg1 : nivel
  psexo = sexoini == 2 ? rand(2) : sexoini
  se arg2 || inivar
    textotxt t
    epara t.addfim(txttroca(txt(arg2) + "\n" + inivar, ",", "\n")), t.linhas, var.mudar(t.remove)
    efim
  fimse
  comum_obj:ini, cmd_ini(arg0, arg1, arg2, arg3, arg4)
  arg0 && mudadono(arg0)
  dono && !dono.perso && objsolto.addfim(este)
  epara nulo, var.ini("e_"), var.mudar(var.ini("e_"))
    criar(var.ini("e_"), este, var.valor(var.ini("e_")))
  efim
  recalc_exec

func fim # Objeto foi apagado
  se sock # Se estiver ligado a um jogador
    casovar txt1(sock.info)
    casose "t" # Conectado via Papovox
    casose "p" # Conectado via Telnet
      apagar(sock)
      sair
    casose "l" # Jogando localmente
      $miscsav.salvartudo
      terminar
    casose "b" # Como bot
      sock.reinicia
    casofim
    sock.perso = nulo # Desliga-se do jogador
    sock = nulo
  fimse
  batalhafim, comum_obj:fim
  epara nulo, lseguir, lseguir.ini.remove
    lseguir.objini.msg("Você pára de seguir " + nome + ".")
  efim

func mudadono # Coloca personagem em outra sala (arg0 = nova sala)
# Muda de sala
  atkrec.limpar, poslugar.remove, mdono(arg0), cmd_mudadono
# Eventos cmd_saiu e variável donoantes.s_item
  listaobj l
  se donoantes && !donoantes.perso
    epara l.addfim(evento, donoantes.evento), l, l.ini.remove
      l.objini.cmd_saiu(este, donoantes)
    efim
    se !sock
    senao donoantes.dentro1.total && !donoantes.socktot
      donoantes.t_item = donoantes.s_item * 600
    senao
      donoantes.t_item = 0
    fimse
  fimse
# Checa se novo dono é personagem
  se dono.perso
    p_proc = 1
    ret este
  fimse
# Eventos cmd_chegou
  (sock || jog) && dono.s_reset1 + dono.cmd_salaperso(este)
  epara l.addfim(evento, arg0.evento), l, l.ini.remove
    l.objini.cmd_chegou(este, arg0)
  efim
# Se for jogador, checa se tem personagens agressivos na sala
  se jog
    int(dono.s_retornar) >= 2 && (!var.z_salafim || int(dono.s_retornar) == 2) && (var.z_salafim \
= dono)
    epara l.addfim(dono.dentro2), l, l.ini.remove
      l.objini.p_agressivo(este) == 2 && (l.objini.p_proc = 1)
    efim
  fimse
# Mostra descrição (jogador) ou processamento do personagem (não jogador)
  se !sock
    p_proc = 1
    ret este
  senao dono.s_ocultar
    dono.t_item = 0
    ret este
  senao
    dono.t_item = 0
    se jogconfig.16
      msg2(txt(dono, 2) + "  " + dono.descsala(este, (jogconfig.bits & 3) + 4))
      ret este
    senao
      msg2(dono.descsala(este, (jogconfig.bits & 3) + 4))
      ret este

func recalc_exec # Ajusta variáveis
  bitver = 17, bitinv = 3, atribs.limpar, recalc_auto, cmd_recalc1(este), atribs_exec

func teclou # Processa comando (arg0=comando)
# Procura objeto que contém o comando
  ref obj # Objeto que vai processar o comando
  prog p # Para procurar o objeto
  ret !arg0, nulo
# Obtém o comando
  enquanto 1
    se arg0 == intpos(arg0) && config:animal1 >= arg0 && config:animal1
      obj = $comando_escolhe_animal
      obj.num = arg0
      sair
    fimse
    sair obj = $cmd_[txt1(arg0)].objcmd(este, arg0) # Checa comando exato
    sair obj = $soc_[txt1(arg0)].objcmd(este, arg0) # Checa social exato
    sair obj = $cmdfim_[txt1(arg0)].objcmd(este, arg0) # Checa comando exato
    epara p.iniclasse("cmd_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair obj
    epara p.iniclasse("soc_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair obj
    epara p.iniclasse("cmdfim_" + txt1(arg0)), p.lin, p.depois
      sair obj = $[p.texto].objcmd(este, arg0)
    efim
    sair
  efim
# Checa se é magia
  se obj.lancamagia
    txt200 lin
    lin = txtremove(txt2(arg0), "EMDSA")
    obj = ref($magia_[txt1(lin)].objcmd(este, arg0))
    se !obj && lin
      epara p.iniclasse("magia_" + txt1(lin)), p.lin, p.depois
        sair obj = $[p.texto].objcmd(este, arg0)
      efim
    fimse
# Magia: Gera eventos
    listaobj l
    epara l.addfim(este.evento), l, l.ini.remove
      ret l.objini.cmd_escr(este, arg0, obj), nulo
    efim
# Magia: Executa comando
    se !lin
      msg("Lançar que magia?")
    senao !obj
      msg("Você não possui a magia " + lin)
    senao posicao < obj.posic
      msg(erropos)
    senao
      obj.escr(este, txt2(lin))
    fimse
    ret
  fimse
# Gera eventos
  listaobj l
  epara l.addfim(este.evento), l, l.ini.remove
    ret l.objini.cmd_escr(este, arg0, obj), nulo
  efim
# Executa comando
  se !obj
    msg("O quê?")
  senao posicao < obj.posic
    msg(erropos)
  senao
    obj.escr(este, txt2(arg0))

func p_espera_exec # Pega o próximo comando
  sock ? sock.espera_exec : p_proc_exec

func erropos # Retorna uma mensagem conforme a posição
  casovar posicao
  casose "0"
    ret "\c9Você está mort" + (msexo ? "o" : "a") + "!!!\b"
  casose "1" # Mortalmente ferido
  casose "2" # Incapacitado
    ret "\c9Você está muito mal, incapaz de fazer qualquer coisa.\b"
  casose "3" # Fraco
    ret "\c9A única coisa que você pode fazer agora é pensar nas estrelas.\b"
  casose "4" # Dormindo
    ret "\c9Nos seus sonhos...\b"
  casose "5" # Descansando
    ret "\c9Você se sente relaxad" + (msexo ? "o" : "a") + " demais para fazer isso.\b"
  casose "6" # Sentado
    ret "\c9Talvez você deva ficar em pé primeiro.\b"
  casose "7" # Lutando
    ret "\c9Sem chance! Você está lutando pela sua vida.\b"
  casose
    ret "\c9Você tenta, mas não consegue.\b"
  casofim

func descpos
  ret posicao == pospadr && descpadr, descpadr
  casovar posicao
  casose "0"
    ret txtcopiamai(descnome, "A") + " jaz aqui."
  casose "1"
    ret txtcopiamai(descnome, "A") + " está aqui mortalmente ferid" + (msexo ? "o." : "a.")
  casose "2"
    ret txtcopiamai(descnome, "A") + " está aqui incapacitad" + (msexo ? "o." : "a.")
  casose "3"
    ret txtcopiamai(descnome, "A") + " está aqui, muito frac" + (msexo ? "o." : "a.")
  casose "4"
    ret !poslugar, txtcopiamai(nome, "A") + " dorme aqui."
    refvar r = poslugar.objlista
    ret txtcopiamai(descnome, "A") + " dorme em um" + (msexo ? " " : "a ") + r.descnome + "."
  casose "5"
    ret !poslugar, txtcopiamai(descnome, "A") + " descansa aqui."
    refvar r = poslugar.objlista
    refvar lin = txtcopiamai(descnome, "A") + " descansa em "
    ret lin + (r.msexo ? "um " : "uma ") + r.descnome + "."
  casose "6"
    refvar lin = txtcopiamai(descnome, "A") + " está sentad" + (msexo ? "o" : "a")
    ret !poslugar, lin + " aqui."
    refvar r = poslugar.objlista
    ret lin + (r.msexo ? " em um " : " em uma ") + r.descnome + "."
  casose "7"
    ret txtcopiamai(descnome, "A") + " está lutando."
  casose "8"
    ret txtcopiamai(descnome, "A") + " está em pé aqui."
  casofim
  ret txtcopiamai(descnome, "A") + " está aqui."

func equippos # Retorna as posições aonde pode usar equipamentos
  txt100 lin
  int32 pos
  lin = "tipo_" + tipo1
  pos = (([lin]:equip1 ? [lin]:equip1 : -1) | [lin]:equip2) & ~[lin]:equip3
  lin = "tipo_" + tipo2
  pos = (([lin]:equip1 ? [lin]:equip1 : pos) | [lin]:equip2) & ~[lin]:equip3
  lin = "tipo_" + tipo3
  pos = (([lin]:equip1 ? [lin]:equip1 : pos) | [lin]:equip2) & ~[lin]:equip3
  ret ((equip1 ? equip1 : pos) | equip2) & ~equip3

func msgvis # Mensagem se o jogador estiver vendo o alvo
  se sock && posicao > 4 && $mens.perso.visivel(este) # Se tem jogador e está acordado
    msg($mens.proc(arg0, este))

func msginv # Mensagem mesmo se o alvo estiver invisível
  se sock && posicao > 4 # Se tem jogador e está acordado
    msg($mens.proc(arg0, este))

func morreu # Procedimentos quando morre
# arg0 = quem atacou o personagem; pode ser nulo
# Checa se pode morrer
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este), nulo
  efim
# Morreu
  mortes += 1
  p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
  apagar(este)
  ref r
  r = sock, r.mudaperso(nulo), r.reinicia
  p_corpo && criar("comum_corpo", este, p_corpo == 2)
# Gera eventos
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este)
  efim


classe comum_persobat
herda comum_perso
# Personagem que pode batalhar
const objmax = 1 # Quantos itens pode carregar
const tipo1 = "normal" # Tipo de personagem
const p_agressivo = 1 # Ataca se atacarem
const p_atktipo = config:atk_txt # Que habilidade usar em ataques automáticos
const p_exp = 100 # Quantidade de experiência que dá, em porcentagem
const p_movervel = 140
const perso = 2 # Para identificar o tipo de personagem
const pesoadd = contr == este && !(bitinv & 48) && !(bitver & 512) # Se falso, está voando
#
const expmax = pnivel * pnivel + 20 # Experiência para subir de nível
sav textotxt p_hist # Histórico do personagem (quem ele matou)
sav uint32 expatual # Experiência atual
sav uint16 pnivel # Nível atual
sav uint32 pvida # Pontos de vida
sav uint32 pmana # Pontos de mana
sav uint32 pmove # Pontos de movimento
uint32 pvidamax # Quantidade máxima de vida
uint32 pmanamax # Quantidade máxima de mana
uint32 pmovemax # Quantidade máxima de movimento
uint16 pveloc1 # Velocidade calculada do personagem
const pveloc = pveloc1 - int((pesoden - pesoveste) / 1500)
uint32 atknorm # Quantidade de ataque normal, sem modificadores em atktipo
uint32 defnorm # Quantidade de defesa normal, sem modificadores em deftipo
uint32 atkesp # Quantidade de ataque especial, sem modificadores em atktipo
uint32 defesp # Quantidade de defesa especial, sem modificadores em deftipo
uint16 evasao # Habilidade de desviar dos golpes (thac0)
uint16 precisao # Habilidade de acertar os golpes (hitroll)
uint32 pesoveste # Metade do peso de tudo que está vestindo
uint32 pesomax # Quanto peso consegue carregar
#
# const tipo2 = "" # Segundo tipo do personagem
# const tipo3 = "" # Terceiro tipo do personagem
real atktipo.32 # Ataque de ataque para diversos tipos de danos
real deftipo.32 # Defesa contra os diversos tipos de danos
# As duas primeiras variáveis do vetor são golpes normais e especiais
# 1=danos normais e 0=nenhum dano (0.5=metade dos danos, etc.)
# Vide constante config:atknomes
#
listaobj atkrec # Quem atacou esse personagem; dá experiência se perder
listaitem atkenv # Item de atkrec; atkenv.objlista = alvo do personagem
listaobj atkdiv # Para dividir experiência entre personagens que atacaram
listaobj atkbat # Para apagar objetos ao iniciar ou terminar uma batalha
inttempo atktempo # Tempo para completar um turno da batalha
uint8 atkturno # Turno da batalha, usado para decidir se encerra
inttempo p_tempoatu # Tempo para atualizar personagem
inttempo p_proc # Para processar comportamento do personagem
intdec p_tmove # Quanto para se mover novamente

func ini # Objeto foi criado
  comum_perso:ini(arg0, arg1, arg2, arg3, arg4)
  p_restaura = 100
  pvida = pvidamax, pmana = pmanamax, pmove = pmovemax
  persobat = este, persoesc = este

func acertapos # Acerta posição
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  p_imortal && pvida < pvidamax && (pvida = pvidamax) # Imortal
  !p_tempoatu && (p_tempoatu = 100) # Para atualizar o personagem
  casovar pvida * 100 / pvidamax
  casose "0" # Mortalmente ferito ou morto
  casose "1"
    poslugar.remove
    ret !(posicao = pvida > 0) && arg0, morreu
    ret
  casose "2"
    poslugar.remove, posicao = 2 # incapacitado
    ret
  casose "3"
    poslugar.remove, posicao = 3 # fraco
    ret
  casose
    se bitver & 1024
      posicao = 4
    senao atkenv
      poslugar.remove, posicao = 7 # lutando
    senao posicao < 4 || posicao == 7
      poslugar.remove, posicao = pospadr # posição padrão
    fimse
  casofim

func recalc_exec # Ajusta variáveis, principalmente batalha
# Checa subida de nível
  se expatual >= expmax
    int8 num
    enquanto expatual >= expmax
      expatual -= expmax
      pnivel += 1
      var.z_aulas_ += config:aulas
      num += 1
      num >= 5 && (expatual = 0)
    efim
    $mens.o_1 = txtcopiamai(descnome, "A") + (este != contr ? " de " + contr.descnome)
    $mens.mens = pnivel
    $mens.p(este)
    $mens.mtodos2(config:nivelmsg1, config:nivelmsg2)
  fimse
# Acerta atributos básicos
  bitver = 17, bitinv = 3, atribs.limpar
  pesoveste = 0
  atktipo.limpar(1)
  deftipo.limpar(1)
# Acerta atributos conforme o tipo de personagem
  config:atribcfg, recalc_auto
  tipo_[tipo1]:recalc_auto, tipo_[tipo2]:recalc_auto, tipo_[tipo3]:recalc_auto
  tipo_[tipo1]:recalc, tipo_[tipo2]:recalc, tipo_[tipo3]:recalc
  cmd_recalc1(este)
# Bônus conforme o que está vestindo e os efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    [i.obj]:recalc_auto, i.obj.cmd_recalc2(este), pesoveste += iobj.pesotot
  efim
  pesoveste /= 2
  epara i = evento.ini, i, i.depois
    i.obj.cmd_recalc3(este)
  efim
# Acerta atributo dormindo de bitver
  bitver & 2048 && (bitver = bitver & ~1024)
  bitver & 1024 && posicao > 4 && (posicao = 4)
  atribs_exec
# Se for jogador, checa PNJs agressivos
  ret !jog, nulo
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.p_agressivo(este) == 2 && !i.obj.p_proc && (i.obj.p_proc = 1)
  efim


const batalhaini = contr.bat_ini_int(arg0.contr, este, arg0)
# batalhaini - Indica que atacou outro personagem (está batalhando)
# arg0 = alvo do personagem

func bat_ini_int # Chamado internamente por batalhaini
# Personagem 'arg1' de 'este' quer atacar personagem 'arg2' de 'arg0'
  ret este == arg0, nulo # Não inicia batalha contra o próprio personagem
  se atkenv.objlista != arg0 # Se o alvo do ataque mudou...
    atkenv.remove
    atkenv = arg0.atkrec.addfim(este)
    atkdiv.limpar
    atktempo = config:atktempo, atkturno = 0
    posicao >= 4 && (posicao = 7)
  fimse
  atkdiv.addfim1(arg1) # Adiciona personagem para ganhar experiência
  se !arg0.atkenv # Se o alvo não está batalhando...
    arg0.atkenv = atkrec.addfim(arg0)
    arg0.atkdiv.limpar
    arg0.atkdiv.addfim(arg2)
    arg0.atktempo = config:atktempo, arg0.atkturno = 0
    arg0.posicao >= 4 && (arg0.posicao = 7)
  fimse
  atkturno = arg0.atkturno = 0
  !p_proc && (p_proc = 1)
  arg0.p_proc = 1 # Para gerar evento de PNJs
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 3 && apagar(i.obj)
  efim

const batalhafim = contr.bat_fim_int(arg0)
# batalhafim - Encerra a batalha
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)

func bat_fim_int # Chamado internamente por batalhafim
  atkenv.remove, atktempo = 0, acertapos(arg0)
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 2 && apagar(i.obj)
  efim
  ref r
  enquanto atkrec.ini
    r = atkrec.objini, atkrec.ini.remove, r.atktempo = 0, r.acertapos(arg0)
    epara i = r.atkbat.ini, i, i.depois
      i.obj.e_condicao == 2 && apagar(i.obj)
    efim
  efim

func batalhaexp # Dá experiência a quem estiver atacando o personagem
# arg0 = fator do ganho de experiência
  listaitem i
  listaobj l
# Preenche lista com os personagens
  epara i = contr.atkrec.ini, i, i.depois
    i.obj.pvida && l.addfim(i.obj.atkdiv)
  efim
# Ganha experiência
  refvar exp1 = arg0 * config:atkexp * (pnivel + 6) / 1000
  real2 v1
  epara i = l.ini, i, i.depois
    refvar r = i.obj
    v1 = intmin(1, intpos(pnivel - r.pnivel + 8) / 16)
    r.dono.perso && r.var.z_dono != r.dono.descnome && (v1 *= 1.5)
    r.ganhaexp(v1 * exp1 * p_exp(r) / (l.total + 1))
  efim

func ganhaexp # Personagem ganha experiência
# arg0 = experiência (se negativo perde experiência)
# arg1 = verdadeiro se não deve mostrar mensagem de ganhar XP para o jogador
  refvar exp1 = intpos(int(expatual + arg0)) - expatual
  ret !exp1, nulo
  expatual += exp1
# Mensagem de experiência ganha
  se !arg1
    refvar n1 = este == contr ? "Você" : txtcopiamai(descnome, "A")
    se exp1 > 1
      contr.msg(n1 + " recebe " + exp1 + " pontos de experiência.")
    senao exp1 < -1
      contr.msg(n1 + " perde " + -exp1 + " pontos de experiência.")
    senao exp1 == 1
      contr.msg(n1 + " recebe 1 ponto de experiência.")
    senao exp1 == -1
      contr.msg(n1 + " perde 1 ponto de experiência.")
    fimse
  fimse
# Subir de nível
  expatual >= expmax && (recalc = 1)

func atkauto # Realiza um ataque automático
# arg0 = alvo do ataque
# arg1 = quanto conhece da habilidade (primeiro, segundo ou terceiro ataque)
# Retorna verdadeiro se tentou atacar
  ref obj # Objeto correspondente à habilidade
  real2 aulas # Quanto sabe da habilidade, de 0 a 1
  se iempu.obj && !iempu.obj.armamanual # Ataque com arma
    obj = $cmd_[txtsublin(config:arma_txt, iempu.obj.armatipo, 1)]
    aulas = intpos((arg1 - 1) * (var.[obj.nomevar] - 1) / 49) # Nota: 49=7*7
    refvar obj2 = $cmd_[iempu.obj.armaatk]
    obj2 && (obj = obj2)
  senao # Ataque sem arma
    obj = $cmd_[p_atktipo]
    aulas = intpos(arg1 - 1) / 14 # Nota: 14=7*2
  fimse
  ret int(obj.tipoalvo) != 8, nulo # Retorna se não for ataque automático
  ret !obj.autohab2(este, aulas), nulo # Checa condições para atacar
# ret txt(obj.cmdmenu) != "ataque", nulo # Retorna se comando não é habilidade
  obj.exechab(este, arg0, aulas, pnivel) # Realiza um ataque
  ret 1

func atktempo_exec # Encerra a batalha depois de um tempo
  ret !atkenv, batalhafim(1) # Termina a batalha se não tem um alvo
  atktempo = config:atktempo
  se pvida < p_fugir
# $cmd_fugir.fugir(este)
  senao persobat.atkauto(atkenv.objlista.persobat, 8)
    ret !atkenv || !persobat.var.h_segundo_ataque_, nulo
    debug d
    d.ini, persobat.atkauto(atkenv.objlista.persobat, persobat.var.h_segundo_ataque_)
    ret !atkenv || !persobat.var.h_terceiro_ataque_, nulo
    d.ini, persobat.atkauto(atkenv.objlista.persobat, persobat.var.h_terceiro_ataque_)
    ret
  fimse
  $mens.p(este, atkenv.objlista)
  casovar atkturno += 1
  casose "1"
    ret
  casose "2"
    posicao >= 4 && $mens.mvis1("$P se prepara.")
    ret
  casose "3"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P procura uma brecha.")
    ret
  casose "4"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P encara $a.")
    ret
  casofim
  atkenv.objlista.msg("Batalha encerrada.")
  msg("Batalha encerrada.")
  batalhafim(1)

func restaurar # Restaura personagem (HP, mana, etc.)
  pmana = pmanamax, pmove = pmovemax
  se !pvida && dono.perso
    pvida = pvidamax
    dono.escolhebat # Atualiza persobat
  senao
    pvida = pvidamax

func morreu # Procedimentos quando morre
# arg0 = quem atacou o personagem; pode ser nulo
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  ref corpo # Corpo do personagem morto
# Checa se pode morrer
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este), nulo
  efim
# Histórico
  mortes += 1
  se arg0
    arg0.p_hist.remove(arg0.p_hist.linhas - 9)
    refvar lin = "N" + arg0.pnivel + " x " + este + "(" + nome + ") N" + pnivel
    se este == contr
      arg0.p_hist.addfim(lin)
    senao
      arg0.p_hist.addfim(lin + " de " + contr + "(" + contr.nome + ") N" + contr.pnivel)
    fimse
  fimse
# Jogador: perde experiência e transfere jogador para outro lugar
  se jog
    pvida = intpos(pvidamax / 2 - 10) + 2
    pmana = pmanamax / 2
    pmove = pmovemax / 2
    p_restaura = rand(100, 130)
    p_sede = intmax($miscfome.cheio / 2, p_sede)
    p_fome = intmax($miscfome.cheio / 2, p_fome)
    p_bebida = p_diges = 0
    casovar config:atkmatoutipo
    casose # Quem atacou ganha experiência como ao matar um PNJ
      batalhaexp(config:atkmatouexp / 100)
      sair
    casose "1" # Transfere experiência para quem atacou
      listaitem i
      epara i = contr.atkrec.ini, i, i.depois
        i.obj.pvida && l.addfim(i.obj.atkdiv)
      efim
      refvar valor = expatual * config:atkmorreuexp * config:atkmatouexp / 10000
      epara i = l.ini, i, i.depois
        i.obj.ganhaexp(valor / l.total)
      efim
      l.limpar
      sair
    casose "2" # Quem atacou perde experiência
      epara l.addfim(contr.atkrec.ini), l, l.ini.remove
        continuar !l.objini.pvida
        l.objini.ganhaexp(l.objini.expatual * config:atkmatouexp / -100)
      efim
      sair
    casofim
    batalhafim # Encerra a batalha
    expatual *= (100 - config:atkmorreuexp) / 100
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    mudadono(config:salafim)
    salvar # Salva o jogo
    !sock && apagar(este) # Sai do jogo se ninguém está controlando o personagem
# Animal do jogador: não dá experiência
  senao dono.jog
    pvida = 0
    p_morreu2 && $mens.p(este) + $mens.mtodos2(p_morreu2)
    dono.escolhebat # Atualiza persobat
# Outro personagem: dá experiência
  senao dono.perso
    pvida = 0, batalhaexp(1.5)
    p_morreu2 && $mens.p(este) + $mens.mtodos2(p_morreu2)
    dono.escolhebat # Atualiza persobat
  senao
    pvida = 0, batalhaexp(1), batalhafim
    p_morreu1 && $mens.p(este) + $mens.mtodos1(p_morreu1)
    apagar(este)
    ref r
    r = sock, r.mudaperso(nulo), r.reinicia
    p_corpo && (corpo = criar("comum_corpo", este, p_corpo == 2))
    se corpo.var.z_moedas && arg0.jogconfig.10 # Se deve pegar moedas
      refvar moeda = corpo.var.z_moedas == 1 ? "uma moeda" : corpo.var.z_moedas + " moedas"
      $mens.p(arg0)
      $mens.mvis1("$P pega " + moeda + ".")
      arg0.var.z_moedas_ += corpo.var.z_moedas_
      corpo.var.z_moedas = ""
    fimse
  fimse
# Apaga efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    i.obj.e_condicao && apagar(i.obj)
  efim
# Gera eventos
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este)
  efim
  ret corpo

func escolheatk # Escolhe e retorna o nome da variável de uma habilidade ou magia
  textotxt t # Lista de habilidades e magias
  txt100 t1 # Nome da habilidade ou magia
  t1 = persoesc.var.ini("h_")
  enquanto txt(t1, 0, 2) == "h_"
    refvar r = $cmd_[txt(t1, 2)]
    r.cmdmenu && 8 != r.tipoalvo && t.addfim(t1), t1 = persoesc.var.depois(t1)
  efim
  se !dono.s_semmagia
    t1 = persoesc.var.ini("m_")
    enquanto txt(t1, 0, 2) == "m_"
      refvar r = $magia_[txt(t1, 2)]
      r.cmdmenu && 8 != r.tipoalvo && t.addfim(t1), t1 = persoesc.var.depois(t1)
    efim
  fimse
  t.remove(rand(t.linhas))
  ret t.ini.texto

func escolhejog # Escolhe e retorna um jogador
  listaitem i
  listaobj l
# Obtém a quantidade de jogadores
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.jog && i.obj.visivel(este) && l.addfim(i.obj)
  efim
  ret !l.objini, nulo # Retorna se não tem jogador
# Escolhe um jogador
  i = l.ini, i.depois(rand(l.total))
  ret i.obj

func p_proc_exec # Processar comportamento do personagem
  ret este != contr, nulo # Retorna se pertence a outro personagem
  ret atkenv && pvida < p_fugir, $cmd_fugir.fugir(este) # Tenta fugir da luta
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
  !p_tempoatu && (p_tempoatu = 100)
# Evento do personagem
  ret cmd_pnj_proc, nulo
# Obtém o alvo para realizar um ataque
  ref alvo
  se atkenv # Alvo durante a batalha
    alvo = atkenv.objlista
  senao dono.socktot # Escolhe um jogador como alvo
    listaitem i
    listaobj l
    epara i = dono.dentro2.ini, i, i.depois
      i.obj.jog && p_agressivo(i.obj) == 2 && i.obj.visivel(este) && l.addfim(i.obj)
    efim
    se l.total
      i = l.ini, i.depois(rand(l.total)), alvo = i.obj
    fimse
  fimse
# Realiza um ataque
  se alvo && persobat.pvida && dono.s_luta
    txt100 t1
    t1 = escolheatk # Obtém o nome de um ataque
    se t1 # Ataque manual
      refvar obj = txt(t1, 0, 1) == "m" ? $magia_[txt(t1, 2)] : $cmd_[txt(t1, 2)]
      refvar aulas = intpos(persobat.var.[obj.nomevar] - 1) / 7
      se obj.autohab2(persobat, aulas)
        ret obj.exechab(persobat, alvo.persobat, aulas, persobat.pnivel)
      fimse
    senao !atkenv # Ataque automático
      persobat.atkauto(alvo.persobat, 8)
    fimse
  fimse
# Acerta condição do personagem
# pmove = pmovemax, pmana = pmanamax, pvida < pvidamax && (pvida += 1)
# Checa se é tempo de agir
  ret p_tmove, p_proc = p_tmove + 1
  ret posicao == 7, p_proc = 30
# Come corpos
  se p_comecorpo && posicao >= 5 && (alvo = dono.dentro1.objini("comum_corpo"))
    $mens.p(este, nulo, alvo)
    $mens.mtodos1("$P come $o.")
    alvo.apagar(1)
    p_tmove = rand(70, 130) * p_movervel / 100, p_proc = p_tmove + 1
# Movimenta-se
  senao p_mover && posicao == 8
    textotxt t
    prog p
    misc:obj = este
    refvar r = ref(dono)
    epara p.inifunctudo(r, "dir_"), p.lin, p.depois
      refvar x = ref(r.[p.texto])
      x && x.dentro2.total - x.socktot < x.s_pnj && t.addfim(txt(p.texto, 4))
    efim
    t.remove(rand(t.linhas)) # Para escolher uma direção aleatoriamente
    txt10 dir
    dir = t.ini.texto # Direção escolhida
    ret !dir || p_mover == 1 && r.dir_[dir].s_area != r.s_area, p_proc = 50
    $cmd_[dir].escr(este)
    p_tmove = rand(70, 130) * p_movervel / 100, p_proc = p_tmove + 1
    !p_tempoatu && (p_tempoatu = 100)
  fimse

func p_tempoatu_exec # Atualiza variáveis e salva o jogo de tempos em tempos
  refvar recup = contr.dono.s_recup(este) / 1200
  se recup && pvida
    uint8 x
    pvida < pvidamax && (x = pvida = intmin(pvidamax, intmax(2, pvida + pvidamax * recup)))
    pmana < pmanamax && (x = pmana = intmin(pmanamax, intmax(2, pmana + pmanamax * recup)))
    pmove < pmovemax && (x = pmove = intmin(pmovemax, intmax(2, pmove + pmovemax * recup)))
    x && (p_tempoatu = 100)
    posicao < 4 && acertapos # Se estiver incapacitado, pode voltar a ficar normal


classe comum_persoanimal
herda comum_persobat
# Personagem que pode batalhar e carregar animais
const perso = 3 # Para identificar o tipo de personagem
const objmax = 15 # Quantos itens pode carregar
sav ref persobat # Personagem usado na batalha
sav ref persoesc # Personagem escolhido pelo jogador

func ini
  comum_persobat:ini(arg0, arg1, arg2, arg3, arg4)

func escolhebat # Escolhe um personagem em condições de lutar
  se persoesc.pvida # Checa se personagem escolhido está em condições
    persobat = persoesc
  senao
    listaitem i
    epara i = dentro2.ini, i && !i.obj.pvida, i.depois
    efim
    persobat = i ? i.obj : este

func animalmais # Retorna quantos animais ainda pode adquirir
  uint8 x
  x = config:animal1
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && (x -= 1)) + i.depois
  efim
  ret x

func animaltot # Retorna quantos animais possui
  uint8 x
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && (x += 1)) + i.depois
  efim
  ret x

func animalnum # Retorna o animal a partir do número
# arg0 = número do animal (0 = o próprio personagem)
  int8 x
  x = arg0
  ret !x, este
  listaitem i
  epara i = dentro2.ini, i, i.depois
    sair i.obj.perso && !(x -= 1)
  efim
  ret ref(i.obj)

func p_proc_exec # Processar comportamento do personagem
  ret sock, comum_persobat:p_proc_exec # Checa se está sendo controlado por jogador
  ret p_espera, comum_persobat:p_proc_exec # Checa tempo para agir
# Escolhe animal
  se persoesc == este || !persoesc.pvida
    listaitem i
    epara i = dentro2.ini, i && !i.obj.pvida, i.depois
    efim
    persobat = i ? i.obj : este
    se persoesc != persobat
      persoesc = persobat
      $mens.p(este, persoesc)
      ret persobat != este, $mens.mvis1("$P escolhe $b.")
      ret $mens.mvis1("$P não escolhe ninguém.")
    fimse
  fimse
# Comportamento de PNJ que pode batalhar
  comum_persobat:p_proc_exec
